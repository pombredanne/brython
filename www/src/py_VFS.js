__BRYTHON__.use_VFS = true;
__BRYTHON__.VFS={"heapq": [".py", "\"\"\n\n\n\n__about__ = \"\"\"Heap queues\n\n[explanation by Fran\u00e7ois Pinard]\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nThe strange invariant above is meant to be an efficient memory\nrepresentation for a tournament.  The numbers below are `k', not a[k]:\n\n                                   0\n\n                  1                                 2\n\n          3               4                5               6\n\n      7       8       9       10      11      12      13      14\n\n    15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30\n\n\nIn the tree above, each cell `k' is topping `2*k+1' and `2*k+2'.  In\nan usual binary tournament we see in sports, each cell is the winner\nover the two cells it tops, and we can trace the winner down the tree\nto see all opponents s/he had.  However, in many computer applications\nof such tournaments, we do not need to trace the history of a winner.\nTo be more memory efficient, when a winner is promoted, we try to\nreplace it by something else at a lower level, and the rule becomes\nthat a cell and the two cells it tops contain three different items,\nbut the top cell \"wins\" over the two topped cells.\n\nIf this heap invariant is protected at all time, index 0 is clearly\nthe overall winner.  The simplest algorithmic way to remove it and\nfind the \"next\" winner is to move some loser (let's say cell 30 in the\ndiagram above) into the 0 position, and then percolate this new 0 down\nthe tree, exchanging values, until the invariant is re-established.\nThis is clearly logarithmic on the total number of items in the tree.\nBy iterating over all items, you get an O(n ln n) sort.\n\nA nice feature of this sort is that you can efficiently insert new\nitems while the sort is going on, provided that the inserted items are\nnot \"better\" than the last 0'th element you extracted.  This is\nespecially useful in simulation contexts, where the tree holds all\nincoming events, and the \"win\" condition means the smallest scheduled\ntime.  When an event schedule other events for execution, they are\nscheduled into the future, so they can easily go into the heap.  So, a\nheap is a good structure for implementing schedulers (this is what I\nused for my MIDI sequencer :-).\n\nVarious structures for implementing schedulers have been extensively\nstudied, and heaps are good for this, as they are reasonably speedy,\nthe speed is almost constant, and the worst case is not much different\nthan the average case.  However, there are other representations which\nare more efficient overall, yet the worst cases might be terrible.\n\nHeaps are also very useful in big disk sorts.  You most probably all\nknow that a big sort implies producing \"runs\" (which are pre-sorted\nsequences, which size is usually related to the amount of CPU memory),\nfollowed by a merging passes for these runs, which merging is often\nvery cleverly organised[1].  It is very important that the initial\nsort produces the longest runs possible.  Tournaments are a good way\nto that.  If, using all the memory available to hold a tournament, you\nreplace and percolate items that happen to fit the current run, you'll\nproduce runs which are twice the size of the memory for random input,\nand much better for input fuzzily ordered.\n\nMoreover, if you output the 0'th item on disk and get an input which\nmay not fit in the current tournament (because the value \"wins\" over\nthe last output value), it cannot fit in the heap, so the size of the\nheap decreases.  The freed memory could be cleverly reused immediately\nfor progressively building a second heap, which grows at exactly the\nsame rate the first heap is melting.  When the first heap completely\nvanishes, you switch heaps and start a new run.  Clever and quite\neffective!\n\nIn a word, heaps are useful memory structures to know.  I use them in\na few applications, and I think it is good to keep a `heap' module\naround. :-)\n\n--------------------\n[1] The disk balancing algorithms which are current, nowadays, are\nmore annoying than clever, and this is a consequence of the seeking\ncapabilities of the disks.  On devices which cannot seek, like big\ntape drives, the story was quite different, and one had to be very\nclever to ensure (far in advance) that each tape movement will be the\nmost effective possible (that is, will best participate at\n\"progressing\" the merge).  Some tapes were even able to read\nbackwards, and this was also used to avoid the rewinding time.\nBelieve me, real good tape sorts were quite spectacular to watch!\nFrom all times, sorting has always been a Great Art! :-)\n\"\"\"\n\n__all__ = ['heappush', 'heappop', 'heapify', 'heapreplace', 'merge',\n'nlargest', 'nsmallest', 'heappushpop']\n\nfrom itertools import islice, count, tee, chain\n\ndef heappush(heap, item):\n \"\"\n heap.append(item)\n _siftdown(heap, 0, len(heap)-1)\n \ndef heappop(heap):\n \"\"\n lastelt = heap.pop() \n if heap:\n  returnitem = heap[0]\n  heap[0] = lastelt\n  _siftup(heap, 0)\n else:\n  returnitem = lastelt\n return returnitem\n \ndef heapreplace(heap, item):\n \"\"\n returnitem = heap[0] \n heap[0] = item\n _siftup(heap, 0)\n return returnitem\n \ndef heappushpop(heap, item):\n \"\"\n if heap and heap[0] < item:\n  item, heap[0] = heap[0], item\n  _siftup(heap, 0)\n return item\n \ndef heapify(x):\n \"\"\n n = len(x)\n \n \n \n \n \n for i in reversed(range(n//2)):\n  _siftup(x, i)\n  \ndef _heappushpop_max(heap, item):\n \"\"\n if heap and item < heap[0]:\n  item, heap[0] = heap[0], item\n  _siftup_max(heap, 0)\n return item\n \ndef _heapify_max(x):\n \"\"\n n = len(x)\n for i in reversed(range(n//2)):\n  _siftup_max(x, i)\n  \ndef nlargest(n, iterable):\n \"\"\n if n < 0:\n  return []\n it = iter(iterable)\n result = list(islice(it, n))\n if not result:\n  return result\n heapify(result)\n _heappushpop = heappushpop\n for elem in it:\n  _heappushpop(result, elem)\n result.sort(reverse=True)\n return result\n \ndef nsmallest(n, iterable):\n \"\"\n if n < 0:\n  return []\n it = iter(iterable)\n result = list(islice(it, n))\n if not result:\n  return result\n _heapify_max(result)\n _heappushpop = _heappushpop_max\n for elem in it:\n  _heappushpop(result, elem)\n result.sort()\n return result\n \n \n \n \ndef _siftdown(heap, startpos, pos):\n newitem = heap[pos]\n \n \n while pos > startpos:\n  parentpos = (pos - 1) >> 1\n  parent = heap[parentpos]\n  if newitem < parent:\n   heap[pos] = parent\n   pos = parentpos\n   continue\n  break\n heap[pos] = newitem\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \ndef _siftup(heap, pos):\n endpos = len(heap)\n startpos = pos\n newitem = heap[pos]\n \n childpos = 2*pos + 1 \n while childpos < endpos:\n \n  rightpos = childpos + 1\n  if rightpos < endpos and not heap[childpos] < heap[rightpos]:\n   childpos = rightpos\n   \n  heap[pos] = heap[childpos]\n  pos = childpos\n  childpos = 2*pos + 1\n  \n  \n heap[pos] = newitem\n _siftdown(heap, startpos, pos)\n \ndef _siftdown_max(heap, startpos, pos):\n \"\"\n newitem = heap[pos]\n \n \n while pos > startpos:\n  parentpos = (pos - 1) >> 1\n  parent = heap[parentpos]\n  if parent < newitem:\n   heap[pos] = parent\n   pos = parentpos\n   continue\n  break\n heap[pos] = newitem\n \ndef _siftup_max(heap, pos):\n \"\"\n endpos = len(heap)\n startpos = pos\n newitem = heap[pos]\n \n childpos = 2*pos + 1 \n while childpos < endpos:\n \n  rightpos = childpos + 1\n  if rightpos < endpos and not heap[rightpos] < heap[childpos]:\n   childpos = rightpos\n   \n  heap[pos] = heap[childpos]\n  pos = childpos\n  childpos = 2*pos + 1\n  \n  \n heap[pos] = newitem\n _siftdown_max(heap, startpos, pos)\n \n \n \n \n \n \n \n \ndef merge(*iterables):\n \"\"\n _heappop, _heapreplace, _StopIteration = heappop, heapreplace, StopIteration\n _len = len\n \n h = []\n h_append = h.append\n for itnum, it in enumerate(map(iter, iterables)):\n  try:\n   next = it.__next__\n   h_append([next(), itnum, next])\n  except _StopIteration:\n   pass\n heapify(h)\n \n while _len(h) > 1:\n  try:\n   while True:\n    v, itnum, next = s = h[0]\n    yield v\n    s[0] = next() \n    _heapreplace(h, s) \n  except _StopIteration:\n   _heappop(h) \n if h:\n \n  v, itnum, next = h[0]\n  yield v\n  yield from next.__self__\n  \n  \n_nsmallest = nsmallest\ndef nsmallest(n, iterable, key=None):\n \"\"\n \n if n == 1:\n  it = iter(iterable)\n  head = list(islice(it, 1))\n  if not head:\n   return []\n  if key is None:\n   return [min(chain(head, it))]\n  return [min(chain(head, it), key=key)]\n  \n  \n try:\n  size = len(iterable)\n except (TypeError, AttributeError):\n  pass\n else:\n  if n >= size:\n   return sorted(iterable, key=key)[:n]\n   \n   \n if key is None:\n  it = zip(iterable, count()) \n  result = _nsmallest(n, it)\n  return [r[0] for r in result] \n  \n  \n in1, in2 = tee(iterable)\n it = zip(map(key, in1), count(), in2) \n result = _nsmallest(n, it)\n return [r[2] for r in result] \n \n_nlargest = nlargest\ndef nlargest(n, iterable, key=None):\n \"\"\n \n \n if n == 1:\n  it = iter(iterable)\n  head = list(islice(it, 1))\n  if not head:\n   return []\n  if key is None:\n   return [max(chain(head, it))]\n  return [max(chain(head, it), key=key)]\n  \n  \n try:\n  size = len(iterable)\n except (TypeError, AttributeError):\n  pass\n else:\n  if n >= size:\n   return sorted(iterable, key=key, reverse=True)[:n]\n   \n   \n if key is None:\n  it = zip(iterable, count(0,-1)) \n  result = _nlargest(n, it)\n  return [r[0] for r in result] \n  \n  \n in1, in2 = tee(iterable)\n it = zip(map(key, in1), count(0,-1), in2) \n result = _nlargest(n, it)\n return [r[2] for r in result] \n \nif __name__ == \"__main__\":\n\n heap = []\n data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]\n for item in data:\n  heappush(heap, item)\n sort = []\n while heap:\n  sort.append(heappop(heap))\n print(sort)\n \n import doctest\n doctest.testmod()\n"], "site-packages.pygame.base": [".py", "\n\n\n\n\"\"\n\n__docformat__ = 'restructuredtext'\n__version__ = '$Id$'\n\nimport atexit\nimport sys\n\n\n\n_quitfunctions = []\n\nclass error(RuntimeError):\n pass\n \ndef init():\n \"\"\n success = 0\n fail = 0\n \n \n \n if _video_autoinit():\n  success += 1\n else:\n  fail += 1\n  \n for mod in sys.modules.values():\n  if hasattr(mod, '__PYGAMEinit__') and callable(mod.__PYGAMEinit__):\n   try:\n    mod.__PYGAMEinit__()\n    success += 1\n   except:\n    fail += 1\n return success, fail\n \ndef register_quit(func):\n \"\"\n _quitfunctions.append(func)\n \ndef _video_autoquit():\n if SDL.SDL_WasInit(SDL.SDL_INIT_VIDEO):\n  SDL.SDL_QuitSubSystem(SDL.SDL_INIT_VIDEO)\n  \ndef _video_autoinit():\n return 1\n \n \n \n \n \ndef _atexit_quit():\n while _quitfunctions:\n  func = _quitfunctions.pop()\n  func()\n _video_autoquit()\n \n \ndef get_sdl_version():\n \"\"\n \n \n return None, None, None\n \ndef quit():\n \"\"\n _atexit_quit()\n \ndef get_error():\n \"\"\n \n return ''\n \ndef _rgba_from_obj(obj):\n if not type(obj) in (tuple, list):\n  return None\n  \n if len(obj) == 1:\n  return _rgba_from_obj(obj[0])\n elif len(obj) == 3:\n  return (int(obj[0]), int(obj[1]), int(obj[2]), 255)\n elif len(obj) == 4:\n  return obj\n else:\n  return None\n  \natexit.register(_atexit_quit)\n"], "crypto_js.rollups.sha384": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(a,c){var d={},j=d.lib={},f=function(){},m=j.Base={extend:function(a){f.prototype=this;var b=new f;a&&b.mixIn(a);b.hasOwnProperty(\"init\")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nB=j.WordArray=m.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=c?b:4*a.length},toString:function(a){return(a||y).stringify(this)},concat:function(a){var b=this.words,g=a.words,e=this.sigBytes;a=a.sigBytes;this.clamp();if(e%4)for(var k=0;k<a;k++)b[e+k>>>2]|=(g[k>>>2]>>>24-8*(k%4)&255)<<24-8*((e+k)%4);else if(65535<g.length)for(k=0;k<a;k+=4)b[e+k>>>2]=g[k>>>2];else b.push.apply(b,g);this.sigBytes+=a;return this},clamp:function(){var n=this.words,b=this.sigBytes;n[b>>>2]&=4294967295<<\n32-8*(b%4);n.length=a.ceil(b/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(n){for(var b=[],g=0;g<n;g+=4)b.push(4294967296*a.random()|0);return new B.init(b,n)}}),v=d.enc={},y=v.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var g=[],e=0;e<a;e++){var k=b[e>>>2]>>>24-8*(e%4)&255;g.push((k>>>4).toString(16));g.push((k&15).toString(16))}return g.join(\"\")},parse:function(a){for(var b=a.length,g=[],e=0;e<b;e+=2)g[e>>>3]|=parseInt(a.substr(e,\n2),16)<<24-4*(e%8);return new B.init(g,b/2)}},F=v.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var g=[],e=0;e<a;e++)g.push(String.fromCharCode(b[e>>>2]>>>24-8*(e%4)&255));return g.join(\"\")},parse:function(a){for(var b=a.length,g=[],e=0;e<b;e++)g[e>>>2]|=(a.charCodeAt(e)&255)<<24-8*(e%4);return new B.init(g,b)}},ha=v.Utf8={stringify:function(a){try{return decodeURIComponent(escape(F.stringify(a)))}catch(b){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return F.parse(unescape(encodeURIComponent(a)))}},\nZ=j.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new B.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=ha.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(n){var b=this._data,g=b.words,e=b.sigBytes,k=this.blockSize,m=e/(4*k),m=n?a.ceil(m):a.max((m|0)-this._minBufferSize,0);n=m*k;e=a.min(4*n,e);if(n){for(var c=0;c<n;c+=k)this._doProcessBlock(g,c);c=g.splice(0,n);b.sigBytes-=e}return new B.init(c,e)},clone:function(){var a=m.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=Z.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){Z.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,g){return(new a.init(g)).finalize(b)}},_createHmacHelper:function(a){return function(b,g){return(new ia.HMAC.init(a,\ng)).finalize(b)}}});var ia=d.algo={};return d}(Math);\n(function(a){var c=CryptoJS,d=c.lib,j=d.Base,f=d.WordArray,c=c.x64={};c.Word=j.extend({init:function(a,c){this.high=a;this.low=c}});c.WordArray=j.extend({init:function(c,d){c=this.words=c||[];this.sigBytes=d!=a?d:8*c.length},toX32:function(){for(var a=this.words,c=a.length,d=[],j=0;j<c;j++){var F=a[j];d.push(F.high);d.push(F.low)}return f.create(d,this.sigBytes)},clone:function(){for(var a=j.clone.call(this),c=a.words=this.words.slice(0),d=c.length,f=0;f<d;f++)c[f]=c[f].clone();return a}})})();\n(function(){function a(){return f.create.apply(f,arguments)}for(var c=CryptoJS,d=c.lib.Hasher,j=c.x64,f=j.Word,m=j.WordArray,j=c.algo,B=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),\na(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,\n2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),\na(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,\n3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],v=[],y=0;80>y;y++)v[y]=a();j=j.SHA512=d.extend({_doReset:function(){this._hash=new m.init([new f.init(1779033703,4089235720),new f.init(3144134277,2227873595),new f.init(1013904242,4271175723),new f.init(2773480762,1595750129),new f.init(1359893119,2917565137),new f.init(2600822924,725511199),new f.init(528734635,4215389547),new f.init(1541459225,327033209)])},_doProcessBlock:function(a,c){for(var d=this._hash.words,\nf=d[0],j=d[1],b=d[2],g=d[3],e=d[4],k=d[5],m=d[6],d=d[7],y=f.high,M=f.low,$=j.high,N=j.low,aa=b.high,O=b.low,ba=g.high,P=g.low,ca=e.high,Q=e.low,da=k.high,R=k.low,ea=m.high,S=m.low,fa=d.high,T=d.low,s=y,p=M,G=$,D=N,H=aa,E=O,W=ba,I=P,t=ca,q=Q,U=da,J=R,V=ea,K=S,X=fa,L=T,u=0;80>u;u++){var z=v[u];if(16>u)var r=z.high=a[c+2*u]|0,h=z.low=a[c+2*u+1]|0;else{var r=v[u-15],h=r.high,w=r.low,r=(h>>>1|w<<31)^(h>>>8|w<<24)^h>>>7,w=(w>>>1|h<<31)^(w>>>8|h<<24)^(w>>>7|h<<25),C=v[u-2],h=C.high,l=C.low,C=(h>>>19|l<<\n13)^(h<<3|l>>>29)^h>>>6,l=(l>>>19|h<<13)^(l<<3|h>>>29)^(l>>>6|h<<26),h=v[u-7],Y=h.high,A=v[u-16],x=A.high,A=A.low,h=w+h.low,r=r+Y+(h>>>0<w>>>0?1:0),h=h+l,r=r+C+(h>>>0<l>>>0?1:0),h=h+A,r=r+x+(h>>>0<A>>>0?1:0);z.high=r;z.low=h}var Y=t&U^~t&V,A=q&J^~q&K,z=s&G^s&H^G&H,ja=p&D^p&E^D&E,w=(s>>>28|p<<4)^(s<<30|p>>>2)^(s<<25|p>>>7),C=(p>>>28|s<<4)^(p<<30|s>>>2)^(p<<25|s>>>7),l=B[u],ka=l.high,ga=l.low,l=L+((q>>>14|t<<18)^(q>>>18|t<<14)^(q<<23|t>>>9)),x=X+((t>>>14|q<<18)^(t>>>18|q<<14)^(t<<23|q>>>9))+(l>>>0<\nL>>>0?1:0),l=l+A,x=x+Y+(l>>>0<A>>>0?1:0),l=l+ga,x=x+ka+(l>>>0<ga>>>0?1:0),l=l+h,x=x+r+(l>>>0<h>>>0?1:0),h=C+ja,z=w+z+(h>>>0<C>>>0?1:0),X=V,L=K,V=U,K=J,U=t,J=q,q=I+l|0,t=W+x+(q>>>0<I>>>0?1:0)|0,W=H,I=E,H=G,E=D,G=s,D=p,p=l+h|0,s=x+z+(p>>>0<l>>>0?1:0)|0}M=f.low=M+p;f.high=y+s+(M>>>0<p>>>0?1:0);N=j.low=N+D;j.high=$+G+(N>>>0<D>>>0?1:0);O=b.low=O+E;b.high=aa+H+(O>>>0<E>>>0?1:0);P=g.low=P+I;g.high=ba+W+(P>>>0<I>>>0?1:0);Q=e.low=Q+q;e.high=ca+t+(Q>>>0<q>>>0?1:0);R=k.low=R+J;k.high=da+U+(R>>>0<J>>>0?1:0);\nS=m.low=S+K;m.high=ea+V+(S>>>0<K>>>0?1:0);T=d.low=T+L;d.high=fa+X+(T>>>0<L>>>0?1:0)},_doFinalize:function(){var a=this._data,c=a.words,d=8*this._nDataBytes,f=8*a.sigBytes;c[f>>>5]|=128<<24-f%32;c[(f+128>>>10<<5)+30]=Math.floor(d/4294967296);c[(f+128>>>10<<5)+31]=d;a.sigBytes=4*c.length;this._process();return this._hash.toX32()},clone:function(){var a=d.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});c.SHA512=d._createHelper(j);c.HmacSHA512=d._createHmacHelper(j)})();\n(function(){var a=CryptoJS,c=a.x64,d=c.Word,j=c.WordArray,c=a.algo,f=c.SHA512,c=c.SHA384=f.extend({_doReset:function(){this._hash=new j.init([new d.init(3418070365,3238371032),new d.init(1654270250,914150663),new d.init(2438529370,812702999),new d.init(355462360,4144912697),new d.init(1731405415,4290775857),new d.init(2394180231,1750603025),new d.init(3675008525,1694076839),new d.init(1203062813,3204075428)])},_doFinalize:function(){var a=f._doFinalize.call(this);a.sigBytes-=16;return a}});a.SHA384=\nf._createHelper(c);a.HmacSHA384=f._createHmacHelper(c)})();\n"], "functools": [".py", "\"\"\n\n\n\n\n\n\n\n\n__all__ = ['update_wrapper', 'wraps', 'WRAPPER_ASSIGNMENTS', 'WRAPPER_UPDATES',\n'total_ordering', 'cmp_to_key', 'lru_cache', 'reduce', 'partial']\n\nfrom _functools import partial, reduce\nfrom collections import namedtuple\ntry:\n from _thread import RLock\nexcept:\n class RLock:\n  \"\"\n  def __enter__(self): pass\n  def __exit__(self, exctype, excinst, exctb): pass\n  \n  \n  \n  \n  \n  \n  \n  \n  \nWRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__',\n'__annotations__')\nWRAPPER_UPDATES = ('__dict__',)\ndef update_wrapper(wrapper,\nwrapped,\nassigned = WRAPPER_ASSIGNMENTS,\nupdated = WRAPPER_UPDATES):\n \"\"\n wrapper.__wrapped__ = wrapped\n for attr in assigned:\n  try:\n   value = getattr(wrapped, attr)\n  except AttributeError:\n   pass\n  else:\n   setattr(wrapper, attr, value)\n for attr in updated:\n  getattr(wrapper, attr).update(getattr(wrapped, attr, {}))\n  \n return wrapper\n \ndef wraps(wrapped,\nassigned = WRAPPER_ASSIGNMENTS,\nupdated = WRAPPER_UPDATES):\n \"\"\n return partial(update_wrapper, wrapped=wrapped,\n assigned=assigned, updated=updated)\n \n \n \n \n \n \ndef total_ordering(cls):\n \"\"\n convert = {\n '__lt__': [('__gt__', lambda self, other: not (self < other or self == other)),\n ('__le__', lambda self, other: self < other or self == other),\n ('__ge__', lambda self, other: not self < other)],\n '__le__': [('__ge__', lambda self, other: not self <= other or self == other),\n ('__lt__', lambda self, other: self <= other and not self == other),\n ('__gt__', lambda self, other: not self <= other)],\n '__gt__': [('__lt__', lambda self, other: not (self > other or self == other)),\n ('__ge__', lambda self, other: self > other or self == other),\n ('__le__', lambda self, other: not self > other)],\n '__ge__': [('__le__', lambda self, other: (not self >= other) or self == other),\n ('__gt__', lambda self, other: self >= other and not self == other),\n ('__lt__', lambda self, other: not self >= other)]\n }\n \n roots = [op for op in convert if getattr(cls, op, None) is not getattr(object, op, None)]\n if not roots:\n  raise ValueError('must define at least one ordering operation: < > <= >=')\n root = max(roots) \n for opname, opfunc in convert[root]:\n  if opname not in roots:\n   opfunc.__name__ = opname\n   opfunc.__doc__ = getattr(int, opname).__doc__\n   setattr(cls, opname, opfunc)\n return cls\n \n \n \n \n \n \ndef cmp_to_key(mycmp):\n \"\"\n class K(object):\n  __slots__ = ['obj']\n  def __init__(self, obj):\n   self.obj = obj\n  def __lt__(self, other):\n   return mycmp(self.obj, other.obj) < 0\n  def __gt__(self, other):\n   return mycmp(self.obj, other.obj) > 0\n  def __eq__(self, other):\n   return mycmp(self.obj, other.obj) == 0\n  def __le__(self, other):\n   return mycmp(self.obj, other.obj) <= 0\n  def __ge__(self, other):\n   return mycmp(self.obj, other.obj) >= 0\n  def __ne__(self, other):\n   return mycmp(self.obj, other.obj) != 0\n  __hash__ = None\n return K\n \ntry:\n from _functools import cmp_to_key\nexcept ImportError:\n pass\n \n \n \n \n \n \n_CacheInfo = namedtuple(\"CacheInfo\", [\"hits\", \"misses\", \"maxsize\", \"currsize\"])\n\nclass _HashedSeq(list):\n \"\"\n \n __slots__ = 'hashvalue'\n \n def __init__(self, tup, hash=hash):\n  self[:] = tup\n  self.hashvalue = hash(tup)\n  \n def __hash__(self):\n  return self.hashvalue\n  \ndef _make_key(args, kwds, typed,\nkwd_mark = (object(),),\nfasttypes = {int, str, frozenset, type(None)},\nsorted=sorted, tuple=tuple, type=type, len=len):\n \"\"\n key = args\n if kwds:\n  sorted_items = sorted(kwds.items())\n  key += kwd_mark\n  for item in sorted_items:\n   key += item\n if typed:\n  key += tuple(type(v) for v in args)\n  if kwds:\n   key += tuple(type(v) for k, v in sorted_items)\n elif len(key) == 1 and type(key[0]) in fasttypes:\n  return key[0]\n return _HashedSeq(key)\n \ndef lru_cache(maxsize=128, typed=False):\n \"\"\n \n \n \n \n \n \n \n sentinel = object() \n make_key = _make_key \n PREV, NEXT, KEY, RESULT = 0, 1, 2, 3 \n \n def decorating_function(user_function):\n \n  cache = {}\n  hits = misses = 0\n  full = False\n  cache_get = cache.get \n  lock = RLock() \n  root = [] \n  root[:] = [root, root, None, None] \n  \n  if maxsize == 0:\n  \n   def wrapper(*args, **kwds):\n   \n    nonlocal misses\n    result = user_function(*args, **kwds)\n    misses += 1\n    return result\n    \n  elif maxsize is None:\n  \n   def wrapper(*args, **kwds):\n   \n    nonlocal hits, misses\n    key = make_key(args, kwds, typed)\n    result = cache_get(key, sentinel)\n    if result is not sentinel:\n     hits += 1\n     return result\n    result = user_function(*args, **kwds)\n    cache[key] = result\n    misses += 1\n    return result\n    \n  else:\n  \n   def wrapper(*args, **kwds):\n   \n    nonlocal root, hits, misses, full\n    key = make_key(args, kwds, typed)\n    with lock:\n     link = cache_get(key)\n     if link is not None:\n     \n      link_prev, link_next, _key, result = link\n      link_prev[NEXT] = link_next\n      link_next[PREV] = link_prev\n      last = root[PREV]\n      last[NEXT] = root[PREV] = link\n      link[PREV] = last\n      link[NEXT] = root\n      hits += 1\n      return result\n    result = user_function(*args, **kwds)\n    with lock:\n     if key in cache:\n     \n     \n     \n     \n      pass\n     elif full:\n     \n      oldroot = root\n      oldroot[KEY] = key\n      oldroot[RESULT] = result\n      \n      \n      \n      \n      \n      \n      root = oldroot[NEXT]\n      oldkey = root[KEY]\n      oldresult = root[RESULT]\n      root[KEY] = root[RESULT] = None\n      \n      del cache[oldkey]\n      \n      \n      \n      cache[key] = oldroot\n     else:\n     \n      last = root[PREV]\n      link = [last, root, key, result]\n      last[NEXT] = root[PREV] = cache[key] = link\n      full = (len(cache) >= maxsize)\n     misses += 1\n    return result\n    \n  def cache_info():\n   \"\"\n   with lock:\n    return _CacheInfo(hits, misses, maxsize, len(cache))\n    \n  def cache_clear():\n   \"\"\n   nonlocal hits, misses, full\n   with lock:\n    cache.clear()\n    root[:] = [root, root, None, None]\n    hits = misses = 0\n    full = False\n    \n  wrapper.cache_info = cache_info\n  wrapper.cache_clear = cache_clear\n  return update_wrapper(wrapper, user_function)\n  \n return decorating_function\n"], "random": [".py", "\"\"\n\n\n\n\ndef _warn(msg):\n print(msg)\n \nfrom types import MethodType as _MethodType, BuiltinMethodType as _BuiltinMethodType\nfrom math import log as _log, exp as _exp, pi as _pi, e as _e, ceil as _ceil\nfrom math import sqrt as _sqrt, acos as _acos, cos as _cos, sin as _sin\n\nfrom browser import window\n\ndef _randint(a, b):\n return int(window.Math.random()*(b-a+1)+a)\n \n \ndef _urandom(n):\n \"\"\n randbytes= [_randint(0,255) for i in range(n)]\n return bytes(randbytes)\n \n \n_Set = set\n_Sequence = [str, list]\n\nfrom hashlib import sha512 as _sha512\n\n__all__ = [\"Random\",\"seed\",\"random\",\"uniform\",\"randint\",\"choice\",\"sample\",\n\"randrange\",\"shuffle\",\"normalvariate\",\"lognormvariate\",\n\"expovariate\",\"vonmisesvariate\",\"gammavariate\",\"triangular\",\n\"gauss\",\"betavariate\",\"paretovariate\",\"weibullvariate\",\n\"getstate\",\"setstate\", \"getrandbits\",\n\"SystemRandom\"]\n\nNV_MAGICCONST = 4 * _exp(-0.5)/_sqrt(2.0)\nTWOPI = 2.0*_pi\nLOG4 = _log(4.0)\nSG_MAGICCONST = 1.0 + _log(4.5)\nBPF = 53 \nRECIP_BPF = 2**-BPF\n\n\n\n\n\n\nimport _random\n\nclass Random(_random.Random):\n \"\"\n \n VERSION = 3 \n \n def __init__(self, x=None):\n  \"\"\n  \n  self.seed(x)\n  self.gauss_next = None\n  \n def seed(self, a=None, version=2):\n  \"\"\n  \n  if a is None:\n   try:\n    a = int.from_bytes(_urandom(32), 'big')\n   except NotImplementedError:\n    import time\n    a = int(time.time() * 256) \n    \n  if version == 2:\n   if isinstance(a, (str, bytes, bytearray)):\n    if isinstance(a, str):\n     a = a.encode()\n    a += _sha512(a).digest()\n    a = int.from_bytes(a, 'big')\n    \n  super().seed(a)\n  self.gauss_next = None\n  \n def getstate(self):\n  \"\"\n  return self.VERSION, super().getstate(), self.gauss_next\n  \n def setstate(self, state):\n  \"\"\n  version = state[0]\n  if version == 3:\n   version, internalstate, self.gauss_next = state\n   super().setstate(internalstate)\n  elif version == 2:\n   version, internalstate, self.gauss_next = state\n   \n   \n   \n   \n   try:\n    internalstate = tuple(x % (2**32) for x in internalstate)\n   except ValueError as e:\n    raise TypeError from e\n   super().setstate(internalstate)\n  else:\n   raise ValueError(\"state with version %s passed to \"\n   \"Random.setstate() of version %s\" %\n   (version, self.VERSION))\n   \n   \n   \n   \n   \n   \n def __getstate__(self): \n  return self.getstate()\n  \n def __setstate__(self, state): \n  self.setstate(state)\n  \n def __reduce__(self):\n  return self.__class__, (), self.getstate()\n  \n  \n  \n def randrange(self, start, stop=None, step=1, _int=int):\n  \"\"\n  \n  \n  \n  istart = _int(start)\n  if istart != start:\n   raise ValueError(\"non-integer arg 1 for randrange()\")\n  if stop is None:\n   if istart > 0:\n    return self._randbelow(istart)\n   raise ValueError(\"empty range for randrange()\")\n   \n   \n  istop = _int(stop)\n  if istop != stop:\n   raise ValueError(\"non-integer stop for randrange()\")\n  width = istop - istart\n  if step == 1 and width > 0:\n   return istart + self._randbelow(width)\n  if step == 1:\n   raise ValueError(\"empty range for randrange() (%d,%d, %d)\" % (istart, istop, width))\n   \n   \n  istep = _int(step)\n  if istep != step:\n   raise ValueError(\"non-integer step for randrange()\")\n  if istep > 0:\n   n = (width + istep - 1) // istep\n  elif istep < 0:\n   n = (width + istep + 1) // istep\n  else:\n   raise ValueError(\"zero step for randrange()\")\n   \n  if n <= 0:\n   raise ValueError(\"empty range for randrange()\")\n   \n  return istart + istep*self._randbelow(n)\n  \n def randint(self, a, b):\n  \"\"\n  \n  return self.randrange(a, b+1)\n  \n def _randbelow(self, n, int=int, maxsize=1<<BPF, type=type,\n Method=_MethodType, BuiltinMethod=_BuiltinMethodType):\n  \"\"\n  \n  getrandbits = self.getrandbits\n  \n  \n  if type(self.random) is BuiltinMethod or type(getrandbits) is Method:\n   k = n.bit_length() \n   r = getrandbits(k) \n   while r >= n:\n    r = getrandbits(k)\n   return r\n   \n   \n  random = self.random\n  if n >= maxsize:\n   _warn(\"Underlying random() generator does not supply \\n\"\n   \"enough bits to choose from a population range this large.\\n\"\n   \"To remove the range limitation, add a getrandbits() method.\")\n   return int(random() * n)\n  rem = maxsize % n\n  limit = (maxsize - rem) / maxsize \n  r = random()\n  while r >= limit:\n   r = random()\n  return int(r*maxsize) % n\n  \n  \n  \n def choice(self, seq):\n  \"\"\n  try:\n   i = self._randbelow(len(seq))\n  except ValueError:\n   raise IndexError('Cannot choose from an empty sequence')\n  return seq[i]\n  \n def shuffle(self, x, random=None):\n  \"\"\n  \n  if random is None:\n   randbelow = self._randbelow\n   for i in reversed(range(1, len(x))):\n   \n    j = randbelow(i+1)\n    x[i], x[j] = x[j], x[i]\n  else:\n   _int = int\n   for i in reversed(range(1, len(x))):\n   \n    j = _int(random() * (i+1))\n    x[i], x[j] = x[j], x[i]\n    \n def sample(self, population, k):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if isinstance(population, _Set):\n   population = tuple(population)\n  if not isinstance(population, _Sequence):\n   raise TypeError(\"Population must be a sequence or set.  For dicts, use list(d).\")\n  randbelow = self._randbelow\n  n = len(population)\n  if not 0 <= k <= n:\n   raise ValueError(\"Sample larger than population\")\n  result = [None] * k\n  setsize = 21 \n  if k > 5:\n   setsize += 4 ** _ceil(_log(k * 3, 4)) \n  if n <= setsize:\n  \n   pool = list(population)\n   for i in range(k): \n    j = randbelow(n-i)\n    result[i] = pool[j]\n    pool[j] = pool[n-i-1] \n  else:\n   selected = set()\n   selected_add = selected.add\n   for i in range(k):\n    j = randbelow(n)\n    while j in selected:\n     j = randbelow(n)\n    selected_add(j)\n    result[i] = population[j]\n  return result\n  \n  \n  \n  \n  \n def uniform(self, a, b):\n  \"\"\n  return a + (b-a) * self.random()\n  \n  \n  \n def triangular(self, low=0.0, high=1.0, mode=None):\n  \"\"\n  u = self.random()\n  c = 0.5 if mode is None else (mode - low) / (high - low)\n  if u > c:\n   u = 1.0 - u\n   c = 1.0 - c\n   low, high = high, low\n  return low + (high - low) * (u * c) ** 0.5\n  \n  \n  \n def normalvariate(self, mu, sigma):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  random = self.random\n  while 1:\n   u1 = random()\n   u2 = 1.0 - random()\n   z = NV_MAGICCONST*(u1-0.5)/u2\n   zz = z*z/4.0\n   if zz <= -_log(u2):\n    break\n  return mu + z*sigma\n  \n  \n  \n def lognormvariate(self, mu, sigma):\n  \"\"\n  return _exp(self.normalvariate(mu, sigma))\n  \n  \n  \n def expovariate(self, lambd):\n  \"\"\n  \n  \n  \n  \n  \n  return -_log(1.0 - self.random())/lambd\n  \n  \n  \n def vonmisesvariate(self, mu, kappa):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  random = self.random\n  if kappa <= 1e-6:\n   return TWOPI * random()\n   \n  s = 0.5 / kappa\n  r = s + _sqrt(1.0 + s * s)\n  \n  while 1:\n   u1 = random()\n   z = _cos(_pi * u1)\n   \n   d = z / (r + z)\n   u2 = random()\n   if u2 < 1.0 - d * d or u2 <= (1.0 - d) * _exp(d):\n    break\n    \n  q = 1.0 / r\n  f = (q + z) / (1.0 + q * z)\n  u3 = random()\n  if u3 > 0.5:\n   theta = (mu + _acos(f)) % TWOPI\n  else:\n   theta = (mu - _acos(f)) % TWOPI\n   \n  return theta\n  \n  \n  \n def gammavariate(self, alpha, beta):\n  \"\"\n  \n  \n  \n  \n  \n  if alpha <= 0.0 or beta <= 0.0:\n   raise ValueError('gammavariate: alpha and beta must be > 0.0')\n   \n  random = self.random\n  if alpha > 1.0:\n  \n  \n  \n  \n  \n   ainv = _sqrt(2.0 * alpha - 1.0)\n   bbb = alpha - LOG4\n   ccc = alpha + ainv\n   \n   while 1:\n    u1 = random()\n    if not 1e-7 < u1 < .9999999:\n     continue\n    u2 = 1.0 - random()\n    v = _log(u1/(1.0-u1))/ainv\n    x = alpha*_exp(v)\n    z = u1*u1*u2\n    r = bbb+ccc*v-x\n    if r + SG_MAGICCONST - 4.5*z >= 0.0 or r >= _log(z):\n     return x * beta\n     \n  elif alpha == 1.0:\n  \n   u = random()\n   while u <= 1e-7:\n    u = random()\n   return -_log(u) * beta\n   \n  else: \n  \n  \n  \n   while 1:\n    u = random()\n    b = (_e + alpha)/_e\n    p = b*u\n    if p <= 1.0:\n     x = p ** (1.0/alpha)\n    else:\n     x = -_log((b-p)/alpha)\n    u1 = random()\n    if p > 1.0:\n     if u1 <= x ** (alpha - 1.0):\n      break\n    elif u1 <= _exp(-x):\n     break\n   return x * beta\n   \n   \n   \n def gauss(self, mu, sigma):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  random = self.random\n  z = self.gauss_next\n  self.gauss_next = None\n  if z is None:\n   x2pi = random() * TWOPI\n   g2rad = _sqrt(-2.0 * _log(1.0 - random()))\n   z = _cos(x2pi) * g2rad\n   self.gauss_next = _sin(x2pi) * g2rad\n   \n  return mu + z*sigma\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def betavariate(self, alpha, beta):\n  \"\"\n  \n  \n  \n  y = self.gammavariate(alpha, 1.)\n  if y == 0:\n   return 0.0\n  else:\n   return y / (y + self.gammavariate(beta, 1.))\n   \n   \n   \n def paretovariate(self, alpha):\n  \"\"\n  \n  \n  u = 1.0 - self.random()\n  return 1.0 / u ** (1.0/alpha)\n  \n  \n  \n def weibullvariate(self, alpha, beta):\n  \"\"\n  \n  \n  u = 1.0 - self.random()\n  return alpha * (-_log(u)) ** (1.0/beta)\n  \n  \n  \nclass SystemRandom(Random):\n \"\"\n \n def random(self):\n  \"\"\n  return (int.from_bytes(_urandom(7), 'big') >> 3) * RECIP_BPF\n  \n def getrandbits(self, k):\n  \"\"\n  if k <= 0:\n   raise ValueError('number of bits must be greater than zero')\n  if k != int(k):\n   raise TypeError('number of bits should be an integer')\n  numbytes = (k + 7) // 8 \n  x = int.from_bytes(_urandom(numbytes), 'big')\n  return x >> (numbytes * 8 - k) \n  \n def seed(self, *args, **kwds):\n  \"\"\n  return None\n  \n def _notimplemented(self, *args, **kwds):\n  \"\"\n  raise NotImplementedError('System entropy source does not have state.')\n getstate = setstate = _notimplemented\n \n \n \ndef _test_generator(n, func, args):\n import time\n print(n, 'times', func.__name__)\n total = 0.0\n sqsum = 0.0\n smallest = 1e10\n largest = -1e10\n t0 = time.time()\n for i in range(n):\n  x = func(*args)\n  total += x\n  sqsum = sqsum + x*x\n  smallest = min(x, smallest)\n  largest = max(x, largest)\n t1 = time.time()\n print(round(t1-t0, 3), 'sec,', end=' ')\n avg = total/n\n stddev = _sqrt(sqsum/n - avg*avg)\n print('avg %g, stddev %g, min %g, max %g' % (avg, stddev, smallest, largest))\n \n \ndef _test(N=2000):\n _test_generator(N, random, ())\n _test_generator(N, normalvariate, (0.0, 1.0))\n _test_generator(N, lognormvariate, (0.0, 1.0))\n _test_generator(N, vonmisesvariate, (0.0, 1.0))\n _test_generator(N, gammavariate, (0.01, 1.0))\n _test_generator(N, gammavariate, (0.1, 1.0))\n _test_generator(N, gammavariate, (0.1, 2.0))\n _test_generator(N, gammavariate, (0.5, 1.0))\n _test_generator(N, gammavariate, (0.9, 1.0))\n _test_generator(N, gammavariate, (1.0, 1.0))\n _test_generator(N, gammavariate, (2.0, 1.0))\n _test_generator(N, gammavariate, (20.0, 1.0))\n _test_generator(N, gammavariate, (200.0, 1.0))\n _test_generator(N, gauss, (0.0, 1.0))\n _test_generator(N, betavariate, (3.0, 3.0))\n _test_generator(N, triangular, (0.0, 1.0, 1.0/3.0))\n \n \n \n \n \n \n \n_inst = Random()\nseed = _inst.seed\nrandom = _inst.random\nuniform = _inst.uniform\ntriangular = _inst.triangular\nrandint = _inst.randint\nchoice = _inst.choice\nrandrange = _inst.randrange\nsample = _inst.sample\nshuffle = _inst.shuffle\nnormalvariate = _inst.normalvariate\nlognormvariate = _inst.lognormvariate\nexpovariate = _inst.expovariate\nvonmisesvariate = _inst.vonmisesvariate\ngammavariate = _inst.gammavariate\ngauss = _inst.gauss\nbetavariate = _inst.betavariate\nparetovariate = _inst.paretovariate\nweibullvariate = _inst.weibullvariate\ngetstate = _inst.getstate\nsetstate = _inst.setstate\ngetrandbits = _inst.getrandbits\n\nif __name__ == '__main__':\n _test()\n"], "xml.dom.expatbuilder": [".py", "\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom xml.dom import xmlbuilder, minidom, Node\nfrom xml.dom import EMPTY_NAMESPACE, EMPTY_PREFIX, XMLNS_NAMESPACE\nfrom xml.parsers import expat\nfrom xml.dom.minidom import _append_child, _set_attribute_node\nfrom xml.dom.NodeFilter import NodeFilter\n\nTEXT_NODE = Node.TEXT_NODE\nCDATA_SECTION_NODE = Node.CDATA_SECTION_NODE\nDOCUMENT_NODE = Node.DOCUMENT_NODE\n\nFILTER_ACCEPT = xmlbuilder.DOMBuilderFilter.FILTER_ACCEPT\nFILTER_REJECT = xmlbuilder.DOMBuilderFilter.FILTER_REJECT\nFILTER_SKIP = xmlbuilder.DOMBuilderFilter.FILTER_SKIP\nFILTER_INTERRUPT = xmlbuilder.DOMBuilderFilter.FILTER_INTERRUPT\n\ntheDOMImplementation = minidom.getDOMImplementation()\n\n\n_typeinfo_map = {\n\"CDATA\": minidom.TypeInfo(None, \"cdata\"),\n\"ENUM\": minidom.TypeInfo(None, \"enumeration\"),\n\"ENTITY\": minidom.TypeInfo(None, \"entity\"),\n\"ENTITIES\": minidom.TypeInfo(None, \"entities\"),\n\"ID\": minidom.TypeInfo(None, \"id\"),\n\"IDREF\": minidom.TypeInfo(None, \"idref\"),\n\"IDREFS\": minidom.TypeInfo(None, \"idrefs\"),\n\"NMTOKEN\": minidom.TypeInfo(None, \"nmtoken\"),\n\"NMTOKENS\": minidom.TypeInfo(None, \"nmtokens\"),\n}\n\nclass ElementInfo(object):\n __slots__ = '_attr_info', '_model', 'tagName'\n \n def __init__(self, tagName, model=None):\n  self.tagName = tagName\n  self._attr_info = []\n  self._model = model\n  \n def __getstate__(self):\n  return self._attr_info, self._model, self.tagName\n  \n def __setstate__(self, state):\n  self._attr_info, self._model, self.tagName = state\n  \n def getAttributeType(self, aname):\n  for info in self._attr_info:\n   if info[1] == aname:\n    t = info[-2]\n    if t[0] == \"(\":\n     return _typeinfo_map[\"ENUM\"]\n    else:\n     return _typeinfo_map[info[-2]]\n  return minidom._no_type\n  \n def getAttributeTypeNS(self, namespaceURI, localName):\n  return minidom._no_type\n  \n def isElementContent(self):\n  if self._model:\n   type = self._model[0]\n   return type not in (expat.model.XML_CTYPE_ANY,\n   expat.model.XML_CTYPE_MIXED)\n  else:\n   return False\n   \n def isEmpty(self):\n  if self._model:\n   return self._model[0] == expat.model.XML_CTYPE_EMPTY\n  else:\n   return False\n   \n def isId(self, aname):\n  for info in self._attr_info:\n   if info[1] == aname:\n    return info[-2] == \"ID\"\n  return False\n  \n def isIdNS(self, euri, ename, auri, aname):\n \n  return self.isId((auri, aname))\n  \ndef _intern(builder, s):\n return builder._intern_setdefault(s, s)\n \ndef _parse_ns_name(builder, name):\n assert ' ' in name\n parts = name.split(' ')\n intern = builder._intern_setdefault\n if len(parts) == 3:\n  uri, localname, prefix = parts\n  prefix = intern(prefix, prefix)\n  qname = \"%s:%s\" % (prefix, localname)\n  qname = intern(qname, qname)\n  localname = intern(localname, localname)\n else:\n  uri, localname = parts\n  prefix = EMPTY_PREFIX\n  qname = localname = intern(localname, localname)\n return intern(uri, uri), localname, prefix, qname\n \n \nclass ExpatBuilder:\n \"\"\n \n def __init__(self, options=None):\n  if options is None:\n   options = xmlbuilder.Options()\n  self._options = options\n  if self._options.filter is not None:\n   self._filter = FilterVisibilityController(self._options.filter)\n  else:\n   self._filter = None\n   \n   \n   self._finish_start_element = id\n  self._parser = None\n  self.reset()\n  \n def createParser(self):\n  \"\"\n  return expat.ParserCreate()\n  \n def getParser(self):\n  \"\"\n  if not self._parser:\n   self._parser = self.createParser()\n   self._intern_setdefault = self._parser.intern.setdefault\n   self._parser.buffer_text = True\n   self._parser.ordered_attributes = True\n   self._parser.specified_attributes = True\n   self.install(self._parser)\n  return self._parser\n  \n def reset(self):\n  \"\"\n  self.document = theDOMImplementation.createDocument(\n  EMPTY_NAMESPACE, None, None)\n  self.curNode = self.document\n  self._elem_info = self.document._elem_info\n  self._cdata = False\n  \n def install(self, parser):\n  \"\"\n  \n  parser.StartDoctypeDeclHandler = self.start_doctype_decl_handler\n  parser.StartElementHandler = self.first_element_handler\n  parser.EndElementHandler = self.end_element_handler\n  parser.ProcessingInstructionHandler = self.pi_handler\n  if self._options.entities:\n   parser.EntityDeclHandler = self.entity_decl_handler\n  parser.NotationDeclHandler = self.notation_decl_handler\n  if self._options.comments:\n   parser.CommentHandler = self.comment_handler\n  if self._options.cdata_sections:\n   parser.StartCdataSectionHandler = self.start_cdata_section_handler\n   parser.EndCdataSectionHandler = self.end_cdata_section_handler\n   parser.CharacterDataHandler = self.character_data_handler_cdata\n  else:\n   parser.CharacterDataHandler = self.character_data_handler\n  parser.ExternalEntityRefHandler = self.external_entity_ref_handler\n  parser.XmlDeclHandler = self.xml_decl_handler\n  parser.ElementDeclHandler = self.element_decl_handler\n  parser.AttlistDeclHandler = self.attlist_decl_handler\n  \n def parseFile(self, file):\n  \"\"\n  parser = self.getParser()\n  first_buffer = True\n  try:\n   while 1:\n    buffer = file.read(16*1024)\n    if not buffer:\n     break\n    parser.Parse(buffer, 0)\n    if first_buffer and self.document.documentElement:\n     self._setup_subset(buffer)\n    first_buffer = False\n   parser.Parse(\"\", True)\n  except ParseEscape:\n   pass\n  doc = self.document\n  self.reset()\n  self._parser = None\n  return doc\n  \n def parseString(self, string):\n  \"\"\n  parser = self.getParser()\n  try:\n   parser.Parse(string, True)\n   self._setup_subset(string)\n  except ParseEscape:\n   pass\n  doc = self.document\n  self.reset()\n  self._parser = None\n  return doc\n  \n def _setup_subset(self, buffer):\n  \"\"\n  if self.document.doctype:\n   extractor = InternalSubsetExtractor()\n   extractor.parseString(buffer)\n   subset = extractor.getSubset()\n   self.document.doctype.internalSubset = subset\n   \n def start_doctype_decl_handler(self, doctypeName, systemId, publicId,\n has_internal_subset):\n  doctype = self.document.implementation.createDocumentType(\n  doctypeName, publicId, systemId)\n  doctype.ownerDocument = self.document\n  _append_child(self.document, doctype)\n  self.document.doctype = doctype\n  if self._filter and self._filter.acceptNode(doctype) == FILTER_REJECT:\n   self.document.doctype = None\n   del self.document.childNodes[-1]\n   doctype = None\n   self._parser.EntityDeclHandler = None\n   self._parser.NotationDeclHandler = None\n  if has_internal_subset:\n   if doctype is not None:\n    doctype.entities._seq = []\n    doctype.notations._seq = []\n   self._parser.CommentHandler = None\n   self._parser.ProcessingInstructionHandler = None\n   self._parser.EndDoctypeDeclHandler = self.end_doctype_decl_handler\n   \n def end_doctype_decl_handler(self):\n  if self._options.comments:\n   self._parser.CommentHandler = self.comment_handler\n  self._parser.ProcessingInstructionHandler = self.pi_handler\n  if not (self._elem_info or self._filter):\n   self._finish_end_element = id\n   \n def pi_handler(self, target, data):\n  node = self.document.createProcessingInstruction(target, data)\n  _append_child(self.curNode, node)\n  if self._filter and self._filter.acceptNode(node) == FILTER_REJECT:\n   self.curNode.removeChild(node)\n   \n def character_data_handler_cdata(self, data):\n  childNodes = self.curNode.childNodes\n  if self._cdata:\n   if ( self._cdata_continue\n   and childNodes[-1].nodeType == CDATA_SECTION_NODE):\n    childNodes[-1].appendData(data)\n    return\n   node = self.document.createCDATASection(data)\n   self._cdata_continue = True\n  elif childNodes and childNodes[-1].nodeType == TEXT_NODE:\n   node = childNodes[-1]\n   value = node.data + data\n   node.data = value\n   return\n  else:\n   node = minidom.Text()\n   node.data = data\n   node.ownerDocument = self.document\n  _append_child(self.curNode, node)\n  \n def character_data_handler(self, data):\n  childNodes = self.curNode.childNodes\n  if childNodes and childNodes[-1].nodeType == TEXT_NODE:\n   node = childNodes[-1]\n   node.data = node.data + data\n   return\n  node = minidom.Text()\n  node.data = node.data + data\n  node.ownerDocument = self.document\n  _append_child(self.curNode, node)\n  \n def entity_decl_handler(self, entityName, is_parameter_entity, value,\n base, systemId, publicId, notationName):\n  if is_parameter_entity:\n  \n   return\n  if not self._options.entities:\n   return\n  node = self.document._create_entity(entityName, publicId,\n  systemId, notationName)\n  if value is not None:\n  \n  \n   child = self.document.createTextNode(value)\n   node.childNodes.append(child)\n  self.document.doctype.entities._seq.append(node)\n  if self._filter and self._filter.acceptNode(node) == FILTER_REJECT:\n   del self.document.doctype.entities._seq[-1]\n   \n def notation_decl_handler(self, notationName, base, systemId, publicId):\n  node = self.document._create_notation(notationName, publicId, systemId)\n  self.document.doctype.notations._seq.append(node)\n  if self._filter and self._filter.acceptNode(node) == FILTER_ACCEPT:\n   del self.document.doctype.notations._seq[-1]\n   \n def comment_handler(self, data):\n  node = self.document.createComment(data)\n  _append_child(self.curNode, node)\n  if self._filter and self._filter.acceptNode(node) == FILTER_REJECT:\n   self.curNode.removeChild(node)\n   \n def start_cdata_section_handler(self):\n  self._cdata = True\n  self._cdata_continue = False\n  \n def end_cdata_section_handler(self):\n  self._cdata = False\n  self._cdata_continue = False\n  \n def external_entity_ref_handler(self, context, base, systemId, publicId):\n  return 1\n  \n def first_element_handler(self, name, attributes):\n  if self._filter is None and not self._elem_info:\n   self._finish_end_element = id\n  self.getParser().StartElementHandler = self.start_element_handler\n  self.start_element_handler(name, attributes)\n  \n def start_element_handler(self, name, attributes):\n  node = self.document.createElement(name)\n  _append_child(self.curNode, node)\n  self.curNode = node\n  \n  if attributes:\n   for i in range(0, len(attributes), 2):\n    a = minidom.Attr(attributes[i], EMPTY_NAMESPACE,\n    None, EMPTY_PREFIX)\n    value = attributes[i+1]\n    a.value = value\n    a.ownerDocument = self.document\n    _set_attribute_node(node, a)\n    \n  if node is not self.document.documentElement:\n   self._finish_start_element(node)\n   \n def _finish_start_element(self, node):\n  if self._filter:\n  \n  \n   if node is self.document.documentElement:\n    return\n   filt = self._filter.startContainer(node)\n   if filt == FILTER_REJECT:\n   \n    Rejecter(self)\n   elif filt == FILTER_SKIP:\n   \n   \n    Skipper(self)\n   else:\n    return\n   self.curNode = node.parentNode\n   node.parentNode.removeChild(node)\n   node.unlink()\n   \n   \n   \n   \n def end_element_handler(self, name):\n  curNode = self.curNode\n  self.curNode = curNode.parentNode\n  self._finish_end_element(curNode)\n  \n def _finish_end_element(self, curNode):\n  info = self._elem_info.get(curNode.tagName)\n  if info:\n   self._handle_white_text_nodes(curNode, info)\n  if self._filter:\n   if curNode is self.document.documentElement:\n    return\n   if self._filter.acceptNode(curNode) == FILTER_REJECT:\n    self.curNode.removeChild(curNode)\n    curNode.unlink()\n    \n def _handle_white_text_nodes(self, node, info):\n  if (self._options.whitespace_in_element_content\n  or not info.isElementContent()):\n   return\n   \n   \n   \n   \n  L = []\n  for child in node.childNodes:\n   if child.nodeType == TEXT_NODE and not child.data.strip():\n    L.append(child)\n    \n    \n  for child in L:\n   node.removeChild(child)\n   \n def element_decl_handler(self, name, model):\n  info = self._elem_info.get(name)\n  if info is None:\n   self._elem_info[name] = ElementInfo(name, model)\n  else:\n   assert info._model is None\n   info._model = model\n   \n def attlist_decl_handler(self, elem, name, type, default, required):\n  info = self._elem_info.get(elem)\n  if info is None:\n   info = ElementInfo(elem)\n   self._elem_info[elem] = info\n  info._attr_info.append(\n  [None, name, None, None, default, 0, type, required])\n  \n def xml_decl_handler(self, version, encoding, standalone):\n  self.document.version = version\n  self.document.encoding = encoding\n  \n  if standalone >= 0:\n   if standalone:\n    self.document.standalone = True\n   else:\n    self.document.standalone = False\n    \n    \n    \n    \n_ALLOWED_FILTER_RETURNS = (FILTER_ACCEPT, FILTER_REJECT, FILTER_SKIP)\n\nclass FilterVisibilityController(object):\n \"\"\n \n __slots__ = 'filter',\n \n def __init__(self, filter):\n  self.filter = filter\n  \n def startContainer(self, node):\n  mask = self._nodetype_mask[node.nodeType]\n  if self.filter.whatToShow & mask:\n   val = self.filter.startContainer(node)\n   if val == FILTER_INTERRUPT:\n    raise ParseEscape\n   if val not in _ALLOWED_FILTER_RETURNS:\n    raise ValueError(\n    \"startContainer() returned illegal value: \" + repr(val))\n   return val\n  else:\n   return FILTER_ACCEPT\n   \n def acceptNode(self, node):\n  mask = self._nodetype_mask[node.nodeType]\n  if self.filter.whatToShow & mask:\n   val = self.filter.acceptNode(node)\n   if val == FILTER_INTERRUPT:\n    raise ParseEscape\n   if val == FILTER_SKIP:\n   \n    parent = node.parentNode\n    for child in node.childNodes[:]:\n     parent.appendChild(child)\n     \n    return FILTER_REJECT\n   if val not in _ALLOWED_FILTER_RETURNS:\n    raise ValueError(\n    \"acceptNode() returned illegal value: \" + repr(val))\n   return val\n  else:\n   return FILTER_ACCEPT\n   \n _nodetype_mask = {\n Node.ELEMENT_NODE: NodeFilter.SHOW_ELEMENT,\n Node.ATTRIBUTE_NODE: NodeFilter.SHOW_ATTRIBUTE,\n Node.TEXT_NODE: NodeFilter.SHOW_TEXT,\n Node.CDATA_SECTION_NODE: NodeFilter.SHOW_CDATA_SECTION,\n Node.ENTITY_REFERENCE_NODE: NodeFilter.SHOW_ENTITY_REFERENCE,\n Node.ENTITY_NODE: NodeFilter.SHOW_ENTITY,\n Node.PROCESSING_INSTRUCTION_NODE: NodeFilter.SHOW_PROCESSING_INSTRUCTION,\n Node.COMMENT_NODE: NodeFilter.SHOW_COMMENT,\n Node.DOCUMENT_NODE: NodeFilter.SHOW_DOCUMENT,\n Node.DOCUMENT_TYPE_NODE: NodeFilter.SHOW_DOCUMENT_TYPE,\n Node.DOCUMENT_FRAGMENT_NODE: NodeFilter.SHOW_DOCUMENT_FRAGMENT,\n Node.NOTATION_NODE: NodeFilter.SHOW_NOTATION,\n }\n \n \nclass FilterCrutch(object):\n __slots__ = '_builder', '_level', '_old_start', '_old_end'\n \n def __init__(self, builder):\n  self._level = 0\n  self._builder = builder\n  parser = builder._parser\n  self._old_start = parser.StartElementHandler\n  self._old_end = parser.EndElementHandler\n  parser.StartElementHandler = self.start_element_handler\n  parser.EndElementHandler = self.end_element_handler\n  \nclass Rejecter(FilterCrutch):\n __slots__ = ()\n \n def __init__(self, builder):\n  FilterCrutch.__init__(self, builder)\n  parser = builder._parser\n  for name in (\"ProcessingInstructionHandler\",\n  \"CommentHandler\",\n  \"CharacterDataHandler\",\n  \"StartCdataSectionHandler\",\n  \"EndCdataSectionHandler\",\n  \"ExternalEntityRefHandler\",\n  ):\n   setattr(parser, name, None)\n   \n def start_element_handler(self, *args):\n  self._level = self._level + 1\n  \n def end_element_handler(self, *args):\n  if self._level == 0:\n  \n   parser = self._builder._parser\n   self._builder.install(parser)\n   parser.StartElementHandler = self._old_start\n   parser.EndElementHandler = self._old_end\n  else:\n   self._level = self._level - 1\n   \nclass Skipper(FilterCrutch):\n __slots__ = ()\n \n def start_element_handler(self, *args):\n  node = self._builder.curNode\n  self._old_start(*args)\n  if self._builder.curNode is not node:\n   self._level = self._level + 1\n   \n def end_element_handler(self, *args):\n  if self._level == 0:\n  \n  \n   self._builder._parser.StartElementHandler = self._old_start\n   self._builder._parser.EndElementHandler = self._old_end\n   self._builder = None\n  else:\n   self._level = self._level - 1\n   self._old_end(*args)\n   \n   \n   \n   \n   \n_FRAGMENT_BUILDER_INTERNAL_SYSTEM_ID = \"http://xml.python.org/entities/fragment-builder/internal\"\n\n_FRAGMENT_BUILDER_TEMPLATE = (\n'''\\\n<!DOCTYPE wrapper\n  %%s [\n  <!ENTITY fragment-builder-internal\n    SYSTEM \"%s\">\n%%s\n]>\n<wrapper %%s\n>&fragment-builder-internal;</wrapper>'''\n% _FRAGMENT_BUILDER_INTERNAL_SYSTEM_ID)\n\n\nclass FragmentBuilder(ExpatBuilder):\n \"\"\n \n def __init__(self, context, options=None):\n  if context.nodeType == DOCUMENT_NODE:\n   self.originalDocument = context\n   self.context = context\n  else:\n   self.originalDocument = context.ownerDocument\n   self.context = context\n  ExpatBuilder.__init__(self, options)\n  \n def reset(self):\n  ExpatBuilder.reset(self)\n  self.fragment = None\n  \n def parseFile(self, file):\n  \"\"\n  return self.parseString(file.read())\n  \n def parseString(self, string):\n  \"\"\n  self._source = string\n  parser = self.getParser()\n  doctype = self.originalDocument.doctype\n  ident = \"\"\n  if doctype:\n   subset = doctype.internalSubset or self._getDeclarations()\n   if doctype.publicId:\n    ident = ('PUBLIC \"%s\" \"%s\"'\n    % (doctype.publicId, doctype.systemId))\n   elif doctype.systemId:\n    ident = 'SYSTEM \"%s\"' % doctype.systemId\n  else:\n   subset = \"\"\n  nsattrs = self._getNSattrs() \n  document = _FRAGMENT_BUILDER_TEMPLATE % (ident, subset, nsattrs)\n  try:\n   parser.Parse(document, 1)\n  except:\n   self.reset()\n   raise\n  fragment = self.fragment\n  self.reset()\n  \n  return fragment\n  \n def _getDeclarations(self):\n  \"\"\n  doctype = self.context.ownerDocument.doctype\n  s = \"\"\n  if doctype:\n   for i in range(doctype.notations.length):\n    notation = doctype.notations.item(i)\n    if s:\n     s = s + \"\\n  \"\n    s = \"%s<!NOTATION %s\" % (s, notation.nodeName)\n    if notation.publicId:\n     s = '%s PUBLIC \"%s\"\\n             \"%s\">' % (s, notation.publicId, notation.systemId)\n    else:\n     s = '%s SYSTEM \"%s\">' % (s, notation.systemId)\n   for i in range(doctype.entities.length):\n    entity = doctype.entities.item(i)\n    if s:\n     s = s + \"\\n  \"\n    s = \"%s<!ENTITY %s\" % (s, entity.nodeName)\n    if entity.publicId:\n     s = '%s PUBLIC \"%s\"\\n             \"%s\"' % (s, entity.publicId, entity.systemId)\n    elif entity.systemId:\n     s = '%s SYSTEM \"%s\"' % (s, entity.systemId)\n    else:\n     s = '%s \"%s\"' % (s, entity.firstChild.data)\n    if entity.notationName:\n     s = \"%s NOTATION %s\" % (s, entity.notationName)\n    s = s + \">\"\n  return s\n  \n def _getNSattrs(self):\n  return \"\"\n  \n def external_entity_ref_handler(self, context, base, systemId, publicId):\n  if systemId == _FRAGMENT_BUILDER_INTERNAL_SYSTEM_ID:\n  \n  \n   old_document = self.document\n   old_cur_node = self.curNode\n   parser = self._parser.ExternalEntityParserCreate(context)\n   \n   self.document = self.originalDocument\n   self.fragment = self.document.createDocumentFragment()\n   self.curNode = self.fragment\n   try:\n    parser.Parse(self._source, 1)\n   finally:\n    self.curNode = old_cur_node\n    self.document = old_document\n    self._source = None\n   return -1\n  else:\n   return ExpatBuilder.external_entity_ref_handler(\n   self, context, base, systemId, publicId)\n   \n   \nclass Namespaces:\n \"\"\n \n def _initNamespaces(self):\n \n \n  self._ns_ordered_prefixes = []\n  \n def createParser(self):\n  \"\"\n  parser = expat.ParserCreate(namespace_separator=\" \")\n  parser.namespace_prefixes = True\n  return parser\n  \n def install(self, parser):\n  \"\"\n  ExpatBuilder.install(self, parser)\n  if self._options.namespace_declarations:\n   parser.StartNamespaceDeclHandler = (\n   self.start_namespace_decl_handler)\n   \n def start_namespace_decl_handler(self, prefix, uri):\n  \"\"\n  self._ns_ordered_prefixes.append((prefix, uri))\n  \n def start_element_handler(self, name, attributes):\n  if ' ' in name:\n   uri, localname, prefix, qname = _parse_ns_name(self, name)\n  else:\n   uri = EMPTY_NAMESPACE\n   qname = name\n   localname = None\n   prefix = EMPTY_PREFIX\n  node = minidom.Element(qname, uri, prefix, localname)\n  node.ownerDocument = self.document\n  _append_child(self.curNode, node)\n  self.curNode = node\n  \n  if self._ns_ordered_prefixes:\n   for prefix, uri in self._ns_ordered_prefixes:\n    if prefix:\n     a = minidom.Attr(_intern(self, 'xmlns:' + prefix),\n     XMLNS_NAMESPACE, prefix, \"xmlns\")\n    else:\n     a = minidom.Attr(\"xmlns\", XMLNS_NAMESPACE,\n     \"xmlns\", EMPTY_PREFIX)\n    a.value = uri\n    a.ownerDocument = self.document\n    _set_attribute_node(node, a)\n   del self._ns_ordered_prefixes[:]\n   \n  if attributes:\n   node._ensure_attributes()\n   _attrs = node._attrs\n   _attrsNS = node._attrsNS\n   for i in range(0, len(attributes), 2):\n    aname = attributes[i]\n    value = attributes[i+1]\n    if ' ' in aname:\n     uri, localname, prefix, qname = _parse_ns_name(self, aname)\n     a = minidom.Attr(qname, uri, localname, prefix)\n     _attrs[qname] = a\n     _attrsNS[(uri, localname)] = a\n    else:\n     a = minidom.Attr(aname, EMPTY_NAMESPACE,\n     aname, EMPTY_PREFIX)\n     _attrs[aname] = a\n     _attrsNS[(EMPTY_NAMESPACE, aname)] = a\n    a.ownerDocument = self.document\n    a.value = value\n    a.ownerElement = node\n    \n if __debug__:\n \n \n \n \n \n  def end_element_handler(self, name):\n   curNode = self.curNode\n   if ' ' in name:\n    uri, localname, prefix, qname = _parse_ns_name(self, name)\n    assert (curNode.namespaceURI == uri\n    and curNode.localName == localname\n    and curNode.prefix == prefix), \"element stack messed up! (namespace)\"\n   else:\n    assert curNode.nodeName == name, \"element stack messed up - bad nodeName\"\n    assert curNode.namespaceURI == EMPTY_NAMESPACE, \"element stack messed up - bad namespaceURI\"\n   self.curNode = curNode.parentNode\n   self._finish_end_element(curNode)\n   \n   \nclass ExpatBuilderNS(Namespaces, ExpatBuilder):\n \"\"\n \n def reset(self):\n  ExpatBuilder.reset(self)\n  self._initNamespaces()\n  \n  \nclass FragmentBuilderNS(Namespaces, FragmentBuilder):\n \"\"\n \n def reset(self):\n  FragmentBuilder.reset(self)\n  self._initNamespaces()\n  \n def _getNSattrs(self):\n  \"\"\n  \n  \n  \n  \n  \n  attrs = \"\"\n  context = self.context\n  L = []\n  while context:\n   if hasattr(context, '_ns_prefix_uri'):\n    for prefix, uri in context._ns_prefix_uri.items():\n    \n     if prefix in L:\n      continue\n     L.append(prefix)\n     if prefix:\n      declname = \"xmlns:\" + prefix\n     else:\n      declname = \"xmlns\"\n     if attrs:\n      attrs = \"%s\\n    %s='%s'\" % (attrs, declname, uri)\n     else:\n      attrs = \" %s='%s'\" % (declname, uri)\n   context = context.parentNode\n  return attrs\n  \n  \nclass ParseEscape(Exception):\n \"\"\n pass\n \nclass InternalSubsetExtractor(ExpatBuilder):\n \"\"\n \n subset = None\n \n def getSubset(self):\n  \"\"\n  return self.subset\n  \n def parseFile(self, file):\n  try:\n   ExpatBuilder.parseFile(self, file)\n  except ParseEscape:\n   pass\n   \n def parseString(self, string):\n  try:\n   ExpatBuilder.parseString(self, string)\n  except ParseEscape:\n   pass\n   \n def install(self, parser):\n  parser.StartDoctypeDeclHandler = self.start_doctype_decl_handler\n  parser.StartElementHandler = self.start_element_handler\n  \n def start_doctype_decl_handler(self, name, publicId, systemId,\n has_internal_subset):\n  if has_internal_subset:\n   parser = self.getParser()\n   self.subset = []\n   parser.DefaultHandler = self.subset.append\n   parser.EndDoctypeDeclHandler = self.end_doctype_decl_handler\n  else:\n   raise ParseEscape()\n   \n def end_doctype_decl_handler(self):\n  s = ''.join(self.subset).replace('\\r\\n', '\\n').replace('\\r', '\\n')\n  self.subset = s\n  raise ParseEscape()\n  \n def start_element_handler(self, name, attrs):\n  raise ParseEscape()\n  \n  \ndef parse(file, namespaces=True):\n \"\"\n if namespaces:\n  builder = ExpatBuilderNS()\n else:\n  builder = ExpatBuilder()\n  \n if isinstance(file, str):\n  fp = open(file, 'rb')\n  try:\n   result = builder.parseFile(fp)\n  finally:\n   fp.close()\n else:\n  result = builder.parseFile(file)\n return result\n \n \ndef parseString(string, namespaces=True):\n \"\"\n if namespaces:\n  builder = ExpatBuilderNS()\n else:\n  builder = ExpatBuilder()\n return builder.parseString(string)\n \n \ndef parseFragment(file, context, namespaces=True):\n \"\"\n if namespaces:\n  builder = FragmentBuilderNS(context)\n else:\n  builder = FragmentBuilder(context)\n  \n if isinstance(file, str):\n  fp = open(file, 'rb')\n  try:\n   result = builder.parseFile(fp)\n  finally:\n   fp.close()\n else:\n  result = builder.parseFile(file)\n return result\n \n \ndef parseFragmentString(string, context, namespaces=True):\n \"\"\n if namespaces:\n  builder = FragmentBuilderNS(context)\n else:\n  builder = FragmentBuilder(context)\n return builder.parseString(string)\n \n \ndef makeBuilder(options):\n \"\"\n if options.namespaces:\n  return ExpatBuilderNS(options)\n else:\n  return ExpatBuilder(options)\n"], "subprocess": [".py", "\n\n\n\n\n\n\n\n\n\"\"\n\nimport sys\nmswindows = (sys.platform == \"win32\")\n\nimport io\nimport os\nimport time\nimport traceback\nimport gc\nimport signal\nimport builtins\nimport warnings\nimport errno\ntry:\n from time import monotonic as _time\nexcept ImportError:\n from time import time as _time\n \n \nclass SubprocessError(Exception): pass\n\n\nclass CalledProcessError(SubprocessError):\n \"\"\n def __init__(self, returncode, cmd, output=None):\n  self.returncode = returncode\n  self.cmd = cmd\n  self.output = output\n def __str__(self):\n  return \"Command '%s' returned non-zero exit status %d\" % (self.cmd, self.returncode)\n  \n  \nclass TimeoutExpired(SubprocessError):\n \"\"\n def __init__(self, cmd, timeout, output=None):\n  self.cmd = cmd\n  self.timeout = timeout\n  self.output = output\n  \n def __str__(self):\n  return (\"Command '%s' timed out after %s seconds\" %\n  (self.cmd, self.timeout))\n  \n  \nif mswindows:\n import threading\n import msvcrt\n import _winapi\n class STARTUPINFO:\n  dwFlags = 0\n  hStdInput = None\n  hStdOutput = None\n  hStdError = None\n  wShowWindow = 0\n class pywintypes:\n  error = IOError\nelse:\n import select\n _has_poll = hasattr(select, 'poll')\n import _posixsubprocess\n _create_pipe = _posixsubprocess.cloexec_pipe\n \n \n \n \n _PIPE_BUF = getattr(select, 'PIPE_BUF', 512)\n \n \n__all__ = [\"Popen\", \"PIPE\", \"STDOUT\", \"call\", \"check_call\", \"getstatusoutput\",\n\"getoutput\", \"check_output\", \"CalledProcessError\", \"DEVNULL\"]\n\nif mswindows:\n from _winapi import (CREATE_NEW_CONSOLE, CREATE_NEW_PROCESS_GROUP,\n STD_INPUT_HANDLE, STD_OUTPUT_HANDLE,\n STD_ERROR_HANDLE, SW_HIDE,\n STARTF_USESTDHANDLES, STARTF_USESHOWWINDOW)\n \n __all__.extend([\"CREATE_NEW_CONSOLE\", \"CREATE_NEW_PROCESS_GROUP\",\n \"STD_INPUT_HANDLE\", \"STD_OUTPUT_HANDLE\",\n \"STD_ERROR_HANDLE\", \"SW_HIDE\",\n \"STARTF_USESTDHANDLES\", \"STARTF_USESHOWWINDOW\"])\n \n class Handle(int):\n  closed = False\n  \n  def Close(self, CloseHandle=_winapi.CloseHandle):\n   if not self.closed:\n    self.closed = True\n    CloseHandle(self)\n    \n  def Detach(self):\n   if not self.closed:\n    self.closed = True\n    return int(self)\n   raise ValueError(\"already closed\")\n   \n  def __repr__(self):\n   return \"Handle(%d)\" % int(self)\n   \n  __del__ = Close\n  __str__ = __repr__\n  \ntry:\n MAXFD = os.sysconf(\"SC_OPEN_MAX\")\nexcept:\n MAXFD = 256\n \n \n \n \n \n_active = []\n\ndef _cleanup():\n for inst in _active[:]:\n  res = inst._internal_poll(_deadstate=sys.maxsize)\n  if res is not None:\n   try:\n    _active.remove(inst)\n   except ValueError:\n   \n   \n    pass\n    \nPIPE = -1\nSTDOUT = -2\nDEVNULL = -3\n\n\ndef _eintr_retry_call(func, *args):\n while True:\n  try:\n   return func(*args)\n  except InterruptedError:\n   continue\n   \n   \n   \n   \n   \n   \ndef _args_from_interpreter_flags():\n \"\"\n flag_opt_map = {\n 'debug': 'd',\n \n \n 'optimize': 'O',\n 'dont_write_bytecode': 'B',\n 'no_user_site': 's',\n 'no_site': 'S',\n 'ignore_environment': 'E',\n 'verbose': 'v',\n 'bytes_warning': 'b',\n 'quiet': 'q',\n 'hash_randomization': 'R',\n }\n args = []\n for flag, opt in flag_opt_map.items():\n  v = getattr(sys.flags, flag)\n  if v > 0:\n   args.append('-' + opt * v)\n for opt in sys.warnoptions:\n  args.append('-W' + opt)\n return args\n \n \ndef call(*popenargs, timeout=None, **kwargs):\n \"\"\n with Popen(*popenargs, **kwargs) as p:\n  try:\n   return p.wait(timeout=timeout)\n  except:\n   p.kill()\n   p.wait()\n   raise\n   \n   \ndef check_call(*popenargs, **kwargs):\n \"\"\n retcode = call(*popenargs, **kwargs)\n if retcode:\n  cmd = kwargs.get(\"args\")\n  if cmd is None:\n   cmd = popenargs[0]\n  raise CalledProcessError(retcode, cmd)\n return 0\n \n \ndef check_output(*popenargs, timeout=None, **kwargs):\n \"\"\n if 'stdout' in kwargs:\n  raise ValueError('stdout argument not allowed, it will be overridden.')\n with Popen(*popenargs, stdout=PIPE, **kwargs) as process:\n  try:\n   output, unused_err = process.communicate(timeout=timeout)\n  except TimeoutExpired:\n   process.kill()\n   output, unused_err = process.communicate()\n   raise TimeoutExpired(process.args, timeout, output=output)\n  except:\n   process.kill()\n   process.wait()\n   raise\n  retcode = process.poll()\n  if retcode:\n   raise CalledProcessError(retcode, process.args, output=output)\n return output\n \n \ndef list2cmdline(seq):\n \"\"\n \n \n \n \n \n result = []\n needquote = False\n for arg in seq:\n  bs_buf = []\n  \n  \n  if result:\n   result.append(' ')\n   \n  needquote = (\" \" in arg) or (\"\\t\" in arg) or not arg\n  if needquote:\n   result.append('\"')\n   \n  for c in arg:\n   if c == '\\\\':\n   \n    bs_buf.append(c)\n   elif c == '\"':\n   \n    result.append('\\\\' * len(bs_buf)*2)\n    bs_buf = []\n    result.append('\\\\\"')\n   else:\n   \n    if bs_buf:\n     result.extend(bs_buf)\n     bs_buf = []\n    result.append(c)\n    \n    \n  if bs_buf:\n   result.extend(bs_buf)\n   \n  if needquote:\n   result.extend(bs_buf)\n   result.append('\"')\n   \n return ''.join(result)\n \n \n \n \n \n \ndef getstatusoutput(cmd):\n \"\"\n with os.popen('{ ' + cmd + '; } 2>&1', 'r') as pipe:\n  try:\n   text = pipe.read()\n   sts = pipe.close()\n  except:\n   process = pipe._proc\n   process.kill()\n   process.wait()\n   raise\n if sts is None:\n  sts = 0\n if text[-1:] == '\\n':\n  text = text[:-1]\n return sts, text\n \n \ndef getoutput(cmd):\n \"\"\n return getstatusoutput(cmd)[1]\n \n \n_PLATFORM_DEFAULT_CLOSE_FDS = object()\n\n\nclass Popen(object):\n def __init__(self, args, bufsize=-1, executable=None,\n stdin=None, stdout=None, stderr=None,\n preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS,\n shell=False, cwd=None, env=None, universal_newlines=False,\n startupinfo=None, creationflags=0,\n restore_signals=True, start_new_session=False,\n pass_fds=()):\n  \"\"\n  _cleanup()\n  \n  self._child_created = False\n  self._input = None\n  self._communication_started = False\n  if bufsize is None:\n   bufsize = -1 \n  if not isinstance(bufsize, int):\n   raise TypeError(\"bufsize must be an integer\")\n   \n  if mswindows:\n   if preexec_fn is not None:\n    raise ValueError(\"preexec_fn is not supported on Windows \"\n    \"platforms\")\n   any_stdio_set = (stdin is not None or stdout is not None or\n   stderr is not None)\n   if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:\n    if any_stdio_set:\n     close_fds = False\n    else:\n     close_fds = True\n   elif close_fds and any_stdio_set:\n    raise ValueError(\n    \"close_fds is not supported on Windows platforms\"\n    \" if you redirect stdin/stdout/stderr\")\n  else:\n  \n   if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:\n    close_fds = True\n   if pass_fds and not close_fds:\n    warnings.warn(\"pass_fds overriding close_fds.\", RuntimeWarning)\n    close_fds = True\n   if startupinfo is not None:\n    raise ValueError(\"startupinfo is only supported on Windows \"\n    \"platforms\")\n   if creationflags != 0:\n    raise ValueError(\"creationflags is only supported on Windows \"\n    \"platforms\")\n    \n  self.args = args\n  self.stdin = None\n  self.stdout = None\n  self.stderr = None\n  self.pid = None\n  self.returncode = None\n  self.universal_newlines = universal_newlines\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  (p2cread, p2cwrite,\n  c2pread, c2pwrite,\n  errread, errwrite) = self._get_handles(stdin, stdout, stderr)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if p2cwrite != -1:\n   self.stdin = io.open(p2cwrite, 'wb', bufsize)\n   if universal_newlines:\n    self.stdin = io.TextIOWrapper(self.stdin, write_through=True)\n  if c2pread != -1:\n   self.stdout = io.open(c2pread, 'rb', bufsize)\n   if universal_newlines:\n    self.stdout = io.TextIOWrapper(self.stdout)\n  if errread != -1:\n   self.stderr = io.open(errread, 'rb', bufsize)\n   if universal_newlines:\n    self.stderr = io.TextIOWrapper(self.stderr)\n    \n  self._closed_child_pipe_fds = False\n  try:\n   self._execute_child(args, executable, preexec_fn, close_fds,\n   pass_fds, cwd, env,\n   startupinfo, creationflags, shell,\n   p2cread, p2cwrite,\n   c2pread, c2pwrite,\n   errread, errwrite,\n   restore_signals, start_new_session)\n  except:\n  \n   for f in filter(None, (self.stdin, self.stdout, self.stderr)):\n    try:\n     f.close()\n    except EnvironmentError:\n     pass \n     \n   if not self._closed_child_pipe_fds:\n    to_close = []\n    if stdin == PIPE:\n     to_close.append(p2cread)\n    if stdout == PIPE:\n     to_close.append(c2pwrite)\n    if stderr == PIPE:\n     to_close.append(errwrite)\n    if hasattr(self, '_devnull'):\n     to_close.append(self._devnull)\n    for fd in to_close:\n     try:\n      os.close(fd)\n     except EnvironmentError:\n      pass\n      \n   raise\n   \n   \n def _translate_newlines(self, data, encoding):\n  data = data.decode(encoding)\n  return data.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self, type, value, traceback):\n  if self.stdout:\n   self.stdout.close()\n  if self.stderr:\n   self.stderr.close()\n  if self.stdin:\n   self.stdin.close()\n   \n  self.wait()\n  \n def __del__(self, _maxsize=sys.maxsize, _active=_active):\n \n \n \n  if not getattr(self, '_child_created', False):\n  \n   return\n   \n  self._internal_poll(_deadstate=_maxsize)\n  if self.returncode is None and _active is not None:\n  \n   _active.append(self)\n   \n def _get_devnull(self):\n  if not hasattr(self, '_devnull'):\n   self._devnull = os.open(os.devnull, os.O_RDWR)\n  return self._devnull\n  \n def communicate(self, input=None, timeout=None):\n  \"\"\n  \n  if self._communication_started and input:\n   raise ValueError(\"Cannot send input after starting communication\")\n   \n   \n   \n   \n  if (timeout is None and not self._communication_started and\n  [self.stdin, self.stdout, self.stderr].count(None) >= 2):\n   stdout = None\n   stderr = None\n   if self.stdin:\n    if input:\n     try:\n      self.stdin.write(input)\n     except IOError as e:\n      if e.errno != errno.EPIPE and e.errno != errno.EINVAL:\n       raise\n    self.stdin.close()\n   elif self.stdout:\n    stdout = _eintr_retry_call(self.stdout.read)\n    self.stdout.close()\n   elif self.stderr:\n    stderr = _eintr_retry_call(self.stderr.read)\n    self.stderr.close()\n   self.wait()\n  else:\n   if timeout is not None:\n    endtime = _time() + timeout\n   else:\n    endtime = None\n    \n   try:\n    stdout, stderr = self._communicate(input, endtime, timeout)\n   finally:\n    self._communication_started = True\n    \n   sts = self.wait(timeout=self._remaining_time(endtime))\n   \n  return (stdout, stderr)\n  \n  \n def poll(self):\n  return self._internal_poll()\n  \n  \n def _remaining_time(self, endtime):\n  \"\"\n  if endtime is None:\n   return None\n  else:\n   return endtime - _time()\n   \n   \n def _check_timeout(self, endtime, orig_timeout):\n  \"\"\n  if endtime is None:\n   return\n  if _time() > endtime:\n   raise TimeoutExpired(self.args, orig_timeout)\n   \n   \n if mswindows:\n \n \n \n  def _get_handles(self, stdin, stdout, stderr):\n   \"\"\n   if stdin is None and stdout is None and stderr is None:\n    return (-1, -1, -1, -1, -1, -1)\n    \n   p2cread, p2cwrite = -1, -1\n   c2pread, c2pwrite = -1, -1\n   errread, errwrite = -1, -1\n   \n   if stdin is None:\n    p2cread = _winapi.GetStdHandle(_winapi.STD_INPUT_HANDLE)\n    if p2cread is None:\n     p2cread, _ = _winapi.CreatePipe(None, 0)\n     p2cread = Handle(p2cread)\n     _winapi.CloseHandle(_)\n   elif stdin == PIPE:\n    p2cread, p2cwrite = _winapi.CreatePipe(None, 0)\n    p2cread, p2cwrite = Handle(p2cread), Handle(p2cwrite)\n   elif stdin == DEVNULL:\n    p2cread = msvcrt.get_osfhandle(self._get_devnull())\n   elif isinstance(stdin, int):\n    p2cread = msvcrt.get_osfhandle(stdin)\n   else:\n   \n    p2cread = msvcrt.get_osfhandle(stdin.fileno())\n   p2cread = self._make_inheritable(p2cread)\n   \n   if stdout is None:\n    c2pwrite = _winapi.GetStdHandle(_winapi.STD_OUTPUT_HANDLE)\n    if c2pwrite is None:\n     _, c2pwrite = _winapi.CreatePipe(None, 0)\n     c2pwrite = Handle(c2pwrite)\n     _winapi.CloseHandle(_)\n   elif stdout == PIPE:\n    c2pread, c2pwrite = _winapi.CreatePipe(None, 0)\n    c2pread, c2pwrite = Handle(c2pread), Handle(c2pwrite)\n   elif stdout == DEVNULL:\n    c2pwrite = msvcrt.get_osfhandle(self._get_devnull())\n   elif isinstance(stdout, int):\n    c2pwrite = msvcrt.get_osfhandle(stdout)\n   else:\n   \n    c2pwrite = msvcrt.get_osfhandle(stdout.fileno())\n   c2pwrite = self._make_inheritable(c2pwrite)\n   \n   if stderr is None:\n    errwrite = _winapi.GetStdHandle(_winapi.STD_ERROR_HANDLE)\n    if errwrite is None:\n     _, errwrite = _winapi.CreatePipe(None, 0)\n     errwrite = Handle(errwrite)\n     _winapi.CloseHandle(_)\n   elif stderr == PIPE:\n    errread, errwrite = _winapi.CreatePipe(None, 0)\n    errread, errwrite = Handle(errread), Handle(errwrite)\n   elif stderr == STDOUT:\n    errwrite = c2pwrite\n   elif stderr == DEVNULL:\n    errwrite = msvcrt.get_osfhandle(self._get_devnull())\n   elif isinstance(stderr, int):\n    errwrite = msvcrt.get_osfhandle(stderr)\n   else:\n   \n    errwrite = msvcrt.get_osfhandle(stderr.fileno())\n   errwrite = self._make_inheritable(errwrite)\n   \n   return (p2cread, p2cwrite,\n   c2pread, c2pwrite,\n   errread, errwrite)\n   \n   \n  def _make_inheritable(self, handle):\n   \"\"\n   h = _winapi.DuplicateHandle(\n   _winapi.GetCurrentProcess(), handle,\n   _winapi.GetCurrentProcess(), 0, 1,\n   _winapi.DUPLICATE_SAME_ACCESS)\n   return Handle(h)\n   \n   \n  def _find_w9xpopen(self):\n   \"\"\n   w9xpopen = os.path.join(\n   os.path.dirname(_winapi.GetModuleFileName(0)),\n   \"w9xpopen.exe\")\n   if not os.path.exists(w9xpopen):\n   \n   \n    w9xpopen = os.path.join(os.path.dirname(sys.base_exec_prefix),\n    \"w9xpopen.exe\")\n    if not os.path.exists(w9xpopen):\n     raise RuntimeError(\"Cannot locate w9xpopen.exe, which is \"\n     \"needed for Popen to work with your \"\n     \"shell or platform.\")\n   return w9xpopen\n   \n   \n  def _execute_child(self, args, executable, preexec_fn, close_fds,\n  pass_fds, cwd, env,\n  startupinfo, creationflags, shell,\n  p2cread, p2cwrite,\n  c2pread, c2pwrite,\n  errread, errwrite,\n  unused_restore_signals, unused_start_new_session):\n   \"\"\n   \n   assert not pass_fds, \"pass_fds not supported on Windows.\"\n   \n   if not isinstance(args, str):\n    args = list2cmdline(args)\n    \n    \n   if startupinfo is None:\n    startupinfo = STARTUPINFO()\n   if -1 not in (p2cread, c2pwrite, errwrite):\n    startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES\n    startupinfo.hStdInput = p2cread\n    startupinfo.hStdOutput = c2pwrite\n    startupinfo.hStdError = errwrite\n    \n   if shell:\n    startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW\n    startupinfo.wShowWindow = _winapi.SW_HIDE\n    comspec = os.environ.get(\"COMSPEC\", \"cmd.exe\")\n    args = '{} /c \"{}\"'.format (comspec, args)\n    if (_winapi.GetVersion() >= 0x80000000 or\n    os.path.basename(comspec).lower() == \"command.com\"):\n    \n    \n    \n    \n     w9xpopen = self._find_w9xpopen()\n     args = '\"%s\" %s' % (w9xpopen, args)\n     \n     \n     \n     \n     \n     \n     creationflags |= _winapi.CREATE_NEW_CONSOLE\n     \n     \n   try:\n    hp, ht, pid, tid = _winapi.CreateProcess(executable, args,\n    \n    None, None,\n    int(not close_fds),\n    creationflags,\n    env,\n    cwd,\n    startupinfo)\n   except pywintypes.error as e:\n   \n   \n   \n   \n    raise WindowsError(*e.args)\n   finally:\n   \n   \n   \n   \n   \n   \n    if p2cread != -1:\n     p2cread.Close()\n    if c2pwrite != -1:\n     c2pwrite.Close()\n    if errwrite != -1:\n     errwrite.Close()\n    if hasattr(self, '_devnull'):\n     os.close(self._devnull)\n     \n     \n   self._child_created = True\n   self._handle = Handle(hp)\n   self.pid = pid\n   _winapi.CloseHandle(ht)\n   \n  def _internal_poll(self, _deadstate=None,\n  _WaitForSingleObject=_winapi.WaitForSingleObject,\n  _WAIT_OBJECT_0=_winapi.WAIT_OBJECT_0,\n  _GetExitCodeProcess=_winapi.GetExitCodeProcess):\n   \"\"\n   if self.returncode is None:\n    if _WaitForSingleObject(self._handle, 0) == _WAIT_OBJECT_0:\n     self.returncode = _GetExitCodeProcess(self._handle)\n   return self.returncode\n   \n   \n  def wait(self, timeout=None, endtime=None):\n   \"\"\n   if endtime is not None:\n    timeout = self._remaining_time(endtime)\n   if timeout is None:\n    timeout_millis = _winapi.INFINITE\n   else:\n    timeout_millis = int(timeout * 1000)\n   if self.returncode is None:\n    result = _winapi.WaitForSingleObject(self._handle,\n    timeout_millis)\n    if result == _winapi.WAIT_TIMEOUT:\n     raise TimeoutExpired(self.args, timeout)\n    self.returncode = _winapi.GetExitCodeProcess(self._handle)\n   return self.returncode\n   \n   \n  def _readerthread(self, fh, buffer):\n   buffer.append(fh.read())\n   fh.close()\n   \n   \n  def _communicate(self, input, endtime, orig_timeout):\n  \n  \n   if self.stdout and not hasattr(self, \"_stdout_buff\"):\n    self._stdout_buff = []\n    self.stdout_thread = threading.Thread(target=self._readerthread,\n    args=(self.stdout, self._stdout_buff))\n    self.stdout_thread.daemon = True\n    self.stdout_thread.start()\n   if self.stderr and not hasattr(self, \"_stderr_buff\"):\n    self._stderr_buff = []\n    self.stderr_thread = threading.Thread(target=self._readerthread,\n    args=(self.stderr, self._stderr_buff))\n    self.stderr_thread.daemon = True\n    self.stderr_thread.start()\n    \n   if self.stdin:\n    if input is not None:\n     try:\n      self.stdin.write(input)\n     except IOError as e:\n      if e.errno != errno.EPIPE:\n       raise\n    self.stdin.close()\n    \n    \n    \n    \n   if self.stdout is not None:\n    self.stdout_thread.join(self._remaining_time(endtime))\n    if self.stdout_thread.is_alive():\n     raise TimeoutExpired(self.args, orig_timeout)\n   if self.stderr is not None:\n    self.stderr_thread.join(self._remaining_time(endtime))\n    if self.stderr_thread.is_alive():\n     raise TimeoutExpired(self.args, orig_timeout)\n     \n     \n     \n   stdout = None\n   stderr = None\n   if self.stdout:\n    stdout = self._stdout_buff\n    self.stdout.close()\n   if self.stderr:\n    stderr = self._stderr_buff\n    self.stderr.close()\n    \n    \n   if stdout is not None:\n    stdout = stdout[0]\n   if stderr is not None:\n    stderr = stderr[0]\n    \n   return (stdout, stderr)\n   \n  def send_signal(self, sig):\n   \"\"\n   if sig == signal.SIGTERM:\n    self.terminate()\n   elif sig == signal.CTRL_C_EVENT:\n    os.kill(self.pid, signal.CTRL_C_EVENT)\n   elif sig == signal.CTRL_BREAK_EVENT:\n    os.kill(self.pid, signal.CTRL_BREAK_EVENT)\n   else:\n    raise ValueError(\"Unsupported signal: {}\".format(sig))\n    \n  def terminate(self):\n   \"\"\n   try:\n    _winapi.TerminateProcess(self._handle, 1)\n   except PermissionError:\n   \n   \n    rc = _winapi.GetExitCodeProcess(self._handle)\n    if rc == _winapi.STILL_ACTIVE:\n     raise\n    self.returncode = rc\n    \n  kill = terminate\n  \n else:\n \n \n \n  def _get_handles(self, stdin, stdout, stderr):\n   \"\"\n   p2cread, p2cwrite = -1, -1\n   c2pread, c2pwrite = -1, -1\n   errread, errwrite = -1, -1\n   \n   if stdin is None:\n    pass\n   elif stdin == PIPE:\n    p2cread, p2cwrite = _create_pipe()\n   elif stdin == DEVNULL:\n    p2cread = self._get_devnull()\n   elif isinstance(stdin, int):\n    p2cread = stdin\n   else:\n   \n    p2cread = stdin.fileno()\n    \n   if stdout is None:\n    pass\n   elif stdout == PIPE:\n    c2pread, c2pwrite = _create_pipe()\n   elif stdout == DEVNULL:\n    c2pwrite = self._get_devnull()\n   elif isinstance(stdout, int):\n    c2pwrite = stdout\n   else:\n   \n    c2pwrite = stdout.fileno()\n    \n   if stderr is None:\n    pass\n   elif stderr == PIPE:\n    errread, errwrite = _create_pipe()\n   elif stderr == STDOUT:\n    errwrite = c2pwrite\n   elif stderr == DEVNULL:\n    errwrite = self._get_devnull()\n   elif isinstance(stderr, int):\n    errwrite = stderr\n   else:\n   \n    errwrite = stderr.fileno()\n    \n   return (p2cread, p2cwrite,\n   c2pread, c2pwrite,\n   errread, errwrite)\n   \n   \n  def _close_fds(self, fds_to_keep):\n   start_fd = 3\n   for fd in sorted(fds_to_keep):\n    if fd >= start_fd:\n     os.closerange(start_fd, fd)\n     start_fd = fd + 1\n   if start_fd <= MAXFD:\n    os.closerange(start_fd, MAXFD)\n    \n    \n  def _execute_child(self, args, executable, preexec_fn, close_fds,\n  pass_fds, cwd, env,\n  startupinfo, creationflags, shell,\n  p2cread, p2cwrite,\n  c2pread, c2pwrite,\n  errread, errwrite,\n  restore_signals, start_new_session):\n   \"\"\n   \n   if isinstance(args, (str, bytes)):\n    args = [args]\n   else:\n    args = list(args)\n    \n   if shell:\n    args = [\"/bin/sh\", \"-c\"] + args\n    if executable:\n     args[0] = executable\n     \n   if executable is None:\n    executable = args[0]\n   orig_executable = executable\n   \n   \n   \n   \n   errpipe_read, errpipe_write = _create_pipe()\n   try:\n    try:\n    \n    \n    \n    \n    \n     if env is not None:\n      env_list = [os.fsencode(k) + b'=' + os.fsencode(v)\n      for k, v in env.items()]\n     else:\n      env_list = None \n     executable = os.fsencode(executable)\n     if os.path.dirname(executable):\n      executable_list = (executable,)\n     else:\n     \n      executable_list = tuple(\n      os.path.join(os.fsencode(dir), executable)\n      for dir in os.get_exec_path(env))\n     fds_to_keep = set(pass_fds)\n     fds_to_keep.add(errpipe_write)\n     self.pid = _posixsubprocess.fork_exec(\n     args, executable_list,\n     close_fds, sorted(fds_to_keep), cwd, env_list,\n     p2cread, p2cwrite, c2pread, c2pwrite,\n     errread, errwrite,\n     errpipe_read, errpipe_write,\n     restore_signals, start_new_session, preexec_fn)\n     self._child_created = True\n    finally:\n    \n     os.close(errpipe_write)\n     \n     \n    devnull_fd = getattr(self, '_devnull', None)\n    if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:\n     os.close(p2cread)\n    if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:\n     os.close(c2pwrite)\n    if errwrite != -1 and errread != -1 and errwrite != devnull_fd:\n     os.close(errwrite)\n    if devnull_fd is not None:\n     os.close(devnull_fd)\n     \n    self._closed_child_pipe_fds = True\n    \n    \n    \n    errpipe_data = bytearray()\n    while True:\n     part = _eintr_retry_call(os.read, errpipe_read, 50000)\n     errpipe_data += part\n     if not part or len(errpipe_data) > 50000:\n      break\n   finally:\n   \n    os.close(errpipe_read)\n    \n   if errpipe_data:\n    try:\n     _eintr_retry_call(os.waitpid, self.pid, 0)\n    except OSError as e:\n     if e.errno != errno.ECHILD:\n      raise\n    try:\n     exception_name, hex_errno, err_msg = (\n     errpipe_data.split(b':', 2))\n    except ValueError:\n     exception_name = b'RuntimeError'\n     hex_errno = b'0'\n     err_msg = (b'Bad exception data from child: ' +\n     repr(errpipe_data))\n    child_exception_type = getattr(\n    builtins, exception_name.decode('ascii'),\n    RuntimeError)\n    err_msg = err_msg.decode(errors=\"surrogatepass\")\n    if issubclass(child_exception_type, OSError) and hex_errno:\n     errno_num = int(hex_errno, 16)\n     child_exec_never_called = (err_msg == \"noexec\")\n     if child_exec_never_called:\n      err_msg = \"\"\n     if errno_num != 0:\n      err_msg = os.strerror(errno_num)\n      if errno_num == errno.ENOENT:\n       if child_exec_never_called:\n       \n        err_msg += ': ' + repr(cwd)\n       else:\n        err_msg += ': ' + repr(orig_executable)\n     raise child_exception_type(errno_num, err_msg)\n    raise child_exception_type(err_msg)\n    \n    \n  def _handle_exitstatus(self, sts, _WIFSIGNALED=os.WIFSIGNALED,\n  _WTERMSIG=os.WTERMSIG, _WIFEXITED=os.WIFEXITED,\n  _WEXITSTATUS=os.WEXITSTATUS):\n  \n  \n   if _WIFSIGNALED(sts):\n    self.returncode = -_WTERMSIG(sts)\n   elif _WIFEXITED(sts):\n    self.returncode = _WEXITSTATUS(sts)\n   else:\n   \n    raise RuntimeError(\"Unknown child exit status!\")\n    \n    \n  def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,\n  _WNOHANG=os.WNOHANG, _os_error=os.error, _ECHILD=errno.ECHILD):\n   \"\"\n   if self.returncode is None:\n    try:\n     pid, sts = _waitpid(self.pid, _WNOHANG)\n     if pid == self.pid:\n      self._handle_exitstatus(sts)\n    except _os_error as e:\n     if _deadstate is not None:\n      self.returncode = _deadstate\n     elif e.errno == _ECHILD:\n     \n     \n     \n     \n     \n      self.returncode = 0\n   return self.returncode\n   \n   \n  def _try_wait(self, wait_flags):\n   try:\n    (pid, sts) = _eintr_retry_call(os.waitpid, self.pid, wait_flags)\n   except OSError as e:\n    if e.errno != errno.ECHILD:\n     raise\n     \n     \n     \n    pid = self.pid\n    sts = 0\n   return (pid, sts)\n   \n   \n  def wait(self, timeout=None, endtime=None):\n   \"\"\n   if self.returncode is not None:\n    return self.returncode\n    \n    \n    \n   if endtime is not None or timeout is not None:\n    if endtime is None:\n     endtime = _time() + timeout\n    elif timeout is None:\n     timeout = self._remaining_time(endtime)\n     \n   if endtime is not None:\n   \n   \n    delay = 0.0005 \n    while True:\n     (pid, sts) = self._try_wait(os.WNOHANG)\n     assert pid == self.pid or pid == 0\n     if pid == self.pid:\n      self._handle_exitstatus(sts)\n      break\n     remaining = self._remaining_time(endtime)\n     if remaining <= 0:\n      raise TimeoutExpired(self.args, timeout)\n     delay = min(delay * 2, remaining, .05)\n     time.sleep(delay)\n   else:\n    while self.returncode is None:\n     (pid, sts) = self._try_wait(0)\n     \n     \n     if pid == self.pid:\n      self._handle_exitstatus(sts)\n   return self.returncode\n   \n   \n  def _communicate(self, input, endtime, orig_timeout):\n   if self.stdin and not self._communication_started:\n   \n   \n    self.stdin.flush()\n    if not input:\n     self.stdin.close()\n     \n   if _has_poll:\n    stdout, stderr = self._communicate_with_poll(input, endtime,\n    orig_timeout)\n   else:\n    stdout, stderr = self._communicate_with_select(input, endtime,\n    orig_timeout)\n    \n   self.wait(timeout=self._remaining_time(endtime))\n   \n   \n   if stdout is not None:\n    stdout = b''.join(stdout)\n   if stderr is not None:\n    stderr = b''.join(stderr)\n    \n    \n    \n   if self.universal_newlines:\n    if stdout is not None:\n     stdout = self._translate_newlines(stdout,\n     self.stdout.encoding)\n    if stderr is not None:\n     stderr = self._translate_newlines(stderr,\n     self.stderr.encoding)\n     \n   return (stdout, stderr)\n   \n   \n  def _save_input(self, input):\n  \n  \n  \n   if self.stdin and self._input is None:\n    self._input_offset = 0\n    self._input = input\n    if self.universal_newlines and input is not None:\n     self._input = self._input.encode(self.stdin.encoding)\n     \n     \n  def _communicate_with_poll(self, input, endtime, orig_timeout):\n   stdout = None \n   stderr = None \n   \n   if not self._communication_started:\n    self._fd2file = {}\n    \n   poller = select.poll()\n   def register_and_append(file_obj, eventmask):\n    poller.register(file_obj.fileno(), eventmask)\n    self._fd2file[file_obj.fileno()] = file_obj\n    \n   def close_unregister_and_remove(fd):\n    poller.unregister(fd)\n    self._fd2file[fd].close()\n    self._fd2file.pop(fd)\n    \n   if self.stdin and input:\n    register_and_append(self.stdin, select.POLLOUT)\n    \n    \n   if not self._communication_started:\n    self._fd2output = {}\n    if self.stdout:\n     self._fd2output[self.stdout.fileno()] = []\n    if self.stderr:\n     self._fd2output[self.stderr.fileno()] = []\n     \n   select_POLLIN_POLLPRI = select.POLLIN | select.POLLPRI\n   if self.stdout:\n    register_and_append(self.stdout, select_POLLIN_POLLPRI)\n    stdout = self._fd2output[self.stdout.fileno()]\n   if self.stderr:\n    register_and_append(self.stderr, select_POLLIN_POLLPRI)\n    stderr = self._fd2output[self.stderr.fileno()]\n    \n   self._save_input(input)\n   \n   while self._fd2file:\n    timeout = self._remaining_time(endtime)\n    if timeout is not None and timeout < 0:\n     raise TimeoutExpired(self.args, orig_timeout)\n    try:\n     ready = poller.poll(timeout)\n    except select.error as e:\n     if e.args[0] == errno.EINTR:\n      continue\n     raise\n    self._check_timeout(endtime, orig_timeout)\n    \n    \n    \n    \n    for fd, mode in ready:\n     if mode & select.POLLOUT:\n      chunk = self._input[self._input_offset :\n      self._input_offset + _PIPE_BUF]\n      try:\n       self._input_offset += os.write(fd, chunk)\n      except OSError as e:\n       if e.errno == errno.EPIPE:\n        close_unregister_and_remove(fd)\n       else:\n        raise\n      else:\n       if self._input_offset >= len(self._input):\n        close_unregister_and_remove(fd)\n     elif mode & select_POLLIN_POLLPRI:\n      data = os.read(fd, 4096)\n      if not data:\n       close_unregister_and_remove(fd)\n      self._fd2output[fd].append(data)\n     else:\n     \n      close_unregister_and_remove(fd)\n      \n   return (stdout, stderr)\n   \n   \n  def _communicate_with_select(self, input, endtime, orig_timeout):\n   if not self._communication_started:\n    self._read_set = []\n    self._write_set = []\n    if self.stdin and input:\n     self._write_set.append(self.stdin)\n    if self.stdout:\n     self._read_set.append(self.stdout)\n    if self.stderr:\n     self._read_set.append(self.stderr)\n     \n   self._save_input(input)\n   \n   stdout = None \n   stderr = None \n   \n   if self.stdout:\n    if not self._communication_started:\n     self._stdout_buff = []\n    stdout = self._stdout_buff\n   if self.stderr:\n    if not self._communication_started:\n     self._stderr_buff = []\n    stderr = self._stderr_buff\n    \n   while self._read_set or self._write_set:\n    timeout = self._remaining_time(endtime)\n    if timeout is not None and timeout < 0:\n     raise TimeoutExpired(self.args, orig_timeout)\n    try:\n     (rlist, wlist, xlist) = select.select(self._read_set, self._write_set, [],\n     timeout)\n    except select.error as e:\n     if e.args[0] == errno.EINTR:\n      continue\n     raise\n     \n     \n     \n    if not (rlist or wlist or xlist):\n     raise TimeoutExpired(self.args, orig_timeout)\n     \n    self._check_timeout(endtime, orig_timeout)\n    \n    \n    \n    \n    if self.stdin in wlist:\n     chunk = self._input[self._input_offset :\n     self._input_offset + _PIPE_BUF]\n     try:\n      bytes_written = os.write(self.stdin.fileno(), chunk)\n     except OSError as e:\n      if e.errno == errno.EPIPE:\n       self.stdin.close()\n       self._write_set.remove(self.stdin)\n      else:\n       raise\n     else:\n      self._input_offset += bytes_written\n      if self._input_offset >= len(self._input):\n       self.stdin.close()\n       self._write_set.remove(self.stdin)\n       \n    if self.stdout in rlist:\n     data = os.read(self.stdout.fileno(), 1024)\n     if not data:\n      self.stdout.close()\n      self._read_set.remove(self.stdout)\n     stdout.append(data)\n     \n    if self.stderr in rlist:\n     data = os.read(self.stderr.fileno(), 1024)\n     if not data:\n      self.stderr.close()\n      self._read_set.remove(self.stderr)\n     stderr.append(data)\n     \n   return (stdout, stderr)\n   \n   \n  def send_signal(self, sig):\n   \"\"\n   os.kill(self.pid, sig)\n   \n  def terminate(self):\n   \"\"\n   self.send_signal(signal.SIGTERM)\n   \n  def kill(self):\n   \"\"\n   self.send_signal(signal.SIGKILL)\n"], "sysconfig": [".py", "\"\"\n\n\n\n\nvariables={'TANH_PRESERVES_ZERO_SIGN': 0, 'WITH_DOC_STRINGS': 0}\n\ndef get_config_var(var):\n if var in variables:\n  return variables[var]\n  \n raise NotImplementedError(\"sysconfig.py:get_config_var: variable '%s' does not exist\" % variable)\n"], "gc": [".py", "\"\"\n\n\nDEBUG_COLLECTABLE = 2\n\nDEBUG_LEAK = 38\n\nDEBUG_SAVEALL = 32\n\nDEBUG_STATS = 1\n\nDEBUG_UNCOLLECTABLE = 4\n\nclass __loader__:\n pass\n \ncallbacks = []\n\ndef collect(*args,**kw):\n \"\"\n pass\n \ndef disable(*args,**kw):\n \"\"\n pass\n \ndef enable(*args,**kw):\n \"\"\n pass\n \ngarbage = []\n\ndef get_count(*args,**kw):\n \"\"\n pass\n \ndef get_debug(*args,**kw):\n \"\"\n pass\n \ndef get_objects(*args,**kw):\n \"\"\n pass\n \ndef get_referents(*args,**kw):\n \"\"\n pass\n \ndef get_referrers(*args,**kw):\n \"\"\n pass\n \ndef get_threshold(*args,**kw):\n \"\"\n pass\n \ndef is_tracked(*args,**kw):\n \"\"\n pass\n \ndef isenabled(*args,**kw):\n \"\"\n pass\n \ndef set_debug(*args,**kw):\n \"\"\n pass\n \ndef set_threshold(*args,**kw):\n \"\"\n pass\n"], "_svg": [".js", "// creation of an HTML element\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\nvar $TagSumDict = $B.$TagSum.$dict\n\nvar $s=[]\nfor(var $b in _b_) $s.push('var ' + $b +'=_b_[\"'+$b+'\"]')\neval($s.join(';'))\n\nvar $svgNS = \"http://www.w3.org/2000/svg\"\nvar $xlinkNS = \"http://www.w3.org/1999/xlink\"\n\nfunction makeTagDict(tagName){\n    // return the dictionary for the class associated with tagName\n    var dict = {__class__:$B.$type,\n        __name__:tagName\n        }\n\n    dict.__getattribute__ = function(self, attr){\n        if(self.elt.hasAttributeNS(null, attr)){\n            return self.elt.getAttributeNS(null,attr)\n        }\n        if(dict[attr]!==undefined){\n            return function(){\n                var args = [self].concat(Array.prototype.slice.call(arguments))\n                return dict[attr].apply(null, args)\n            }\n        }\n        return $B.DOMNode.__getattribute__(self, attr)        \n    }\n\n    dict.__init__ = function(){\n        var $ns=$B.$MakeArgs('pow',arguments,['self'],[],'args','kw')\n        var self = $ns['self']\n        var args = $ns['args']\n        if(args.length==1){\n            var first=args[0]\n            if(isinstance(first,[str,int,float])){\n                self.elt.appendChild(document.createTextNode(str(first)))\n            } else if(first.__class__===$TagSumDict){\n                for(var i=0, _len_i = first.children.length; i < _len_i;i++){\n                    self.elt.appendChild(first.children[i].elt)\n                }\n            } else { // argument is another DOMNode instance\n                try{self.elt.appendChild(first.elt)}\n                catch(err){throw ValueError('wrong element '+first)}\n            }\n        }\n\n        // attributes\n        var items = _b_.list(_b_.dict.$dict.items($ns['kw']))\n        for(var i=0, _len_i = items.length; i < _len_i;i++){\n            // keyword arguments\n            var arg = items[i][0]\n            var value = items[i][1]\n            if(arg.toLowerCase().substr(0,2)===\"on\"){ \n                // Event binding passed as argument \"onclick\", \"onfocus\"...\n                // Better use method bind of DOMNode objects\n                var js = '$B.DOMNode.bind(self,\"'\n                js += arg.toLowerCase().substr(2)\n                eval(js+'\",function(){'+value+'})')\n            }else if(arg.toLowerCase()==\"style\"){\n                $B.DOMNode.set_style(self,value)\n            }else if(arg.toLowerCase().indexOf(\"href\") !== -1){ // xlink:href\n                self.elt.setAttributeNS( \"http://www.w3.org/1999/xlink\",\"href\",value)\n            } else {\n                if(value!==false){\n                    // option.selected=false sets it to true :-)\n                    try{\n                        arg = arg.toLowerCase().replace('_','-')\n                        self.elt.setAttributeNS(null,arg,value)\n                    }catch(err){\n                        throw ValueError(\"can't set attribute \"+arg)\n                    }\n                }\n            }\n        }\n    }\n\n    dict.__mro__ = [dict,$B.DOMNode,$B.builtins.object.$dict]\n\n    dict.__new__ = function(cls){\n        var res = $B.$DOMNode(document.createElementNS($svgNS,tagName))\n        res.__class__ = cls.$dict\n        return res\n    }\n    \n    dict.__setattr__ = function(self, key, value){\n        if(self.elt.hasAttributeNS(null, key)){\n            self.elt.setAttributeNS(null,key,value)\n        }else{\n            $B.DOMNode.__setattr__(self, key, value)\n        }\n    }\n\n    return dict\n}\n\n\n// the classes used for tag sums, $TagSum and $TagSumClass \n// are defined in py_dom.js\n\nfunction makeFactory(tagName){\n    var factory = function(){\n        var res = $B.$DOMNode(document.createElementNS($svgNS,tagName))\n        res.__class__ = dicts[tagName]\n        // apply __init__\n        var args = [res]\n        for(var i=0, _len_i = arguments.length; i < _len_i;i++){args.push(arguments[i])}\n        dicts[tagName].__init__.apply(null,args)\n        return res\n    }\n    factory.__class__=$B.$factory\n    factory.$dict = dicts[tagName]\n    return factory\n}\n\n// SVG\nvar $svg_tags = ['a',\n'altGlyph',\n'altGlyphDef',\n'altGlyphItem',\n'animate',\n'animateColor',\n'animateMotion',\n'animateTransform',\n'circle',\n'clipPath',\n'color_profile', // instead of color-profile\n'cursor',\n'defs',\n'desc',\n'ellipse',\n'feBlend',\n'foreignObject', //patch to enable foreign objects\n'g',\n'image',\n'line',\n'linearGradient',\n'marker',\n'mask',\n'path',\n'pattern',\n'polygon',\n'polyline',\n'radialGradient',\n'rect',\n'set',\n'stop',\n'svg',\n'text',\n'tref',\n'tspan',\n'use']\n\n// create classes\nvar obj = new Object()\nvar dicts = {}\nfor(var i=0, _len_i = $svg_tags.length; i < _len_i;i++){\n    var tag = $svg_tags[i]\n    dicts[tag]=makeTagDict(tag)\n    obj[tag] = makeFactory(tag)\n    dicts[tag].$factory = obj[tag]\n}\nreturn obj\n})(__BRYTHON__)\n"], "external_import": [".py", "import os\nfrom browser import doc\nimport urllib.request\n\n\n\n\n\nclass ModuleFinder:\n def __init__(self, path_entry):\n  print(\"external_import here..\")\n  \n  self._module=None\n  if path_entry.startswith('http://'):\n   self.path_entry=path_entry\n  else:\n   raise ImportError()\n   \n def __str__(self):\n  return '<%s for \"%s\">' % (self.__class__.__name__, self.path_entry)\n  \n def find_module(self, fullname, path=None):\n  path = path or self.path_entry\n  \n  for _ext in ['js', 'pyj', 'py']:\n   _fp,_url,_headers=urllib.request.urlopen(path + '/' + '%s.%s' % (fullname, _ext))\n   self._module=_fp.read()\n   _fp.close()\n   if self._module is not None:\n    print(\"module found at %s:%s\" % (path, fullname))\n    return ModuleLoader(path, fullname, self._module)\n    \n  print('module %s not found' % fullname)\n  raise ImportError()\n  return None\n  \nclass ModuleLoader:\n \"\"\n \n def __init__(self, filepath, name, module_source):\n  self._filepath=filepath\n  self._name=name\n  self._module_source=module_source\n  \n def get_source(self):\n  return self._module_source\n  \n def is_package(self):\n  return '.' in self._name\n  \n def load_module(self):\n  if self._name in sys.modules:\n  \n   mod = sys.modules[self._name]\n   return mod\n   \n  _src=self.get_source()\n  if self._filepath.endswith('.js'):\n   mod=JSObject(import_js_module(_src, self._filepath, self._name))\n  elif self._filepath.endswith('.py'):\n   mod=JSObject(import_py_module(_src, self._filepath, self._name))\n  elif self._filepath.endswith('.pyj'):\n   mod=JSObject(import_pyj_module(_src, self._filepath, self._name))\n  else:\n   raise ImportError('Invalid Module: %s' % self._filepath)\n   \n   \n  mod.__file__ = self._filepath\n  mod.__name__ = self._name\n  mod.__path__ = os.path.abspath(self._filepath)\n  mod.__loader__ = self\n  mod.__package__ = '.'.join(self._name.split('.')[:-1])\n  \n  if self.is_package():\n   print('adding path for package')\n   \n   \n   mod.__path__ = [ self._filepath ]\n  else:\n   print('imported as regular module')\n   \n  print('creating a new module object for \"%s\"' % self._name)\n  sys.modules.setdefault(self._name, mod)\n  JSObject(__BRYTHON__.imported)[self._name]=mod\n  \n  return mod\n"], "_dummy_thread": [".py", "\"\"\n\n\n__all__ = ['error', 'start_new_thread', 'exit', 'get_ident', 'allocate_lock',\n'interrupt_main', 'LockType']\n\n\nTIMEOUT_MAX = 2**31\n\n\n\n\n\n\nerror = RuntimeError\n\ndef start_new_thread(function, args, kwargs={}):\n \"\"\n if type(args) != type(tuple()):\n  raise TypeError(\"2nd arg must be a tuple\")\n if type(kwargs) != type(dict()):\n  raise TypeError(\"3rd arg must be a dict\")\n global _main\n _main = False\n try:\n  function(*args, **kwargs)\n except SystemExit:\n  pass\n except:\n  import traceback\n  traceback.print_exc()\n _main = True\n global _interrupt\n if _interrupt:\n  _interrupt = False\n  raise KeyboardInterrupt\n  \ndef exit():\n \"\"\n raise SystemExit\n \ndef get_ident():\n \"\"\n return -1\n \ndef allocate_lock():\n \"\"\n return LockType()\n \ndef stack_size(size=None):\n \"\"\n if size is not None:\n  raise error(\"setting thread stack size not supported\")\n return 0\n \nclass LockType(object):\n \"\"\n \n def __init__(self):\n  self.locked_status = False\n  \n def acquire(self, waitflag=None, timeout=-1):\n  \"\"\n  if waitflag is None or waitflag:\n   self.locked_status = True\n   return True\n  else:\n   if not self.locked_status:\n    self.locked_status = True\n    return True\n   else:\n    if timeout > 0:\n     import time\n     time.sleep(timeout)\n    return False\n    \n __enter__ = acquire\n \n def __exit__(self, typ, val, tb):\n  self.release()\n  \n def release(self):\n  \"\"\n  \n  \n  if not self.locked_status:\n   raise error\n  self.locked_status = False\n  return True\n  \n def locked(self):\n  return self.locked_status\n  \n  \n_interrupt = False\n\n_main = True\n\ndef interrupt_main():\n \"\"\n if _main:\n  raise KeyboardInterrupt\n else:\n  global _interrupt\n  _interrupt = True\n"], "importlib.util": [".py", "\"\"\n\nfrom ._bootstrap import module_for_loader\nfrom ._bootstrap import set_loader\nfrom ._bootstrap import set_package\nfrom ._bootstrap import _resolve_name\n\n\ndef resolve_name(name, package):\n \"\"\n if not name.startswith('.'):\n  return name\n elif not package:\n  raise ValueError('{!r} is not a relative name '\n  '(no leading dot)'.format(name))\n level = 0\n for character in name:\n  if character != '.':\n   break\n  level += 1\n return _resolve_name(name[level:], package, level)\n"], "_markupbase": [".py", "\"\"\n\nimport re\n\n_declname_match = re.compile(r'[a-zA-Z][-_.a-zA-Z0-9]*\\s*').match\n_declstringlit_match = re.compile(r'(\\'[^\\']*\\'|\"[^\"]*\")\\s*').match\n_commentclose = re.compile(r'--\\s*>')\n_markedsectionclose = re.compile(r']\\s*]\\s*>')\n\n\n\n\n_msmarkedsectionclose = re.compile(r']\\s*>')\n\ndel re\n\n\nclass ParserBase:\n \"\"\n \n def __init__(self):\n  if self.__class__ is ParserBase:\n   raise RuntimeError(\n   \"_markupbase.ParserBase must be subclassed\")\n   \n def error(self, message):\n  raise NotImplementedError(\n  \"subclasses of ParserBase must override error()\")\n  \n def reset(self):\n  self.lineno = 1\n  self.offset = 0\n  \n def getpos(self):\n  \"\"\n  return self.lineno, self.offset\n  \n  \n  \n  \n  \n def updatepos(self, i, j):\n  if i >= j:\n   return j\n  rawdata = self.rawdata\n  nlines = rawdata.count(\"\\n\", i, j)\n  if nlines:\n   self.lineno = self.lineno + nlines\n   pos = rawdata.rindex(\"\\n\", i, j) \n   self.offset = j-(pos+1)\n  else:\n   self.offset = self.offset + j-i\n  return j\n  \n _decl_otherchars = ''\n \n \n def parse_declaration(self, i):\n \n \n \n \n \n \n \n \n \n \n  rawdata = self.rawdata\n  j = i + 2\n  assert rawdata[i:j] == \"<!\", \"unexpected call to parse_declaration\"\n  if rawdata[j:j+1] == \">\":\n  \n   return j + 1\n  if rawdata[j:j+1] in (\"-\", \"\"):\n  \n  \n   return -1\n   \n  n = len(rawdata)\n  if rawdata[j:j+2] == '--': \n  \n   return self.parse_comment(i)\n  elif rawdata[j] == '[': \n  \n  \n  \n  \n   return self.parse_marked_section(i)\n  else: \n   decltype, j = self._scan_name(j, i)\n  if j < 0:\n   return j\n  if decltype == \"doctype\":\n   self._decl_otherchars = ''\n  while j < n:\n   c = rawdata[j]\n   if c == \">\":\n   \n    data = rawdata[i+2:j]\n    if decltype == \"doctype\":\n     self.handle_decl(data)\n    else:\n    \n    \n    \n    \n     self.unknown_decl(data)\n    return j + 1\n   if c in \"\\\"'\":\n    m = _declstringlit_match(rawdata, j)\n    if not m:\n     return -1 \n    j = m.end()\n   elif c in \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n    name, j = self._scan_name(j, i)\n   elif c in self._decl_otherchars:\n    j = j + 1\n   elif c == \"[\":\n   \n    if decltype == \"doctype\":\n     j = self._parse_doctype_subset(j + 1, i)\n    elif decltype in {\"attlist\", \"linktype\", \"link\", \"element\"}:\n    \n    \n    \n    \n     self.error(\"unsupported '[' char in %s declaration\" % decltype)\n    else:\n     self.error(\"unexpected '[' char in declaration\")\n   else:\n    self.error(\n    \"unexpected %r char in declaration\" % rawdata[j])\n   if j < 0:\n    return j\n  return -1 \n  \n  \n  \n def parse_marked_section(self, i, report=1):\n  rawdata= self.rawdata\n  assert rawdata[i:i+3] == '<![', \"unexpected call to parse_marked_section()\"\n  sectName, j = self._scan_name( i+3, i )\n  if j < 0:\n   return j\n  if sectName in {\"temp\", \"cdata\", \"ignore\", \"include\", \"rcdata\"}:\n  \n   match= _markedsectionclose.search(rawdata, i+3)\n  elif sectName in {\"if\", \"else\", \"endif\"}:\n  \n   match= _msmarkedsectionclose.search(rawdata, i+3)\n  else:\n   self.error('unknown status keyword %r in marked section' % rawdata[i+3:j])\n  if not match:\n   return -1\n  if report:\n   j = match.start(0)\n   self.unknown_decl(rawdata[i+3: j])\n  return match.end(0)\n  \n  \n def parse_comment(self, i, report=1):\n  rawdata = self.rawdata\n  if rawdata[i:i+4] != '<!--':\n   self.error('unexpected call to parse_comment()')\n  match = _commentclose.search(rawdata, i+4)\n  if not match:\n   return -1\n  if report:\n   j = match.start(0)\n   self.handle_comment(rawdata[i+4: j])\n  return match.end(0)\n  \n  \n  \n def _parse_doctype_subset(self, i, declstartpos):\n  rawdata = self.rawdata\n  n = len(rawdata)\n  j = i\n  while j < n:\n   c = rawdata[j]\n   if c == \"<\":\n    s = rawdata[j:j+2]\n    if s == \"<\":\n    \n     return -1\n    if s != \"<!\":\n     self.updatepos(declstartpos, j + 1)\n     self.error(\"unexpected char in internal subset (in %r)\" % s)\n    if (j + 2) == n:\n    \n     return -1\n    if (j + 4) > n:\n    \n     return -1\n    if rawdata[j:j+4] == \"<!--\":\n     j = self.parse_comment(j, report=0)\n     if j < 0:\n      return j\n     continue\n    name, j = self._scan_name(j + 2, declstartpos)\n    if j == -1:\n     return -1\n    if name not in {\"attlist\", \"element\", \"entity\", \"notation\"}:\n     self.updatepos(declstartpos, j + 2)\n     self.error(\n     \"unknown declaration %r in internal subset\" % name)\n     \n    meth = getattr(self, \"_parse_doctype_\" + name)\n    j = meth(j, declstartpos)\n    if j < 0:\n     return j\n   elif c == \"%\":\n   \n    if (j + 1) == n:\n    \n     return -1\n    s, j = self._scan_name(j + 1, declstartpos)\n    if j < 0:\n     return j\n    if rawdata[j] == \";\":\n     j = j + 1\n   elif c == \"]\":\n    j = j + 1\n    while j < n and rawdata[j].isspace():\n     j = j + 1\n    if j < n:\n     if rawdata[j] == \">\":\n      return j\n     self.updatepos(declstartpos, j)\n     self.error(\"unexpected char after internal subset\")\n    else:\n     return -1\n   elif c.isspace():\n    j = j + 1\n   else:\n    self.updatepos(declstartpos, j)\n    self.error(\"unexpected char %r in internal subset\" % c)\n    \n  return -1\n  \n  \n def _parse_doctype_element(self, i, declstartpos):\n  name, j = self._scan_name(i, declstartpos)\n  if j == -1:\n   return -1\n   \n  rawdata = self.rawdata\n  if '>' in rawdata[j:]:\n   return rawdata.find(\">\", j) + 1\n  return -1\n  \n  \n def _parse_doctype_attlist(self, i, declstartpos):\n  rawdata = self.rawdata\n  name, j = self._scan_name(i, declstartpos)\n  c = rawdata[j:j+1]\n  if c == \"\":\n   return -1\n  if c == \">\":\n   return j + 1\n  while 1:\n  \n  \n   name, j = self._scan_name(j, declstartpos)\n   if j < 0:\n    return j\n   c = rawdata[j:j+1]\n   if c == \"\":\n    return -1\n   if c == \"(\":\n   \n    if \")\" in rawdata[j:]:\n     j = rawdata.find(\")\", j) + 1\n    else:\n     return -1\n    while rawdata[j:j+1].isspace():\n     j = j + 1\n    if not rawdata[j:]:\n    \n     return -1\n   else:\n    name, j = self._scan_name(j, declstartpos)\n   c = rawdata[j:j+1]\n   if not c:\n    return -1\n   if c in \"'\\\"\":\n    m = _declstringlit_match(rawdata, j)\n    if m:\n     j = m.end()\n    else:\n     return -1\n    c = rawdata[j:j+1]\n    if not c:\n     return -1\n   if c == \"#\":\n    if rawdata[j:] == \"#\":\n    \n     return -1\n    name, j = self._scan_name(j + 1, declstartpos)\n    if j < 0:\n     return j\n    c = rawdata[j:j+1]\n    if not c:\n     return -1\n   if c == '>':\n   \n    return j + 1\n    \n    \n def _parse_doctype_notation(self, i, declstartpos):\n  name, j = self._scan_name(i, declstartpos)\n  if j < 0:\n   return j\n  rawdata = self.rawdata\n  while 1:\n   c = rawdata[j:j+1]\n   if not c:\n   \n    return -1\n   if c == '>':\n    return j + 1\n   if c in \"'\\\"\":\n    m = _declstringlit_match(rawdata, j)\n    if not m:\n     return -1\n    j = m.end()\n   else:\n    name, j = self._scan_name(j, declstartpos)\n    if j < 0:\n     return j\n     \n     \n def _parse_doctype_entity(self, i, declstartpos):\n  rawdata = self.rawdata\n  if rawdata[i:i+1] == \"%\":\n   j = i + 1\n   while 1:\n    c = rawdata[j:j+1]\n    if not c:\n     return -1\n    if c.isspace():\n     j = j + 1\n    else:\n     break\n  else:\n   j = i\n  name, j = self._scan_name(j, declstartpos)\n  if j < 0:\n   return j\n  while 1:\n   c = self.rawdata[j:j+1]\n   if not c:\n    return -1\n   if c in \"'\\\"\":\n    m = _declstringlit_match(rawdata, j)\n    if m:\n     j = m.end()\n    else:\n     return -1 \n   elif c == \">\":\n    return j + 1\n   else:\n    name, j = self._scan_name(j, declstartpos)\n    if j < 0:\n     return j\n     \n     \n     \n def _scan_name(self, i, declstartpos):\n  rawdata = self.rawdata\n  n = len(rawdata)\n  if i == n:\n   return None, -1\n  m = _declname_match(rawdata, i)\n  if m:\n   s = m.group()\n   name = s.strip()\n   if (i + len(s)) == n:\n    return None, -1 \n   return name.lower(), m.end()\n  else:\n   self.updatepos(declstartpos, i)\n   self.error(\"expected name token at %r\"\n   % rawdata[declstartpos:declstartpos+20])\n   \n   \n def unknown_decl(self, data):\n  pass\n"], "builtins": [".js", "var $module = (function(){\n    var obj = {__class__:__BRYTHON__.$ModuleDict,__name__:'builtins'}\n    var builtin_names = ['ArithmeticError', 'AssertionError', 'AttributeError', \n    'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', \n    'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', \n    'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', \n    'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', \n    'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', \n    'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', \n    'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError',\n    'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', \n    'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', \n    'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', \n    'ProcessLookupError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', \n    'RuntimeWarning', 'StopIteration', 'SyntaxError', 'SyntaxWarning', \n    'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', \n    'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', \n    'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', \n    'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_', \n    '__build_class__', '__debug__', '__doc__', '__import__', '__name__', \n    '__package__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', \n    'bytes','callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', \n    'credits','delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', \n    'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', \n    'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', \n    'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', \n    'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', \n    'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', \n    'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', \n    'vars', 'zip']\n    for(var i=0, _len_i = builtin_names.length; i < _len_i;i++){\n        try{eval(\"obj['\"+builtin_names[i]+\"']=__BRYTHON__.builtins.\"+builtin_names[i])}\n        catch(err){if (__BRYTHON__.$debug) {console.log(err)}}\n    }\n    return obj\n})()\n"], "struct": [".py", "__all__ = [\n\n'calcsize', 'pack', 'pack_into', 'unpack', 'unpack_from',\n\n\n'Struct',\n\n\n'error'\n]\n\nfrom _struct import *\nfrom _struct import _clearcache\nfrom _struct import __doc__\n"], "re": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\n\nimport sre_compile\nimport sre_parse\n\n\n__all__ = [ \"match\", \"search\", \"sub\", \"subn\", \"split\", \"findall\",\n\"compile\", \"purge\", \"template\", \"escape\", \"A\", \"I\", \"L\", \"M\", \"S\", \"X\",\n\"U\", \"ASCII\", \"IGNORECASE\", \"LOCALE\", \"MULTILINE\", \"DOTALL\", \"VERBOSE\",\n\"UNICODE\", \"error\" ]\n\n__version__ = \"2.2.1\"\n\n\nA = ASCII = sre_compile.SRE_FLAG_ASCII \nI = IGNORECASE = sre_compile.SRE_FLAG_IGNORECASE \nL = LOCALE = sre_compile.SRE_FLAG_LOCALE \nU = UNICODE = sre_compile.SRE_FLAG_UNICODE \nM = MULTILINE = sre_compile.SRE_FLAG_MULTILINE \nS = DOTALL = sre_compile.SRE_FLAG_DOTALL \nX = VERBOSE = sre_compile.SRE_FLAG_VERBOSE \n\n\nT = TEMPLATE = sre_compile.SRE_FLAG_TEMPLATE \nDEBUG = sre_compile.SRE_FLAG_DEBUG \n\n\nerror = sre_compile.error\n\n\n\n\ndef match(pattern, string, flags=0):\n \"\"\n return _compile(pattern, flags).match(string)\n \ndef search(pattern, string, flags=0):\n \"\"\n return _compile(pattern, flags).search(string)\n \ndef sub(pattern, repl, string, count=0, flags=0):\n \"\"\n return _compile(pattern, flags).sub(repl, string, count)\n \ndef subn(pattern, repl, string, count=0, flags=0):\n \"\"\n return _compile(pattern, flags).subn(repl, string, count)\n \ndef split(pattern, string, maxsplit=0, flags=0):\n \"\"\n return _compile(pattern, flags).split(string, maxsplit)\n \ndef findall(pattern, string, flags=0):\n \"\"\n return _compile(pattern, flags).findall(string)\n \ndef finditer(pattern, string, flags=0):\n \"\"\n return _compile(pattern, flags).finditer(string)\n \ndef compile(pattern, flags=0):\n \"\"\n \n return _compile(pattern, flags)\n \ndef purge():\n \"\"\n _cache.clear()\n _cache_repl.clear()\n \ndef template(pattern, flags=0):\n \"\"\n return _compile(pattern, flags|T)\n \n_alphanum_str = frozenset(\n\"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890\")\n_alphanum_bytes = frozenset(\nb\"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890\")\n\ndef escape(pattern):\n \"\"\n if isinstance(pattern, str):\n  alphanum = _alphanum_str\n  s = list(pattern)\n  for i, c in enumerate(pattern):\n   if c not in alphanum:\n    if c == \"\\000\":\n     s[i] = \"\\\\000\"\n    else:\n     s[i] = \"\\\\\" + c\n  return \"\".join(s)\n else:\n  alphanum = _alphanum_bytes\n  s = []\n  esc = ord(b\"\\\\\")\n  for c in pattern:\n   if c in alphanum:\n    s.append(c)\n   else:\n    if c == 0:\n     s.extend(b\"\\\\000\")\n    else:\n     s.append(esc)\n     s.append(c)\n  return bytes(s)\n  \n  \n  \n  \n_cache = {}\n_cache_repl = {}\n\n_pattern_type = type(sre_compile.compile(\"\", 0))\n\n_MAXCACHE = 512\ndef _compile(pattern, flags):\n\n try:\n \n \n  return _cache[\"%s:%s:%s\" % (type(pattern), pattern, flags)]\n except KeyError:\n  pass\n  \n if isinstance(pattern, _pattern_type):\n  if flags:\n   raise ValueError(\n   \"Cannot process flags argument with a compiled pattern\")\n  return pattern\n if not sre_compile.isstring(pattern):\n  raise TypeError(\"first argument must be string or compiled pattern\")\n p = sre_compile.compile(pattern, flags)\n \n if len(_cache) >= _MAXCACHE:\n  _cache.clear()\n  \n  \n _cache[\"%s:%s:%s\" % (type(pattern), pattern, flags)]= p\n return p\n \ndef _compile_repl(repl, pattern):\n\n try:\n \n \n  return _cache_repl[\"%s:%s\" % (repl, pattern)]\n except KeyError:\n  pass\n p = sre_parse.parse_template(repl, pattern)\n if len(_cache_repl) >= _MAXCACHE:\n  _cache_repl.clear()\n _cache_repl[\"%s:%s\" % (repl, pattern)] = p\n \n \n return p\n \ndef _expand(pattern, match, template):\n\n template = sre_parse.parse_template(template, pattern)\n return sre_parse.expand_template(template, match)\n \ndef _subx(pattern, template):\n\n template = _compile_repl(template, pattern)\n if not template[0] and len(template[1]) == 1:\n \n  return template[1][0]\n def filter(match, template=template):\n  return sre_parse.expand_template(template, match)\n return filter\n \n \n \nimport copyreg\n\ndef _pickle(p):\n return _compile, (p.pattern, p.flags)\n \ncopyreg.pickle(_pattern_type, _pickle, _compile)\n\n\n\n\nclass Scanner:\n def __init__(self, lexicon, flags=0):\n  from sre_constants import BRANCH, SUBPATTERN\n  self.lexicon = lexicon\n  \n  p = []\n  s = sre_parse.Pattern()\n  s.flags = flags\n  for phrase, action in lexicon:\n   p.append(sre_parse.SubPattern(s, [\n   (SUBPATTERN, (len(p)+1, sre_parse.parse(phrase, flags))),\n   ]))\n  s.groups = len(p)+1\n  p = sre_parse.SubPattern(s, [(BRANCH, (None, p))])\n  self.scanner = sre_compile.compile(p)\n def scan(self, string):\n  result = []\n  append = result.append\n  match = self.scanner.scanner(string).match\n  i = 0\n  while 1:\n   m = match()\n   if not m:\n    break\n   j = m.end()\n   if i == j:\n    break\n   action = self.lexicon[m.lastindex-1][1]\n   if callable(action):\n    self.match = m\n    action = action(self, m.group())\n   if action is not None:\n    append(action)\n   i = j\n  return result, string[i:]\n"], "tempfile": [".py", "\"\"\n\n__all__ = [\n\"NamedTemporaryFile\", \"TemporaryFile\", \n\"SpooledTemporaryFile\", \"TemporaryDirectory\",\n\"mkstemp\", \"mkdtemp\", \n\"mktemp\", \n\"TMP_MAX\", \"gettempprefix\", \n\"tempdir\", \"gettempdir\"\n]\n\n\n\n\nimport warnings as _warnings\nimport sys as _sys\nimport io as _io\nimport os as _os\nimport errno as _errno\nfrom random import Random as _Random\n\ntry:\n import fcntl as _fcntl\nexcept ImportError:\n def _set_cloexec(fd):\n  pass\nelse:\n def _set_cloexec(fd):\n  try:\n   flags = _fcntl.fcntl(fd, _fcntl.F_GETFD, 0)\n  except OSError:\n   pass\n  else:\n  \n   flags |= _fcntl.FD_CLOEXEC\n   _fcntl.fcntl(fd, _fcntl.F_SETFD, flags)\n   \n   \ntry:\n import _thread\nexcept ImportError:\n import _dummy_thread as _thread\n_allocate_lock = _thread.allocate_lock\n\n_text_openflags = _os.O_RDWR | _os.O_CREAT | _os.O_EXCL\nif hasattr(_os, 'O_NOINHERIT'):\n _text_openflags |= _os.O_NOINHERIT\nif hasattr(_os, 'O_NOFOLLOW'):\n _text_openflags |= _os.O_NOFOLLOW\n \n_bin_openflags = _text_openflags\nif hasattr(_os, 'O_BINARY'):\n _bin_openflags |= _os.O_BINARY\n \nif hasattr(_os, 'TMP_MAX'):\n TMP_MAX = _os.TMP_MAX\nelse:\n TMP_MAX = 10000\n \n \n \ntemplate = \"tmp\"\n\n\n\n_once_lock = _allocate_lock()\n\nif hasattr(_os, \"lstat\"):\n _stat = _os.lstat\nelif hasattr(_os, \"stat\"):\n _stat = _os.stat\nelse:\n\n\n def _stat(fn):\n  f = open(fn)\n  f.close()\n  \ndef _exists(fn):\n try:\n  _stat(fn)\n except OSError:\n  return False\n else:\n  return True\n  \nclass _RandomNameSequence:\n \"\"\n \n characters = \"abcdefghijklmnopqrstuvwxyz0123456789_\"\n \n @property\n def rng(self):\n  cur_pid = _os.getpid()\n  if cur_pid != getattr(self, '_rng_pid', None):\n   self._rng = _Random()\n   self._rng_pid = cur_pid\n  return self._rng\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  c = self.characters\n  choose = self.rng.choice\n  letters = [choose(c) for dummy in \"123456\"]\n  return ''.join(letters)\n  \ndef _candidate_tempdir_list():\n \"\"\n \n dirlist = []\n \n \n for envname in 'TMPDIR', 'TEMP', 'TMP':\n  dirname = _os.getenv(envname)\n  if dirname: dirlist.append(dirname)\n  \n  \n if _os.name == 'nt':\n  dirlist.extend([ r'c:\\temp', r'c:\\tmp', r'\\temp', r'\\tmp' ])\n else:\n  dirlist.extend([ '/tmp', '/var/tmp', '/usr/tmp' ])\n  \n  \n try:\n  dirlist.append(_os.getcwd())\n except (AttributeError, OSError):\n  dirlist.append(_os.curdir)\n  \n return dirlist\n \ndef _get_default_tempdir():\n \"\"\n \n namer = _RandomNameSequence()\n dirlist = _candidate_tempdir_list()\n \n for dir in dirlist:\n  if dir != _os.curdir:\n   dir = _os.path.normcase(_os.path.abspath(dir))\n   \n  for seq in range(100):\n   name = next(namer)\n   filename = _os.path.join(dir, name)\n   try:\n    fd = _os.open(filename, _bin_openflags, 0o600)\n    try:\n     try:\n      with _io.open(fd, 'wb', closefd=False) as fp:\n       fp.write(b'blat')\n     finally:\n      _os.close(fd)\n    finally:\n     _os.unlink(filename)\n    return dir\n   except FileExistsError:\n    pass\n   except OSError:\n    break \n raise FileNotFoundError(_errno.ENOENT,\n \"No usable temporary directory found in %s\" %\n dirlist)\n \n_name_sequence = None\n\ndef _get_candidate_names():\n \"\"\n \n global _name_sequence\n if _name_sequence is None:\n  _once_lock.acquire()\n  try:\n   if _name_sequence is None:\n    _name_sequence = _RandomNameSequence()\n  finally:\n   _once_lock.release()\n return _name_sequence\n \n \ndef _mkstemp_inner(dir, pre, suf, flags):\n \"\"\n \n names = _get_candidate_names()\n \n for seq in range(TMP_MAX):\n  name = next(names)\n  file = _os.path.join(dir, pre + name + suf)\n  try:\n   fd = _os.open(file, flags, 0o600)\n   _set_cloexec(fd)\n   return (fd, _os.path.abspath(file))\n  except FileExistsError:\n   continue \n  except PermissionError:\n  \n  \n   if _os.name == 'nt':\n    continue\n   else:\n    raise\n    \n raise FileExistsError(_errno.EEXIST,\n \"No usable temporary file name found\")\n \n \n \n \ndef gettempprefix():\n \"\"\n return template\n \ntempdir = None\n\ndef gettempdir():\n \"\"\n global tempdir\n if tempdir is None:\n  _once_lock.acquire()\n  try:\n   if tempdir is None:\n    tempdir = _get_default_tempdir()\n  finally:\n   _once_lock.release()\n return tempdir\n \ndef mkstemp(suffix=\"\", prefix=template, dir=None, text=False):\n \"\"\n \n if dir is None:\n  dir = gettempdir()\n  \n if text:\n  flags = _text_openflags\n else:\n  flags = _bin_openflags\n  \n return _mkstemp_inner(dir, prefix, suffix, flags)\n \n \ndef mkdtemp(suffix=\"\", prefix=template, dir=None):\n \"\"\n \n if dir is None:\n  dir = gettempdir()\n  \n names = _get_candidate_names()\n \n for seq in range(TMP_MAX):\n  name = next(names)\n  file = _os.path.join(dir, prefix + name + suffix)\n  try:\n   _os.mkdir(file, 0o700)\n   return file\n  except FileExistsError:\n   continue \n   \n raise FileExistsError(_errno.EEXIST,\n \"No usable temporary directory name found\")\n \ndef mktemp(suffix=\"\", prefix=template, dir=None):\n \"\"\n \n \n \n \n \n if dir is None:\n  dir = gettempdir()\n  \n names = _get_candidate_names()\n for seq in range(TMP_MAX):\n  name = next(names)\n  file = _os.path.join(dir, prefix + name + suffix)\n  if not _exists(file):\n   return file\n   \n raise FileExistsError(_errno.EEXIST,\n \"No usable temporary filename found\")\n \n \nclass _TemporaryFileWrapper:\n \"\"\n \n def __init__(self, file, name, delete=True):\n  self.file = file\n  self.name = name\n  self.close_called = False\n  self.delete = delete\n  \n def __getattr__(self, name):\n \n \n \n  file = self.__dict__['file']\n  a = getattr(file, name)\n  if not isinstance(a, int):\n   setattr(self, name, a)\n  return a\n  \n  \n  \n def __enter__(self):\n  self.file.__enter__()\n  return self\n  \n  \n def __iter__(self):\n  return iter(self.file)\n  \n  \n  \n  \n if _os.name != 'nt':\n \n \n \n \n \n  unlink = _os.unlink\n  \n  def close(self):\n   if not self.close_called:\n    self.close_called = True\n    self.file.close()\n    if self.delete:\n     self.unlink(self.name)\n     \n  def __del__(self):\n   self.close()\n   \n   \n   \n  def __exit__(self, exc, value, tb):\n   result = self.file.__exit__(exc, value, tb)\n   self.close()\n   return result\n else:\n  def __exit__(self, exc, value, tb):\n   self.file.__exit__(exc, value, tb)\n   \n   \ndef NamedTemporaryFile(mode='w+b', buffering=-1, encoding=None,\nnewline=None, suffix=\"\", prefix=template,\ndir=None, delete=True):\n \"\"\n \n if dir is None:\n  dir = gettempdir()\n  \n flags = _bin_openflags\n \n \n \n if _os.name == 'nt' and delete:\n  flags |= _os.O_TEMPORARY\n  \n (fd, name) = _mkstemp_inner(dir, prefix, suffix, flags)\n file = _io.open(fd, mode, buffering=buffering,\n newline=newline, encoding=encoding)\n \n return _TemporaryFileWrapper(file, name, delete)\n \nif _os.name != 'posix' or _os.sys.platform == 'cygwin':\n\n\n TemporaryFile = NamedTemporaryFile\n \nelse:\n def TemporaryFile(mode='w+b', buffering=-1, encoding=None,\n newline=None, suffix=\"\", prefix=template,\n dir=None):\n  \"\"\n  \n  if dir is None:\n   dir = gettempdir()\n   \n  flags = _bin_openflags\n  \n  (fd, name) = _mkstemp_inner(dir, prefix, suffix, flags)\n  try:\n   _os.unlink(name)\n   return _io.open(fd, mode, buffering=buffering,\n   newline=newline, encoding=encoding)\n  except:\n   _os.close(fd)\n   raise\n   \nclass SpooledTemporaryFile:\n \"\"\n _rolled = False\n \n def __init__(self, max_size=0, mode='w+b', buffering=-1,\n encoding=None, newline=None,\n suffix=\"\", prefix=template, dir=None):\n  if 'b' in mode:\n   self._file = _io.BytesIO()\n  else:\n  \n  \n  \n   self._file = _io.StringIO(newline=\"\\n\")\n  self._max_size = max_size\n  self._rolled = False\n  self._TemporaryFileArgs = {'mode': mode, 'buffering': buffering,\n  'suffix': suffix, 'prefix': prefix,\n  'encoding': encoding, 'newline': newline,\n  'dir': dir}\n  \n def _check(self, file):\n  if self._rolled: return\n  max_size = self._max_size\n  if max_size and file.tell() > max_size:\n   self.rollover()\n   \n def rollover(self):\n  if self._rolled: return\n  file = self._file\n  newfile = self._file = TemporaryFile(**self._TemporaryFileArgs)\n  del self._TemporaryFileArgs\n  \n  newfile.write(file.getvalue())\n  newfile.seek(file.tell(), 0)\n  \n  self._rolled = True\n  \n  \n  \n  \n  \n  \n  \n def __enter__(self):\n  if self._file.closed:\n   raise ValueError(\"Cannot enter context with closed file\")\n  return self\n  \n def __exit__(self, exc, value, tb):\n  self._file.close()\n  \n  \n def __iter__(self):\n  return self._file.__iter__()\n  \n def close(self):\n  self._file.close()\n  \n @property\n def closed(self):\n  return self._file.closed\n  \n @property\n def encoding(self):\n  try:\n   return self._file.encoding\n  except AttributeError:\n   if 'b' in self._TemporaryFileArgs['mode']:\n    raise\n   return self._TemporaryFileArgs['encoding']\n   \n def fileno(self):\n  self.rollover()\n  return self._file.fileno()\n  \n def flush(self):\n  self._file.flush()\n  \n def isatty(self):\n  return self._file.isatty()\n  \n @property\n def mode(self):\n  try:\n   return self._file.mode\n  except AttributeError:\n   return self._TemporaryFileArgs['mode']\n   \n @property\n def name(self):\n  try:\n   return self._file.name\n  except AttributeError:\n   return None\n   \n @property\n def newlines(self):\n  try:\n   return self._file.newlines\n  except AttributeError:\n   if 'b' in self._TemporaryFileArgs['mode']:\n    raise\n   return self._TemporaryFileArgs['newline']\n   \n def read(self, *args):\n  return self._file.read(*args)\n  \n def readline(self, *args):\n  return self._file.readline(*args)\n  \n def readlines(self, *args):\n  return self._file.readlines(*args)\n  \n def seek(self, *args):\n  self._file.seek(*args)\n  \n @property\n def softspace(self):\n  return self._file.softspace\n  \n def tell(self):\n  return self._file.tell()\n  \n def truncate(self, size=None):\n  if size is None:\n   self._file.truncate()\n  else:\n   if size > self._max_size:\n    self.rollover()\n   self._file.truncate(size)\n   \n def write(self, s):\n  file = self._file\n  rv = file.write(s)\n  self._check(file)\n  return rv\n  \n def writelines(self, iterable):\n  file = self._file\n  rv = file.writelines(iterable)\n  self._check(file)\n  return rv\n  \n  \nclass TemporaryDirectory(object):\n \"\"\n \n def __init__(self, suffix=\"\", prefix=template, dir=None):\n  self._closed = False\n  self.name = None \n  self.name = mkdtemp(suffix, prefix, dir)\n  \n def __repr__(self):\n  return \"<{} {!r}>\".format(self.__class__.__name__, self.name)\n  \n def __enter__(self):\n  return self.name\n  \n def cleanup(self, _warn=False):\n  if self.name and not self._closed:\n   try:\n    self._rmtree(self.name)\n   except (TypeError, AttributeError) as ex:\n   \n   \n   \n    if \"None\" not in str(ex):\n     raise\n    print(\"ERROR: {!r} while cleaning up {!r}\".format(ex, self,),\n    file=_sys.stderr)\n    return\n   self._closed = True\n   if _warn:\n    self._warn(\"Implicitly cleaning up {!r}\".format(self),\n    ResourceWarning)\n    \n def __exit__(self, exc, value, tb):\n  self.cleanup()\n  \n def __del__(self):\n \n  self.cleanup(_warn=True)\n  \n  \n  \n  \n  \n _listdir = staticmethod(_os.listdir)\n _path_join = staticmethod(_os.path.join)\n _isdir = staticmethod(_os.path.isdir)\n _islink = staticmethod(_os.path.islink)\n _remove = staticmethod(_os.remove)\n _rmdir = staticmethod(_os.rmdir)\n _os_error = OSError\n _warn = _warnings.warn\n \n def _rmtree(self, path):\n \n \n  for name in self._listdir(path):\n   fullname = self._path_join(path, name)\n   try:\n    isdir = self._isdir(fullname) and not self._islink(fullname)\n   except self._os_error:\n    isdir = False\n   if isdir:\n    self._rmtree(fullname)\n   else:\n    try:\n     self._remove(fullname)\n    except self._os_error:\n     pass\n  try:\n   self._rmdir(path)\n  except self._os_error:\n   pass\n"], "base64": [".py", "\n\n\"\"\n\n\n\n\n\nimport re\nimport struct\nimport binascii\n\n\n__all__ = [\n\n'encode', 'decode', 'encodebytes', 'decodebytes',\n\n'b64encode', 'b64decode', 'b32encode', 'b32decode',\n'b16encode', 'b16decode',\n\n'standard_b64encode', 'standard_b64decode',\n\n\n\n\n'urlsafe_b64encode', 'urlsafe_b64decode',\n]\n\n\nbytes_types = (bytes, bytearray) \n\ndef _bytes_from_decode_data(s):\n if isinstance(s, str):\n  try:\n   return s.encode('ascii')\n  except UnicodeEncodeError:\n   raise ValueError('string argument should contain only ASCII characters')\n elif isinstance(s, bytes_types):\n  return s\n else:\n  raise TypeError(\"argument should be bytes or ASCII string, not %s\" % s.__class__.__name__)\n  \n  \n  \n  \n  \ndef b64encode(s, altchars=None):\n \"\"\n if not isinstance(s, bytes_types):\n  raise TypeError(\"expected bytes, not %s\" % s.__class__.__name__)\n  \n encoded = binascii.b2a_base64(s)[:-1]\n if altchars is not None:\n  if not isinstance(altchars, bytes_types):\n   raise TypeError(\"expected bytes, not %s\"\n   % altchars.__class__.__name__)\n  assert len(altchars) == 2, repr(altchars)\n  return encoded.translate(bytes.maketrans(b'+/', altchars))\n return encoded\n \n \ndef b64decode(s, altchars=None, validate=False):\n \"\"\n s = _bytes_from_decode_data(s)\n if altchars is not None:\n  altchars = _bytes_from_decode_data(altchars)\n  assert len(altchars) == 2, repr(altchars)\n  s = s.translate(bytes.maketrans(altchars, b'+/'))\n if validate and not re.match(b'^[A-Za-z0-9+/]*={0,2}$', s):\n  raise binascii.Error('Non-base64 digit found')\n return binascii.a2b_base64(s)\n \n \ndef standard_b64encode(s):\n \"\"\n return b64encode(s)\n \ndef standard_b64decode(s):\n \"\"\n return b64decode(s)\n \n \n_urlsafe_encode_translation = bytes.maketrans(b'+/', b'-_')\n_urlsafe_decode_translation = bytes.maketrans(b'-_', b'+/')\n\ndef urlsafe_b64encode(s):\n \"\"\n return b64encode(s).translate(_urlsafe_encode_translation)\n \ndef urlsafe_b64decode(s):\n \"\"\n s = _bytes_from_decode_data(s)\n s = s.translate(_urlsafe_decode_translation)\n return b64decode(s)\n \n \n \n \n_b32alphabet = {\n0: b'A', 9: b'J', 18: b'S', 27: b'3',\n1: b'B', 10: b'K', 19: b'T', 28: b'4',\n2: b'C', 11: b'L', 20: b'U', 29: b'5',\n3: b'D', 12: b'M', 21: b'V', 30: b'6',\n4: b'E', 13: b'N', 22: b'W', 31: b'7',\n5: b'F', 14: b'O', 23: b'X',\n6: b'G', 15: b'P', 24: b'Y',\n7: b'H', 16: b'Q', 25: b'Z',\n8: b'I', 17: b'R', 26: b'2',\n}\n\n_b32tab = [v[0] for k, v in sorted(_b32alphabet.items())]\n_b32rev = dict([(v[0], k) for k, v in _b32alphabet.items()])\n\n\ndef b32encode(s):\n \"\"\n if not isinstance(s, bytes_types):\n  raise TypeError(\"expected bytes, not %s\" % s.__class__.__name__)\n quanta, leftover = divmod(len(s), 5)\n \n if leftover:\n  s = s + bytes(5 - leftover) \n  quanta += 1\n encoded = bytearray()\n for i in range(quanta):\n \n \n \n \n \n  c1, c2, c3 = struct.unpack('!HHB', s[i*5:(i+1)*5])\n  c2 += (c1 & 1) << 16 \n  c3 += (c2 & 3) << 8 \n  encoded += bytes([_b32tab[c1 >> 11], \n  _b32tab[(c1 >> 6) & 0x1f], \n  _b32tab[(c1 >> 1) & 0x1f], \n  _b32tab[c2 >> 12], \n  _b32tab[(c2 >> 7) & 0x1f], \n  _b32tab[(c2 >> 2) & 0x1f], \n  _b32tab[c3 >> 5], \n  _b32tab[c3 & 0x1f], \n  ])\n  \n if leftover == 1:\n  encoded[-6:] = b'======'\n elif leftover == 2:\n  encoded[-4:] = b'===='\n elif leftover == 3:\n  encoded[-3:] = b'==='\n elif leftover == 4:\n  encoded[-1:] = b'='\n return bytes(encoded)\n \n \ndef b32decode(s, casefold=False, map01=None):\n \"\"\n s = _bytes_from_decode_data(s)\n quanta, leftover = divmod(len(s), 8)\n if leftover:\n  raise binascii.Error('Incorrect padding')\n  \n  \n  \n if map01 is not None:\n  map01 = _bytes_from_decode_data(map01)\n  assert len(map01) == 1, repr(map01)\n  s = s.translate(bytes.maketrans(b'01', b'O' + map01))\n if casefold:\n  s = s.upper()\n  \n  \n  \n padchars = 0\n mo = re.search(b'(?P<pad>[=]*)$', s)\n if mo:\n  padchars = len(mo.group('pad'))\n  if padchars > 0:\n   s = s[:-padchars]\n   \n parts = []\n acc = 0\n shift = 35\n for c in s:\n  val = _b32rev.get(c)\n  if val is None:\n   raise binascii.Error('Non-base32 digit found')\n  acc += _b32rev[c] << shift\n  shift -= 5\n  if shift < 0:\n   parts.append(binascii.unhexlify(bytes('%010x' % acc, \"ascii\")))\n   acc = 0\n   shift = 35\n   \n last = binascii.unhexlify(bytes('%010x' % acc, \"ascii\"))\n if padchars == 0:\n  last = b'' \n elif padchars == 1:\n  last = last[:-1]\n elif padchars == 3:\n  last = last[:-2]\n elif padchars == 4:\n  last = last[:-3]\n elif padchars == 6:\n  last = last[:-4]\n else:\n  raise binascii.Error('Incorrect padding')\n parts.append(last)\n return b''.join(parts)\n \n \n \n \n \n \ndef b16encode(s):\n \"\"\n if not isinstance(s, bytes_types):\n  raise TypeError(\"expected bytes, not %s\" % s.__class__.__name__)\n return binascii.hexlify(s).upper()\n \n \ndef b16decode(s, casefold=False):\n \"\"\n s = _bytes_from_decode_data(s)\n if casefold:\n  s = s.upper()\n if re.search(b'[^0-9A-F]', s):\n  raise binascii.Error('Non-base16 digit found')\n return binascii.unhexlify(s)\n \n \n \n \n \n \n \nMAXLINESIZE = 76 \nMAXBINSIZE = (MAXLINESIZE//4)*3\n\ndef encode(input, output):\n \"\"\n while True:\n  s = input.read(MAXBINSIZE)\n  if not s:\n   break\n  while len(s) < MAXBINSIZE:\n   ns = input.read(MAXBINSIZE-len(s))\n   if not ns:\n    break\n   s += ns\n  line = binascii.b2a_base64(s)\n  output.write(line)\n  \n  \ndef decode(input, output):\n \"\"\n while True:\n  line = input.readline()\n  if not line:\n   break\n  s = binascii.a2b_base64(line)\n  output.write(s)\n  \n  \ndef encodebytes(s):\n \"\"\n if not isinstance(s, bytes_types):\n  raise TypeError(\"expected bytes, not %s\" % s.__class__.__name__)\n pieces = []\n for i in range(0, len(s), MAXBINSIZE):\n  chunk = s[i : i + MAXBINSIZE]\n  pieces.append(binascii.b2a_base64(chunk))\n return b\"\".join(pieces)\n \ndef encodestring(s):\n \"\"\n import warnings\n warnings.warn(\"encodestring() is a deprecated alias, use encodebytes()\",\n DeprecationWarning, 2)\n return encodebytes(s)\n \n \ndef decodebytes(s):\n \"\"\n if not isinstance(s, bytes_types):\n  raise TypeError(\"expected bytes, not %s\" % s.__class__.__name__)\n return binascii.a2b_base64(s)\n \ndef decodestring(s):\n \"\"\n import warnings\n warnings.warn(\"decodestring() is a deprecated alias, use decodebytes()\",\n DeprecationWarning, 2)\n return decodebytes(s)\n \n \n \ndef main():\n \"\"\n import sys, getopt\n try:\n  opts, args = getopt.getopt(sys.argv[1:], 'deut')\n except getopt.error as msg:\n  sys.stdout = sys.stderr\n  print(msg)\n  print(\"\"\"usage: %s [-d|-e|-u|-t] [file|-]\n        -d, -u: decode\n        -e: encode (default)\n        -t: encode and decode string 'Aladdin:open sesame'\"\"\"  %sys.argv[0])\n  sys.exit(2)\n func = encode\n for o, a in opts:\n  if o == '-e': func = encode\n  if o == '-d': func = decode\n  if o == '-u': func = decode\n  if o == '-t': test(); return\n if args and args[0] != '-':\n  with open(args[0], 'rb') as f:\n   func(f, sys.stdout.buffer)\n else:\n  func(sys.stdin.buffer, sys.stdout.buffer)\n  \n  \ndef test():\n s0 = b\"Aladdin:open sesame\"\n print(repr(s0))\n s1 = encodebytes(s0)\n print(repr(s1))\n s2 = decodebytes(s1)\n print(repr(s2))\n assert s0 == s2\n \n \nif __name__ == '__main__':\n main()\n"], "platform": [".py", "\n\n\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__copyright__ = \"\"\"\n    Copyright (c) 1999-2000, Marc-Andre Lemburg; mailto:mal@lemburg.com\n    Copyright (c) 2000-2010, eGenix.com Software GmbH; mailto:info@egenix.com\n\n    Permission to use, copy, modify, and distribute this software and its\n    documentation for any purpose and without fee or royalty is hereby granted,\n    provided that the above copyright notice appear in all copies and that\n    both that copyright notice and this permission notice appear in\n    supporting documentation or portions thereof, including modifications,\n    that you make.\n\n    EGENIX.COM SOFTWARE GMBH DISCLAIMS ALL WARRANTIES WITH REGARD TO\n    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n    FITNESS, IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,\n    INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING\n    FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n    NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n    WITH THE USE OR PERFORMANCE OF THIS SOFTWARE !\n\n\"\"\"\n\n__version__ = '1.0.7'\n\nimport collections\nimport sys, os, re, subprocess\n\n\n\n\ntry:\n DEV_NULL = os.devnull\nexcept AttributeError:\n\n\n if sys.platform in ('dos','win32','win16','os2'):\n \n  DEV_NULL = 'NUL'\n else:\n \n  DEV_NULL = '/dev/null'\n  \n  \n  \n_libc_search = re.compile(b'(__libc_init)'\nb'|'\nb'(GLIBC_([0-9.]+))'\nb'|'\nbr'(libc(_\\w+)?\\.so(?:\\.(\\d[0-9.]*))?)', re.ASCII)\n\ndef libc_ver(executable=sys.executable,lib='',version='',\n\nchunksize=16384):\n\n \"\"\n if hasattr(os.path, 'realpath'):\n \n \n \n  executable = os.path.realpath(executable)\n f = open(executable,'rb')\n binary = f.read(chunksize)\n pos = 0\n while 1:\n  if b'libc' in binary or b'GLIBC' in binary:\n   m = _libc_search.search(binary,pos)\n  else:\n   m = None\n  if not m:\n   binary = f.read(chunksize)\n   if not binary:\n    break\n   pos = 0\n   continue\n  libcinit,glibc,glibcversion,so,threads,soversion = [\n  s.decode('latin1') if s is not None else s\n  for s in m.groups()]\n  if libcinit and not lib:\n   lib = 'libc'\n  elif glibc:\n   if lib != 'glibc':\n    lib = 'glibc'\n    version = glibcversion\n   elif glibcversion > version:\n    version = glibcversion\n  elif so:\n   if lib != 'glibc':\n    lib = 'libc'\n    if soversion and soversion > version:\n     version = soversion\n    if threads and version[-len(threads):] != threads:\n     version = version + threads\n  pos = m.end()\n f.close()\n return lib,version\n \ndef _dist_try_harder(distname,version,id):\n\n \"\"\n if os.path.exists('/var/adm/inst-log/info'):\n \n  distname = 'SuSE'\n  for line in open('/var/adm/inst-log/info'):\n   tv = line.split()\n   if len(tv) == 2:\n    tag,value = tv\n   else:\n    continue\n   if tag == 'MIN_DIST_VERSION':\n    version = value.strip()\n   elif tag == 'DIST_IDENT':\n    values = value.split('-')\n    id = values[2]\n  return distname,version,id\n  \n if os.path.exists('/etc/.installed'):\n \n  for line in open('/etc/.installed'):\n   pkg = line.split('-')\n   if len(pkg) >= 2 and pkg[0] == 'OpenLinux':\n   \n   \n    return 'OpenLinux',pkg[1],id\n    \n if os.path.isdir('/usr/lib/setup'):\n \n  verfiles = os.listdir('/usr/lib/setup')\n  for n in range(len(verfiles)-1, -1, -1):\n   if verfiles[n][:14] != 'slack-version-':\n    del verfiles[n]\n  if verfiles:\n   verfiles.sort()\n   distname = 'slackware'\n   version = verfiles[-1][14:]\n   return distname,version,id\n   \n return distname,version,id\n \n_release_filename = re.compile(r'(\\w+)[-_](release|version)', re.ASCII)\n_lsb_release_version = re.compile(r'(.+)'\n' release '\n'([\\d.]+)'\n'[^(]*(?:\\((.+)\\))?', re.ASCII)\n_release_version = re.compile(r'([^0-9]+)'\n'(?: release )?'\n'([\\d.]+)'\n'[^(]*(?:\\((.+)\\))?', re.ASCII)\n\n\n\n\n\n\n_supported_dists = (\n'SuSE', 'debian', 'fedora', 'redhat', 'centos',\n'mandrake', 'mandriva', 'rocks', 'slackware', 'yellowdog', 'gentoo',\n'UnitedLinux', 'turbolinux', 'arch', 'mageia')\n\ndef _parse_release_file(firstline):\n\n\n\n\n version = ''\n id = ''\n \n \n m = _lsb_release_version.match(firstline)\n if m is not None:\n \n  return tuple(m.groups())\n  \n  \n m = _release_version.match(firstline)\n if m is not None:\n  return tuple(m.groups())\n  \n  \n l = firstline.strip().split()\n if l:\n  version = l[0]\n  if len(l) > 1:\n   id = l[1]\n return '', version, id\n \ndef linux_distribution(distname='', version='', id='',\n\nsupported_dists=_supported_dists,\nfull_distribution_name=1):\n\n \"\"\n try:\n  etc = os.listdir('/etc')\n except os.error:\n \n  return distname,version,id\n etc.sort()\n for file in etc:\n  m = _release_filename.match(file)\n  if m is not None:\n   _distname,dummy = m.groups()\n   if _distname in supported_dists:\n    distname = _distname\n    break\n else:\n  return _dist_try_harder(distname,version,id)\n  \n  \n with open('/etc/'+file, 'r') as f:\n  firstline = f.readline()\n _distname, _version, _id = _parse_release_file(firstline)\n \n if _distname and full_distribution_name:\n  distname = _distname\n if _version:\n  version = _version\n if _id:\n  id = _id\n return distname, version, id\n \n \n \ndef dist(distname='',version='',id='',\n\nsupported_dists=_supported_dists):\n\n \"\"\n return linux_distribution(distname, version, id,\n supported_dists=supported_dists,\n full_distribution_name=0)\n \ndef popen(cmd, mode='r', bufsize=-1):\n\n \"\"\n import warnings\n warnings.warn('use os.popen instead', DeprecationWarning, stacklevel=2)\n return os.popen(cmd, mode, bufsize)\n \ndef _norm_version(version, build=''):\n\n \"\"\n l = version.split('.')\n if build:\n  l.append(build)\n try:\n  ints = map(int,l)\n except ValueError:\n  strings = l\n else:\n  strings = list(map(str,ints))\n version = '.'.join(strings[:3])\n return version\n \n_ver_output = re.compile(r'(?:([\\w ]+) ([\\w.]+) '\n'.*'\n'\\[.* ([\\d.]+)\\])')\n\n\n\n\n\n\n\n\n\n\ndef _syscmd_ver(system='', release='', version='',\n\nsupported_platforms=('win32','win16','dos','os2')):\n\n \"\"\n if sys.platform not in supported_platforms:\n  return system,release,version\n  \n  \n for cmd in ('ver','command /c ver','cmd /c ver'):\n  try:\n   pipe = popen(cmd)\n   info = pipe.read()\n   if pipe.close():\n    raise os.error('command failed')\n    \n    \n  except os.error as why:\n  \n   continue\n  except IOError as why:\n  \n   continue\n  else:\n   break\n else:\n  return system,release,version\n  \n  \n info = info.strip()\n m = _ver_output.match(info)\n if m is not None:\n  system,release,version = m.groups()\n  \n  if release[-1] == '.':\n   release = release[:-1]\n  if version[-1] == '.':\n   version = version[:-1]\n   \n   \n  version = _norm_version(version)\n return system,release,version\n \ndef _win32_getvalue(key,name,default=''):\n\n \"\"\n try:\n \n  from win32api import RegQueryValueEx\n except ImportError:\n \n  import winreg\n  RegQueryValueEx = winreg.QueryValueEx\n try:\n  return RegQueryValueEx(key,name)\n except:\n  return default\n  \ndef win32_ver(release='',version='',csd='',ptype=''):\n\n \"\"\n \n \n \n \n \n \n \n \n \n try:\n  import win32api\n  from win32api import RegQueryValueEx, RegOpenKeyEx, RegCloseKey, GetVersionEx\n  from win32con import HKEY_LOCAL_MACHINE, VER_PLATFORM_WIN32_NT, VER_PLATFORM_WIN32_WINDOWS, VER_NT_WORKSTATION\n except ImportError:\n \n  try:\n   sys.getwindowsversion\n  except AttributeError:\n  \n   return release,version,csd,ptype\n  else:\n  \n  \n   import winreg\n   GetVersionEx = sys.getwindowsversion\n   RegQueryValueEx = winreg.QueryValueEx\n   RegOpenKeyEx = winreg.OpenKeyEx\n   RegCloseKey = winreg.CloseKey\n   HKEY_LOCAL_MACHINE = winreg.HKEY_LOCAL_MACHINE\n   VER_PLATFORM_WIN32_WINDOWS = 1\n   VER_PLATFORM_WIN32_NT = 2\n   VER_NT_WORKSTATION = 1\n   VER_NT_SERVER = 3\n   REG_SZ = 1\n   \n   \n winver = GetVersionEx()\n maj,min,buildno,plat,csd = winver\n version = '%i.%i.%i' % (maj,min,buildno & 0xFFFF)\n if hasattr(winver, \"service_pack\"):\n  if winver.service_pack != \"\":\n   csd = 'SP%s' % winver.service_pack_major\n else:\n  if csd[:13] == 'Service Pack ':\n   csd = 'SP' + csd[13:]\n   \n if plat == VER_PLATFORM_WIN32_WINDOWS:\n  regkey = 'SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion'\n  \n  if maj == 4:\n   if min == 0:\n    release = '95'\n   elif min == 10:\n    release = '98'\n   elif min == 90:\n    release = 'Me'\n   else:\n    release = 'postMe'\n  elif maj == 5:\n   release = '2000'\n   \n elif plat == VER_PLATFORM_WIN32_NT:\n  regkey = 'SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion'\n  if maj <= 4:\n   release = 'NT'\n  elif maj == 5:\n   if min == 0:\n    release = '2000'\n   elif min == 1:\n    release = 'XP'\n   elif min == 2:\n    release = '2003Server'\n   else:\n    release = 'post2003'\n  elif maj == 6:\n   if hasattr(winver, \"product_type\"):\n    product_type = winver.product_type\n   else:\n    product_type = VER_NT_WORKSTATION\n    \n    \n    \n    try:\n     key = RegOpenKeyEx(HKEY_LOCAL_MACHINE, regkey)\n     name, type = RegQueryValueEx(key, \"ProductName\")\n     \n     if type == REG_SZ and name.find(\"Server\") != -1:\n      product_type = VER_NT_SERVER\n    except WindowsError:\n    \n     pass\n     \n   if min == 0:\n    if product_type == VER_NT_WORKSTATION:\n     release = 'Vista'\n    else:\n     release = '2008Server'\n   elif min == 1:\n    if product_type == VER_NT_WORKSTATION:\n     release = '7'\n    else:\n     release = '2008ServerR2'\n   elif min == 2:\n    if product_type == VER_NT_WORKSTATION:\n     release = '8'\n    else:\n     release = '2012Server'\n   else:\n    release = 'post2012Server'\n    \n else:\n  if not release:\n  \n   release = '%i.%i' % (maj,min)\n  return release,version,csd,ptype\n  \n  \n try:\n  keyCurVer = RegOpenKeyEx(HKEY_LOCAL_MACHINE, regkey)\n  \n  RegQueryValueEx(keyCurVer, 'SystemRoot')\n except:\n  return release,version,csd,ptype\n  \n  \n  \n  \n  \n  \n  \n build = _win32_getvalue(keyCurVer,\n 'CurrentBuildNumber',\n ('',1))[0]\n ptype = _win32_getvalue(keyCurVer,\n 'CurrentType',\n (ptype,1))[0]\n \n \n version = _norm_version(version,build)\n \n \n RegCloseKey(keyCurVer)\n return release,version,csd,ptype\n \ndef _mac_ver_lookup(selectors,default=None):\n\n from _gestalt import gestalt\n l = []\n append = l.append\n for selector in selectors:\n  try:\n   append(gestalt(selector))\n  except (RuntimeError, OSError):\n   append(default)\n return l\n \ndef _bcd2str(bcd):\n\n return hex(bcd)[2:]\n \ndef _mac_ver_gestalt():\n \"\"\n \n try:\n  import _gestalt\n except ImportError:\n  return None\n  \n sysv, sysa = _mac_ver_lookup(('sysv','sysa'))\n \n if sysv:\n  major = (sysv & 0xFF00) >> 8\n  minor = (sysv & 0x00F0) >> 4\n  patch = (sysv & 0x000F)\n  \n  if (major, minor) >= (10, 4):\n  \n  \n  \n  \n  \n   major,minor,patch = _mac_ver_lookup(('sys1','sys2','sys3'))\n   release = '%i.%i.%i' %(major, minor, patch)\n  else:\n   release = '%s.%i.%i' % (_bcd2str(major),minor,patch)\n   \n if sysa:\n  machine = {0x1: '68k',\n  0x2: 'PowerPC',\n  0xa: 'i386'}.get(sysa,'')\n  \n versioninfo=('', '', '')\n return release,versioninfo,machine\n \ndef _mac_ver_xml():\n fn = '/System/Library/CoreServices/SystemVersion.plist'\n if not os.path.exists(fn):\n  return None\n  \n try:\n  import plistlib\n except ImportError:\n  return None\n  \n pl = plistlib.readPlist(fn)\n release = pl['ProductVersion']\n versioninfo=('', '', '')\n machine = os.uname().machine\n if machine in ('ppc', 'Power Macintosh'):\n \n  machine = 'PowerPC'\n  \n return release,versioninfo,machine\n \n \ndef mac_ver(release='',versioninfo=('','',''),machine=''):\n\n \"\"\n \n \n \n info = _mac_ver_xml()\n if info is not None:\n  return info\n  \n  \n  \n info = _mac_ver_gestalt()\n if info is not None:\n  return info\n  \n  \n return release,versioninfo,machine\n \ndef _java_getprop(name,default):\n\n from java.lang import System\n try:\n  value = System.getProperty(name)\n  if value is None:\n   return default\n  return value\n except AttributeError:\n  return default\n  \ndef java_ver(release='',vendor='',vminfo=('','',''),osinfo=('','','')):\n\n \"\"\n \n try:\n  import java.lang\n except ImportError:\n  return release,vendor,vminfo,osinfo\n  \n vendor = _java_getprop('java.vendor', vendor)\n release = _java_getprop('java.version', release)\n vm_name, vm_release, vm_vendor = vminfo\n vm_name = _java_getprop('java.vm.name', vm_name)\n vm_vendor = _java_getprop('java.vm.vendor', vm_vendor)\n vm_release = _java_getprop('java.vm.version', vm_release)\n vminfo = vm_name, vm_release, vm_vendor\n os_name, os_version, os_arch = osinfo\n os_arch = _java_getprop('java.os.arch', os_arch)\n os_name = _java_getprop('java.os.name', os_name)\n os_version = _java_getprop('java.os.version', os_version)\n osinfo = os_name, os_version, os_arch\n \n return release, vendor, vminfo, osinfo\n \n \n \ndef system_alias(system,release,version):\n\n \"\"\n if system == 'Rhapsody':\n \n \n  return 'MacOS X Server',system+release,version\n  \n elif system == 'SunOS':\n \n  if release < '5':\n  \n   return system,release,version\n   \n  l = release.split('.')\n  if l:\n   try:\n    major = int(l[0])\n   except ValueError:\n    pass\n   else:\n    major = major - 3\n    l[0] = str(major)\n    release = '.'.join(l)\n  if release < '6':\n   system = 'Solaris'\n  else:\n  \n   system = 'Solaris'\n   \n elif system == 'IRIX64':\n \n \n \n  system = 'IRIX'\n  if version:\n   version = version + ' (64bit)'\n  else:\n   version = '64bit'\n   \n elif system in ('win32','win16'):\n \n  system = 'Windows'\n  \n return system,release,version\n \n \n \ndef _platform(*args):\n\n \"\"\n \n platform = '-'.join(x.strip() for x in filter(len, args))\n \n \n platform = platform.replace(' ','_')\n platform = platform.replace('/','-')\n platform = platform.replace('\\\\','-')\n platform = platform.replace(':','-')\n platform = platform.replace(';','-')\n platform = platform.replace('\"','-')\n platform = platform.replace('(','-')\n platform = platform.replace(')','-')\n \n \n platform = platform.replace('unknown','')\n \n \n while 1:\n  cleaned = platform.replace('--','-')\n  if cleaned == platform:\n   break\n  platform = cleaned\n while platform[-1] == '-':\n  platform = platform[:-1]\n  \n return platform\n \ndef _node(default=''):\n\n \"\"\n try:\n  import socket\n except ImportError:\n \n  return default\n try:\n  return socket.gethostname()\n except socket.error:\n \n  return default\n  \ndef _follow_symlinks(filepath):\n\n \"\"\n filepath = os.path.abspath(filepath)\n while os.path.islink(filepath):\n  filepath = os.path.normpath(\n  os.path.join(os.path.dirname(filepath),os.readlink(filepath)))\n return filepath\n \ndef _syscmd_uname(option,default=''):\n\n \"\"\n if sys.platform in ('dos','win32','win16','os2'):\n \n  return default\n try:\n  f = os.popen('uname %s 2> %s' % (option, DEV_NULL))\n except (AttributeError,os.error):\n  return default\n output = f.read().strip()\n rc = f.close()\n if not output or rc:\n  return default\n else:\n  return output\n  \ndef _syscmd_file(target,default=''):\n\n \"\"\n if sys.platform in ('dos','win32','win16','os2'):\n \n  return default\n target = _follow_symlinks(target)\n try:\n  proc = subprocess.Popen(['file', target],\n  stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n  \n except (AttributeError,os.error):\n  return default\n output = proc.communicate()[0].decode('latin-1')\n rc = proc.wait()\n if not output or rc:\n  return default\n else:\n  return output\n  \n  \n  \n  \n  \n_default_architecture = {\n'win32': ('','WindowsPE'),\n'win16': ('','Windows'),\n'dos': ('','MSDOS'),\n}\n\ndef architecture(executable=sys.executable,bits='',linkage=''):\n\n \"\"\n \n \n if not bits:\n  import struct\n  try:\n   size = struct.calcsize('P')\n  except struct.error:\n  \n   size = struct.calcsize('l')\n  bits = str(size*8) + 'bit'\n  \n  \n if executable:\n  fileout = _syscmd_file(executable, '')\n else:\n  fileout = ''\n  \n if not fileout and executable == sys.executable:\n \n \n  if sys.platform in _default_architecture:\n   b,l = _default_architecture[sys.platform]\n   if b:\n    bits = b\n   if l:\n    linkage = l\n  return bits,linkage\n  \n if 'executable' not in fileout:\n \n  return bits,linkage\n  \n  \n if '32-bit' in fileout:\n  bits = '32bit'\n elif 'N32' in fileout:\n \n  bits = 'n32bit'\n elif '64-bit' in fileout:\n  bits = '64bit'\n  \n  \n if 'ELF' in fileout:\n  linkage = 'ELF'\n elif 'PE' in fileout:\n \n  if 'Windows' in fileout:\n   linkage = 'WindowsPE'\n  else:\n   linkage = 'PE'\n elif 'COFF' in fileout:\n  linkage = 'COFF'\n elif 'MS-DOS' in fileout:\n  linkage = 'MSDOS'\n else:\n \n  pass\n  \n return bits,linkage\n \n \n \nuname_result = collections.namedtuple(\"uname_result\",\n\"system node release version machine processor\")\n\n_uname_cache = None\n\ndef uname():\n\n \"\"\n global _uname_cache\n no_os_uname = 0\n \n if _uname_cache is not None:\n  return _uname_cache\n  \n processor = ''\n \n \n try:\n  system,node,release,version,machine = os.uname()\n except AttributeError:\n  no_os_uname = 1\n  \n if no_os_uname or not list(filter(None, (system, node, release, version, machine))):\n \n \n  if no_os_uname:\n   system = sys.platform\n   release = ''\n   version = ''\n   node = _node()\n   machine = ''\n   \n  use_syscmd_ver = 1\n  \n  \n  if system == 'win32':\n   release,version,csd,ptype = win32_ver()\n   if release and version:\n    use_syscmd_ver = 0\n    \n    \n    \n    \n   if not machine:\n   \n    if \"PROCESSOR_ARCHITEW6432\" in os.environ:\n     machine = os.environ.get(\"PROCESSOR_ARCHITEW6432\", '')\n    else:\n     machine = os.environ.get('PROCESSOR_ARCHITECTURE', '')\n   if not processor:\n    processor = os.environ.get('PROCESSOR_IDENTIFIER', machine)\n    \n    \n    \n  if use_syscmd_ver:\n   system,release,version = _syscmd_ver(system)\n   \n   \n   if system == 'Microsoft Windows':\n    system = 'Windows'\n   elif system == 'Microsoft' and release == 'Windows':\n   \n   \n   \n   \n    system = 'Windows'\n    if '6.0' == version[:3]:\n     release = 'Vista'\n    else:\n     release = ''\n     \n     \n     \n  if system in ('win32','win16'):\n   if not version:\n    if system == 'win32':\n     version = '32bit'\n    else:\n     version = '16bit'\n   system = 'Windows'\n   \n  elif system[:4] == 'java':\n   release,vendor,vminfo,osinfo = java_ver()\n   system = 'Java'\n   version = ', '.join(vminfo)\n   if not version:\n    version = vendor\n    \n    \n if system == 'OpenVMS':\n \n  if not release or release == '0':\n   release = version\n   version = ''\n   \n  try:\n   import vms_lib\n  except ImportError:\n   pass\n  else:\n   csid, cpu_number = vms_lib.getsyi('SYI$_CPU',0)\n   if (cpu_number >= 128):\n    processor = 'Alpha'\n   else:\n    processor = 'VAX'\n if not processor:\n \n  processor = _syscmd_uname('-p','')\n  \n  \n if system == 'unknown':\n  system = ''\n if node == 'unknown':\n  node = ''\n if release == 'unknown':\n  release = ''\n if version == 'unknown':\n  version = ''\n if machine == 'unknown':\n  machine = ''\n if processor == 'unknown':\n  processor = ''\n  \n  \n if system == 'Microsoft' and release == 'Windows':\n  system = 'Windows'\n  release = 'Vista'\n  \n _uname_cache = uname_result(system,node,release,version,machine,processor)\n return _uname_cache\n \n \n \ndef system():\n\n \"\"\n return uname().system\n \ndef node():\n\n \"\"\n return uname().node\n \ndef release():\n\n \"\"\n return uname().release\n \ndef version():\n\n \"\"\n return uname().version\n \ndef machine():\n\n \"\"\n return uname().machine\n \ndef processor():\n\n \"\"\n return uname().processor\n \n \n \n_sys_version_parser = re.compile(\nr'([\\w.+]+)\\s*'\n'\\(#?([^,]+),\\s*([\\w ]+),\\s*([\\w :]+)\\)\\s*'\n'\\[([^\\]]+)\\]?', re.ASCII)\n\n_ironpython_sys_version_parser = re.compile(\nr'IronPython\\s*'\n'([\\d\\.]+)'\n'(?: \\(([\\d\\.]+)\\))?'\n' on (.NET [\\d\\.]+)', re.ASCII)\n\n\n_ironpython26_sys_version_parser = re.compile(\nr'([\\d.]+)\\s*'\n'\\(IronPython\\s*'\n'[\\d.]+\\s*'\n'\\(([\\d.]+)\\) on ([\\w.]+ [\\d.]+(?: \\(\\d+-bit\\))?)\\)'\n)\n\n_pypy_sys_version_parser = re.compile(\nr'([\\w.+]+)\\s*'\n'\\(#?([^,]+),\\s*([\\w ]+),\\s*([\\w :]+)\\)\\s*'\n'\\[PyPy [^\\]]+\\]?')\n\n_sys_version_cache = {}\n\ndef _sys_version(sys_version=None):\n\n \"\"\n \n if sys_version is None:\n  sys_version = sys.version\n  \n  \n result = _sys_version_cache.get(sys_version, None)\n if result is not None:\n  return result\n  \n  \n  \n if 'Brython' in sys_version:\n \n  name = 'Brython'\n  _parser=re.compile(\"^(\\d+\\.\\d+\\.\\d+)[^[]+\\[(.*)\\]\")\n  \n  match=_parser.match(sys_version)\n  \n  if match is None:\n   raise ValueError(\n   'failed to parse Brython sys.version: %s' %\n   repr(sys_version))\n   \n   \n  version, compiler = match.groups()\n  alt_version = ''\n  buildno = ''\n  builddate = ''\n  \n elif 'IronPython' in sys_version:\n \n  name = 'IronPython'\n  if sys_version.startswith('IronPython'):\n   match = _ironpython_sys_version_parser.match(sys_version)\n  else:\n   match = _ironpython26_sys_version_parser.match(sys_version)\n   \n  if match is None:\n   raise ValueError(\n   'failed to parse IronPython sys.version: %s' %\n   repr(sys_version))\n   \n  version, alt_version, compiler = match.groups()\n  buildno = ''\n  builddate = ''\n  \n elif sys.platform.startswith('java'):\n \n  name = 'Jython'\n  match = _sys_version_parser.match(sys_version)\n  if match is None:\n   raise ValueError(\n   'failed to parse Jython sys.version: %s' %\n   repr(sys_version))\n  version, buildno, builddate, buildtime, _ = match.groups()\n  compiler = sys.platform\n  \n elif \"PyPy\" in sys_version:\n \n  name = \"PyPy\"\n  match = _pypy_sys_version_parser.match(sys_version)\n  if match is None:\n   raise ValueError(\"failed to parse PyPy sys.version: %s\" %\n   repr(sys_version))\n  version, buildno, builddate, buildtime = match.groups()\n  compiler = \"\"\n  \n else:\n \n  match = _sys_version_parser.match(sys_version)\n  if match is None:\n   raise ValueError(\n   'failed to parse CPython sys.version: %s' %\n   repr(sys_version))\n  version, buildno, builddate, buildtime, compiler = match.groups()\n  name = 'CPython'\n  builddate = builddate + ' ' + buildtime\n  \n if hasattr(sys, '_mercurial'):\n  _, branch, revision = sys._mercurial\n elif hasattr(sys, 'subversion'):\n \n  _, branch, revision = sys.subversion\n else:\n  branch = ''\n  revision = ''\n  \n  \n l = version.split('.')\n if len(l) == 2:\n  l.append('0')\n  version = '.'.join(l)\n  \n  \n result = (name, version, branch, revision, buildno, builddate, compiler)\n _sys_version_cache[sys_version] = result\n return result\n \ndef python_implementation():\n\n \"\"\n return _sys_version()[0]\n \ndef python_version():\n\n \"\"\n return _sys_version()[1]\n \ndef python_version_tuple():\n\n \"\"\n return tuple(_sys_version()[1].split('.'))\n \ndef python_branch():\n\n \"\"\n \n return _sys_version()[2]\n \ndef python_revision():\n\n \"\"\n return _sys_version()[3]\n \ndef python_build():\n\n \"\"\n return _sys_version()[4:6]\n \ndef python_compiler():\n\n \"\"\n return _sys_version()[6]\n \n \n \n_platform_cache = {}\n\ndef platform(aliased=0, terse=0):\n\n \"\"\n result = _platform_cache.get((aliased, terse), None)\n if result is not None:\n  return result\n  \n  \n  \n system,node,release,version,machine,processor = uname()\n if machine == processor:\n  processor = ''\n if aliased:\n  system,release,version = system_alias(system,release,version)\n  \n if system == 'Windows':\n \n  rel,vers,csd,ptype = win32_ver(version)\n  if terse:\n   platform = _platform(system,release)\n  else:\n   platform = _platform(system,release,version,csd)\n   \n elif system in ('Linux',):\n \n  distname,distversion,distid = dist('')\n  if distname and not terse:\n   platform = _platform(system,release,machine,processor,\n   'with',\n   distname,distversion,distid)\n  else:\n  \n   libcname,libcversion = libc_ver(sys.executable)\n   platform = _platform(system,release,machine,processor,\n   'with',\n   libcname+libcversion)\n elif system == 'Java':\n \n  r,v,vminfo,(os_name,os_version,os_arch) = java_ver()\n  if terse or not os_name:\n   platform = _platform(system,release,version)\n  else:\n   platform = _platform(system,release,version,\n   'on',\n   os_name,os_version,os_arch)\n   \n elif system == 'MacOS':\n \n  if terse:\n   platform = _platform(system,release)\n  else:\n   platform = _platform(system,release,machine)\n   \n else:\n \n  if terse:\n   platform = _platform(system,release)\n  else:\n   bits,linkage = architecture(sys.executable)\n   platform = _platform(system,release,machine,processor,bits,linkage)\n   \n _platform_cache[(aliased, terse)] = platform\n return platform\n \n \n \nif __name__ == '__main__':\n\n terse = ('terse' in sys.argv or '--terse' in sys.argv)\n aliased = (not 'nonaliased' in sys.argv and not '--nonaliased' in sys.argv)\n print(platform(aliased,terse))\n sys.exit(0)\n"], "html": [".py", "\"\"\n\n\n_escape_map = {ord('&'): '&amp;', ord('<'): '&lt;', ord('>'): '&gt;'}\n_escape_map_full = {ord('&'): '&amp;', ord('<'): '&lt;', ord('>'): '&gt;',\nord('\"'): '&quot;', ord('\\''): '&#x27;'}\n\n\n\ndef escape(s, quote=True):\n \"\"\n if quote:\n  return s.translate(_escape_map_full)\n return s.translate(_escape_map)\n", 1], "collections": [".py", "\n\nfrom _collections import deque, defaultdict\n\n\n\n__all__ = ['deque', 'defaultdict', 'namedtuple', 'UserDict', 'UserList',\n'UserString', 'Counter', 'OrderedDict']\n\n\n\n\n\n\nfrom _abcoll import MutableMapping\n\n\n\nfrom collections.abc import *\nimport collections.abc\n__all__ += collections.abc.__all__\n\nfrom _collections import deque, defaultdict, namedtuple\nfrom operator import itemgetter as _itemgetter\nfrom keyword import iskeyword as _iskeyword\nimport sys as _sys\nimport heapq as _heapq\n\n\nfrom itertools import repeat as _repeat, chain as _chain, starmap as _starmap\nfrom reprlib import recursive_repr as _recursive_repr\n\nclass Set(set):\n pass\n \nclass Sequence(list):\n pass\n \ndef _proxy(obj):\n return obj\n \n \n \n \n \nclass _Link(object):\n __slots__ = 'prev', 'next', 'key', '__weakref__'\n \nclass OrderedDict(dict):\n \"\"\n \n \n \n \n \n \n \n \n \n \n \n \n \n def __init__(self, *args, **kwds):\n  \"\"\n  if len(args) > 1:\n   raise TypeError('expected at most 1 arguments, got %d' % len(args))\n  try:\n   self.__root\n  except AttributeError:\n   self.__hardroot = _Link()\n   self.__root = root = _proxy(self.__hardroot)\n   root.prev = root.next = root\n   self.__map = {}\n  self.__update(*args, **kwds)\n  \n def __setitem__(self, key, value,\n dict_setitem=dict.__setitem__, proxy=_proxy, Link=_Link):\n  \"\"\n  \n  \n  if key not in self:\n   self.__map[key] = link = Link()\n   root = self.__root\n   last = root.prev\n   link.prev, link.next, link.key = last, root, key\n   last.next = link\n   root.prev = proxy(link)\n  dict_setitem(self, key, value)\n  \n def __delitem__(self, key, dict_delitem=dict.__delitem__):\n  \"\"\n  \n  \n  dict_delitem(self, key)\n  link = self.__map.pop(key)\n  link_prev = link.prev\n  link_next = link.next\n  link_prev.next = link_next\n  link_next.prev = link_prev\n  \n def __iter__(self):\n  \"\"\n  \n  root = self.__root\n  curr = root.next\n  while curr is not root:\n   yield curr.key\n   curr = curr.next\n   \n def __reversed__(self):\n  \"\"\n  \n  root = self.__root\n  curr = root.prev\n  while curr is not root:\n   yield curr.key\n   curr = curr.prev\n   \n def clear(self):\n  \"\"\n  root = self.__root\n  root.prev = root.next = root\n  self.__map.clear()\n  dict.clear(self)\n  \n def popitem(self, last=True):\n  \"\"\n  if not self:\n   raise KeyError('dictionary is empty')\n  root = self.__root\n  if last:\n   link = root.prev\n   link_prev = link.prev\n   link_prev.next = root\n   root.prev = link_prev\n  else:\n   link = root.next\n   link_next = link.next\n   root.next = link_next\n   link_next.prev = root\n  key = link.key\n  del self.__map[key]\n  value = dict.pop(self, key)\n  return key, value\n  \n def move_to_end(self, key, last=True):\n  \"\"\n  link = self.__map[key]\n  link_prev = link.prev\n  link_next = link.next\n  link_prev.next = link_next\n  link_next.prev = link_prev\n  root = self.__root\n  if last:\n   last = root.prev\n   link.prev = last\n   link.next = root\n   last.next = root.prev = link\n  else:\n   first = root.next\n   link.prev = root\n   link.next = first\n   root.next = first.prev = link\n   \n def __sizeof__(self):\n  sizeof = _sys.getsizeof\n  n = len(self) + 1 \n  size = sizeof(self.__dict__) \n  size += sizeof(self.__map) * 2 \n  size += sizeof(self.__hardroot) * n \n  size += sizeof(self.__root) * n \n  return size\n  \n  \n update = __update = MutableMapping.update\n keys = MutableMapping.keys\n values = MutableMapping.values\n items = MutableMapping.items\n __ne__ = MutableMapping.__ne__\n \n __marker = object()\n \n def pop(self, key, default=__marker):\n  \"\"\n  if key in self:\n   result = self[key]\n   del self[key]\n   return result\n  if default is self.__marker:\n   raise KeyError(key)\n  return default\n  \n def setdefault(self, key, default=None):\n  \"\"\n  if key in self:\n   return self[key]\n  self[key] = default\n  return default\n  \n  \n  \n def __repr__(self):\n  \"\"\n  if not self:\n   return '%s()' % (self.__class__.__name__,)\n  return '%s(%r)' % (self.__class__.__name__, list(self.items()))\n  \n def __reduce__(self):\n  \"\"\n  items = [[k, self[k]] for k in self]\n  inst_dict = vars(self).copy()\n  for k in vars(OrderedDict()):\n   inst_dict.pop(k, None)\n  if inst_dict:\n   return (self.__class__, (items,), inst_dict)\n  return self.__class__, (items,)\n  \n def copy(self):\n  \"\"\n  return self.__class__(self)\n  \n @classmethod\n def fromkeys(cls, iterable, value=None):\n  \"\"\n  self = cls()\n  for key in iterable:\n   self[key] = value\n  return self\n  \n def __eq__(self, other):\n  \"\"\n  if isinstance(other, OrderedDict):\n   return len(self)==len(other) and all(p==q for p, q in zip(self.items(), other.items()))\n  return dict.__eq__(self, other)\n  \n  \n  \n  \n  \n  \n  \ndef _count_elements(mapping, iterable):\n \"\"\n mapping_get = mapping.get\n for elem in iterable:\n  mapping[elem] = mapping_get(elem, 0) + 1\n  \n  \n  \n  \n  \n  \nclass Counter(dict):\n \"\"\n \n \n \n \n \n \n \n def __init__(self, iterable=None, **kwds):\n  \"\"\n  \n  dict.__init__(self)\n  self.update(iterable, **kwds)\n  \n def __missing__(self, key):\n  \"\"\n  \n  return 0\n  \n def most_common(self, n=None):\n  \"\"\n  \n  if n is None:\n   return sorted(self.items(), key=_itemgetter(1), reverse=True)\n  return _heapq.nlargest(n, self.items(), key=_itemgetter(1))\n  \n def elements(self):\n  \"\"\n  \n  return _chain.from_iterable(_starmap(_repeat, self.items()))\n  \n  \n  \n @classmethod\n def fromkeys(cls, iterable, v=None):\n \n \n  raise NotImplementedError(\n  'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')\n  \n def update(self, iterable=None, **kwds):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  if iterable is not None:\n   if isinstance(iterable, Mapping):\n    if self:\n     self_get = self.get\n     for elem, count in iterable.items():\n      self[elem] = count + self_get(elem, 0)\n    else:\n     super().update(iterable) \n   else:\n    _count_elements(self, iterable)\n  if kwds:\n   self.update(kwds)\n   \n def subtract(self, iterable=None, **kwds):\n  \"\"\n  if iterable is not None:\n   self_get = self.get\n   if isinstance(iterable, Mapping):\n    for elem, count in iterable.items():\n     self[elem] = self_get(elem, 0) - count\n   else:\n    for elem in iterable:\n     self[elem] = self_get(elem, 0) - 1\n  if kwds:\n   self.subtract(kwds)\n   \n def copy(self):\n  \"\"\n  return self.__class__(self)\n  \n def __reduce__(self):\n  return self.__class__, (dict(self),)\n  \n def __delitem__(self, elem):\n  \"\"\n  if elem in self:\n   super().__delitem__(elem)\n   \n def __repr__(self):\n  if not self:\n   return '%s()' % self.__class__.__name__\n  try:\n   items = ', '.join(map('%r: %r'.__mod__, self.most_common()))\n   return '%s({%s})' % (self.__class__.__name__, items)\n  except TypeError:\n  \n   return '{0}({1!r})'.format(self.__class__.__name__, dict(self))\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def __add__(self, other):\n  \"\"\n  if not isinstance(other, Counter):\n   return NotImplemented\n  result = Counter()\n  for elem, count in self.items():\n   newcount = count + other[elem]\n   if newcount > 0:\n    result[elem] = newcount\n  for elem, count in other.items():\n   if elem not in self and count > 0:\n    result[elem] = count\n  return result\n  \n def __sub__(self, other):\n  \"\"\n  if not isinstance(other, Counter):\n   return NotImplemented\n  result = Counter()\n  for elem, count in self.items():\n   newcount = count - other[elem]\n   if newcount > 0:\n    result[elem] = newcount\n  for elem, count in other.items():\n   if elem not in self and count < 0:\n    result[elem] = 0 - count\n  return result\n  \n def __or__(self, other):\n  \"\"\n  if not isinstance(other, Counter):\n   return NotImplemented\n  result = Counter()\n  for elem, count in self.items():\n   other_count = other[elem]\n   newcount = other_count if count < other_count else count\n   if newcount > 0:\n    result[elem] = newcount\n  for elem, count in other.items():\n   if elem not in self and count > 0:\n    result[elem] = count\n  return result\n  \n def __and__(self, other):\n  \"\"\n  if not isinstance(other, Counter):\n   return NotImplemented\n  result = Counter()\n  for elem, count in self.items():\n   other_count = other[elem]\n   newcount = count if count < other_count else other_count\n   if newcount > 0:\n    result[elem] = newcount\n  return result\n  \n  \n  \n  \n  \n  \nclass ChainMap(MutableMapping):\n \"\"\n \n def __init__(self, *maps):\n  \"\"\n  self.maps = list(maps) or [{}] \n  \n def __missing__(self, key):\n  raise KeyError(key)\n  \n def __getitem__(self, key):\n  for mapping in self.maps:\n   try:\n    return mapping[key] \n   except KeyError:\n    pass\n  return self.__missing__(key) \n  \n def get(self, key, default=None):\n  return self[key] if key in self else default\n  \n def __len__(self):\n  return len(set().union(*self.maps)) \n  \n def __iter__(self):\n  return iter(set().union(*self.maps))\n  \n def __contains__(self, key):\n  return any(key in m for m in self.maps)\n  \n def __bool__(self):\n  return any(self.maps)\n  \n  \n  \n def __repr__(self):\n  return '{0.__class__.__name__}({1})'.format(\n  self, ', '.join(map(repr, self.maps)))\n  \n def __repr__(self):\n  return ','.join(str(_map) for _map in self.maps)\n  \n @classmethod\n def fromkeys(cls, iterable, *args):\n  \"\"\n  return cls(dict.fromkeys(iterable, *args))\n  \n def copy(self):\n  \"\"\n  return self.__class__(self.maps[0].copy(), *self.maps[1:])\n  \n __copy__ = copy\n \n def new_child(self): \n  \"\"\n  return self.__class__({}, *self.maps)\n  \n @property\n def parents(self): \n  \"\"\n  return self.__class__(*self.maps[1:])\n  \n def __setitem__(self, key, value):\n  self.maps[0][key] = value\n  \n def __delitem__(self, key):\n  try:\n   del self.maps[0][key]\n  except KeyError:\n   raise KeyError('Key not found in the first mapping: {!r}'.format(key))\n   \n def popitem(self):\n  \"\"\n  try:\n   return self.maps[0].popitem()\n  except KeyError:\n   raise KeyError('No keys found in the first mapping.')\n   \n def pop(self, key, *args):\n  \"\"\n  try:\n   return self.maps[0].pop(key, *args)\n  except KeyError:\n  \n   raise KeyError('Key not found in the first mapping: %s' % key)\n   \n def clear(self):\n  \"\"\n  self.maps[0].clear()\n  \n  \n  \n  \n  \n  \nclass UserDict(MutableMapping):\n\n\n def __init__(self, dict=None, **kwargs):\n  self.data = {}\n  if dict is not None:\n   self.update(dict)\n  if len(kwargs):\n   self.update(kwargs)\n def __len__(self): return len(self.data)\n def __getitem__(self, key):\n  if key in self.data:\n   return self.data[key]\n  if hasattr(self.__class__, \"__missing__\"):\n   return self.__class__.__missing__(self, key)\n  raise KeyError(key)\n def __setitem__(self, key, item): self.data[key] = item\n def __delitem__(self, key): del self.data[key]\n def __iter__(self):\n  return iter(self.data)\n  \n  \n def __contains__(self, key):\n  return key in self.data\n  \n  \n def __repr__(self): return repr(self.data)\n def copy(self):\n  if self.__class__ is UserDict:\n   return UserDict(self.data.copy())\n  import copy\n  data = self.data\n  try:\n   self.data = {}\n   c = copy.copy(self)\n  finally:\n   self.data = data\n  c.update(self)\n  return c\n @classmethod\n def fromkeys(cls, iterable, value=None):\n  d = cls()\n  for key in iterable:\n   d[key] = value\n  return d\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n", 1], "browser.html": [".py", "from _html import *"], "ui.progressbar": [".py", "from . import widget\nfrom browser import html\n\nclass ProgressBar(widget.Widget):\n def __init__(self, id=None, label=False):\n  self._div_shell=html.DIV(Class=\"ui-progressbar ui-widget ui-widget-content ui-corner-all\")\n  widget.Widget.__init__(self, self._div_shell, 'progressbar', id)\n  \n  self._show_label=label\n  if label:\n   self._label=html.DIV(Class='progress-label')\n   self._div_shell <= self._label\n   \n  self._bar=html.DIV(Class=\"ui-progressbar-value ui-widget-header ui-corner-left\",\n  style={'width': '0px'})\n  self._div_shell <= self._bar\n  \n def set_progress(self, percent):\n  self._bar.style.width='%s%%' % percent\n  if self._show_label:\n   self._label.text='%s%%' % percent\n"], "xml.etree.cElementTree": [".py", "\n\nfrom xml.etree.ElementTree import *\n"], "browser.object_storage": [".py", "import pickle\n\nclass __UnProvided():\n pass\n \n \nclass ObjectStorage():\n\n def __init__(self, storage):\n  self.storage = storage\n  \n def __delitem__(self, key):\n  del self.storage[pickle.dumps(key)]\n  \n def __getitem__(self, key):\n  return pickle.loads(self.storage[pickle.dumps(key)])\n  \n def __setitem__(self, key, value):\n  self.storage[pickle.dumps(key)] = pickle.dumps(value)\n  \n def __contains__(self, key):\n  return pickle.dumps(key) in self.storage\n  \n def get(self, key, default=None):\n  if pickle.dumps(key) in self.storage:\n   return self.storage[pickle.dumps(key)]\n  return default\n  \n def pop(self, key, default=__UnProvided()):\n  if type(default) is __UnProvided or pickle.dumps(key) in self.storage:\n   return pickle.loads(self.storage.pop(pickle.dumps(key)))\n  return default\n  \n def __iter__(self):\n  keys = self.keys()\n  return keys.__iter__()\n  \n def keys(self):\n  return [pickle.loads(key) for key in self.storage.keys()]\n  \n def values(self):\n  return [pickle.loads(val) for val in self.storage.values()]\n  \n def items(self):\n  return list(zip(self.keys(), self.values()))\n  \n def clear(self):\n  self.storage.clear()\n  \n def __len__(self):\n  return len(self.storage)\n"], "string": [".py", "\"\"\n\nimport _string\n\n\nwhitespace = ' \\t\\n\\r\\v\\f'\nascii_lowercase = 'abcdefghijklmnopqrstuvwxyz'\nascii_uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nascii_letters = ascii_lowercase + ascii_uppercase\ndigits = '0123456789'\nhexdigits = digits + 'abcdef' + 'ABCDEF'\noctdigits = '01234567'\npunctuation = \"\"\"!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\"\"\"\nprintable = digits + ascii_letters + punctuation + whitespace\n\n\n\n\ndef capwords(s, sep=None):\n \"\"\n return (sep or ' ').join(x.capitalize() for x in s.split(sep))\n \n \n \nimport re as _re\nfrom collections import ChainMap\n\nclass _TemplateMetaclass(type):\n pattern = r\"\"\"\n    %(delim)s(?:\n      (?P<escaped>%(delim)s) |   # Escape sequence of two delimiters\n      (?P<named>%(id)s)      |   # delimiter and a Python identifier\n      {(?P<braced>%(id)s)}   |   # delimiter and a braced identifier\n      (?P<invalid>)              # Other ill-formed delimiter exprs\n    )\n    \"\"\" \n \n def __init__(cls, name, bases, dct):\n  super(_TemplateMetaclass, cls).__init__(name, bases, dct)\n  if 'pattern' in dct:\n   pattern = cls.pattern\n  else:\n   pattern = _TemplateMetaclass.pattern % {\n   'delim' : _re.escape(cls.delimiter),\n   'id' : cls.idpattern,\n   }\n  cls.pattern = _re.compile(pattern, cls.flags | _re.VERBOSE)\n  \n  \nclass Template(metaclass=_TemplateMetaclass):\n \"\"\n \n delimiter = '$'\n idpattern = r'[_a-z][_a-z0-9]*'\n flags = _re.IGNORECASE\n \n def __init__(self, template):\n  self.template = template\n  \n  \n  \n def _invalid(self, mo):\n  i = mo.start('invalid')\n  lines = self.template[:i].splitlines(keepends=True)\n  if not lines:\n   colno = 1\n   lineno = 1\n  else:\n   colno = i - len(''.join(lines[:-1]))\n   lineno = len(lines)\n  raise ValueError('Invalid placeholder in string: line %d, col %d' %\n  (lineno, colno))\n  \n def substitute(self, *args, **kws):\n  if len(args) > 1:\n   raise TypeError('Too many positional arguments')\n  if not args:\n   mapping = kws\n  elif kws:\n   mapping = ChainMap(kws, args[0])\n  else:\n   mapping = args[0]\n   \n  def convert(mo):\n  \n   named = mo.group('named') or mo.group('braced')\n   if named is not None:\n    val = mapping[named]\n    \n    \n    return '%s' % (val,)\n   if mo.group('escaped') is not None:\n    return self.delimiter\n   if mo.group('invalid') is not None:\n    self._invalid(mo)\n   raise ValueError('Unrecognized named group in pattern',\n   self.pattern)\n  return self.pattern.sub(convert, self.template)\n  \n def safe_substitute(self, *args, **kws):\n  if len(args) > 1:\n   raise TypeError('Too many positional arguments')\n  if not args:\n   mapping = kws\n  elif kws:\n   mapping = ChainMap(kws, args[0])\n  else:\n   mapping = args[0]\n   \n  def convert(mo):\n   named = mo.group('named') or mo.group('braced')\n   if named is not None:\n    try:\n    \n    \n     return '%s' % (mapping[named],)\n    except KeyError:\n     return mo.group()\n   if mo.group('escaped') is not None:\n    return self.delimiter\n   if mo.group('invalid') is not None:\n    return mo.group()\n   raise ValueError('Unrecognized named group in pattern',\n   self.pattern)\n  return self.pattern.sub(convert, self.template)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass Formatter:\n def format(self, format_string, *args, **kwargs):\n  return self.vformat(format_string, args, kwargs)\n  \n def vformat(self, format_string, args, kwargs):\n  used_args = set()\n  result = self._vformat(format_string, args, kwargs, used_args, 2)\n  self.check_unused_args(used_args, args, kwargs)\n  return result\n  \n def _vformat(self, format_string, args, kwargs, used_args, recursion_depth):\n  if recursion_depth < 0:\n   raise ValueError('Max string recursion exceeded')\n  result = []\n  for literal_text, field_name, format_spec, conversion in self.parse(format_string):\n  \n  \n   if literal_text:\n    result.append(literal_text)\n    \n    \n   if field_name is not None:\n   \n   \n   \n   \n   \n    obj, arg_used = self.get_field(field_name, args, kwargs)\n    used_args.add(arg_used)\n    \n    \n    obj = self.convert_field(obj, conversion)\n    \n    \n    format_spec = self._vformat(format_spec, args, kwargs,\n    used_args, recursion_depth-1)\n    \n    \n    result.append(self.format_field(obj, format_spec))\n    \n  return ''.join(result)\n  \n  \n def get_value(self, key, args, kwargs):\n  if isinstance(key, int):\n   return args[key]\n  else:\n   return kwargs[key]\n   \n   \n def check_unused_args(self, used_args, args, kwargs):\n  pass\n  \n  \n def format_field(self, value, format_spec):\n  return format(value, format_spec)\n  \n  \n def convert_field(self, value, conversion):\n \n  if conversion is None:\n   return value\n  elif conversion == 's':\n   return str(value)\n  elif conversion == 'r':\n   return repr(value)\n  elif conversion == 'a':\n   return ascii(value)\n  raise ValueError(\"Unknown conversion specifier {0!s}\".format(conversion))\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def parse(self, format_string):\n  return _string.formatter_parser(format_string)\n  \n  \n  \n  \n  \n  \n  \n def get_field(self, field_name, args, kwargs):\n  first, rest = _string.formatter_field_name_split(field_name)\n  \n  obj = self.get_value(first, args, kwargs)\n  \n  \n  \n  for is_attr, i in rest:\n   if is_attr:\n    obj = getattr(obj, i)\n   else:\n    obj = obj[i]\n    \n  return obj, first\n"], "browser.local_storage": [".py", "\nimport sys\nfrom javascript import JSObject\n\nclass __UnProvided():\n pass\n \nclass LocalStorage():\n storage_type = \"local_storage\"\n \n def __init__(self):\n  if not sys.has_local_storage:\n   raise EnvironmentError(\"LocalStorage not available\")\n  self.store = JSObject(__BRYTHON__.local_storage)\n  \n def __delitem__(self, key):\n  if (not isinstance(key, str)):\n   raise TypeError(\"key must be string\")\n  if key not in self:\n   raise KeyError(key)\n  self.store.removeItem(key)\n  \n def __getitem__(self, key):\n  if (not isinstance(key, str)):\n   raise TypeError(\"key must be string\")\n  res = __BRYTHON__.JSObject(self.store.getItem(key))\n  if res:\n   return res\n  raise KeyError(key)\n  \n def __setitem__(self, key, value):\n  if (not isinstance(key, str)):\n   raise TypeError(\"key must be string\")\n  if (not isinstance(value, str)):\n   raise TypeError(\"value must be string\")\n  self.store.setItem(key, value)\n  \n  \n def __contains__(self, key):\n  if (not isinstance(key, str)):\n   raise TypeError(\"key must be string\")\n  res = __BRYTHON__.JSObject(self.store.getItem(key))\n  if res is None:\n   return False\n  return True\n  \n def __iter__(self):\n  keys = self.keys()\n  return keys.__iter__()\n  \n def get(self, key, default=None):\n  if (not isinstance(key, str)):\n   raise TypeError(\"key must be string\")\n  return __BRYTHON__.JSObject(self.store.getItem(key)) or default\n  \n def pop(self, key, default=__UnProvided()):\n  if (not isinstance(key, str)):\n   raise TypeError(\"key must be string\")\n  if type(default) is __UnProvided:\n   ret = self.get(key)\n   del self[key] \n   return ret\n  else:\n   if key in self:\n    ret = self.get(key)\n    del self[key]\n    return ret\n   else:\n    return default\n    \n    \n    \n def keys(self):\n  return [__BRYTHON__.JSObject(self.store.key(i)) for i in range(self.store.length)]\n  \n def values(self):\n  return [__BRYTHON__.JSObject(self.__getitem__(k)) for k in self.keys()]\n  \n def items(self):\n  return list(zip(self.keys(), self.values()))\n  \n def clear(self):\n  self.store.clear()\n  \n def __len__(self):\n  return self.store.length\n  \nif sys.has_local_storage:\n storage = LocalStorage()\n"], "multiprocessing.dummy": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__ = [\n'Process', 'current_process', 'active_children', 'freeze_support',\n'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Condition',\n'Event', 'Barrier', 'Queue', 'Manager', 'Pipe', 'Pool', 'JoinableQueue'\n]\n\n\n\n\n\nimport threading\nimport sys\nimport weakref\n\n\n\nfrom multiprocessing.dummy.connection import Pipe\nfrom threading import Lock, RLock, Semaphore, BoundedSemaphore\nfrom threading import Event, Condition, Barrier\nfrom queue import Queue\n\n\n\n\n\nclass DummyProcess(threading.Thread):\n\n def __init__(self, group=None, target=None, name=None, args=(), kwargs={}):\n  threading.Thread.__init__(self, group, target, name, args, kwargs)\n  self._pid = None\n  self._children = weakref.WeakKeyDictionary()\n  self._start_called = False\n  self._parent = current_process()\n  \n def start(self):\n  assert self._parent is current_process()\n  self._start_called = True\n  if hasattr(self._parent, '_children'):\n   self._parent._children[self] = None\n  threading.Thread.start(self)\n  \n @property\n def exitcode(self):\n  if self._start_called and not self.is_alive():\n   return 0\n  else:\n   return None\n   \n   \n   \n   \n   \nProcess = DummyProcess\ncurrent_process = threading.current_thread\ncurrent_process()._children = weakref.WeakKeyDictionary()\n\ndef active_children():\n children = current_process()._children\n for p in list(children):\n  if not p.is_alive():\n   children.pop(p, None)\n return list(children)\n \ndef freeze_support():\n pass\n \n \n \n \n \nclass Namespace(object):\n def __init__(self, **kwds):\n  self.__dict__.update(kwds)\n def __repr__(self):\n  items = list(self.__dict__.items())\n  temp = []\n  for name, value in items:\n   if not name.startswith('_'):\n    temp.append('%s=%r' % (name, value))\n  temp.sort()\n  return 'Namespace(%s)' % str.join(', ', temp)\n  \ndict = dict\nlist = list\n\n\n\n\n\nclass Value(object):\n def __init__(self, typecode, value, lock=True):\n  self._typecode = typecode\n  self._value = value\n def _get(self):\n  return self._value\n def _set(self, value):\n  self._value = value\n value = property(_get, _set)\n def __repr__(self):\n  return '<%r(%r, %r)>'%(type(self).__name__,self._typecode,self._value)\n  \ndef Manager():\n return sys.modules[__name__]\n \ndef shutdown():\n pass\n \ndef Pool(processes=None, initializer=None, initargs=()):\n from multiprocessing.pool import ThreadPool\n return ThreadPool(processes, initializer, initargs)\n \nJoinableQueue = Queue\n", 1], "site-packages.pygame.mouse": [".py", "from browser import document \nfrom javascript import console\n\n_mouse_x, _mouse_y=0,0\n\n_canvas=None\n\ndef _getMousePosition(e):\n global _mouse_x, _mouse_y, _canvas\n _rect=_canvas.getBoundingCientRRect()\n _mouse_x=e.clientX - _rect.left\n _mouse_y=e.clientY - _rect.top\n \ndef get_pos():\n global _canvas\n if _canvas is None:\n  _c=document.get(selector='canvas')\n  if len(_c) > 0:\n   _canvas=_c[0]\n   console.log(_canvas.id)\n   _canvas.mousemove=_getMousePosition\n   \n return _mouse_x, _mouse_y\n"], "zipfile": [".py", "\"\"\nimport io\nimport os\nimport re\nimport imp\nimport sys\nimport time\nimport stat\nimport shutil\nimport struct\nimport binascii\n\n\ntry:\n import zlib \n crc32 = zlib.crc32\nexcept ImportError:\n zlib = None\n crc32 = binascii.crc32\n \ntry:\n import bz2 \nexcept ImportError:\n bz2 = None\n \ntry:\n import lzma \nexcept ImportError:\n lzma = None\n \n__all__ = [\"BadZipFile\", \"BadZipfile\", \"error\",\n\"ZIP_STORED\", \"ZIP_DEFLATED\", \"ZIP_BZIP2\", \"ZIP_LZMA\",\n\"is_zipfile\", \"ZipInfo\", \"ZipFile\", \"PyZipFile\", \"LargeZipFile\"]\n\nclass BadZipFile(Exception):\n pass\n \n \nclass LargeZipFile(Exception):\n \"\"\n \nerror = BadZipfile = BadZipFile \n\n\nZIP64_LIMIT = (1 << 31) - 1\nZIP_FILECOUNT_LIMIT = 1 << 16\nZIP_MAX_COMMENT = (1 << 16) - 1\n\n\nZIP_STORED = 0\nZIP_DEFLATED = 8\nZIP_BZIP2 = 12\nZIP_LZMA = 14\n\n\nDEFAULT_VERSION = 20\nZIP64_VERSION = 45\nBZIP2_VERSION = 46\nLZMA_VERSION = 63\n\nMAX_EXTRACT_VERSION = 63\n\n\n\n\n\n\n\n\n\nstructEndArchive = b\"<4s4H2LH\"\nstringEndArchive = b\"PK\\005\\006\"\nsizeEndCentDir = struct.calcsize(structEndArchive)\n\n_ECD_SIGNATURE = 0\n_ECD_DISK_NUMBER = 1\n_ECD_DISK_START = 2\n_ECD_ENTRIES_THIS_DISK = 3\n_ECD_ENTRIES_TOTAL = 4\n_ECD_SIZE = 5\n_ECD_OFFSET = 6\n_ECD_COMMENT_SIZE = 7\n\n\n_ECD_COMMENT = 8\n_ECD_LOCATION = 9\n\n\n\nstructCentralDir = \"<4s4B4HL2L5H2L\"\nstringCentralDir = b\"PK\\001\\002\"\nsizeCentralDir = struct.calcsize(structCentralDir)\n\n\n_CD_SIGNATURE = 0\n_CD_CREATE_VERSION = 1\n_CD_CREATE_SYSTEM = 2\n_CD_EXTRACT_VERSION = 3\n_CD_EXTRACT_SYSTEM = 4\n_CD_FLAG_BITS = 5\n_CD_COMPRESS_TYPE = 6\n_CD_TIME = 7\n_CD_DATE = 8\n_CD_CRC = 9\n_CD_COMPRESSED_SIZE = 10\n_CD_UNCOMPRESSED_SIZE = 11\n_CD_FILENAME_LENGTH = 12\n_CD_EXTRA_FIELD_LENGTH = 13\n_CD_COMMENT_LENGTH = 14\n_CD_DISK_NUMBER_START = 15\n_CD_INTERNAL_FILE_ATTRIBUTES = 16\n_CD_EXTERNAL_FILE_ATTRIBUTES = 17\n_CD_LOCAL_HEADER_OFFSET = 18\n\n\n\nstructFileHeader = \"<4s2B4HL2L2H\"\nstringFileHeader = b\"PK\\003\\004\"\nsizeFileHeader = struct.calcsize(structFileHeader)\n\n_FH_SIGNATURE = 0\n_FH_EXTRACT_VERSION = 1\n_FH_EXTRACT_SYSTEM = 2\n_FH_GENERAL_PURPOSE_FLAG_BITS = 3\n_FH_COMPRESSION_METHOD = 4\n_FH_LAST_MOD_TIME = 5\n_FH_LAST_MOD_DATE = 6\n_FH_CRC = 7\n_FH_COMPRESSED_SIZE = 8\n_FH_UNCOMPRESSED_SIZE = 9\n_FH_FILENAME_LENGTH = 10\n_FH_EXTRA_FIELD_LENGTH = 11\n\n\nstructEndArchive64Locator = \"<4sLQL\"\nstringEndArchive64Locator = b\"PK\\x06\\x07\"\nsizeEndCentDir64Locator = struct.calcsize(structEndArchive64Locator)\n\n\n\nstructEndArchive64 = \"<4sQ2H2L4Q\"\nstringEndArchive64 = b\"PK\\x06\\x06\"\nsizeEndCentDir64 = struct.calcsize(structEndArchive64)\n\n_CD64_SIGNATURE = 0\n_CD64_DIRECTORY_RECSIZE = 1\n_CD64_CREATE_VERSION = 2\n_CD64_EXTRACT_VERSION = 3\n_CD64_DISK_NUMBER = 4\n_CD64_DISK_NUMBER_START = 5\n_CD64_NUMBER_ENTRIES_THIS_DISK = 6\n_CD64_NUMBER_ENTRIES_TOTAL = 7\n_CD64_DIRECTORY_SIZE = 8\n_CD64_OFFSET_START_CENTDIR = 9\n\ndef _check_zipfile(fp):\n try:\n  if _EndRecData(fp):\n   return True \n except IOError:\n  pass\n return False\n \ndef is_zipfile(filename):\n \"\"\n result = False\n try:\n  if hasattr(filename, \"read\"):\n   result = _check_zipfile(fp=filename)\n  else:\n   with open(filename, \"rb\") as fp:\n    result = _check_zipfile(fp)\n except IOError:\n  pass\n return result\n \ndef _EndRecData64(fpin, offset, endrec):\n \"\"\n try:\n  fpin.seek(offset - sizeEndCentDir64Locator, 2)\n except IOError:\n \n \n  return endrec\n  \n data = fpin.read(sizeEndCentDir64Locator)\n if len(data) != sizeEndCentDir64Locator:\n  return endrec\n sig, diskno, reloff, disks = struct.unpack(structEndArchive64Locator, data)\n if sig != stringEndArchive64Locator:\n  return endrec\n  \n if diskno != 0 or disks != 1:\n  raise BadZipFile(\"zipfiles that span multiple disks are not supported\")\n  \n  \n fpin.seek(offset - sizeEndCentDir64Locator - sizeEndCentDir64, 2)\n data = fpin.read(sizeEndCentDir64)\n if len(data) != sizeEndCentDir64:\n  return endrec\n sig, sz, create_version, read_version, disk_num, disk_dir, dircount, dircount2, dirsize, diroffset = struct.unpack(structEndArchive64, data)\n if sig != stringEndArchive64:\n  return endrec\n  \n  \n endrec[_ECD_SIGNATURE] = sig\n endrec[_ECD_DISK_NUMBER] = disk_num\n endrec[_ECD_DISK_START] = disk_dir\n endrec[_ECD_ENTRIES_THIS_DISK] = dircount\n endrec[_ECD_ENTRIES_TOTAL] = dircount2\n endrec[_ECD_SIZE] = dirsize\n endrec[_ECD_OFFSET] = diroffset\n return endrec\n \n \ndef _EndRecData(fpin):\n \"\"\n \n \n fpin.seek(0, 2)\n filesize = fpin.tell()\n \n \n \n \n try:\n  fpin.seek(-sizeEndCentDir, 2)\n except IOError:\n  return None\n data = fpin.read()\n if (len(data) == sizeEndCentDir and\n data[0:4] == stringEndArchive and\n data[-2:] == b\"\\000\\000\"):\n \n  endrec = struct.unpack(structEndArchive, data)\n  endrec=list(endrec)\n  \n  \n  endrec.append(b\"\")\n  endrec.append(filesize - sizeEndCentDir)\n  \n  \n  return _EndRecData64(fpin, -sizeEndCentDir, endrec)\n  \n  \n  \n  \n  \n  \n maxCommentStart = max(filesize - (1 << 16) - sizeEndCentDir, 0)\n fpin.seek(maxCommentStart, 0)\n data = fpin.read()\n start = data.rfind(stringEndArchive)\n if start >= 0:\n \n  recData = data[start:start+sizeEndCentDir]\n  if len(recData) != sizeEndCentDir:\n  \n   return None\n  endrec = list(struct.unpack(structEndArchive, recData))\n  commentSize = endrec[_ECD_COMMENT_SIZE] \n  comment = data[start+sizeEndCentDir:start+sizeEndCentDir+commentSize]\n  endrec.append(comment)\n  endrec.append(maxCommentStart + start)\n  \n  \n  return _EndRecData64(fpin, maxCommentStart + start - filesize,\n  endrec)\n  \n  \n return None\n \n \nclass ZipInfo (object):\n \"\"\n \n __slots__ = (\n 'orig_filename',\n 'filename',\n 'date_time',\n 'compress_type',\n 'comment',\n 'extra',\n 'create_system',\n 'create_version',\n 'extract_version',\n 'reserved',\n 'flag_bits',\n 'volume',\n 'internal_attr',\n 'external_attr',\n 'header_offset',\n 'CRC',\n 'compress_size',\n 'file_size',\n '_raw_time',\n )\n \n def __init__(self, filename=\"NoName\", date_time=(1980,1,1,0,0,0)):\n  self.orig_filename = filename \n  \n  \n  \n  null_byte = filename.find(chr(0))\n  if null_byte >= 0:\n   filename = filename[0:null_byte]\n   \n   \n   \n  if os.sep != \"/\" and os.sep in filename:\n   filename = filename.replace(os.sep, \"/\")\n   \n  self.filename = filename \n  self.date_time = date_time \n  \n  if date_time[0] < 1980:\n   raise ValueError('ZIP does not support timestamps before 1980')\n   \n   \n  self.compress_type = ZIP_STORED \n  self.comment = b\"\" \n  self.extra = b\"\" \n  if sys.platform == 'win32':\n   self.create_system = 0 \n  else:\n  \n   self.create_system = 3 \n  self.create_version = DEFAULT_VERSION \n  self.extract_version = DEFAULT_VERSION \n  self.reserved = 0 \n  self.flag_bits = 0 \n  self.volume = 0 \n  self.internal_attr = 0 \n  self.external_attr = 0 \n  \n  \n  \n  \n  \n  \n def FileHeader(self, zip64=None):\n  \"\"\n  dt = self.date_time\n  dosdate = (dt[0] - 1980) << 9 | dt[1] << 5 | dt[2]\n  dostime = dt[3] << 11 | dt[4] << 5 | (dt[5] // 2)\n  if self.flag_bits & 0x08:\n  \n   CRC = compress_size = file_size = 0\n  else:\n   CRC = self.CRC\n   compress_size = self.compress_size\n   file_size = self.file_size\n   \n  extra = self.extra\n  \n  min_version = 0\n  if zip64 is None:\n   zip64 = file_size > ZIP64_LIMIT or compress_size > ZIP64_LIMIT\n  if zip64:\n   fmt = '<HHQQ'\n   extra = extra + struct.pack(fmt,\n   1, struct.calcsize(fmt)-4, file_size, compress_size)\n  if file_size > ZIP64_LIMIT or compress_size > ZIP64_LIMIT:\n   if not zip64:\n    raise LargeZipFile(\"Filesize would require ZIP64 extensions\")\n    \n    \n   file_size = 0xffffffff\n   compress_size = 0xffffffff\n   min_version = ZIP64_VERSION\n   \n  if self.compress_type == ZIP_BZIP2:\n   min_version = max(BZIP2_VERSION, min_version)\n  elif self.compress_type == ZIP_LZMA:\n   min_version = max(LZMA_VERSION, min_version)\n   \n  self.extract_version = max(min_version, self.extract_version)\n  self.create_version = max(min_version, self.create_version)\n  filename, flag_bits = self._encodeFilenameFlags()\n  header = struct.pack(structFileHeader, stringFileHeader,\n  self.extract_version, self.reserved, flag_bits,\n  self.compress_type, dostime, dosdate, CRC,\n  compress_size, file_size,\n  len(filename), len(extra))\n  return header + filename + extra\n  \n def _encodeFilenameFlags(self):\n  try:\n   return self.filename.encode('ascii'), self.flag_bits\n  except UnicodeEncodeError:\n   return self.filename.encode('utf-8'), self.flag_bits | 0x800\n   \n def _decodeExtra(self):\n \n  extra = self.extra\n  unpack = struct.unpack\n  while extra:\n   tp, ln = unpack('<HH', extra[:4])\n   if tp == 1:\n    if ln >= 24:\n     counts = unpack('<QQQ', extra[4:28])\n    elif ln == 16:\n     counts = unpack('<QQ', extra[4:20])\n    elif ln == 8:\n     counts = unpack('<Q', extra[4:12])\n    elif ln == 0:\n     counts = ()\n    else:\n     raise RuntimeError(\"Corrupt extra field %s\"%(ln,))\n     \n    idx = 0\n    \n    \n    if self.file_size in (0xffffffffffffffff, 0xffffffff):\n     self.file_size = counts[idx]\n     idx += 1\n     \n    if self.compress_size == 0xFFFFFFFF:\n     self.compress_size = counts[idx]\n     idx += 1\n     \n    if self.header_offset == 0xffffffff:\n     old = self.header_offset\n     self.header_offset = counts[idx]\n     idx+=1\n     \n   extra = extra[ln+4:]\n   \n   \nclass _ZipDecrypter:\n \"\"\n \n def _GenerateCRCTable():\n  \"\"\n  poly = 0xedb88320\n  table = [0] * 256\n  for i in range(256):\n   crc = i\n   for j in range(8):\n    if crc & 1:\n     crc = ((crc >> 1) & 0x7FFFFFFF) ^ poly\n    else:\n     crc = ((crc >> 1) & 0x7FFFFFFF)\n   table[i] = crc\n  return table\n crctable = _GenerateCRCTable()\n \n def _crc32(self, ch, crc):\n  \"\"\n  return ((crc >> 8) & 0xffffff) ^ self.crctable[(crc ^ ch) & 0xff]\n  \n def __init__(self, pwd):\n  self.key0 = 305419896\n  self.key1 = 591751049\n  self.key2 = 878082192\n  for p in pwd:\n   self._UpdateKeys(p)\n   \n def _UpdateKeys(self, c):\n  self.key0 = self._crc32(c, self.key0)\n  self.key1 = (self.key1 + (self.key0 & 255)) & 4294967295\n  self.key1 = (self.key1 * 134775813 + 1) & 4294967295\n  self.key2 = self._crc32((self.key1 >> 24) & 255, self.key2)\n  \n def __call__(self, c):\n  \"\"\n  assert isinstance(c, int)\n  k = self.key2 | 2\n  c = c ^ (((k * (k^1)) >> 8) & 255)\n  self._UpdateKeys(c)\n  return c\n  \n  \nclass LZMACompressor:\n\n def __init__(self):\n  self._comp = None\n  \n def _init(self):\n  props = lzma._encode_filter_properties({'id': lzma.FILTER_LZMA1})\n  self._comp = lzma.LZMACompressor(lzma.FORMAT_RAW, filters=[\n  lzma._decode_filter_properties(lzma.FILTER_LZMA1, props)\n  ])\n  return struct.pack('<BBH', 9, 4, len(props)) + props\n  \n def compress(self, data):\n  if self._comp is None:\n   return self._init() + self._comp.compress(data)\n  return self._comp.compress(data)\n  \n def flush(self):\n  if self._comp is None:\n   return self._init() + self._comp.flush()\n  return self._comp.flush()\n  \n  \nclass LZMADecompressor:\n\n def __init__(self):\n  self._decomp = None\n  self._unconsumed = b''\n  self.eof = False\n  \n def decompress(self, data):\n  if self._decomp is None:\n   self._unconsumed += data\n   if len(self._unconsumed) <= 4:\n    return b''\n   psize, = struct.unpack('<H', self._unconsumed[2:4])\n   if len(self._unconsumed) <= 4 + psize:\n    return b''\n    \n   self._decomp = lzma.LZMADecompressor(lzma.FORMAT_RAW, filters=[\n   lzma._decode_filter_properties(lzma.FILTER_LZMA1,\n   self._unconsumed[4:4 + psize])\n   ])\n   data = self._unconsumed[4 + psize:]\n   del self._unconsumed\n   \n  result = self._decomp.decompress(data)\n  self.eof = self._decomp.eof\n  return result\n  \n  \ncompressor_names = {\n0: 'store',\n1: 'shrink',\n2: 'reduce',\n3: 'reduce',\n4: 'reduce',\n5: 'reduce',\n6: 'implode',\n7: 'tokenize',\n8: 'deflate',\n9: 'deflate64',\n10: 'implode',\n12: 'bzip2',\n14: 'lzma',\n18: 'terse',\n19: 'lz77',\n97: 'wavpack',\n98: 'ppmd',\n}\n\ndef _check_compression(compression):\n if compression == ZIP_STORED:\n  pass\n elif compression == ZIP_DEFLATED:\n  if not zlib:\n   raise RuntimeError(\n   \"Compression requires the (missing) zlib module\")\n elif compression == ZIP_BZIP2:\n  if not bz2:\n   raise RuntimeError(\n   \"Compression requires the (missing) bz2 module\")\n elif compression == ZIP_LZMA:\n  if not lzma:\n   raise RuntimeError(\n   \"Compression requires the (missing) lzma module\")\n else:\n  raise RuntimeError(\"That compression method is not supported\")\n  \n  \ndef _get_compressor(compress_type):\n if compress_type == ZIP_DEFLATED:\n  return zlib.compressobj(zlib.Z_DEFAULT_COMPRESSION,\n  zlib.DEFLATED, -15)\n elif compress_type == ZIP_BZIP2:\n  return bz2.BZ2Compressor()\n elif compress_type == ZIP_LZMA:\n  return LZMACompressor()\n else:\n  return None\n  \n  \ndef _get_decompressor(compress_type):\n if compress_type == ZIP_STORED:\n  return None\n elif compress_type == ZIP_DEFLATED:\n  return zlib.decompressobj(-15)\n elif compress_type == ZIP_BZIP2:\n  return bz2.BZ2Decompressor()\n elif compress_type == ZIP_LZMA:\n  return LZMADecompressor()\n else:\n  descr = compressor_names.get(compress_type)\n  if descr:\n   raise NotImplementedError(\"compression type %d (%s)\" % (compress_type, descr))\n  else:\n   raise NotImplementedError(\"compression type %d\" % (compress_type,))\n   \n   \nclass ZipExtFile(io.BufferedIOBase):\n \"\"\n \n \n MAX_N = 1 << 31 - 1\n \n \n MIN_READ_SIZE = 4096\n \n \n PATTERN = re.compile(br'^(?P<chunk>[^\\r\\n]+)|(?P<newline>\\n|\\r\\n?)')\n \n def __init__(self, fileobj, mode, zipinfo, decrypter=None,\n close_fileobj=False):\n  self._fileobj = fileobj\n  self._decrypter = decrypter\n  self._close_fileobj = close_fileobj\n  \n  self._compress_type = zipinfo.compress_type\n  self._compress_left = zipinfo.compress_size\n  self._left = zipinfo.file_size\n  \n  self._decompressor = _get_decompressor(self._compress_type)\n  \n  self._eof = False\n  self._readbuffer = b''\n  self._offset = 0\n  \n  self._universal = 'U' in mode\n  self.newlines = None\n  \n  \n  \n  if self._decrypter is not None:\n   self._compress_left -= 12\n   \n  self.mode = mode\n  self.name = zipinfo.filename\n  \n  if hasattr(zipinfo, 'CRC'):\n   self._expected_crc = zipinfo.CRC\n   self._running_crc = crc32(b'') & 0xffffffff\n  else:\n   self._expected_crc = None\n   \n def readline(self, limit=-1):\n  \"\"\n  \n  if not self._universal and limit < 0:\n  \n   i = self._readbuffer.find(b'\\n', self._offset) + 1\n   if i > 0:\n    line = self._readbuffer[self._offset: i]\n    self._offset = i\n    return line\n    \n  if not self._universal:\n   return io.BufferedIOBase.readline(self, limit)\n   \n  line = b''\n  while limit < 0 or len(line) < limit:\n   readahead = self.peek(2)\n   if readahead == b'':\n    return line\n    \n    \n    \n    \n    \n    \n    \n    \n    \n   match = self.PATTERN.search(readahead)\n   newline = match.group('newline')\n   if newline is not None:\n    if self.newlines is None:\n     self.newlines = []\n    if newline not in self.newlines:\n     self.newlines.append(newline)\n    self._offset += len(newline)\n    return line + b'\\n'\n    \n   chunk = match.group('chunk')\n   if limit >= 0:\n    chunk = chunk[: limit - len(line)]\n    \n   self._offset += len(chunk)\n   line += chunk\n   \n  return line\n  \n def peek(self, n=1):\n  \"\"\n  if n > len(self._readbuffer) - self._offset:\n   chunk = self.read(n)\n   if len(chunk) > self._offset:\n    self._readbuffer = chunk + self._readbuffer[self._offset:]\n    self._offset = 0\n   else:\n    self._offset -= len(chunk)\n    \n    \n  return self._readbuffer[self._offset: self._offset + 512]\n  \n def readable(self):\n  return True\n  \n def read(self, n=-1):\n  \"\"\n  if n is None or n < 0:\n   buf = self._readbuffer[self._offset:]\n   self._readbuffer = b''\n   self._offset = 0\n   while not self._eof:\n    buf += self._read1(self.MAX_N)\n   return buf\n   \n  end = n + self._offset\n  if end < len(self._readbuffer):\n   buf = self._readbuffer[self._offset:end]\n   self._offset = end\n   return buf\n   \n  n = end - len(self._readbuffer)\n  buf = self._readbuffer[self._offset:]\n  self._readbuffer = b''\n  self._offset = 0\n  while n > 0 and not self._eof:\n   data = self._read1(n)\n   if n < len(data):\n    self._readbuffer = data\n    self._offset = n\n    buf += data[:n]\n    break\n   buf += data\n   n -= len(data)\n  return buf\n  \n def _update_crc(self, newdata):\n \n  if self._expected_crc is None:\n  \n   return\n  self._running_crc = crc32(newdata, self._running_crc) & 0xffffffff\n  \n  if self._eof and self._running_crc != self._expected_crc:\n   raise BadZipFile(\"Bad CRC-32 for file %r\" % self.name)\n   \n def read1(self, n):\n  \"\"\n  \n  if n is None or n < 0:\n   buf = self._readbuffer[self._offset:]\n   self._readbuffer = b''\n   self._offset = 0\n   while not self._eof:\n    data = self._read1(self.MAX_N)\n    if data:\n     buf += data\n     break\n   return buf\n   \n  end = n + self._offset\n  if end < len(self._readbuffer):\n   buf = self._readbuffer[self._offset:end]\n   self._offset = end\n   return buf\n   \n  n = end - len(self._readbuffer)\n  buf = self._readbuffer[self._offset:]\n  self._readbuffer = b''\n  self._offset = 0\n  if n > 0:\n   while not self._eof:\n    data = self._read1(n)\n    if n < len(data):\n     self._readbuffer = data\n     self._offset = n\n     buf += data[:n]\n     break\n    if data:\n     buf += data\n     break\n  return buf\n  \n def _read1(self, n):\n \n \n  if self._eof or n <= 0:\n   return b''\n   \n   \n  if self._compress_type == ZIP_DEFLATED:\n  \n   data = self._decompressor.unconsumed_tail\n   if n > len(data):\n    data += self._read2(n - len(data))\n  else:\n   data = self._read2(n)\n   \n  if self._compress_type == ZIP_STORED:\n   self._eof = self._compress_left <= 0\n  elif self._compress_type == ZIP_DEFLATED:\n   n = max(n, self.MIN_READ_SIZE)\n   data = self._decompressor.decompress(data, n)\n   self._eof = (self._decompressor.eof or\n   self._compress_left <= 0 and\n   not self._decompressor.unconsumed_tail)\n   if self._eof:\n    data += self._decompressor.flush()\n  else:\n   data = self._decompressor.decompress(data)\n   self._eof = self._decompressor.eof or self._compress_left <= 0\n   \n  data = data[:self._left]\n  self._left -= len(data)\n  if self._left <= 0:\n   self._eof = True\n  self._update_crc(data)\n  return data\n  \n def _read2(self, n):\n  if self._compress_left <= 0:\n   return b''\n   \n  n = max(n, self.MIN_READ_SIZE)\n  n = min(n, self._compress_left)\n  \n  data = self._fileobj.read(n)\n  self._compress_left -= len(data)\n  \n  if self._decrypter is not None:\n   data = bytes(map(self._decrypter, data))\n  return data\n  \n def close(self):\n  try:\n   if self._close_fileobj:\n    self._fileobj.close()\n  finally:\n   super().close()\n   \n   \nclass ZipFile:\n \"\"\n \n fp = None \n _windows_illegal_name_trans_table = None\n \n def __init__(self, file, mode=\"r\", compression=ZIP_STORED, allowZip64=False):\n  \"\"\n  if mode not in (\"r\", \"w\", \"a\"):\n   raise RuntimeError('ZipFile() requires mode \"r\", \"w\", or \"a\"')\n   \n  _check_compression(compression)\n  \n  self._allowZip64 = allowZip64\n  self._didModify = False\n  self.debug = 0 \n  self.NameToInfo = {} \n  self.filelist = [] \n  self.compression = compression \n  self.mode = key = mode.replace('b', '')[0]\n  self.pwd = None\n  self._comment = b''\n  \n  \n  if isinstance(file, str):\n  \n   self._filePassed = 0\n   self.filename = file\n   modeDict = {'r' : 'rb', 'w': 'wb', 'a' : 'r+b'}\n   try:\n    self.fp = io.open(file, modeDict[mode])\n   except IOError:\n    if mode == 'a':\n     mode = key = 'w'\n     self.fp = io.open(file, modeDict[mode])\n    else:\n     raise\n  else:\n   self._filePassed = 1\n   self.fp = file\n   self.filename = getattr(file, 'name', None)\n   \n  try:\n   if key == 'r':\n    self._RealGetContents()\n   elif key == 'w':\n   \n   \n    self._didModify = True\n   elif key == 'a':\n    try:\n    \n     self._RealGetContents()\n     \n     self.fp.seek(self.start_dir, 0)\n    except BadZipFile:\n    \n     self.fp.seek(0, 2)\n     \n     \n     \n     self._didModify = True\n   else:\n    raise RuntimeError('Mode must be \"r\", \"w\" or \"a\"')\n  except:\n   fp = self.fp\n   self.fp = None\n   if not self._filePassed:\n    fp.close()\n   raise\n   \n def __enter__(self):\n  return self\n  \n def __exit__(self, type, value, traceback):\n  self.close()\n  \n def _RealGetContents(self):\n  \"\"\n  fp = self.fp\n  try:\n   endrec = _EndRecData(fp)\n  except IOError:\n   raise BadZipFile(\"File is not a zip file\")\n  if not endrec:\n   raise BadZipFile(\"File is not a zip file\")\n  if self.debug > 1:\n   print(endrec)\n  size_cd = endrec[_ECD_SIZE] \n  offset_cd = endrec[_ECD_OFFSET] \n  self._comment = endrec[_ECD_COMMENT] \n  \n  \n  concat = endrec[_ECD_LOCATION] - size_cd - offset_cd\n  if endrec[_ECD_SIGNATURE] == stringEndArchive64:\n  \n   concat -= (sizeEndCentDir64 + sizeEndCentDir64Locator)\n   \n  if self.debug > 2:\n   inferred = concat + offset_cd\n   print(\"given, inferred, offset\", offset_cd, inferred, concat)\n   \n  self.start_dir = offset_cd + concat\n  fp.seek(self.start_dir, 0)\n  data = fp.read(size_cd)\n  fp = io.BytesIO(data)\n  total = 0\n  while total < size_cd:\n   centdir = fp.read(sizeCentralDir)\n   if len(centdir) != sizeCentralDir:\n    raise BadZipFile(\"Truncated central directory\")\n   centdir = struct.unpack(structCentralDir, centdir)\n   if centdir[_CD_SIGNATURE] != stringCentralDir:\n    raise BadZipFile(\"Bad magic number for central directory\")\n   if self.debug > 2:\n    print(centdir)\n   filename = fp.read(centdir[_CD_FILENAME_LENGTH])\n   flags = centdir[5]\n   if flags & 0x800:\n   \n    filename = filename.decode('utf-8')\n   else:\n   \n    filename = filename.decode('cp437')\n    \n   x = ZipInfo(filename)\n   x.extra = fp.read(centdir[_CD_EXTRA_FIELD_LENGTH])\n   x.comment = fp.read(centdir[_CD_COMMENT_LENGTH])\n   x.header_offset = centdir[_CD_LOCAL_HEADER_OFFSET]\n   (x.create_version, x.create_system, x.extract_version, x.reserved,\n   x.flag_bits, x.compress_type, t, d,\n   x.CRC, x.compress_size, x.file_size) = centdir[1:12]\n   if x.extract_version > MAX_EXTRACT_VERSION:\n    raise NotImplementedError(\"zip file version %.1f\" %\n    (x.extract_version / 10))\n   x.volume, x.internal_attr, x.external_attr = centdir[15:18]\n   \n   x._raw_time = t\n   x.date_time = ( (d>>9)+1980, (d>>5)&0xF, d&0x1F,\n   t>>11, (t>>5)&0x3F, (t&0x1F) * 2 )\n   \n   x._decodeExtra()\n   x.header_offset = x.header_offset + concat\n   self.filelist.append(x)\n   self.NameToInfo[x.filename] = x\n   \n   \n   total = (total + sizeCentralDir + centdir[_CD_FILENAME_LENGTH]\n   + centdir[_CD_EXTRA_FIELD_LENGTH]\n   + centdir[_CD_COMMENT_LENGTH])\n   \n   if self.debug > 2:\n    print(\"total\", total)\n    \n    \n def namelist(self):\n  \"\"\n  return [data.filename for data in self.filelist]\n  \n def infolist(self):\n  \"\"\n  return self.filelist\n  \n def printdir(self, file=None):\n  \"\"\n  print(\"%-46s %19s %12s\" % (\"File Name\", \"Modified    \", \"Size\"),\n  file=file)\n  for zinfo in self.filelist:\n   date = \"%d-%02d-%02d %02d:%02d:%02d\" % zinfo.date_time[:6]\n   print(\"%-46s %s %12d\" % (zinfo.filename, date, zinfo.file_size),\n   file=file)\n   \n def testzip(self):\n  \"\"\n  chunk_size = 2 ** 20\n  for zinfo in self.filelist:\n   try:\n   \n   \n    with self.open(zinfo.filename, \"r\") as f:\n     while f.read(chunk_size): \n      pass\n   except BadZipFile:\n    return zinfo.filename\n    \n def getinfo(self, name):\n  \"\"\n  info = self.NameToInfo.get(name)\n  if info is None:\n   raise KeyError(\n   'There is no item named %r in the archive' % name)\n   \n  return info\n  \n def setpassword(self, pwd):\n  \"\"\n  if pwd and not isinstance(pwd, bytes):\n   raise TypeError(\"pwd: expected bytes, got %s\" % type(pwd))\n  if pwd:\n   self.pwd = pwd\n  else:\n   self.pwd = None\n   \n @property\n def comment(self):\n  \"\"\n  return self._comment\n  \n @comment.setter\n def comment(self, comment):\n  if not isinstance(comment, bytes):\n   raise TypeError(\"comment: expected bytes, got %s\" % type(comment))\n   \n  if len(comment) >= ZIP_MAX_COMMENT:\n   if self.debug:\n    print('Archive comment is too long; truncating to %d bytes'\n    % ZIP_MAX_COMMENT)\n   comment = comment[:ZIP_MAX_COMMENT]\n  self._comment = comment\n  self._didModify = True\n  \n def read(self, name, pwd=None):\n  \"\"\n  with self.open(name, \"r\", pwd) as fp:\n   return fp.read()\n   \n def open(self, name, mode=\"r\", pwd=None):\n  \"\"\n  if mode not in (\"r\", \"U\", \"rU\"):\n   raise RuntimeError('open() requires mode \"r\", \"U\", or \"rU\"')\n  if pwd and not isinstance(pwd, bytes):\n   raise TypeError(\"pwd: expected bytes, got %s\" % type(pwd))\n  if not self.fp:\n   raise RuntimeError(\n   \"Attempt to read ZIP archive that was already closed\")\n   \n   \n   \n  if self._filePassed:\n   zef_file = self.fp\n  else:\n   zef_file = io.open(self.filename, 'rb')\n   \n  try:\n  \n   if isinstance(name, ZipInfo):\n   \n    zinfo = name\n   else:\n   \n    zinfo = self.getinfo(name)\n   zef_file.seek(zinfo.header_offset, 0)\n   \n   \n   fheader = zef_file.read(sizeFileHeader)\n   if len(fheader) != sizeFileHeader:\n    raise BadZipFile(\"Truncated file header\")\n   fheader = struct.unpack(structFileHeader, fheader)\n   if fheader[_FH_SIGNATURE] != stringFileHeader:\n    raise BadZipFile(\"Bad magic number for file header\")\n    \n   fname = zef_file.read(fheader[_FH_FILENAME_LENGTH])\n   if fheader[_FH_EXTRA_FIELD_LENGTH]:\n    zef_file.read(fheader[_FH_EXTRA_FIELD_LENGTH])\n    \n   if zinfo.flag_bits & 0x20:\n   \n    raise NotImplementedError(\"compressed patched data (flag bit 5)\")\n    \n   if zinfo.flag_bits & 0x40:\n   \n    raise NotImplementedError(\"strong encryption (flag bit 6)\")\n    \n   if zinfo.flag_bits & 0x800:\n   \n    fname_str = fname.decode(\"utf-8\")\n   else:\n    fname_str = fname.decode(\"cp437\")\n    \n   if fname_str != zinfo.orig_filename:\n    raise BadZipFile(\n    'File name in directory %r and header %r differ.'\n    % (zinfo.orig_filename, fname))\n    \n    \n   is_encrypted = zinfo.flag_bits & 0x1\n   zd = None\n   if is_encrypted:\n    if not pwd:\n     pwd = self.pwd\n    if not pwd:\n     raise RuntimeError(\"File %s is encrypted, password \"\n     \"required for extraction\" % name)\n     \n    zd = _ZipDecrypter(pwd)\n    \n    \n    \n    \n    \n    header = zef_file.read(12)\n    h = list(map(zd, header[0:12]))\n    if zinfo.flag_bits & 0x8:\n    \n     check_byte = (zinfo._raw_time >> 8) & 0xff\n    else:\n    \n     check_byte = (zinfo.CRC >> 24) & 0xff\n    if h[11] != check_byte:\n     raise RuntimeError(\"Bad password for file\", name)\n     \n   return ZipExtFile(zef_file, mode, zinfo, zd,\n   close_fileobj=not self._filePassed)\n  except:\n   if not self._filePassed:\n    zef_file.close()\n   raise\n   \n def extract(self, member, path=None, pwd=None):\n  \"\"\n  if not isinstance(member, ZipInfo):\n   member = self.getinfo(member)\n   \n  if path is None:\n   path = os.getcwd()\n   \n  return self._extract_member(member, path, pwd)\n  \n def extractall(self, path=None, members=None, pwd=None):\n  \"\"\n  if members is None:\n   members = self.namelist()\n   \n  for zipinfo in members:\n   self.extract(zipinfo, path, pwd)\n   \n @classmethod\n def _sanitize_windows_name(cls, arcname, pathsep):\n  \"\"\n  table = cls._windows_illegal_name_trans_table\n  if not table:\n   illegal = ':<>|\"?*'\n   table = str.maketrans(illegal, '_' * len(illegal))\n   cls._windows_illegal_name_trans_table = table\n  arcname = arcname.translate(table)\n  \n  arcname = (x.rstrip('.') for x in arcname.split(pathsep))\n  \n  arcname = pathsep.join(x for x in arcname if x)\n  return arcname\n  \n def _extract_member(self, member, targetpath, pwd):\n  \"\"\n  \n  \n  arcname = member.filename.replace('/', os.path.sep)\n  \n  if os.path.altsep:\n   arcname = arcname.replace(os.path.altsep, os.path.sep)\n   \n   \n  arcname = os.path.splitdrive(arcname)[1]\n  invalid_path_parts = ('', os.path.curdir, os.path.pardir)\n  arcname = os.path.sep.join(x for x in arcname.split(os.path.sep)\n  if x not in invalid_path_parts)\n  if os.path.sep == '\\\\':\n  \n   arcname = self._sanitize_windows_name(arcname, os.path.sep)\n   \n  targetpath = os.path.join(targetpath, arcname)\n  targetpath = os.path.normpath(targetpath)\n  \n  \n  upperdirs = os.path.dirname(targetpath)\n  if upperdirs and not os.path.exists(upperdirs):\n   os.makedirs(upperdirs)\n   \n  if member.filename[-1] == '/':\n   if not os.path.isdir(targetpath):\n    os.mkdir(targetpath)\n   return targetpath\n   \n  with self.open(member, pwd=pwd) as source, open(targetpath, \"wb\") as target:\n   shutil.copyfileobj(source, target)\n   \n  return targetpath\n  \n def _writecheck(self, zinfo):\n  \"\"\n  if zinfo.filename in self.NameToInfo:\n   if self.debug: \n    print(\"Duplicate name:\", zinfo.filename)\n  if self.mode not in (\"w\", \"a\"):\n   raise RuntimeError('write() requires mode \"w\" or \"a\"')\n  if not self.fp:\n   raise RuntimeError(\n   \"Attempt to write ZIP archive that was already closed\")\n  _check_compression(zinfo.compress_type)\n  if zinfo.file_size > ZIP64_LIMIT:\n   if not self._allowZip64:\n    raise LargeZipFile(\"Filesize would require ZIP64 extensions\")\n  if zinfo.header_offset > ZIP64_LIMIT:\n   if not self._allowZip64:\n    raise LargeZipFile(\n    \"Zipfile size would require ZIP64 extensions\")\n    \n def write(self, filename, arcname=None, compress_type=None):\n  \"\"\n  if not self.fp:\n   raise RuntimeError(\n   \"Attempt to write to ZIP archive that was already closed\")\n   \n  st = os.stat(filename)\n  isdir = stat.S_ISDIR(st.st_mode)\n  mtime = time.localtime(st.st_mtime)\n  date_time = mtime[0:6]\n  \n  if arcname is None:\n   arcname = filename\n  arcname = os.path.normpath(os.path.splitdrive(arcname)[1])\n  while arcname[0] in (os.sep, os.altsep):\n   arcname = arcname[1:]\n  if isdir:\n   arcname += '/'\n  zinfo = ZipInfo(arcname, date_time)\n  zinfo.external_attr = (st[0] & 0xFFFF) << 16 \n  if compress_type is None:\n   zinfo.compress_type = self.compression\n  else:\n   zinfo.compress_type = compress_type\n   \n  zinfo.file_size = st.st_size\n  zinfo.flag_bits = 0x00\n  zinfo.header_offset = self.fp.tell() \n  if zinfo.compress_type == ZIP_LZMA:\n  \n   zinfo.flag_bits |= 0x02\n   \n  self._writecheck(zinfo)\n  self._didModify = True\n  \n  if isdir:\n   zinfo.file_size = 0\n   zinfo.compress_size = 0\n   zinfo.CRC = 0\n   self.filelist.append(zinfo)\n   self.NameToInfo[zinfo.filename] = zinfo\n   self.fp.write(zinfo.FileHeader(False))\n   return\n   \n  cmpr = _get_compressor(zinfo.compress_type)\n  with open(filename, \"rb\") as fp:\n  \n   zinfo.CRC = CRC = 0\n   zinfo.compress_size = compress_size = 0\n   \n   zip64 = self._allowZip64 and zinfo.file_size * 1.05 > ZIP64_LIMIT\n   self.fp.write(zinfo.FileHeader(zip64))\n   file_size = 0\n   while 1:\n    buf = fp.read(1024 * 8)\n    if not buf:\n     break\n    file_size = file_size + len(buf)\n    CRC = crc32(buf, CRC) & 0xffffffff\n    if cmpr:\n     buf = cmpr.compress(buf)\n     compress_size = compress_size + len(buf)\n    self.fp.write(buf)\n  if cmpr:\n   buf = cmpr.flush()\n   compress_size = compress_size + len(buf)\n   self.fp.write(buf)\n   zinfo.compress_size = compress_size\n  else:\n   zinfo.compress_size = file_size\n  zinfo.CRC = CRC\n  zinfo.file_size = file_size\n  if not zip64 and self._allowZip64:\n   if file_size > ZIP64_LIMIT:\n    raise RuntimeError('File size has increased during compressing')\n   if compress_size > ZIP64_LIMIT:\n    raise RuntimeError('Compressed size larger than uncompressed size')\n    \n    \n  position = self.fp.tell() \n  self.fp.seek(zinfo.header_offset, 0)\n  self.fp.write(zinfo.FileHeader(zip64))\n  self.fp.seek(position, 0)\n  self.filelist.append(zinfo)\n  self.NameToInfo[zinfo.filename] = zinfo\n  \n def writestr(self, zinfo_or_arcname, data, compress_type=None):\n  \"\"\n  if isinstance(data, str):\n   data = data.encode(\"utf-8\")\n  if not isinstance(zinfo_or_arcname, ZipInfo):\n   zinfo = ZipInfo(filename=zinfo_or_arcname,\n   date_time=time.localtime(time.time())[:6])\n   zinfo.compress_type = self.compression\n   zinfo.external_attr = 0o600 << 16\n  else:\n   zinfo = zinfo_or_arcname\n   \n  if not self.fp:\n   raise RuntimeError(\n   \"Attempt to write to ZIP archive that was already closed\")\n   \n  zinfo.file_size = len(data) \n  zinfo.header_offset = self.fp.tell() \n  if compress_type is not None:\n   zinfo.compress_type = compress_type\n  if zinfo.compress_type == ZIP_LZMA:\n  \n   zinfo.flag_bits |= 0x02\n   \n  self._writecheck(zinfo)\n  self._didModify = True\n  zinfo.CRC = crc32(data) & 0xffffffff \n  co = _get_compressor(zinfo.compress_type)\n  if co:\n   data = co.compress(data) + co.flush()\n   zinfo.compress_size = len(data) \n  else:\n   zinfo.compress_size = zinfo.file_size\n  zip64 = zinfo.file_size > ZIP64_LIMIT or zinfo.compress_size > ZIP64_LIMIT\n  if zip64 and not self._allowZip64:\n   raise LargeZipFile(\"Filesize would require ZIP64 extensions\")\n  self.fp.write(zinfo.FileHeader(zip64))\n  self.fp.write(data)\n  if zinfo.flag_bits & 0x08:\n  \n   fmt = '<LQQ' if zip64 else '<LLL'\n   self.fp.write(struct.pack(fmt, zinfo.CRC, zinfo.compress_size,\n   zinfo.file_size))\n  self.fp.flush()\n  self.filelist.append(zinfo)\n  self.NameToInfo[zinfo.filename] = zinfo\n  \n def __del__(self):\n  \"\"\n  self.close()\n  \n def close(self):\n  \"\"\n  if self.fp is None:\n   return\n   \n  try:\n   if self.mode in (\"w\", \"a\") and self._didModify: \n    count = 0\n    pos1 = self.fp.tell()\n    for zinfo in self.filelist: \n     count = count + 1\n     dt = zinfo.date_time\n     dosdate = (dt[0] - 1980) << 9 | dt[1] << 5 | dt[2]\n     dostime = dt[3] << 11 | dt[4] << 5 | (dt[5] // 2)\n     extra = []\n     if zinfo.file_size > ZIP64_LIMIT or zinfo.compress_size > ZIP64_LIMIT:\n      extra.append(zinfo.file_size)\n      extra.append(zinfo.compress_size)\n      file_size = 0xffffffff\n      compress_size = 0xffffffff\n     else:\n      file_size = zinfo.file_size\n      compress_size = zinfo.compress_size\n      \n     if zinfo.header_offset > ZIP64_LIMIT:\n      extra.append(zinfo.header_offset)\n      header_offset = 0xffffffff\n     else:\n      header_offset = zinfo.header_offset\n      \n     extra_data = zinfo.extra\n     min_version = 0\n     if extra:\n     \n      extra_data = struct.pack(\n      '<HH' + 'Q'*len(extra),\n      1, 8*len(extra), *extra) + extra_data\n      \n      min_version = ZIP64_VERSION\n      \n     if zinfo.compress_type == ZIP_BZIP2:\n      min_version = max(BZIP2_VERSION, min_version)\n     elif zinfo.compress_type == ZIP_LZMA:\n      min_version = max(LZMA_VERSION, min_version)\n      \n     extract_version = max(min_version, zinfo.extract_version)\n     create_version = max(min_version, zinfo.create_version)\n     try:\n      filename, flag_bits = zinfo._encodeFilenameFlags()\n      centdir = struct.pack(structCentralDir,\n      stringCentralDir, create_version,\n      zinfo.create_system, extract_version, zinfo.reserved,\n      flag_bits, zinfo.compress_type, dostime, dosdate,\n      zinfo.CRC, compress_size, file_size,\n      len(filename), len(extra_data), len(zinfo.comment),\n      0, zinfo.internal_attr, zinfo.external_attr,\n      header_offset)\n     except DeprecationWarning:\n      print((structCentralDir, stringCentralDir, create_version,\n      zinfo.create_system, extract_version, zinfo.reserved,\n      zinfo.flag_bits, zinfo.compress_type, dostime, dosdate,\n      zinfo.CRC, compress_size, file_size,\n      len(zinfo.filename), len(extra_data), len(zinfo.comment),\n      0, zinfo.internal_attr, zinfo.external_attr,\n      header_offset), file=sys.stderr)\n      raise\n     self.fp.write(centdir)\n     self.fp.write(filename)\n     self.fp.write(extra_data)\n     self.fp.write(zinfo.comment)\n     \n    pos2 = self.fp.tell()\n    \n    centDirCount = count\n    centDirSize = pos2 - pos1\n    centDirOffset = pos1\n    if (centDirCount >= ZIP_FILECOUNT_LIMIT or\n    centDirOffset > ZIP64_LIMIT or\n    centDirSize > ZIP64_LIMIT):\n    \n     zip64endrec = struct.pack(\n     structEndArchive64, stringEndArchive64,\n     44, 45, 45, 0, 0, centDirCount, centDirCount,\n     centDirSize, centDirOffset)\n     self.fp.write(zip64endrec)\n     \n     zip64locrec = struct.pack(\n     structEndArchive64Locator,\n     stringEndArchive64Locator, 0, pos2, 1)\n     self.fp.write(zip64locrec)\n     centDirCount = min(centDirCount, 0xFFFF)\n     centDirSize = min(centDirSize, 0xFFFFFFFF)\n     centDirOffset = min(centDirOffset, 0xFFFFFFFF)\n     \n    endrec = struct.pack(structEndArchive, stringEndArchive,\n    0, 0, centDirCount, centDirCount,\n    centDirSize, centDirOffset, len(self._comment))\n    self.fp.write(endrec)\n    self.fp.write(self._comment)\n    self.fp.flush()\n  finally:\n   fp = self.fp\n   self.fp = None\n   if not self._filePassed:\n    fp.close()\n    \n    \nclass PyZipFile(ZipFile):\n \"\"\n \n def __init__(self, file, mode=\"r\", compression=ZIP_STORED,\n allowZip64=False, optimize=-1):\n  ZipFile.__init__(self, file, mode=mode, compression=compression,\n  allowZip64=allowZip64)\n  self._optimize = optimize\n  \n def writepy(self, pathname, basename=\"\"):\n  \"\"\n  dir, name = os.path.split(pathname)\n  if os.path.isdir(pathname):\n   initname = os.path.join(pathname, \"__init__.py\")\n   if os.path.isfile(initname):\n   \n    if basename:\n     basename = \"%s/%s\" % (basename, name)\n    else:\n     basename = name\n    if self.debug:\n     print(\"Adding package in\", pathname, \"as\", basename)\n    fname, arcname = self._get_codename(initname[0:-3], basename)\n    if self.debug:\n     print(\"Adding\", arcname)\n    self.write(fname, arcname)\n    dirlist = os.listdir(pathname)\n    dirlist.remove(\"__init__.py\")\n    \n    for filename in dirlist:\n     path = os.path.join(pathname, filename)\n     root, ext = os.path.splitext(filename)\n     if os.path.isdir(path):\n      if os.path.isfile(os.path.join(path, \"__init__.py\")):\n      \n       self.writepy(path, basename) \n     elif ext == \".py\":\n      fname, arcname = self._get_codename(path[0:-3],\n      basename)\n      if self.debug:\n       print(\"Adding\", arcname)\n      self.write(fname, arcname)\n   else:\n   \n    if self.debug:\n     print(\"Adding files from directory\", pathname)\n    for filename in os.listdir(pathname):\n     path = os.path.join(pathname, filename)\n     root, ext = os.path.splitext(filename)\n     if ext == \".py\":\n      fname, arcname = self._get_codename(path[0:-3],\n      basename)\n      if self.debug:\n       print(\"Adding\", arcname)\n      self.write(fname, arcname)\n  else:\n   if pathname[-3:] != \".py\":\n    raise RuntimeError(\n    'Files added with writepy() must end with \".py\"')\n   fname, arcname = self._get_codename(pathname[0:-3], basename)\n   if self.debug:\n    print(\"Adding file\", arcname)\n   self.write(fname, arcname)\n   \n def _get_codename(self, pathname, basename):\n  \"\"\n  def _compile(file, optimize=-1):\n   import py_compile\n   if self.debug:\n    print(\"Compiling\", file)\n   try:\n    py_compile.compile(file, doraise=True, optimize=optimize)\n   except py_compile.PyCompileError as err:\n    print(err.msg)\n    return False\n   return True\n   \n  file_py = pathname + \".py\"\n  file_pyc = pathname + \".pyc\"\n  file_pyo = pathname + \".pyo\"\n  pycache_pyc = imp.cache_from_source(file_py, True)\n  pycache_pyo = imp.cache_from_source(file_py, False)\n  if self._optimize == -1:\n  \n   if (os.path.isfile(file_pyo) and\n   os.stat(file_pyo).st_mtime >= os.stat(file_py).st_mtime):\n   \n    arcname = fname = file_pyo\n   elif (os.path.isfile(file_pyc) and\n   os.stat(file_pyc).st_mtime >= os.stat(file_py).st_mtime):\n   \n    arcname = fname = file_pyc\n   elif (os.path.isfile(pycache_pyc) and\n   os.stat(pycache_pyc).st_mtime >= os.stat(file_py).st_mtime):\n   \n   \n    fname = pycache_pyc\n    arcname = file_pyc\n   elif (os.path.isfile(pycache_pyo) and\n   os.stat(pycache_pyo).st_mtime >= os.stat(file_py).st_mtime):\n   \n   \n    fname = pycache_pyo\n    arcname = file_pyo\n   else:\n   \n    if _compile(file_py):\n     fname = (pycache_pyc if __debug__ else pycache_pyo)\n     arcname = (file_pyc if __debug__ else file_pyo)\n    else:\n     fname = arcname = file_py\n  else:\n  \n   if self._optimize == 0:\n    fname = pycache_pyc\n    arcname = file_pyc\n   else:\n    fname = pycache_pyo\n    arcname = file_pyo\n   if not (os.path.isfile(fname) and\n   os.stat(fname).st_mtime >= os.stat(file_py).st_mtime):\n    if not _compile(file_py, optimize=self._optimize):\n     fname = arcname = file_py\n  archivename = os.path.split(arcname)[1]\n  if basename:\n   archivename = \"%s/%s\" % (basename, archivename)\n  return (fname, archivename)\n  \n  \ndef main(args = None):\n import textwrap\n USAGE=textwrap.dedent(\"\"\"\\\n        Usage:\n            zipfile.py -l zipfile.zip        # Show listing of a zipfile\n            zipfile.py -t zipfile.zip        # Test if a zipfile is valid\n            zipfile.py -e zipfile.zip target # Extract zipfile into target dir\n            zipfile.py -c zipfile.zip src ... # Create zipfile from sources\n        \"\"\" )\n if args is None:\n  args = sys.argv[1:]\n  \n if not args or args[0] not in ('-l', '-c', '-e', '-t'):\n  print(USAGE)\n  sys.exit(1)\n  \n if args[0] == '-l':\n  if len(args) != 2:\n   print(USAGE)\n   sys.exit(1)\n  with ZipFile(args[1], 'r') as zf:\n   zf.printdir()\n   \n elif args[0] == '-t':\n  if len(args) != 2:\n   print(USAGE)\n   sys.exit(1)\n  with ZipFile(args[1], 'r') as zf:\n   badfile = zf.testzip()\n  if badfile:\n   print(\"The following enclosed file is corrupted: {!r}\".format(badfile))\n  print(\"Done testing\")\n  \n elif args[0] == '-e':\n  if len(args) != 3:\n   print(USAGE)\n   sys.exit(1)\n   \n  with ZipFile(args[1], 'r') as zf:\n   out = args[2]\n   for path in zf.namelist():\n    if path.startswith('./'):\n     tgt = os.path.join(out, path[2:])\n    else:\n     tgt = os.path.join(out, path)\n     \n    tgtdir = os.path.dirname(tgt)\n    if not os.path.exists(tgtdir):\n     os.makedirs(tgtdir)\n    with open(tgt, 'wb') as fp:\n     fp.write(zf.read(path))\n     \n elif args[0] == '-c':\n  if len(args) < 3:\n   print(USAGE)\n   sys.exit(1)\n   \n  def addToZip(zf, path, zippath):\n   if os.path.isfile(path):\n    zf.write(path, zippath, ZIP_DEFLATED)\n   elif os.path.isdir(path):\n    for nm in os.listdir(path):\n     addToZip(zf,\n     os.path.join(path, nm), os.path.join(zippath, nm))\n     \n     \n  with ZipFile(args[1], 'w', allowZip64=True) as zf:\n   for src in args[2:]:\n    addToZip(zf, src, os.path.basename(src))\n    \nif __name__ == \"__main__\":\n main()\n"], "textwrap": [".py", "\"\"\n\n\n\n\n\nimport re\n\n__all__ = ['TextWrapper', 'wrap', 'fill', 'dedent', 'indent']\n\n\n\n\n\n\n\n\n\n_whitespace = '\\t\\n\\x0b\\x0c\\r '\n\nclass TextWrapper:\n \"\"\n \n unicode_whitespace_trans = {}\n uspace = ord(' ')\n for x in _whitespace:\n  unicode_whitespace_trans[ord(x)] = uspace\n  \n  \n  \n  \n  \n  \n  \n wordsep_re = re.compile(\n r'(\\s+|' \n r'[^\\s\\w]*\\w+[^0-9\\W]-(?=\\w+[^0-9\\W])|' \n r'(?<=[\\w\\!\\\"\\'\\&\\.\\,\\?])-{2,}(?=\\w))') \n \n \n \n \n \n wordsep_simple_re = re.compile(r'(\\s+)')\n \n \n \n sentence_end_re = re.compile(r'[a-z]' \n r'[\\.\\!\\?]' \n r'[\\\"\\']?' \n r'\\Z') \n \n \n def __init__(self,\n width=70,\n initial_indent=\"\",\n subsequent_indent=\"\",\n expand_tabs=True,\n replace_whitespace=True,\n fix_sentence_endings=False,\n break_long_words=True,\n drop_whitespace=True,\n break_on_hyphens=True,\n tabsize=8):\n  self.width = width\n  self.initial_indent = initial_indent\n  self.subsequent_indent = subsequent_indent\n  self.expand_tabs = expand_tabs\n  self.replace_whitespace = replace_whitespace\n  self.fix_sentence_endings = fix_sentence_endings\n  self.break_long_words = break_long_words\n  self.drop_whitespace = drop_whitespace\n  self.break_on_hyphens = break_on_hyphens\n  self.tabsize = tabsize\n  \n  \n  \n  \n  \n def _munge_whitespace(self, text):\n  \"\"\n  if self.expand_tabs:\n   text = text.expandtabs(self.tabsize)\n  if self.replace_whitespace:\n   text = text.translate(self.unicode_whitespace_trans)\n  return text\n  \n  \n def _split(self, text):\n  \"\"\n  if self.break_on_hyphens is True:\n   chunks = self.wordsep_re.split(text)\n  else:\n   chunks = self.wordsep_simple_re.split(text)\n  chunks = [c for c in chunks if c]\n  return chunks\n  \n def _fix_sentence_endings(self, chunks):\n  \"\"\n  i = 0\n  patsearch = self.sentence_end_re.search\n  while i < len(chunks)-1:\n   if chunks[i+1] == \" \" and patsearch(chunks[i]):\n    chunks[i+1] = \"  \"\n    i += 2\n   else:\n    i += 1\n    \n def _handle_long_word(self, reversed_chunks, cur_line, cur_len, width):\n  \"\"\n  \n  \n  if width < 1:\n   space_left = 1\n  else:\n   space_left = width - cur_len\n   \n   \n   \n  if self.break_long_words:\n   cur_line.append(reversed_chunks[-1][:space_left])\n   reversed_chunks[-1] = reversed_chunks[-1][space_left:]\n   \n   \n   \n   \n  elif not cur_line:\n   cur_line.append(reversed_chunks.pop())\n   \n   \n   \n   \n   \n   \n   \n def _wrap_chunks(self, chunks):\n  \"\"\n  lines = []\n  if self.width <= 0:\n   raise ValueError(\"invalid width %r (must be > 0)\" % self.width)\n   \n   \n   \n  chunks.reverse()\n  \n  while chunks:\n  \n  \n  \n   cur_line = []\n   cur_len = 0\n   \n   \n   if lines:\n    indent = self.subsequent_indent\n   else:\n    indent = self.initial_indent\n    \n    \n   width = self.width - len(indent)\n   \n   \n   \n   if self.drop_whitespace and chunks[-1].strip() == '' and lines:\n    del chunks[-1]\n    \n   while chunks:\n    l = len(chunks[-1])\n    \n    \n    if cur_len + l <= width:\n     cur_line.append(chunks.pop())\n     cur_len += l\n     \n     \n    else:\n     break\n     \n     \n     \n   if chunks and len(chunks[-1]) > width:\n    self._handle_long_word(chunks, cur_line, cur_len, width)\n    \n    \n   if self.drop_whitespace and cur_line and cur_line[-1].strip() == '':\n    del cur_line[-1]\n    \n    \n    \n   if cur_line:\n    lines.append(indent + ''.join(cur_line))\n    \n  return lines\n  \n  \n  \n  \n def wrap(self, text):\n  \"\"\n  text = self._munge_whitespace(text)\n  chunks = self._split(text)\n  if self.fix_sentence_endings:\n   self._fix_sentence_endings(chunks)\n  return self._wrap_chunks(chunks)\n  \n def fill(self, text):\n  \"\"\n  return \"\\n\".join(self.wrap(text))\n  \n  \n  \n  \ndef wrap(text, width=70, **kwargs):\n \"\"\n w = TextWrapper(width=width, **kwargs)\n return w.wrap(text)\n \ndef fill(text, width=70, **kwargs):\n \"\"\n w = TextWrapper(width=width, **kwargs)\n return w.fill(text)\n \n \n \n \n_whitespace_only_re = re.compile('^[ \\t]+$', re.MULTILINE)\n_leading_whitespace_re = re.compile('(^[ \\t]*)(?:[^ \\t\\n])', re.MULTILINE)\n\ndef dedent(text):\n \"\"\n \n \n margin = None\n text = _whitespace_only_re.sub('', text)\n indents = _leading_whitespace_re.findall(text)\n for indent in indents:\n  if margin is None:\n   margin = indent\n   \n   \n   \n  elif indent.startswith(margin):\n   pass\n   \n   \n   \n  elif margin.startswith(indent):\n   margin = indent\n   \n   \n   \n  else:\n   margin = \"\"\n   break\n   \n   \n if 0 and margin:\n  for line in text.split(\"\\n\"):\n   assert not line or line.startswith(margin), \"line = %r, margin = %r\" % (line, margin)\n   \n if margin:\n  text = re.sub(r'(?m)^' + margin, '', text)\n return text\n \n \ndef indent(text, prefix, predicate=None):\n \"\"\n if predicate is None:\n  def predicate(line):\n   return line.strip()\n   \n def prefixed_lines():\n  for line in text.splitlines(True):\n   yield (prefix + line if predicate(line) else line)\n return ''.join(prefixed_lines())\n \n \nif __name__ == \"__main__\":\n\n\n print(dedent(\"Hello there.\\n  This is indented.\"))\n"], "antigravity": [".py", "\nimport webbrowser\nimport hashlib\n\nwebbrowser.open(\"http://xkcd.com/353/\")\n\ndef geohash(latitude, longitude, datedow):\n \"\"\n \n h = hashlib.md5(datedow).hexdigest()\n p, q = [('%f' % float.fromhex('0.' + x)) for x in (h[:16], h[16:32])]\n print('%d%s %d%s' % (latitude, p[1:], longitude, q[1:]))\n"], "collections.abc": [".py", "\n\n\n\"\"\n\nfrom abc import ABCMeta, abstractmethod\nimport sys\n\n__all__ = [\"Hashable\", \"Iterable\", \"Iterator\",\n\"Sized\", \"Container\", \"Callable\",\n\"Set\", \"MutableSet\",\n\"Mapping\", \"MutableMapping\",\n\"MappingView\", \"KeysView\", \"ItemsView\", \"ValuesView\",\n\"Sequence\", \"MutableSequence\",\n\"ByteString\",\n]\n\n\n\n\n\n\n\n\nbytes_iterator = type(iter(b''))\nbytearray_iterator = type(iter(bytearray()))\n\ndict_keyiterator = type(iter({}.keys()))\ndict_valueiterator = type(iter({}.values()))\ndict_itemiterator = type(iter({}.items()))\nlist_iterator = type(iter([]))\nlist_reverseiterator = type(iter(reversed([])))\nrange_iterator = type(iter(range(0)))\nset_iterator = type(iter(set()))\nstr_iterator = type(iter(\"\"))\ntuple_iterator = type(iter(()))\nzip_iterator = type(iter(zip()))\n\ndict_keys = type({}.keys())\ndict_values = type({}.values())\ndict_items = type({}.items())\n\nmappingproxy = type(type.__dict__)\n\n\n\n\nclass Hashable(metaclass=ABCMeta):\n\n __slots__ = ()\n \n @abstractmethod\n def __hash__(self):\n  return 0\n  \n @classmethod\n def __subclasshook__(cls, C):\n  if cls is Hashable:\n   for B in C.__mro__:\n    if \"__hash__\" in B.__dict__:\n     if B.__dict__[\"__hash__\"]:\n      return True\n     break\n  return NotImplemented\n  \n  \nclass Iterable(metaclass=ABCMeta):\n\n __slots__ = ()\n \n @abstractmethod\n def __iter__(self):\n  while False:\n   yield None\n   \n @classmethod\n def __subclasshook__(cls, C):\n  if cls is Iterable:\n   if any(\"__iter__\" in B.__dict__ for B in C.__mro__):\n    return True\n  return NotImplemented\n  \n  \nclass Iterator(Iterable):\n\n __slots__ = ()\n \n @abstractmethod\n def __next__(self):\n  raise StopIteration\n  \n def __iter__(self):\n  return self\n  \n @classmethod\n def __subclasshook__(cls, C):\n  if cls is Iterator:\n   if (any(\"__next__\" in B.__dict__ for B in C.__mro__) and\n   any(\"__iter__\" in B.__dict__ for B in C.__mro__)):\n    return True\n  return NotImplemented\n  \nIterator.register(bytes_iterator)\nIterator.register(bytearray_iterator)\n\nIterator.register(dict_keyiterator)\nIterator.register(dict_valueiterator)\nIterator.register(dict_itemiterator)\nIterator.register(list_iterator)\nIterator.register(list_reverseiterator)\nIterator.register(range_iterator)\nIterator.register(set_iterator)\nIterator.register(str_iterator)\nIterator.register(tuple_iterator)\nIterator.register(zip_iterator)\n\nclass Sized(metaclass=ABCMeta):\n\n __slots__ = ()\n \n @abstractmethod\n def __len__(self):\n  return 0\n  \n @classmethod\n def __subclasshook__(cls, C):\n  if cls is Sized:\n   if any(\"__len__\" in B.__dict__ for B in C.__mro__):\n    return True\n  return NotImplemented\n  \n  \nclass Container(metaclass=ABCMeta):\n\n __slots__ = ()\n \n @abstractmethod\n def __contains__(self, x):\n  return False\n  \n @classmethod\n def __subclasshook__(cls, C):\n  if cls is Container:\n   if any(\"__contains__\" in B.__dict__ for B in C.__mro__):\n    return True\n  return NotImplemented\n  \n  \nclass Callable(metaclass=ABCMeta):\n\n __slots__ = ()\n \n @abstractmethod\n def __call__(self, *args, **kwds):\n  return False\n  \n @classmethod\n def __subclasshook__(cls, C):\n  if cls is Callable:\n   if any(\"__call__\" in B.__dict__ for B in C.__mro__):\n    return True\n  return NotImplemented\n  \n  \n  \n  \n  \nclass Set(Sized, Iterable, Container):\n\n \"\"\n \n __slots__ = ()\n \n def __le__(self, other):\n  if not isinstance(other, Set):\n   return NotImplemented\n  if len(self) > len(other):\n   return False\n  for elem in self:\n   if elem not in other:\n    return False\n  return True\n  \n def __lt__(self, other):\n  if not isinstance(other, Set):\n   return NotImplemented\n  return len(self) < len(other) and self.__le__(other)\n  \n def __gt__(self, other):\n  if not isinstance(other, Set):\n   return NotImplemented\n  return other < self\n  \n def __ge__(self, other):\n  if not isinstance(other, Set):\n   return NotImplemented\n  return other <= self\n  \n def __eq__(self, other):\n  if not isinstance(other, Set):\n   return NotImplemented\n  return len(self) == len(other) and self.__le__(other)\n  \n def __ne__(self, other):\n  return not (self == other)\n  \n @classmethod\n def _from_iterable(cls, it):\n  \"\"\n  return cls(it)\n  \n def __and__(self, other):\n  if not isinstance(other, Iterable):\n   return NotImplemented\n  return self._from_iterable(value for value in other if value in self)\n  \n def isdisjoint(self, other):\n  for value in other:\n   if value in self:\n    return False\n  return True\n  \n def __or__(self, other):\n  if not isinstance(other, Iterable):\n   return NotImplemented\n  chain = (e for s in (self, other) for e in s)\n  return self._from_iterable(chain)\n  \n def __sub__(self, other):\n  if not isinstance(other, Set):\n   if not isinstance(other, Iterable):\n    return NotImplemented\n   other = self._from_iterable(other)\n  return self._from_iterable(value for value in self\n  if value not in other)\n  \n def __xor__(self, other):\n  if not isinstance(other, Set):\n   if not isinstance(other, Iterable):\n    return NotImplemented\n   other = self._from_iterable(other)\n  return (self - other) | (other - self)\n  \n def _hash(self):\n  \"\"\n  MAX = sys.maxsize\n  MASK = 2 * MAX + 1\n  n = len(self)\n  h = 1927868237 * (n + 1)\n  h &= MASK\n  for x in self:\n   hx = hash(x)\n   h ^= (hx ^ (hx << 16) ^ 89869747) * 3644798167\n   h &= MASK\n  h = h * 69069 + 907133923\n  h &= MASK\n  if h > MAX:\n   h -= MASK + 1\n  if h == -1:\n   h = 590923713\n  return h\n  \nSet.register(frozenset)\n\n\nclass MutableSet(Set):\n\n __slots__ = ()\n \n @abstractmethod\n def add(self, value):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def discard(self, value):\n  \"\"\n  raise NotImplementedError\n  \n def remove(self, value):\n  \"\"\n  if value not in self:\n   raise KeyError(value)\n  self.discard(value)\n  \n def pop(self):\n  \"\"\n  it = iter(self)\n  try:\n   value = next(it)\n  except StopIteration:\n   raise KeyError\n  self.discard(value)\n  return value\n  \n def clear(self):\n  \"\"\n  try:\n   while True:\n    self.pop()\n  except KeyError:\n   pass\n   \n def __ior__(self, it):\n  for value in it:\n   self.add(value)\n  return self\n  \n def __iand__(self, it):\n  for value in (self - it):\n   self.discard(value)\n  return self\n  \n def __ixor__(self, it):\n  if it is self:\n   self.clear()\n  else:\n   if not isinstance(it, Set):\n    it = self._from_iterable(it)\n   for value in it:\n    if value in self:\n     self.discard(value)\n    else:\n     self.add(value)\n  return self\n  \n def __isub__(self, it):\n  if it is self:\n   self.clear()\n  else:\n   for value in it:\n    self.discard(value)\n  return self\n  \nMutableSet.register(set)\n\n\n\n\n\nclass Mapping(Sized, Iterable, Container):\n\n __slots__ = ()\n \n @abstractmethod\n def __getitem__(self, key):\n  raise KeyError\n  \n def get(self, key, default=None):\n  try:\n   return self[key]\n  except KeyError:\n   return default\n   \n def __contains__(self, key):\n  try:\n   self[key]\n  except KeyError:\n   return False\n  else:\n   return True\n   \n def keys(self):\n  return KeysView(self)\n  \n def items(self):\n  return ItemsView(self)\n  \n def values(self):\n  return ValuesView(self)\n  \n def __eq__(self, other):\n  if not isinstance(other, Mapping):\n   return NotImplemented\n  return dict(self.items()) == dict(other.items())\n  \n def __ne__(self, other):\n  return not (self == other)\n  \nMapping.register(mappingproxy)\n\n\nclass MappingView(Sized):\n\n def __init__(self, mapping):\n  self._mapping = mapping\n  \n def __len__(self):\n  return len(self._mapping)\n  \n def __repr__(self):\n  return '{0.__class__.__name__}({0._mapping!r})'.format(self)\n  \n  \nclass KeysView(MappingView, Set):\n\n @classmethod\n def _from_iterable(self, it):\n  return set(it)\n  \n def __contains__(self, key):\n  return key in self._mapping\n  \n def __iter__(self):\n  for key in self._mapping:\n   yield key\n   \nKeysView.register(dict_keys)\n\n\nclass ItemsView(MappingView, Set):\n\n @classmethod\n def _from_iterable(self, it):\n  return set(it)\n  \n def __contains__(self, item):\n  key, value = item\n  try:\n   v = self._mapping[key]\n  except KeyError:\n   return False\n  else:\n   return v == value\n   \n def __iter__(self):\n  for key in self._mapping:\n   yield (key, self._mapping[key])\n   \nItemsView.register(dict_items)\n\n\nclass ValuesView(MappingView):\n\n def __contains__(self, value):\n  for key in self._mapping:\n   if value == self._mapping[key]:\n    return True\n  return False\n  \n def __iter__(self):\n  for key in self._mapping:\n   yield self._mapping[key]\n   \nValuesView.register(dict_values)\n\n\nclass MutableMapping(Mapping):\n\n __slots__ = ()\n \n @abstractmethod\n def __setitem__(self, key, value):\n  raise KeyError\n  \n @abstractmethod\n def __delitem__(self, key):\n  raise KeyError\n  \n __marker = object()\n \n def pop(self, key, default=__marker):\n  try:\n   value = self[key]\n  except KeyError:\n   if default is self.__marker:\n    raise\n   return default\n  else:\n   del self[key]\n   return value\n   \n def popitem(self):\n  try:\n   key = next(iter(self))\n  except StopIteration:\n   raise KeyError\n  value = self[key]\n  del self[key]\n  return key, value\n  \n def clear(self):\n  try:\n   while True:\n    self.popitem()\n  except KeyError:\n   pass\n   \n def update(*args, **kwds):\n  if len(args) > 2:\n   raise TypeError(\"update() takes at most 2 positional \"\n   \"arguments ({} given)\".format(len(args)))\n  elif not args:\n   raise TypeError(\"update() takes at least 1 argument (0 given)\")\n  self = args[0]\n  other = args[1] if len(args) >= 2 else ()\n  \n  if isinstance(other, Mapping):\n   for key in other:\n    self[key] = other[key]\n  elif hasattr(other, \"keys\"):\n   for key in other.keys():\n    self[key] = other[key]\n  else:\n   for key, value in other:\n    self[key] = value\n  for key, value in kwds.items():\n   self[key] = value\n   \n def setdefault(self, key, default=None):\n  try:\n   return self[key]\n  except KeyError:\n   self[key] = default\n  return default\n  \nMutableMapping.register(dict)\n\n\n\n\n\nclass Sequence(Sized, Iterable, Container):\n\n \"\"\n \n __slots__ = ()\n \n @abstractmethod\n def __getitem__(self, index):\n  raise IndexError\n  \n def __iter__(self):\n  i = 0\n  try:\n   while True:\n    v = self[i]\n    yield v\n    i += 1\n  except IndexError:\n   return\n   \n def __contains__(self, value):\n  for v in self:\n   if v == value:\n    return True\n  return False\n  \n def __reversed__(self):\n  for i in reversed(range(len(self))):\n   yield self[i]\n   \n def index(self, value):\n  for i, v in enumerate(self):\n   if v == value:\n    return i\n  raise ValueError\n  \n def count(self, value):\n  return sum(1 for v in self if v == value)\n  \nSequence.register(tuple)\nSequence.register(str)\nSequence.register(range)\n\n\nclass ByteString(Sequence):\n\n \"\"\n \n __slots__ = ()\n \nByteString.register(bytes)\nByteString.register(bytearray)\n\n\nclass MutableSequence(Sequence):\n\n __slots__ = ()\n \n @abstractmethod\n def __setitem__(self, index, value):\n  raise IndexError\n  \n @abstractmethod\n def __delitem__(self, index):\n  raise IndexError\n  \n @abstractmethod\n def insert(self, index, value):\n  raise IndexError\n  \n def append(self, value):\n  self.insert(len(self), value)\n  \n def clear(self):\n  try:\n   while True:\n    self.pop()\n  except IndexError:\n   pass\n   \n def reverse(self):\n  n = len(self)\n  for i in range(n//2):\n   self[i], self[n-i-1] = self[n-i-1], self[i]\n   \n def extend(self, values):\n  for v in values:\n   self.append(v)\n   \n def pop(self, index=-1):\n  v = self[index]\n  del self[index]\n  return v\n  \n def remove(self, value):\n  del self[self.index(value)]\n  \n def __iadd__(self, values):\n  self.extend(values)\n  return self\n  \nMutableSequence.register(list)\nMutableSequence.register(bytearray) \n"], "importlib.abc": [".py", "\"\"\nfrom . import _bootstrap\nfrom . import machinery\ntry:\n import _frozen_importlib\nexcept ImportError as exc:\n if exc.name != '_frozen_importlib':\n  raise\n _frozen_importlib = None\nimport abc\nimport imp\nimport marshal\nimport sys\nimport tokenize\nimport warnings\n\n\ndef _register(abstract_cls, *classes):\n for cls in classes:\n  abstract_cls.register(cls)\n  if _frozen_importlib is not None:\n   frozen_cls = getattr(_frozen_importlib, cls.__name__)\n   abstract_cls.register(frozen_cls)\n   \n   \nclass Finder(metaclass=abc.ABCMeta):\n\n \"\"\n \n @abc.abstractmethod\n def find_module(self, fullname, path=None):\n  \"\"\n  raise NotImplementedError\n  \n  \nclass MetaPathFinder(Finder):\n\n \"\"\n \n @abc.abstractmethod\n def find_module(self, fullname, path):\n  \"\"\n  raise NotImplementedError\n  \n def invalidate_caches(self):\n  \"\"\n  return NotImplemented\n  \n_register(MetaPathFinder, machinery.BuiltinImporter, machinery.FrozenImporter,\nmachinery.PathFinder, machinery.WindowsRegistryFinder)\n\n\nclass PathEntryFinder(Finder):\n\n \"\"\n \n @abc.abstractmethod\n def find_loader(self, fullname):\n  \"\"\n  raise NotImplementedError\n  \n find_module = _bootstrap._find_module_shim\n \n def invalidate_caches(self):\n  \"\"\n  return NotImplemented\n  \n_register(PathEntryFinder, machinery.FileFinder)\n\n\nclass Loader(metaclass=abc.ABCMeta):\n\n \"\"\n \n @abc.abstractmethod\n def load_module(self, fullname):\n  \"\"\n  raise NotImplementedError\n  \n @abc.abstractmethod\n def module_repr(self, module):\n  \"\"\n  raise NotImplementedError\n  \n  \nclass ResourceLoader(Loader):\n\n \"\"\n \n @abc.abstractmethod\n def get_data(self, path):\n  \"\"\n  raise NotImplementedError\n  \n  \nclass InspectLoader(Loader):\n\n \"\"\n \n @abc.abstractmethod\n def is_package(self, fullname):\n  \"\"\n  raise NotImplementedError\n  \n @abc.abstractmethod\n def get_code(self, fullname):\n  \"\"\n  raise NotImplementedError\n  \n @abc.abstractmethod\n def get_source(self, fullname):\n  \"\"\n  raise NotImplementedError\n  \n_register(InspectLoader, machinery.BuiltinImporter, machinery.FrozenImporter,\nmachinery.ExtensionFileLoader)\n\n\nclass ExecutionLoader(InspectLoader):\n\n \"\"\n \n @abc.abstractmethod\n def get_filename(self, fullname):\n  \"\"\n  raise NotImplementedError\n  \n  \nclass FileLoader(_bootstrap.FileLoader, ResourceLoader, ExecutionLoader):\n\n \"\"\n \n_register(FileLoader, machinery.SourceFileLoader,\nmachinery.SourcelessFileLoader)\n\n\nclass SourceLoader(_bootstrap.SourceLoader, ResourceLoader, ExecutionLoader):\n\n \"\"\n \n def path_mtime(self, path):\n  \"\"\n  if self.path_stats.__func__ is SourceLoader.path_stats:\n   raise NotImplementedError\n  return int(self.path_stats(path)['mtime'])\n  \n def path_stats(self, path):\n  \"\"\n  if self.path_mtime.__func__ is SourceLoader.path_mtime:\n   raise NotImplementedError\n  return {'mtime': self.path_mtime(path)}\n  \n def set_data(self, path, data):\n  \"\"\n  raise NotImplementedError\n  \n_register(SourceLoader, machinery.SourceFileLoader)\n\nclass PyLoader(SourceLoader):\n\n \"\"\n \n @abc.abstractmethod\n def is_package(self, fullname):\n  raise NotImplementedError\n  \n @abc.abstractmethod\n def source_path(self, fullname):\n  \"\"\n  raise NotImplementedError\n  \n def get_filename(self, fullname):\n  \"\"\n  warnings.warn(\"importlib.abc.PyLoader is deprecated and is \"\n  \"slated for removal in Python 3.4; \"\n  \"use SourceLoader instead. \"\n  \"See the importlib documentation on how to be \"\n  \"compatible with Python 3.1 onwards.\",\n  DeprecationWarning)\n  path = self.source_path(fullname)\n  if path is None:\n   raise ImportError(name=fullname)\n  else:\n   return path\n   \n   \nclass PyPycLoader(PyLoader):\n\n \"\"\n \n def get_filename(self, fullname):\n  \"\"\n  path = self.source_path(fullname)\n  if path is not None:\n   return path\n  path = self.bytecode_path(fullname)\n  if path is not None:\n   return path\n  raise ImportError(\"no source or bytecode path available for \"\n  \"{0!r}\".format(fullname), name=fullname)\n  \n def get_code(self, fullname):\n  \"\"\n  warnings.warn(\"importlib.abc.PyPycLoader is deprecated and slated for \"\n  \"removal in Python 3.4; use SourceLoader instead. \"\n  \"If Python 3.1 compatibility is required, see the \"\n  \"latest documentation for PyLoader.\",\n  DeprecationWarning)\n  source_timestamp = self.source_mtime(fullname)\n  \n  bytecode_path = self.bytecode_path(fullname)\n  if bytecode_path:\n   data = self.get_data(bytecode_path)\n   try:\n    magic = data[:4]\n    if len(magic) < 4:\n     raise ImportError(\n     \"bad magic number in {}\".format(fullname),\n     name=fullname, path=bytecode_path)\n    raw_timestamp = data[4:8]\n    if len(raw_timestamp) < 4:\n     raise EOFError(\"bad timestamp in {}\".format(fullname))\n    pyc_timestamp = _bootstrap._r_long(raw_timestamp)\n    raw_source_size = data[8:12]\n    if len(raw_source_size) != 4:\n     raise EOFError(\"bad file size in {}\".format(fullname))\n     \n     \n    bytecode = data[12:]\n    \n    if imp.get_magic() != magic:\n     raise ImportError(\n     \"bad magic number in {}\".format(fullname),\n     name=fullname, path=bytecode_path)\n     \n     \n    if source_timestamp:\n     if pyc_timestamp < source_timestamp:\n      raise ImportError(\"bytecode is stale\", name=fullname,\n      path=bytecode_path)\n   except (ImportError, EOFError):\n   \n    if source_timestamp is not None:\n     pass\n    else:\n     raise\n   else:\n   \n    return marshal.loads(bytecode)\n  elif source_timestamp is None:\n   raise ImportError(\"no source or bytecode available to create code \"\n   \"object for {0!r}\".format(fullname),\n   name=fullname)\n   \n  source_path = self.source_path(fullname)\n  if source_path is None:\n   message = \"a source path must exist to load {0}\".format(fullname)\n   raise ImportError(message, name=fullname)\n  source = self.get_data(source_path)\n  code_object = compile(source, source_path, 'exec', dont_inherit=True)\n  \n  if not sys.dont_write_bytecode:\n   data = bytearray(imp.get_magic())\n   data.extend(_bootstrap._w_long(source_timestamp))\n   data.extend(_bootstrap._w_long(len(source) & 0xFFFFFFFF))\n   data.extend(marshal.dumps(code_object))\n   self.write_bytecode(fullname, data)\n  return code_object\n  \n @abc.abstractmethod\n def source_mtime(self, fullname):\n  \"\"\n  raise NotImplementedError\n  \n @abc.abstractmethod\n def bytecode_path(self, fullname):\n  \"\"\n  raise NotImplementedError\n  \n @abc.abstractmethod\n def write_bytecode(self, fullname, bytecode):\n  \"\"\n  raise NotImplementedError\n"], "site-packages.pygame.draw": [".py", "from javascript import console\nfrom browser import timer\nimport math\n\nclass Queue:\n def __init__(self):\n  self._list=[]\n  \n def empty(self):\n  return len(self._list) == 0\n  \n def put(self, element):\n  self._list.append(element)\n  \n def get(self):\n  if len(self._list) == 0:\n   raise BaseError\n   \n  _element=self._list[0]\n  if len(self._list) == 1:\n   self._list=[]\n  else:\n   self._list=self._list[1:]\n   \n  return _element\n  \ndm={}\n\ndef aaline(canvas, color, startpos, endpos, width, outline, blend=1):\n\n if canvas not in dm:\n  dm[canvas]=DrawManager(canvas)\n  dm[canvas].process()\n  \n _dl=DrawLine(startpos[0], startpos[1], endpos[0], endpos[1], color, \n width, outline, speed=10)\n dm[canvas].add_line(_dl) \n \ndef aapolygon(canvas, color, coordinates, width, outline, blend=1):\n\n if canvas not in dm:\n  dm[canvas]=DrawManager(canvas)\n  dm[canvas].process()\n  \n _dp=DrawPolygon(coordinates, color, width, outline, speed=10)\n dm[canvas].add_polygon(_dp)\n \ndef aapolygon_bg(canvas, shape):\n if canvas not in dm:\n  dm[canvas]=DrawManager(canvas)\n  dm[canvas].process()\n  \n dm[canvas].add_polygon_bg(shape) \n \nclass DrawPolygon:\n def __init__(self, coordinates, color, width, outline, speed=10):\n  self.moveTo=coordinates[0]\n  self.segments=coordinates[1:]\n  self.color=color\n  self.width=width\n  self.outline=outline\n  \nclass DrawLine:\n def __init__(self, x0, y0, x1, y1, color, width, outline, speed=None):\n  self._type='LINE'\n  self._x0=x0\n  self._x1=x1\n  self._y0=y0\n  self._y1=y1\n  \n  self._speed=speed\n  self._color=color\n  self._width=width\n  self._outline=outline\n  \n def get_segments(self):\n  if self._speed==0: \n   return [{'type': self._type, 'x0':self._x0, 'y0': self._y0,\n   'x1': self._x1, 'y1': self._y1, 'color': self._color}]\n   \n   \n   \n  _x=(self._x1 - self._x0)\n  _x*=_x\n  \n  _y=(self._y1 - self._y0)\n  _y*=_y\n  \n  _distance=math.sqrt(_x + _y)\n  \n  if _distance < self._speed: \n   return [{'type': self._type, 'x0':self._x0, 'y0': self._y0,\n   'x1': self._x1, 'y1': self._y1, 'color': self._color}]\n   \n  _segments=[]\n  _num_segments=math.floor(_distance/self._speed)\n  _pos_x=self._x0\n  _pos_y=self._y0\n  _x_diff=self._x1 - self._x0\n  _y_diff=self._y1 - self._y0\n  for _i in range(1,_num_segments+1):\n   _x=self._x0 + _i/_num_segments * _x_diff\n   _y=self._y0 + _i/_num_segments * _y_diff\n   \n   _segments.append({'type': 'LINE': 'x0': _pos_x, 'y0': _pos_y,\n   'x1': _x, 'y1': _y, 'color': self._color})\n   \n   _pos_x=_x\n   _pos_y=_y\n   \n  if _pos_x != self._x1 or _pos_y != self._y1:\n   _segments.append({'type': 'LINE': 'x0': _pos_x, 'y0': _pos_y,\n   'x1': _x, 'y1': _y, 'color': self._color})\n   \n  return _segments\n  \nclass DrawManager:\n def __init__(self, canvas):\n  self._queue=Queue()\n  self._canvas=canvas\n  self._ctx=canvas.getContext('2d')\n  self._interval=None\n  \n  self._bg=None \n  \n def __del__(self):\n  if self._interval is not None:\n   timer.clear_Interval(self._interval)\n   self._interval=None\n   \n  del self._queue\n  \n def rect_from_shape(self, points):\n  _width=self._canvas.width\n  _height=self._canvas.height\n  _min_x=_width\n  _max_x=0\n  _min_y=_height\n  _max_y=0\n  \n  for _point in points:\n   _x, _y = _point\n   _min_x=min(_min_x, _x)\n   _min_y=min(_min_y, _y)\n   _max_x=max(_max_x, _x)\n   _max_y=max(_max_y, _y)\n   \n  _w2=_width/2\n  _h2=_height/2\n  return math.floor(_min_x-0.5)+_w2, math.floor(_min_y-0.5+_h2), math.ceil(_max_x+0.5)+_w2, math.ceil(_max_y+0.5+_h2)\n  \n def __interval(self):\n  if not self._queue.empty():\n   _dict=self._queue.get()\n   \n   if _dict['type'] == 'LINE':\n    self._ctx.beginPath()\n    self._ctx.moveTo(_dict['x0'], _dict['y0'])\n    self._ctx.lineTo(_dict['x1'], _dict['y1'])\n    \n    \n    if _dict['color'] is not None:\n     self._ctx.fillStyle=_dict['color']\n    self._ctx.stroke()\n   elif _dict['type'] == 'POLYGON':\n    if self._bg is not None:\n     self._ctx.putImageData(self._bg[0], self._bg[1], self._bg[2])\n     console.log(self._bg[0])\n     self._bg=None\n     \n    self._ctx.beginPath()\n    _moveTo=_dict['moveTo']\n    self._ctx.moveTo(_moveTo[0], _moveTo[1])\n    for _segment in _dict['segments']:\n     self._ctx.lineTo(_segment[0], _segment[1])\n     \n    if _dict['width']:\n     self._ctx.lineWidth=_dict['width']\n    if _dict['outline']:\n     self._ctx.strokeStyle=_dict['outline']\n    if _dict['color']:\n     self._ctx.fillStyle=_dict['color']\n     self._ctx.fill() \n     \n    self._ctx.closePath()\n    self._ctx.stroke()\n   elif _dict['type'] == 'POLYGON_BG':\n    _x0,_y0,_x1,_y1=self.rect_from_shape(_dict['shape'])\n    console.log(_x0,_y0,_x1, _y1)\n    self._bg=[]\n    self._bg.append(self._ctx.getImageData(_x0,_y0,abs(_x1)-abs(_x0),abs(_y1)-abs(_y0)))\n    self._bg.append(_x0)\n    self._bg.append(_y0)\n    \n def process(self):\n  self._interval=timer.set_interval(self.__interval, 10)\n  \n def add_line(self, dl): \n  for _segment in dl.get_segments():\n   self._queue.put(_segment)\n   \n def add_polygon(self, dp):\n  self._queue.put({'type': 'POLYGON', 'moveTo': dp.moveTo,\n  'segments': dp.segments, 'color': dp.color,\n  'outline': dp.outline, 'width': dp.width})\n  \n def add_polygon_bg(self, shape):\n  self._queue.put({'type': 'POLYGON_BG', 'shape': shape})\n"], "xml.sax._exceptions": [".py", "\"\"\n\n\n\n\n\n\n\n\nclass SAXException(Exception):\n \"\"\n \n def __init__(self, msg, exception=None):\n  \"\"\n  self._msg = msg\n  self._exception = exception\n  Exception.__init__(self, msg)\n  \n def getMessage(self):\n  \"\"\n  return self._msg\n  \n def getException(self):\n  \"\"\n  return self._exception\n  \n def __str__(self):\n  \"\"\n  return self._msg\n  \n def __getitem__(self, ix):\n  \"\"\n  raise AttributeError(\"__getitem__\")\n  \n  \n  \n  \nclass SAXParseException(SAXException):\n \"\"\n \n def __init__(self, msg, exception, locator):\n  \"\"\n  SAXException.__init__(self, msg, exception)\n  self._locator = locator\n  \n  \n  \n  \n  \n  self._systemId = self._locator.getSystemId()\n  self._colnum = self._locator.getColumnNumber()\n  self._linenum = self._locator.getLineNumber()\n  \n def getColumnNumber(self):\n  \"\"\n  return self._colnum\n  \n def getLineNumber(self):\n  \"\"\n  return self._linenum\n  \n def getPublicId(self):\n  \"\"\n  return self._locator.getPublicId()\n  \n def getSystemId(self):\n  \"\"\n  return self._systemId\n  \n def __str__(self):\n  \"\"\n  sysid = self.getSystemId()\n  if sysid is None:\n   sysid = \"<unknown>\"\n  linenum = self.getLineNumber()\n  if linenum is None:\n   linenum = \"?\"\n  colnum = self.getColumnNumber()\n  if colnum is None:\n   colnum = \"?\"\n  return \"%s:%s:%s: %s\" % (sysid, linenum, colnum, self._msg)\n  \n  \n  \n  \nclass SAXNotRecognizedException(SAXException):\n \"\"\n pass\n \n \n \n \nclass SAXNotSupportedException(SAXException):\n \"\"\n \n pass\n \n \nclass SAXReaderNotAvailable(SAXNotSupportedException):\n \"\"\n \n pass\n"], "ui": [".py", "from browser import html, document\nfrom .dialog import *\nfrom .progressbar import *\nfrom .slider import *\n\ndef add_stylesheet():\n _link=html.LINK(Href='/src/Lib/ui/css/smoothness/jquery-ui-1.10.3.custom.min.css')\n _link.rel='stylesheet'\n \n document <= _link\n", 1], "datetime": [".py", "\"\"\n\nimport time as _time\nimport math as _math\n\ndef _cmp(x, y):\n return 0 if x == y else 1 if x > y else -1\n \nMINYEAR = 1\nMAXYEAR = 9999\n_MAXORDINAL = 3652059 \n\n\n\n\n\n\n\n\n\n\n_DAYS_IN_MONTH = [None, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n_DAYS_BEFORE_MONTH = [None]\ndbm = 0\nfor dim in _DAYS_IN_MONTH[1:]:\n _DAYS_BEFORE_MONTH.append(dbm)\n dbm += dim\ndel dbm, dim\n\ndef _is_leap(year):\n \"\"\n return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n \ndef _days_before_year(year):\n \"\"\n y = year - 1\n return y*365 + y//4 - y//100 + y//400\n \ndef _days_in_month(year, month):\n \"\"\n assert 1 <= month <= 12, month\n if month == 2 and _is_leap(year):\n  return 29\n return _DAYS_IN_MONTH[month]\n \ndef _days_before_month(year, month):\n \"\"\n assert 1 <= month <= 12, 'month must be in 1..12'\n return _DAYS_BEFORE_MONTH[month] + (month > 2 and _is_leap(year))\n \ndef _ymd2ord(year, month, day):\n \"\"\n assert 1 <= month <= 12, 'month must be in 1..12'\n dim = _days_in_month(year, month)\n assert 1 <= day <= dim, ('day must be in 1..%d' % dim)\n return (_days_before_year(year) +\n _days_before_month(year, month) +\n day)\n \n_DI400Y = _days_before_year(401) \n_DI100Y = _days_before_year(101) \n_DI4Y = _days_before_year(5) \n\n\n\nassert _DI4Y == 4 * 365 + 1\n\n\n\nassert _DI400Y == 4 * _DI100Y + 1\n\n\n\nassert _DI100Y == 25 * _DI4Y - 1\n\ndef _ord2ymd(n):\n \"\"\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n n -= 1\n n400, n = divmod(n, _DI400Y)\n year = n400 * 400 + 1 \n \n \n \n \n \n \n n100, n = divmod(n, _DI100Y)\n \n \n n4, n = divmod(n, _DI4Y)\n \n \n \n n1, n = divmod(n, 365)\n \n year += n100 * 100 + n4 * 4 + n1\n if n1 == 4 or n100 == 4:\n  assert n == 0\n  return year-1, 12, 31\n  \n  \n  \n leapyear = n1 == 3 and (n4 != 24 or n100 == 3)\n assert leapyear == _is_leap(year)\n month = (n + 50) >> 5\n preceding = _DAYS_BEFORE_MONTH[month] + (month > 2 and leapyear)\n if preceding > n: \n  month -= 1\n  preceding -= _DAYS_IN_MONTH[month] + (month == 2 and leapyear)\n n -= preceding\n assert 0 <= n < _days_in_month(year, month)\n \n \n \n return year, month, n+1\n \n \n_MONTHNAMES = [None, \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n_DAYNAMES = [None, \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"]\n\n\ndef _build_struct_time(y, m, d, hh, mm, ss, dstflag):\n wday = (_ymd2ord(y, m, d) + 6) % 7\n dnum = _days_before_month(y, m) + d\n return _time.struct_time((y, m, d, hh, mm, ss, wday, dnum, dstflag))\n \ndef _format_time(hh, mm, ss, us):\n\n result = \"%02d:%02d:%02d\" % (hh, mm, ss)\n if us:\n  result += \".%06d\" % us\n return result\n \n \ndef _wrap_strftime(object, format, timetuple):\n\n freplace = None \n zreplace = None \n Zreplace = None \n \n \n newformat = []\n push = newformat.append\n i, n = 0, len(format)\n while i < n:\n  ch = format[i]\n  i += 1\n  if ch == '%':\n   if i < n:\n    ch = format[i]\n    i += 1\n    if ch == 'f':\n     if freplace is None:\n      freplace = '%06d' % getattr(object,\n      'microsecond', 0)\n     newformat.append(freplace)\n    elif ch == 'z':\n     if zreplace is None:\n      zreplace = \"\"\n      if hasattr(object, \"utcoffset\"):\n       offset = object.utcoffset()\n       if offset is not None:\n        sign = '+'\n        if offset.days < 0:\n         offset = -offset\n         sign = '-'\n        h, m = divmod(offset, timedelta(hours=1))\n        assert not m % timedelta(minutes=1), \"whole minute\"\n        m //= timedelta(minutes=1)\n        zreplace = '%c%02d%02d' % (sign, h, m)\n     assert '%' not in zreplace\n     newformat.append(zreplace)\n    elif ch == 'Z':\n     if Zreplace is None:\n      Zreplace = \"\"\n      if hasattr(object, \"tzname\"):\n       s = object.tzname()\n       if s is not None:\n       \n        Zreplace = s.replace('%', '%%')\n     newformat.append(Zreplace)\n    else:\n     push('%')\n     push(ch)\n   else:\n    push('%')\n  else:\n   push(ch)\n newformat = \"\".join(newformat)\n return _time.strftime(newformat, timetuple)\n \ndef _call_tzinfo_method(tzinfo, methname, tzinfoarg):\n if tzinfo is None:\n  return None\n return getattr(tzinfo, methname)(tzinfoarg)\n \n \ndef _check_tzname(name):\n if name is not None and not isinstance(name, str):\n  raise TypeError(\"tzinfo.tzname() must return None or string, \"\n  \"not '%s'\" % type(name))\n  \n  \n  \n  \n  \n  \n  \ndef _check_utc_offset(name, offset):\n assert name in (\"utcoffset\", \"dst\")\n if offset is None:\n  return\n if not isinstance(offset, timedelta):\n  raise TypeError(\"tzinfo.%s() must return None \"\n  \"or timedelta, not '%s'\" % (name, type(offset)))\n if offset % timedelta(minutes=1) or offset.microseconds:\n  raise ValueError(\"tzinfo.%s() must return a whole number \"\n  \"of minutes, got %s\" % (name, offset))\n if not -timedelta(1) < offset < timedelta(1):\n  raise ValueError(\"%s()=%s, must be must be strictly between\"\n  \" -timedelta(hours=24) and timedelta(hours=24)\"\n  % (name, offset))\n  \ndef _check_date_fields(year, month, day):\n if not isinstance(year, int):\n  raise TypeError('int expected')\n if not MINYEAR <= year <= MAXYEAR:\n  raise ValueError('year must be in %d..%d' % (MINYEAR, MAXYEAR), year)\n if not 1 <= month <= 12:\n  raise ValueError('month must be in 1..12', month)\n dim = _days_in_month(year, month)\n if not 1 <= day <= dim:\n  raise ValueError('day must be in 1..%d' % dim, day)\n  \ndef _check_time_fields(hour, minute, second, microsecond):\n if not isinstance(hour, int):\n  raise TypeError('int expected')\n if not 0 <= hour <= 23:\n  raise ValueError('hour must be in 0..23', hour)\n if not 0 <= minute <= 59:\n  raise ValueError('minute must be in 0..59', minute)\n if not 0 <= second <= 59:\n  raise ValueError('second must be in 0..59', second)\n if not 0 <= microsecond <= 999999:\n  raise ValueError('microsecond must be in 0..999999', microsecond)\n  \ndef _check_tzinfo_arg(tz):\n if tz is not None and not isinstance(tz, tzinfo):\n  raise TypeError(\"tzinfo argument must be None or of a tzinfo subclass\")\n  \ndef _cmperror(x, y):\n raise TypeError(\"can't compare '%s' to '%s'\" % (\n type(x).__name__, type(y).__name__))\n \nclass timedelta:\n \"\"\n __slots__ = '_days', '_seconds', '_microseconds'\n \n def __new__(cls, days=0, seconds=0, microseconds=0,\n milliseconds=0, minutes=0, hours=0, weeks=0):\n \n \n \n \n \n \n \n \n \n \n \n \n  d = s = us = 0\n  \n  \n  days += weeks*7\n  seconds += minutes*60 + hours*3600\n  microseconds += milliseconds*1000\n  \n  \n  \n  if isinstance(days, float):\n   dayfrac, days = _math.modf(days)\n   daysecondsfrac, daysecondswhole = _math.modf(dayfrac * (24.*3600.))\n   assert daysecondswhole == int(daysecondswhole) \n   s = int(daysecondswhole)\n   assert days == int(days)\n   d = int(days)\n  else:\n   daysecondsfrac = 0.0\n   d = days\n  assert isinstance(daysecondsfrac, float)\n  assert abs(daysecondsfrac) <= 1.0\n  assert isinstance(d, int)\n  assert abs(s) <= 24 * 3600\n  \n  \n  if isinstance(seconds, float):\n   secondsfrac, seconds = _math.modf(seconds)\n   assert seconds == int(seconds)\n   seconds = int(seconds)\n   secondsfrac += daysecondsfrac\n   assert abs(secondsfrac) <= 2.0\n  else:\n   secondsfrac = daysecondsfrac\n   \n  assert isinstance(secondsfrac, float)\n  assert abs(secondsfrac) <= 2.0\n  \n  assert isinstance(seconds, int)\n  days, seconds = divmod(seconds, 24*3600)\n  d += days\n  s += int(seconds) \n  assert isinstance(s, int)\n  assert abs(s) <= 2 * 24 * 3600\n  \n  \n  usdouble = secondsfrac * 1e6\n  assert abs(usdouble) < 2.1e6 \n  \n  \n  if isinstance(microseconds, float):\n   microseconds += usdouble\n   microseconds = round(microseconds, 0)\n   seconds, microseconds = divmod(microseconds, 1e6)\n   assert microseconds == int(microseconds)\n   assert seconds == int(seconds)\n   days, seconds = divmod(seconds, 24.*3600.)\n   assert days == int(days)\n   assert seconds == int(seconds)\n   d += int(days)\n   s += int(seconds) \n   assert isinstance(s, int)\n   assert abs(s) <= 3 * 24 * 3600\n  else:\n   seconds, microseconds = divmod(microseconds, 1000000)\n   days, seconds = divmod(seconds, 24*3600)\n   d += days\n   s += int(seconds) \n   assert isinstance(s, int)\n   assert abs(s) <= 3 * 24 * 3600\n   microseconds = float(microseconds)\n   microseconds += usdouble\n   microseconds = round(microseconds, 0)\n  assert abs(s) <= 3 * 24 * 3600\n  assert abs(microseconds) < 3.1e6\n  \n  \n  assert isinstance(microseconds, float)\n  assert int(microseconds) == microseconds\n  us = int(microseconds)\n  seconds, us = divmod(us, 1000000)\n  s += seconds \n  assert isinstance(s, int)\n  days, s = divmod(s, 24*3600)\n  d += days\n  \n  assert isinstance(d, int)\n  assert isinstance(s, int) and 0 <= s < 24*3600\n  assert isinstance(us, int) and 0 <= us < 1000000\n  \n  self = object.__new__(cls)\n  \n  self._days = d\n  self._seconds = s\n  self._microseconds = us\n  if abs(d) > 999999999:\n   raise OverflowError(\"timedelta # of days is too large: %d\" % d)\n   \n  return self\n  \n def __repr__(self):\n  if self._microseconds:\n   return \"%s(%d, %d, %d)\" % ('datetime.' + self.__class__.__name__,\n   self._days,\n   self._seconds,\n   self._microseconds)\n  if self._seconds:\n   return \"%s(%d, %d)\" % ('datetime.' + self.__class__.__name__,\n   self._days,\n   self._seconds)\n  return \"%s(%d)\" % ('datetime.' + self.__class__.__name__, self._days)\n  \n def __str__(self):\n  mm, ss = divmod(self._seconds, 60)\n  hh, mm = divmod(mm, 60)\n  s = \"%d:%02d:%02d\" % (hh, mm, ss)\n  if self._days:\n   def plural(n):\n    return n, abs(n) != 1 and \"s\" or \"\"\n   s = (\"%d day%s, \" % plural(self._days)) + s\n  if self._microseconds:\n   s = s + \".%06d\" % self._microseconds\n  return s\n  \n def total_seconds(self):\n  \"\"\n  return ((self.days * 86400 + self.seconds)*10**6 +\n  self.microseconds) / 10**6\n  \n  \n @property\n def days(self):\n  \"\"\n  return self._days\n  \n @property\n def seconds(self):\n  \"\"\n  return self._seconds\n  \n @property\n def microseconds(self):\n  \"\"\n  return self._microseconds\n  \n def __add__(self, other):\n  if isinstance(other, timedelta):\n  \n  \n   return timedelta(self._days + other._days,\n   self._seconds + other._seconds,\n   self._microseconds + other._microseconds)\n  return NotImplemented\n  \n __radd__ = __add__\n \n def __sub__(self, other):\n  if isinstance(other, timedelta):\n  \n  \n   return timedelta(self._days - other._days,\n   self._seconds - other._seconds,\n   self._microseconds - other._microseconds)\n  return NotImplemented\n  \n def __rsub__(self, other):\n  if isinstance(other, timedelta):\n   return -self + other\n  return NotImplemented\n  \n def __neg__(self):\n \n \n  return timedelta(-self._days,\n  -self._seconds,\n  -self._microseconds)\n  \n def __pos__(self):\n  return self\n  \n def __abs__(self):\n  if self._days < 0:\n   return -self\n  else:\n   return self\n   \n def __mul__(self, other):\n  if isinstance(other, int):\n  \n  \n   return timedelta(self._days * other,\n   self._seconds * other,\n   self._microseconds * other)\n  if isinstance(other, float):\n   a, b = other.as_integer_ratio()\n   return self * a / b\n  return NotImplemented\n  \n __rmul__ = __mul__\n \n def _to_microseconds(self):\n  return ((self._days * (24*3600) + self._seconds) * 1000000 +\n  self._microseconds)\n  \n def __floordiv__(self, other):\n  if not isinstance(other, (int, timedelta)):\n   return NotImplemented\n  usec = self._to_microseconds()\n  if isinstance(other, timedelta):\n   return usec // other._to_microseconds()\n  if isinstance(other, int):\n   return timedelta(0, 0, usec // other)\n   \n def __truediv__(self, other):\n  if not isinstance(other, (int, float, timedelta)):\n   return NotImplemented\n  usec = self._to_microseconds()\n  if isinstance(other, timedelta):\n   return usec / other._to_microseconds()\n  if isinstance(other, int):\n   return timedelta(0, 0, usec / other)\n  if isinstance(other, float):\n   a, b = other.as_integer_ratio()\n   return timedelta(0, 0, b * usec / a)\n   \n def __mod__(self, other):\n  if isinstance(other, timedelta):\n   r = self._to_microseconds() % other._to_microseconds()\n   return timedelta(0, 0, r)\n  return NotImplemented\n  \n def __divmod__(self, other):\n  if isinstance(other, timedelta):\n   q, r = divmod(self._to_microseconds(),\n   other._to_microseconds())\n   return q, timedelta(0, 0, r)\n  return NotImplemented\n  \n  \n  \n def __eq__(self, other):\n  if isinstance(other, timedelta):\n   return self._cmp(other) == 0\n  else:\n   return False\n   \n def __ne__(self, other):\n  if isinstance(other, timedelta):\n   return self._cmp(other) != 0\n  else:\n   return True\n   \n def __le__(self, other):\n  if isinstance(other, timedelta):\n   return self._cmp(other) <= 0\n  else:\n   _cmperror(self, other)\n   \n def __lt__(self, other):\n  if isinstance(other, timedelta):\n   return self._cmp(other) < 0\n  else:\n   _cmperror(self, other)\n   \n def __ge__(self, other):\n  if isinstance(other, timedelta):\n   return self._cmp(other) >= 0\n  else:\n   _cmperror(self, other)\n   \n def __gt__(self, other):\n  if isinstance(other, timedelta):\n   return self._cmp(other) > 0\n  else:\n   _cmperror(self, other)\n   \n def _cmp(self, other):\n  assert isinstance(other, timedelta)\n  return _cmp(self._getstate(), other._getstate())\n  \n def __hash__(self):\n  return hash(self._getstate())\n  \n def __bool__(self):\n  return (self._days != 0 or\n  self._seconds != 0 or\n  self._microseconds != 0)\n  \n  \n  \n def _getstate(self):\n  return (self._days, self._seconds, self._microseconds)\n  \n def __reduce__(self):\n  return (self.__class__, self._getstate())\n  \ntimedelta.min = timedelta(-999999999)\ntimedelta.max = timedelta(days=999999999, hours=23, minutes=59, seconds=59,\nmicroseconds=999999)\ntimedelta.resolution = timedelta(microseconds=1)\n\nclass date:\n \"\"\n __slots__ = '_year', '_month', '_day'\n \n def __new__(cls, year, month=None, day=None):\n  \"\"\n  if (isinstance(year, bytes) and len(year) == 4 and\n  1 <= year[2] <= 12 and month is None): \n  \n   self = object.__new__(cls)\n   self.__setstate(year)\n   return self\n  _check_date_fields(year, month, day)\n  self = object.__new__(cls)\n  self._year = year\n  self._month = month\n  self._day = day\n  return self\n  \n  \n  \n @classmethod\n def fromtimestamp(cls, t):\n  \"\"\n  y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t)\n  return cls(y, m, d)\n  \n @classmethod\n def today(cls):\n  \"\"\n  t = _time.time()\n  return cls.fromtimestamp(t)\n  \n @classmethod\n def fromordinal(cls, n):\n  \"\"\n  y, m, d = _ord2ymd(n)\n  return cls(y, m, d)\n  \n  \n  \n def __repr__(self):\n  \"\"\n  return \"%s(%d, %d, %d)\" % ('datetime.' + self.__class__.__name__,\n  self._year,\n  self._month,\n  self._day)\n  \n  \n  \n  \n  \n  \n def ctime(self):\n  \"\"\n  weekday = self.toordinal() % 7 or 7\n  return \"%s %s %2d 00:00:00 %04d\" % (\n  _DAYNAMES[weekday],\n  _MONTHNAMES[self._month],\n  self._day, self._year)\n  \n def strftime(self, fmt):\n  \"\"\n  return _wrap_strftime(self, fmt, self.timetuple())\n  \n def __format__(self, fmt):\n  if len(fmt) != 0:\n   return self.strftime(fmt)\n  return str(self)\n  \n def isoformat(self):\n  \"\"\n  return \"%04d-%02d-%02d\" % (self._year, self._month, self._day)\n  \n __str__ = isoformat\n \n \n @property\n def year(self):\n  \"\"\n  return self._year\n  \n @property\n def month(self):\n  \"\"\n  return self._month\n  \n @property\n def day(self):\n  \"\"\n  return self._day\n  \n  \n  \n def timetuple(self):\n  \"\"\n  return _build_struct_time(self._year, self._month, self._day,\n  0, 0, 0, -1)\n  \n def toordinal(self):\n  \"\"\n  return _ymd2ord(self._year, self._month, self._day)\n  \n def replace(self, year=None, month=None, day=None):\n  \"\"\n  if year is None:\n   year = self._year\n  if month is None:\n   month = self._month\n  if day is None:\n   day = self._day\n  _check_date_fields(year, month, day)\n  return date(year, month, day)\n  \n  \n  \n def __eq__(self, other):\n  if isinstance(other, date):\n   return self._cmp(other) == 0\n  return NotImplemented\n  \n def __ne__(self, other):\n  if isinstance(other, date):\n   return self._cmp(other) != 0\n  return NotImplemented\n  \n def __le__(self, other):\n  if isinstance(other, date):\n   return self._cmp(other) <= 0\n  return NotImplemented\n  \n def __lt__(self, other):\n  if isinstance(other, date):\n   return self._cmp(other) < 0\n  return NotImplemented\n  \n def __ge__(self, other):\n  if isinstance(other, date):\n   return self._cmp(other) >= 0\n  return NotImplemented\n  \n def __gt__(self, other):\n  if isinstance(other, date):\n   return self._cmp(other) > 0\n  return NotImplemented\n  \n def _cmp(self, other):\n  assert isinstance(other, date)\n  y, m, d = self._year, self._month, self._day\n  y2, m2, d2 = other._year, other._month, other._day\n  return _cmp((y, m, d), (y2, m2, d2))\n  \n def __hash__(self):\n  \"\"\n  return hash(self._getstate())\n  \n  \n  \n def __add__(self, other):\n  \"\"\n  if isinstance(other, timedelta):\n   o = self.toordinal() + other.days\n   if 0 < o <= _MAXORDINAL:\n    return date.fromordinal(o)\n   raise OverflowError(\"result out of range\")\n  return NotImplemented\n  \n __radd__ = __add__\n \n def __sub__(self, other):\n  \"\"\n  if isinstance(other, timedelta):\n   return self + timedelta(-other.days)\n  if isinstance(other, date):\n   days1 = self.toordinal()\n   days2 = other.toordinal()\n   return timedelta(days1 - days2)\n  return NotImplemented\n  \n def weekday(self):\n  \"\"\n  return (self.toordinal() + 6) % 7\n  \n  \n  \n def isoweekday(self):\n  \"\"\n  \n  return self.toordinal() % 7 or 7\n  \n def isocalendar(self):\n  \"\"\n  year = self._year\n  week1monday = _isoweek1monday(year)\n  today = _ymd2ord(self._year, self._month, self._day)\n  \n  week, day = divmod(today - week1monday, 7)\n  if week < 0:\n   year -= 1\n   week1monday = _isoweek1monday(year)\n   week, day = divmod(today - week1monday, 7)\n  elif week >= 52:\n   if today >= _isoweek1monday(year+1):\n    year += 1\n    week = 0\n  return year, week+1, day+1\n  \n  \n  \n def _getstate(self):\n  yhi, ylo = divmod(self._year, 256)\n  return bytes([yhi, ylo, self._month, self._day]),\n  \n def __setstate(self, string):\n  if len(string) != 4 or not (1 <= string[2] <= 12):\n   raise TypeError(\"not enough arguments\")\n  yhi, ylo, self._month, self._day = string\n  self._year = yhi * 256 + ylo\n  \n def __reduce__(self):\n  return (self.__class__, self._getstate())\n  \n_date_class = date \n\ndate.min = date(1, 1, 1)\ndate.max = date(9999, 12, 31)\ndate.resolution = timedelta(days=1)\n\nclass tzinfo:\n \"\"\n __slots__ = ()\n def tzname(self, dt):\n  \"\"\n  raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n  \n def utcoffset(self, dt):\n  \"\"\n  raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")\n  \n def dst(self, dt):\n  \"\"\n  raise NotImplementedError(\"tzinfo subclass must override dst()\")\n  \n def fromutc(self, dt):\n  \"\"\n  \n  if not isinstance(dt, datetime):\n   raise TypeError(\"fromutc() requires a datetime argument\")\n  if dt.tzinfo is not self:\n   raise ValueError(\"dt.tzinfo is not self\")\n   \n  dtoff = dt.utcoffset()\n  if dtoff is None:\n   raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n   \"result\")\n   \n   \n   \n  dtdst = dt.dst()\n  if dtdst is None:\n   raise ValueError(\"fromutc() requires a non-None dst() result\")\n  delta = dtoff - dtdst\n  if delta:\n   dt += delta\n   dtdst = dt.dst()\n   if dtdst is None:\n    raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n    \"results; cannot convert\")\n  return dt + dtdst\n  \n  \n  \n def __reduce__(self):\n  getinitargs = getattr(self, \"__getinitargs__\", None)\n  if getinitargs:\n   args = getinitargs()\n  else:\n   args = ()\n  getstate = getattr(self, \"__getstate__\", None)\n  if getstate:\n   state = getstate()\n  else:\n   state = getattr(self, \"__dict__\", None) or None\n  if state is None:\n   return (self.__class__, args)\n  else:\n   return (self.__class__, args, state)\n   \n_tzinfo_class = tzinfo\n\nclass time:\n \"\"\n \n def __new__(cls, hour=0, minute=0, second=0, microsecond=0, tzinfo=None):\n  \"\"\n  self = object.__new__(cls)\n  if isinstance(hour, bytes) and len(hour) == 6:\n  \n   self.__setstate(hour, minute or None)\n   return self\n  _check_tzinfo_arg(tzinfo)\n  _check_time_fields(hour, minute, second, microsecond)\n  self._hour = hour\n  self._minute = minute\n  self._second = second\n  self._microsecond = microsecond\n  self._tzinfo = tzinfo\n  return self\n  \n  \n @property\n def hour(self):\n  \"\"\n  return self._hour\n  \n @property\n def minute(self):\n  \"\"\n  return self._minute\n  \n @property\n def second(self):\n  \"\"\n  return self._second\n  \n @property\n def microsecond(self):\n  \"\"\n  return self._microsecond\n  \n @property\n def tzinfo(self):\n  \"\"\n  return self._tzinfo\n  \n  \n  \n  \n  \n def __eq__(self, other):\n  if isinstance(other, time):\n   return self._cmp(other, allow_mixed=True) == 0\n  else:\n   return False\n   \n def __ne__(self, other):\n  if isinstance(other, time):\n   return self._cmp(other, allow_mixed=True) != 0\n  else:\n   return True\n   \n def __le__(self, other):\n  if isinstance(other, time):\n   return self._cmp(other) <= 0\n  else:\n   _cmperror(self, other)\n   \n def __lt__(self, other):\n  if isinstance(other, time):\n   return self._cmp(other) < 0\n  else:\n   _cmperror(self, other)\n   \n def __ge__(self, other):\n  if isinstance(other, time):\n   return self._cmp(other) >= 0\n  else:\n   _cmperror(self, other)\n   \n def __gt__(self, other):\n  if isinstance(other, time):\n   return self._cmp(other) > 0\n  else:\n   _cmperror(self, other)\n   \n def _cmp(self, other, allow_mixed=False):\n  assert isinstance(other, time)\n  mytz = self._tzinfo\n  ottz = other._tzinfo\n  myoff = otoff = None\n  \n  if mytz is ottz:\n   base_compare = True\n  else:\n   myoff = self.utcoffset()\n   otoff = other.utcoffset()\n   base_compare = myoff == otoff\n   \n  if base_compare:\n   return _cmp((self._hour, self._minute, self._second,\n   self._microsecond),\n   (other._hour, other._minute, other._second,\n   other._microsecond))\n  if myoff is None or otoff is None:\n   if allow_mixed:\n    return 2 \n   else:\n    raise TypeError(\"cannot compare naive and aware times\")\n  myhhmm = self._hour * 60 + self._minute - myoff//timedelta(minutes=1)\n  othhmm = other._hour * 60 + other._minute - otoff//timedelta(minutes=1)\n  return _cmp((myhhmm, self._second, self._microsecond),\n  (othhmm, other._second, other._microsecond))\n  \n def __hash__(self):\n  \"\"\n  tzoff = self.utcoffset()\n  if not tzoff: \n   return hash(self._getstate()[0])\n  h, m = divmod(timedelta(hours=self.hour, minutes=self.minute) - tzoff,\n  timedelta(hours=1))\n  assert not m % timedelta(minutes=1), \"whole minute\"\n  m //= timedelta(minutes=1)\n  if 0 <= h < 24:\n   return hash(time(h, m, self.second, self.microsecond))\n  return hash((h, m, self.second, self.microsecond))\n  \n  \n  \n def _tzstr(self, sep=\":\"):\n  \"\"\n  off = self.utcoffset()\n  if off is not None:\n   if off.days < 0:\n    sign = \"-\"\n    off = -off\n   else:\n    sign = \"+\"\n   hh, mm = divmod(off, timedelta(hours=1))\n   assert not mm % timedelta(minutes=1), \"whole minute\"\n   mm //= timedelta(minutes=1)\n   assert 0 <= hh < 24\n   off = \"%s%02d%s%02d\" % (sign, hh, sep, mm)\n  return off\n  \n def __repr__(self):\n  \"\"\n  if self._microsecond != 0:\n   s = \", %d, %d\" % (self._second, self._microsecond)\n  elif self._second != 0:\n   s = \", %d\" % self._second\n  else:\n   s = \"\"\n  s= \"%s(%d, %d%s)\" % ('datetime.' + self.__class__.__name__,\n  self._hour, self._minute, s)\n  if self._tzinfo is not None:\n   assert s[-1:] == \")\"\n   s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n  return s\n  \n def isoformat(self):\n  \"\"\n  s = _format_time(self._hour, self._minute, self._second,\n  self._microsecond)\n  tz = self._tzstr()\n  if tz:\n   s += tz\n  return s\n  \n __str__ = isoformat\n \n def strftime(self, fmt):\n  \"\"\n  \n  \n  timetuple = (1900, 1, 1,\n  self._hour, self._minute, self._second,\n  0, 1, -1)\n  return _wrap_strftime(self, fmt, timetuple)\n  \n def __format__(self, fmt):\n  if len(fmt) != 0:\n   return self.strftime(fmt)\n  return str(self)\n  \n  \n  \n def utcoffset(self):\n  \"\"\n  if self._tzinfo is None:\n   return None\n  offset = self._tzinfo.utcoffset(None)\n  _check_utc_offset(\"utcoffset\", offset)\n  return offset\n  \n def tzname(self):\n  \"\"\n  if self._tzinfo is None:\n   return None\n  name = self._tzinfo.tzname(None)\n  _check_tzname(name)\n  return name\n  \n def dst(self):\n  \"\"\n  if self._tzinfo is None:\n   return None\n  offset = self._tzinfo.dst(None)\n  _check_utc_offset(\"dst\", offset)\n  return offset\n  \n def replace(self, hour=None, minute=None, second=None, microsecond=None,\n tzinfo=True):\n  \"\"\n  if hour is None:\n   hour = self.hour\n  if minute is None:\n   minute = self.minute\n  if second is None:\n   second = self.second\n  if microsecond is None:\n   microsecond = self.microsecond\n  if tzinfo is True:\n   tzinfo = self.tzinfo\n  _check_time_fields(hour, minute, second, microsecond)\n  _check_tzinfo_arg(tzinfo)\n  return time(hour, minute, second, microsecond, tzinfo)\n  \n def __bool__(self):\n  if self.second or self.microsecond:\n   return True\n  offset = self.utcoffset() or timedelta(0)\n  return timedelta(hours=self.hour, minutes=self.minute) != offset\n  \n  \n  \n def _getstate(self):\n  us2, us3 = divmod(self._microsecond, 256)\n  us1, us2 = divmod(us2, 256)\n  basestate = bytes([self._hour, self._minute, self._second,\n  us1, us2, us3])\n  if self._tzinfo is None:\n   return (basestate,)\n  else:\n   return (basestate, self._tzinfo)\n   \n def __setstate(self, string, tzinfo):\n  if len(string) != 6 or string[0] >= 24:\n   raise TypeError(\"an integer is required\")\n  (self._hour, self._minute, self._second,\n  us1, us2, us3) = string\n  self._microsecond = (((us1 << 8) | us2) << 8) | us3\n  if tzinfo is None or isinstance(tzinfo, _tzinfo_class):\n   self._tzinfo = tzinfo\n  else:\n   raise TypeError(\"bad tzinfo state arg %r\" % tzinfo)\n   \n def __reduce__(self):\n  return (time, self._getstate())\n  \n_time_class = time \n\ntime.min = time(0, 0, 0)\ntime.max = time(23, 59, 59, 999999)\ntime.resolution = timedelta(microseconds=1)\n\nclass datetime(date):\n \"\"\n \n __slots__ = date.__slots__ + (\n '_hour', '_minute', '_second',\n '_microsecond', '_tzinfo')\n def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n microsecond=0, tzinfo=None):\n  if isinstance(year, bytes) and len(year) == 10:\n  \n   self = date.__new__(cls, year[:4])\n   self.__setstate(year, month)\n   return self\n  _check_tzinfo_arg(tzinfo)\n  _check_time_fields(hour, minute, second, microsecond)\n  self = date.__new__(cls, year, month, day)\n  self._hour = hour\n  self._minute = minute\n  self._second = second\n  self._microsecond = microsecond\n  self._tzinfo = tzinfo\n  return self\n  \n  \n @property\n def hour(self):\n  \"\"\n  return self._hour\n  \n @property\n def minute(self):\n  \"\"\n  return self._minute\n  \n @property\n def second(self):\n  \"\"\n  return self._second\n  \n @property\n def microsecond(self):\n  \"\"\n  return self._microsecond\n  \n @property\n def tzinfo(self):\n  \"\"\n  return self._tzinfo\n  \n @classmethod\n def fromtimestamp(cls, t, tz=None):\n  \"\"\n  \n  _check_tzinfo_arg(tz)\n  \n  converter = _time.localtime if tz is None else _time.gmtime\n  \n  t, frac = divmod(t, 1.0)\n  us = int(frac * 1e6)\n  \n  \n  \n  \n  \n  if us == 1000000:\n   t += 1\n   us = 0\n  y, m, d, hh, mm, ss, weekday, jday, dst = converter(t)\n  ss = min(ss, 59) \n  result = cls(y, m, d, hh, mm, ss, us, tz)\n  if tz is not None:\n   result = tz.fromutc(result)\n  return result\n  \n @classmethod\n def utcfromtimestamp(cls, t):\n  \"\"\n  t, frac = divmod(t, 1.0)\n  us = int(frac * 1e6)\n  \n  \n  \n  \n  \n  if us == 1000000:\n   t += 1\n   us = 0\n  y, m, d, hh, mm, ss, weekday, jday, dst = _time.gmtime(t)\n  ss = min(ss, 59) \n  return cls(y, m, d, hh, mm, ss, us)\n  \n  \n  \n  \n  \n  \n @classmethod\n def now(cls, tz=None):\n  \"\"\n  t = _time.time()\n  return cls.fromtimestamp(t, tz)\n  \n @classmethod\n def utcnow(cls):\n  \"\"\n  t = _time.time()\n  return cls.utcfromtimestamp(t)\n  \n @classmethod\n def combine(cls, date, time):\n  \"\"\n  if not isinstance(date, _date_class):\n   raise TypeError(\"date argument must be a date instance\")\n  if not isinstance(time, _time_class):\n   raise TypeError(\"time argument must be a time instance\")\n  return cls(date.year, date.month, date.day,\n  time.hour, time.minute, time.second, time.microsecond,\n  time.tzinfo)\n  \n def timetuple(self):\n  \"\"\n  dst = self.dst()\n  if dst is None:\n   dst = -1\n  elif dst:\n   dst = 1\n  else:\n   dst = 0\n  return _build_struct_time(self.year, self.month, self.day,\n  self.hour, self.minute, self.second,\n  dst)\n  \n def timestamp(self):\n  \"\"\n  if self._tzinfo is None:\n   return _time.mktime((self.year, self.month, self.day,\n   self.hour, self.minute, self.second,\n   -1, -1, -1)) + self.microsecond / 1e6\n  else:\n   return (self - _EPOCH).total_seconds()\n   \n def utctimetuple(self):\n  \"\"\n  offset = self.utcoffset()\n  if offset:\n   self -= offset\n  y, m, d = self.year, self.month, self.day\n  hh, mm, ss = self.hour, self.minute, self.second\n  return _build_struct_time(y, m, d, hh, mm, ss, 0)\n  \n def date(self):\n  \"\"\n  return date(self._year, self._month, self._day)\n  \n def time(self):\n  \"\"\n  return time(self.hour, self.minute, self.second, self.microsecond)\n  \n def timetz(self):\n  \"\"\n  return time(self.hour, self.minute, self.second, self.microsecond,\n  self._tzinfo)\n  \n def replace(self, year=None, month=None, day=None, hour=None,\n minute=None, second=None, microsecond=None, tzinfo=True):\n  \"\"\n  if year is None:\n   year = self.year\n  if month is None:\n   month = self.month\n  if day is None:\n   day = self.day\n  if hour is None:\n   hour = self.hour\n  if minute is None:\n   minute = self.minute\n  if second is None:\n   second = self.second\n  if microsecond is None:\n   microsecond = self.microsecond\n  if tzinfo is True:\n   tzinfo = self.tzinfo\n  _check_date_fields(year, month, day)\n  _check_time_fields(hour, minute, second, microsecond)\n  _check_tzinfo_arg(tzinfo)\n  return datetime(year, month, day, hour, minute, second,\n  microsecond, tzinfo)\n  \n def astimezone(self, tz=None):\n  if tz is None:\n   if self.tzinfo is None:\n    raise ValueError(\"astimezone() requires an aware datetime\")\n   ts = (self - _EPOCH) // timedelta(seconds=1)\n   localtm = _time.localtime(ts)\n   local = datetime(*localtm[:6])\n   try:\n   \n    gmtoff = localtm.tm_gmtoff\n    zone = localtm.tm_zone\n   except AttributeError:\n   \n   \n   \n    delta = local - datetime(*_time.gmtime(ts)[:6])\n    dst = _time.daylight and localtm.tm_isdst > 0\n    gmtoff = -(_time.altzone if dst else _time.timezone)\n    if delta == timedelta(seconds=gmtoff):\n     tz = timezone(delta, _time.tzname[dst])\n    else:\n     tz = timezone(delta)\n   else:\n    tz = timezone(timedelta(seconds=gmtoff), zone)\n    \n  elif not isinstance(tz, tzinfo):\n   raise TypeError(\"tz argument must be an instance of tzinfo\")\n   \n  mytz = self.tzinfo\n  if mytz is None:\n   raise ValueError(\"astimezone() requires an aware datetime\")\n   \n  if tz is mytz:\n   return self\n   \n   \n  myoffset = self.utcoffset()\n  if myoffset is None:\n   raise ValueError(\"astimezone() requires an aware datetime\")\n  utc = (self - myoffset).replace(tzinfo=tz)\n  \n  \n  return tz.fromutc(utc)\n  \n  \n  \n def ctime(self):\n  \"\"\n  weekday = self.toordinal() % 7 or 7\n  return \"%s %s %2d %02d:%02d:%02d %04d\" % (\n  _DAYNAMES[weekday],\n  _MONTHNAMES[self._month],\n  self._day,\n  self._hour, self._minute, self._second,\n  self._year)\n  \n def isoformat(self, sep='T'):\n  \"\"\n  s = (\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day,\n  sep) +\n  _format_time(self._hour, self._minute, self._second,\n  self._microsecond))\n  off = self.utcoffset()\n  if off is not None:\n   if off.days < 0:\n    sign = \"-\"\n    off = -off\n   else:\n    sign = \"+\"\n   hh, mm = divmod(off, timedelta(hours=1))\n   assert not mm % timedelta(minutes=1), \"whole minute\"\n   mm //= timedelta(minutes=1)\n   s += \"%s%02d:%02d\" % (sign, hh, mm)\n  return s\n  \n def __repr__(self):\n  \"\"\n  L = [self._year, self._month, self._day, \n  self._hour, self._minute, self._second, self._microsecond]\n  if L[-1] == 0:\n   del L[-1]\n  if L[-1] == 0:\n   del L[-1]\n  s = \", \".join(map(str, L))\n  s = \"%s(%s)\" % ('datetime.' + self.__class__.__name__, s)\n  if self._tzinfo is not None:\n   assert s[-1:] == \")\"\n   s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n  return s\n  \n def __str__(self):\n  \"\"\n  return self.isoformat(sep=' ')\n  \n @classmethod\n def strptime(cls, date_string, format):\n  \"\"\n  import _strptime\n  return _strptime._strptime_datetime(cls, date_string, format)\n  \n def utcoffset(self):\n  \"\"\n  if self._tzinfo is None:\n   return None\n  offset = self._tzinfo.utcoffset(self)\n  _check_utc_offset(\"utcoffset\", offset)\n  return offset\n  \n def tzname(self):\n  \"\"\n  name = _call_tzinfo_method(self._tzinfo, \"tzname\", self)\n  _check_tzname(name)\n  return name\n  \n def dst(self):\n  \"\"\n  if self._tzinfo is None:\n   return None\n  offset = self._tzinfo.dst(self)\n  _check_utc_offset(\"dst\", offset)\n  return offset\n  \n  \n  \n def __eq__(self, other):\n  if isinstance(other, datetime):\n   return self._cmp(other, allow_mixed=True) == 0\n  elif not isinstance(other, date):\n   return NotImplemented\n  else:\n   return False\n   \n def __ne__(self, other):\n  if isinstance(other, datetime):\n   return self._cmp(other, allow_mixed=True) != 0\n  elif not isinstance(other, date):\n   return NotImplemented\n  else:\n   return True\n   \n def __le__(self, other):\n  if isinstance(other, datetime):\n   return self._cmp(other) <= 0\n  elif not isinstance(other, date):\n   return NotImplemented\n  else:\n   _cmperror(self, other)\n   \n def __lt__(self, other):\n  if isinstance(other, datetime):\n   return self._cmp(other) < 0\n  elif not isinstance(other, date):\n   return NotImplemented\n  else:\n   _cmperror(self, other)\n   \n def __ge__(self, other):\n  if isinstance(other, datetime):\n   return self._cmp(other) >= 0\n  elif not isinstance(other, date):\n   return NotImplemented\n  else:\n   _cmperror(self, other)\n   \n def __gt__(self, other):\n  if isinstance(other, datetime):\n   return self._cmp(other) > 0\n  elif not isinstance(other, date):\n   return NotImplemented\n  else:\n   _cmperror(self, other)\n   \n def _cmp(self, other, allow_mixed=False):\n  assert isinstance(other, datetime)\n  mytz = self._tzinfo\n  ottz = other._tzinfo\n  myoff = otoff = None\n  \n  if mytz is ottz:\n   base_compare = True\n  else:\n   myoff = self.utcoffset()\n   otoff = other.utcoffset()\n   base_compare = myoff == otoff\n   \n  if base_compare:\n   return _cmp((self._year, self._month, self._day,\n   self._hour, self._minute, self._second,\n   self._microsecond),\n   (other._year, other._month, other._day,\n   other._hour, other._minute, other._second,\n   other._microsecond))\n  if myoff is None or otoff is None:\n   if allow_mixed:\n    return 2 \n   else:\n    raise TypeError(\"cannot compare naive and aware datetimes\")\n    \n  diff = self - other \n  if diff.days < 0:\n   return -1\n  return diff and 1 or 0\n  \n def __add__(self, other):\n  \"\"\n  if not isinstance(other, timedelta):\n   return NotImplemented\n  delta = timedelta(self.toordinal(),\n  hours=self._hour,\n  minutes=self._minute,\n  seconds=self._second,\n  microseconds=self._microsecond)\n  delta += other\n  hour, rem = divmod(delta.seconds, 3600)\n  minute, second = divmod(rem, 60)\n  if 0 < delta.days <= _MAXORDINAL:\n   return datetime.combine(date.fromordinal(delta.days),\n   time(hour, minute, second,\n   delta.microseconds,\n   tzinfo=self._tzinfo))\n  raise OverflowError(\"result out of range\")\n  \n __radd__ = __add__\n \n def __sub__(self, other):\n  \"\"\n  if not isinstance(other, datetime):\n   if isinstance(other, timedelta):\n    return self + -other\n   return NotImplemented\n   \n  days1 = self.toordinal()\n  days2 = other.toordinal()\n  secs1 = self._second + self._minute * 60 + self._hour * 3600\n  secs2 = other._second + other._minute * 60 + other._hour * 3600\n  base = timedelta(days1 - days2,\n  secs1 - secs2,\n  self._microsecond - other._microsecond)\n  if self._tzinfo is other._tzinfo:\n   return base\n  myoff = self.utcoffset()\n  otoff = other.utcoffset()\n  if myoff == otoff:\n   return base\n  if myoff is None or otoff is None:\n   raise TypeError(\"cannot mix naive and timezone-aware time\")\n  return base + otoff - myoff\n  \n def __hash__(self):\n  tzoff = self.utcoffset()\n  if tzoff is None:\n   return hash(self._getstate()[0])\n  days = _ymd2ord(self.year, self.month, self.day)\n  seconds = self.hour * 3600 + self.minute * 60 + self.second\n  return hash(timedelta(days, seconds, self.microsecond) - tzoff)\n  \n  \n  \n def _getstate(self):\n  yhi, ylo = divmod(self._year, 256)\n  us2, us3 = divmod(self._microsecond, 256)\n  us1, us2 = divmod(us2, 256)\n  basestate = bytes([yhi, ylo, self._month, self._day,\n  self._hour, self._minute, self._second,\n  us1, us2, us3])\n  if self._tzinfo is None:\n   return (basestate,)\n  else:\n   return (basestate, self._tzinfo)\n   \n def __setstate(self, string, tzinfo):\n  (yhi, ylo, self._month, self._day, self._hour,\n  self._minute, self._second, us1, us2, us3) = string\n  self._year = yhi * 256 + ylo\n  self._microsecond = (((us1 << 8) | us2) << 8) | us3\n  if tzinfo is None or isinstance(tzinfo, _tzinfo_class):\n   self._tzinfo = tzinfo\n  else:\n   raise TypeError(\"bad tzinfo state arg %r\" % tzinfo)\n   \n def __reduce__(self):\n  return (self.__class__, self._getstate())\n  \n  \ndatetime.min = datetime(1, 1, 1)\ndatetime.max = datetime(9999, 12, 31, 23, 59, 59, 999999)\ndatetime.resolution = timedelta(microseconds=1)\n\n\ndef _isoweek1monday(year):\n\n\n THURSDAY = 3\n firstday = _ymd2ord(year, 1, 1)\n firstweekday = (firstday + 6) % 7 \n week1monday = firstday - firstweekday\n if firstweekday > THURSDAY:\n  week1monday += 7\n return week1monday\n \nclass timezone(tzinfo):\n __slots__ = '_offset', '_name'\n \n \n _Omitted = object()\n def __new__(cls, offset, name=_Omitted):\n  if not isinstance(offset, timedelta):\n   raise TypeError(\"offset must be a timedelta\")\n  if name is cls._Omitted:\n   if not offset:\n    return cls.utc\n   name = None\n  elif not isinstance(name, str):\n   raise TypeError(\"name must be a string\")\n  if not cls._minoffset <= offset <= cls._maxoffset:\n   raise ValueError(\"offset must be a timedelta\"\n   \" strictly between -timedelta(hours=24) and\"\n   \" timedelta(hours=24).\")\n  if (offset.microseconds != 0 or\n  offset.seconds % 60 != 0):\n   raise ValueError(\"offset must be a timedelta\"\n   \" representing a whole number of minutes\")\n  return cls._create(offset, name)\n  \n @classmethod\n def _create(cls, offset, name=None):\n  self = tzinfo.__new__(cls)\n  self._offset = offset\n  self._name = name\n  return self\n  \n def __getinitargs__(self):\n  \"\"\n  if self._name is None:\n   return (self._offset,)\n  return (self._offset, self._name)\n  \n def __eq__(self, other):\n  if type(other) != timezone:\n   return False\n  return self._offset == other._offset\n  \n def __hash__(self):\n  return hash(self._offset)\n  \n def __repr__(self):\n  \"\"\n  if self is self.utc:\n   return 'datetime.timezone.utc'\n  if self._name is None:\n   return \"%s(%r)\" % ('datetime.' + self.__class__.__name__,\n   self._offset)\n  return \"%s(%r, %r)\" % ('datetime.' + self.__class__.__name__,\n  self._offset, self._name)\n  \n def __str__(self):\n  return self.tzname(None)\n  \n def utcoffset(self, dt):\n  if isinstance(dt, datetime) or dt is None:\n   return self._offset\n  raise TypeError(\"utcoffset() argument must be a datetime instance\"\n  \" or None\")\n  \n def tzname(self, dt):\n  if isinstance(dt, datetime) or dt is None:\n   if self._name is None:\n    return self._name_from_offset(self._offset)\n   return self._name\n  raise TypeError(\"tzname() argument must be a datetime instance\"\n  \" or None\")\n  \n def dst(self, dt):\n  if isinstance(dt, datetime) or dt is None:\n   return None\n  raise TypeError(\"dst() argument must be a datetime instance\"\n  \" or None\")\n  \n def fromutc(self, dt):\n  if isinstance(dt, datetime):\n   if dt.tzinfo is not self:\n    raise ValueError(\"fromutc: dt.tzinfo \"\n    \"is not self\")\n   return dt + self._offset\n  raise TypeError(\"fromutc() argument must be a datetime instance\"\n  \" or None\")\n  \n _maxoffset = timedelta(hours=23, minutes=59)\n _minoffset = -_maxoffset\n \n @staticmethod\n def _name_from_offset(delta):\n  if delta < timedelta(0):\n   sign = '-'\n   delta = -delta\n  else:\n   sign = '+'\n  hours, rest = divmod(delta, timedelta(hours=1))\n  minutes = rest // timedelta(minutes=1)\n  return 'UTC{}{:02d}:{:02d}'.format(sign, hours, minutes)\n  \ntimezone.utc = timezone._create(timedelta(0))\ntimezone.min = timezone._create(timezone._minoffset)\ntimezone.max = timezone._create(timezone._maxoffset)\n_EPOCH = datetime(1970, 1, 1, tzinfo=timezone.utc)\n\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"], "urllib.parse": [".py", "\"\"\n\nimport re\nimport sys\nimport collections\n\n__all__ = [\"urlparse\", \"urlunparse\", \"urljoin\", \"urldefrag\",\n\"urlsplit\", \"urlunsplit\", \"urlencode\", \"parse_qs\",\n\"parse_qsl\", \"quote\", \"quote_plus\", \"quote_from_bytes\",\n\"unquote\", \"unquote_plus\", \"unquote_to_bytes\"]\n\n\nuses_relative = ['ftp', 'http', 'gopher', 'nntp', 'imap',\n'wais', 'file', 'https', 'shttp', 'mms',\n'prospero', 'rtsp', 'rtspu', '', 'sftp',\n'svn', 'svn+ssh']\nuses_netloc = ['ftp', 'http', 'gopher', 'nntp', 'telnet',\n'imap', 'wais', 'file', 'mms', 'https', 'shttp',\n'snews', 'prospero', 'rtsp', 'rtspu', 'rsync', '',\n'svn', 'svn+ssh', 'sftp', 'nfs', 'git', 'git+ssh']\nuses_params = ['ftp', 'hdl', 'prospero', 'http', 'imap',\n'https', 'shttp', 'rtsp', 'rtspu', 'sip', 'sips',\n'mms', '', 'sftp', 'tel']\n\n\n\nnon_hierarchical = ['gopher', 'hdl', 'mailto', 'news',\n'telnet', 'wais', 'imap', 'snews', 'sip', 'sips']\nuses_query = ['http', 'wais', 'imap', 'https', 'shttp', 'mms',\n'gopher', 'rtsp', 'rtspu', 'sip', 'sips', '']\nuses_fragment = ['ftp', 'hdl', 'http', 'gopher', 'news',\n'nntp', 'wais', 'https', 'shttp', 'snews',\n'file', 'prospero', '']\n\n\nscheme_chars = ('abcdefghijklmnopqrstuvwxyz'\n'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n'0123456789'\n'+-.')\n\n\nMAX_CACHE_SIZE = 20\n_parse_cache = {}\n\ndef clear_cache():\n \"\"\n _parse_cache.clear()\n _safe_quoters.clear()\n \n \n \n \n \n \n \n \n_implicit_encoding = 'ascii'\n_implicit_errors = 'strict'\n\ndef _noop(obj):\n return obj\n \ndef _encode_result(obj, encoding=_implicit_encoding,\nerrors=_implicit_errors):\n return obj.encode(encoding, errors)\n \ndef _decode_args(args, encoding=_implicit_encoding,\nerrors=_implicit_errors):\n return tuple(x.decode(encoding, errors) if x else '' for x in args)\n \ndef _coerce_args(*args):\n\n\n\n\n\n str_input = isinstance(args[0], str)\n for arg in args[1:]:\n \n \n  if arg and isinstance(arg, str) != str_input:\n   raise TypeError(\"Cannot mix str and non-str arguments\")\n if str_input:\n  return args + (_noop,)\n return _decode_args(args) + (_encode_result,)\n \n \nclass _ResultMixinStr(object):\n \"\"\n __slots__ = ()\n \n def encode(self, encoding='ascii', errors='strict'):\n  return self._encoded_counterpart(*(x.encode(encoding, errors) for x in self))\n  \n  \nclass _ResultMixinBytes(object):\n \"\"\n __slots__ = ()\n \n def decode(self, encoding='ascii', errors='strict'):\n  return self._decoded_counterpart(*(x.decode(encoding, errors) for x in self))\n  \n  \nclass _NetlocResultMixinBase(object):\n \"\"\n __slots__ = ()\n \n @property\n def username(self):\n  return self._userinfo[0]\n  \n @property\n def password(self):\n  return self._userinfo[1]\n  \n @property\n def hostname(self):\n  hostname = self._hostinfo[0]\n  if not hostname:\n   hostname = None\n  elif hostname is not None:\n   hostname = hostname.lower()\n  return hostname\n  \n @property\n def port(self):\n  port = self._hostinfo[1]\n  if port is not None:\n   port = int(port, 10)\n   \n   if not ( 0 <= port <= 65535):\n    return None\n  return port\n  \n  \nclass _NetlocResultMixinStr(_NetlocResultMixinBase, _ResultMixinStr):\n __slots__ = ()\n \n @property\n def _userinfo(self):\n  netloc = self.netloc\n  userinfo, have_info, hostinfo = netloc.rpartition('@')\n  if have_info:\n   username, have_password, password = userinfo.partition(':')\n   if not have_password:\n    password = None\n  else:\n   username = password = None\n  return username, password\n  \n @property\n def _hostinfo(self):\n  netloc = self.netloc\n  _, _, hostinfo = netloc.rpartition('@')\n  _, have_open_br, bracketed = hostinfo.partition('[')\n  if have_open_br:\n   hostname, _, port = bracketed.partition(']')\n   _, have_port, port = port.partition(':')\n  else:\n   hostname, have_port, port = hostinfo.partition(':')\n  if not have_port:\n   port = None\n  return hostname, port\n  \n  \nclass _NetlocResultMixinBytes(_NetlocResultMixinBase, _ResultMixinBytes):\n __slots__ = ()\n \n @property\n def _userinfo(self):\n  netloc = self.netloc\n  userinfo, have_info, hostinfo = netloc.rpartition(b'@')\n  if have_info:\n   username, have_password, password = userinfo.partition(b':')\n   if not have_password:\n    password = None\n  else:\n   username = password = None\n  return username, password\n  \n @property\n def _hostinfo(self):\n  netloc = self.netloc\n  _, _, hostinfo = netloc.rpartition(b'@')\n  _, have_open_br, bracketed = hostinfo.partition(b'[')\n  if have_open_br:\n   hostname, _, port = bracketed.partition(b']')\n   _, have_port, port = port.partition(b':')\n  else:\n   hostname, have_port, port = hostinfo.partition(b':')\n  if not have_port:\n   port = None\n  return hostname, port\n  \n  \nfrom collections import namedtuple\n\n_DefragResultBase = namedtuple('DefragResult', 'url fragment')\n_SplitResultBase = namedtuple('SplitResult', 'scheme netloc path query fragment')\n_ParseResultBase = namedtuple('ParseResult', 'scheme netloc path params query fragment')\n\n\n\n\nResultBase = _NetlocResultMixinStr\n\n\nclass DefragResult(_DefragResultBase, _ResultMixinStr):\n __slots__ = ()\n def geturl(self):\n  if self.fragment:\n   return self.url + '#' + self.fragment\n  else:\n   return self.url\n   \nclass SplitResult(_SplitResultBase, _NetlocResultMixinStr):\n __slots__ = ()\n def geturl(self):\n  return urlunsplit(self)\n  \nclass ParseResult(_ParseResultBase, _NetlocResultMixinStr):\n __slots__ = ()\n def geturl(self):\n  return urlunparse(self)\n  \n  \nclass DefragResultBytes(_DefragResultBase, _ResultMixinBytes):\n __slots__ = ()\n def geturl(self):\n  if self.fragment:\n   return self.url + b'#' + self.fragment\n  else:\n   return self.url\n   \nclass SplitResultBytes(_SplitResultBase, _NetlocResultMixinBytes):\n __slots__ = ()\n def geturl(self):\n  return urlunsplit(self)\n  \nclass ParseResultBytes(_ParseResultBase, _NetlocResultMixinBytes):\n __slots__ = ()\n def geturl(self):\n  return urlunparse(self)\n  \n  \ndef _fix_result_transcoding():\n _result_pairs = (\n (DefragResult, DefragResultBytes),\n (SplitResult, SplitResultBytes),\n (ParseResult, ParseResultBytes),\n )\n for _decoded, _encoded in _result_pairs:\n  _decoded._encoded_counterpart = _encoded\n  _encoded._decoded_counterpart = _decoded\n  \n_fix_result_transcoding()\ndel _fix_result_transcoding\n\ndef urlparse(url, scheme='', allow_fragments=True):\n \"\"\n url, scheme, _coerce_result = _coerce_args(url, scheme)\n splitresult = urlsplit(url, scheme, allow_fragments)\n scheme, netloc, url, query, fragment = splitresult\n if scheme in uses_params and ';' in url:\n  url, params = _splitparams(url)\n else:\n  params = ''\n result = ParseResult(scheme, netloc, url, params, query, fragment)\n return _coerce_result(result)\n \ndef _splitparams(url):\n if '/' in url:\n  i = url.find(';', url.rfind('/'))\n  if i < 0:\n   return url, ''\n else:\n  i = url.find(';')\n return url[:i], url[i+1:]\n \ndef _splitnetloc(url, start=0):\n delim = len(url) \n for c in '/?#': \n  wdelim = url.find(c, start) \n  if wdelim >= 0: \n   delim = min(delim, wdelim) \n return url[start:delim], url[delim:] \n \ndef urlsplit(url, scheme='', allow_fragments=True):\n \"\"\n url, scheme, _coerce_result = _coerce_args(url, scheme)\n allow_fragments = bool(allow_fragments)\n key = url, scheme, allow_fragments, type(url), type(scheme)\n cached = _parse_cache.get(key, None)\n if cached:\n  return _coerce_result(cached)\n if len(_parse_cache) >= MAX_CACHE_SIZE: \n  clear_cache()\n netloc = query = fragment = ''\n i = url.find(':')\n if i > 0:\n  if url[:i] == 'http': \n   scheme = url[:i].lower()\n   url = url[i+1:]\n   if url[:2] == '//':\n    netloc, url = _splitnetloc(url, 2)\n    if (('[' in netloc and ']' not in netloc) or\n    (']' in netloc and '[' not in netloc)):\n     raise ValueError(\"Invalid IPv6 URL\")\n   if allow_fragments and '#' in url:\n    url, fragment = url.split('#', 1)\n   if '?' in url:\n    url, query = url.split('?', 1)\n   v = SplitResult(scheme, netloc, url, query, fragment)\n   _parse_cache[key] = v\n   return _coerce_result(v)\n  for c in url[:i]:\n   if c not in scheme_chars:\n    break\n  else:\n  \n  \n   rest = url[i+1:]\n   if not rest or any(c not in '0123456789' for c in rest):\n   \n    scheme, url = url[:i].lower(), rest\n    \n if url[:2] == '//':\n  netloc, url = _splitnetloc(url, 2)\n  if (('[' in netloc and ']' not in netloc) or\n  (']' in netloc and '[' not in netloc)):\n   raise ValueError(\"Invalid IPv6 URL\")\n if allow_fragments and '#' in url:\n  url, fragment = url.split('#', 1)\n if '?' in url:\n  url, query = url.split('?', 1)\n v = SplitResult(scheme, netloc, url, query, fragment)\n _parse_cache[key] = v\n return _coerce_result(v)\n \ndef urlunparse(components):\n \"\"\n scheme, netloc, url, params, query, fragment, _coerce_result = (\n _coerce_args(*components))\n if params:\n  url = \"%s;%s\" % (url, params)\n return _coerce_result(urlunsplit((scheme, netloc, url, query, fragment)))\n \ndef urlunsplit(components):\n \"\"\n scheme, netloc, url, query, fragment, _coerce_result = (\n _coerce_args(*components))\n if netloc or (scheme and scheme in uses_netloc and url[:2] != '//'):\n  if url and url[:1] != '/': url = '/' + url\n  url = '//' + (netloc or '') + url\n if scheme:\n  url = scheme + ':' + url\n if query:\n  url = url + '?' + query\n if fragment:\n  url = url + '#' + fragment\n return _coerce_result(url)\n \ndef urljoin(base, url, allow_fragments=True):\n \"\"\n if not base:\n  return url\n if not url:\n  return base\n base, url, _coerce_result = _coerce_args(base, url)\n bscheme, bnetloc, bpath, bparams, bquery, bfragment = urlparse(base, '', allow_fragments)\n scheme, netloc, path, params, query, fragment = urlparse(url, bscheme, allow_fragments)\n if scheme != bscheme or scheme not in uses_relative:\n  return _coerce_result(url)\n if scheme in uses_netloc:\n  if netloc:\n   return _coerce_result(urlunparse((scheme, netloc, path,\n   params, query, fragment)))\n  netloc = bnetloc\n if path[:1] == '/':\n  return _coerce_result(urlunparse((scheme, netloc, path,\n  params, query, fragment)))\n if not path and not params:\n  path = bpath\n  params = bparams\n  if not query:\n   query = bquery\n  return _coerce_result(urlunparse((scheme, netloc, path,\n  params, query, fragment)))\n segments = bpath.split('/')[:-1] + path.split('/')\n \n if segments[-1] == '.':\n  segments[-1] = ''\n while '.' in segments:\n  segments.remove('.')\n while 1:\n  i = 1\n  n = len(segments) - 1\n  while i < n:\n   if (segments[i] == '..'\n   and segments[i-1] not in ('', '..')):\n    del segments[i-1:i+1]\n    break\n   i = i+1\n  else:\n   break\n if segments == ['', '..']:\n  segments[-1] = ''\n elif len(segments) >= 2 and segments[-1] == '..':\n  segments[-2:] = ['']\n return _coerce_result(urlunparse((scheme, netloc, '/'.join(segments),\n params, query, fragment)))\n \ndef urldefrag(url):\n \"\"\n url, _coerce_result = _coerce_args(url)\n if '#' in url:\n  s, n, p, a, q, frag = urlparse(url)\n  defrag = urlunparse((s, n, p, a, q, ''))\n else:\n  frag = ''\n  defrag = url\n return _coerce_result(DefragResult(defrag, frag))\n \n_hexdig = '0123456789ABCDEFabcdef'\n_hextobyte = {(a + b).encode(): bytes([int(a + b, 16)])\nfor a in _hexdig for b in _hexdig}\n\ndef unquote_to_bytes(string):\n \"\"\n \n \n if not string:\n \n  string.split\n  return b''\n if isinstance(string, str):\n  string = string.encode('utf-8')\n bits = string.split(b'%')\n if len(bits) == 1:\n  return string\n res = [bits[0]]\n append = res.append\n for item in bits[1:]:\n  try:\n   append(_hextobyte[item[:2]])\n   append(item[2:])\n  except KeyError:\n   append(b'%')\n   append(item)\n return b''.join(res)\n \n_asciire = re.compile('([\\x00-\\x7f]+)')\n\ndef unquote(string, encoding='utf-8', errors='replace'):\n \"\"\n if '%' not in string:\n  string.split\n  return string\n if encoding is None:\n  encoding = 'utf-8'\n if errors is None:\n  errors = 'replace'\n bits = _asciire.split(string)\n res = [bits[0]]\n append = res.append\n for i in range(1, len(bits), 2):\n  append(unquote_to_bytes(bits[i]).decode(encoding, errors))\n  append(bits[i + 1])\n return ''.join(res)\n \ndef parse_qs(qs, keep_blank_values=False, strict_parsing=False,\nencoding='utf-8', errors='replace'):\n \"\"\n parsed_result = {}\n pairs = parse_qsl(qs, keep_blank_values, strict_parsing,\n encoding=encoding, errors=errors)\n for name, value in pairs:\n  if name in parsed_result:\n   parsed_result[name].append(value)\n  else:\n   parsed_result[name] = [value]\n return parsed_result\n \ndef parse_qsl(qs, keep_blank_values=False, strict_parsing=False,\nencoding='utf-8', errors='replace'):\n \"\"\n qs, _coerce_result = _coerce_args(qs)\n pairs = [s2 for s1 in qs.split('&') for s2 in s1.split(';')]\n r = []\n for name_value in pairs:\n  if not name_value and not strict_parsing:\n   continue\n  nv = name_value.split('=', 1)\n  if len(nv) != 2:\n   if strict_parsing:\n    raise ValueError(\"bad query field: %r\" % (name_value,))\n    \n   if keep_blank_values:\n    nv.append('')\n   else:\n    continue\n  if len(nv[1]) or keep_blank_values:\n   name = nv[0].replace('+', ' ')\n   name = unquote(name, encoding=encoding, errors=errors)\n   name = _coerce_result(name)\n   value = nv[1].replace('+', ' ')\n   value = unquote(value, encoding=encoding, errors=errors)\n   value = _coerce_result(value)\n   r.append((name, value))\n return r\n \ndef unquote_plus(string, encoding='utf-8', errors='replace'):\n \"\"\n string = string.replace('+', ' ')\n return unquote(string, encoding, errors)\n \n_ALWAYS_SAFE = frozenset(b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nb'abcdefghijklmnopqrstuvwxyz'\nb'0123456789'\nb'_.-')\n_ALWAYS_SAFE_BYTES = bytes(_ALWAYS_SAFE)\n_safe_quoters = {}\n\nclass Quoter(collections.defaultdict):\n \"\"\n \n \n def __init__(self, safe):\n  \"\"\n  self.safe = _ALWAYS_SAFE.union(safe)\n  \n def __repr__(self):\n \n  return \"<Quoter %r>\" % dict(self)\n  \n def __missing__(self, b):\n \n  res = chr(b) if b in self.safe else '%{:02X}'.format(b)\n  self[b] = res\n  return res\n  \ndef quote(string, safe='/', encoding=None, errors=None):\n \"\"\n if isinstance(string, str):\n  if not string:\n   return string\n  if encoding is None:\n   encoding = 'utf-8'\n  if errors is None:\n   errors = 'strict'\n  string = string.encode(encoding, errors)\n else:\n  if encoding is not None:\n   raise TypeError(\"quote() doesn't support 'encoding' for bytes\")\n  if errors is not None:\n   raise TypeError(\"quote() doesn't support 'errors' for bytes\")\n return quote_from_bytes(string, safe)\n \ndef quote_plus(string, safe='', encoding=None, errors=None):\n \"\"\n \n \n if ((isinstance(string, str) and ' ' not in string) or\n (isinstance(string, bytes) and b' ' not in string)):\n  return quote(string, safe, encoding, errors)\n if isinstance(safe, str):\n  space = ' '\n else:\n  space = b' '\n string = quote(string, safe + space, encoding, errors)\n return string.replace(' ', '+')\n \ndef quote_from_bytes(bs, safe='/'):\n \"\"\n if not isinstance(bs, (bytes, bytearray)):\n  raise TypeError(\"quote_from_bytes() expected bytes\")\n if not bs:\n  return ''\n if isinstance(safe, str):\n \n  safe = safe.encode('ascii', 'ignore')\n else:\n  safe = bytes([c for c in safe if c < 128])\n if not bs.rstrip(_ALWAYS_SAFE_BYTES + safe):\n  return bs.decode()\n try:\n  quoter = _safe_quoters[safe]\n except KeyError:\n  _safe_quoters[safe] = quoter = Quoter(safe).__getitem__\n return ''.join([quoter(char) for char in bs])\n \ndef urlencode(query, doseq=False, safe='', encoding=None, errors=None):\n \"\"\n \n if hasattr(query, \"items\"):\n  query = query.items()\n else:\n \n \n  try:\n  \n  \n   if len(query) and not isinstance(query[0], tuple):\n    raise TypeError\n    \n    \n    \n    \n  except TypeError:\n   ty, va, tb = sys.exc_info()\n   raise TypeError(\"not a valid non-string sequence \"\n   \"or mapping object\").with_traceback(tb)\n   \n l = []\n if not doseq:\n  for k, v in query:\n   if isinstance(k, bytes):\n    k = quote_plus(k, safe)\n   else:\n    k = quote_plus(str(k), safe, encoding, errors)\n    \n   if isinstance(v, bytes):\n    v = quote_plus(v, safe)\n   else:\n    v = quote_plus(str(v), safe, encoding, errors)\n   l.append(k + '=' + v)\n else:\n  for k, v in query:\n   if isinstance(k, bytes):\n    k = quote_plus(k, safe)\n   else:\n    k = quote_plus(str(k), safe, encoding, errors)\n    \n   if isinstance(v, bytes):\n    v = quote_plus(v, safe)\n    l.append(k + '=' + v)\n   elif isinstance(v, str):\n    v = quote_plus(v, safe, encoding, errors)\n    l.append(k + '=' + v)\n   else:\n    try:\n    \n     x = len(v)\n    except TypeError:\n    \n     v = quote_plus(str(v), safe, encoding, errors)\n     l.append(k + '=' + v)\n    else:\n    \n     for elt in v:\n      if isinstance(elt, bytes):\n       elt = quote_plus(elt, safe)\n      else:\n       elt = quote_plus(str(elt), safe, encoding, errors)\n      l.append(k + '=' + elt)\n return '&'.join(l)\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \ndef to_bytes(url):\n \"\"\n \n \n \n if isinstance(url, str):\n  try:\n   url = url.encode(\"ASCII\").decode()\n  except UnicodeError:\n   raise UnicodeError(\"URL \" + repr(url) +\n   \" contains non-ASCII characters\")\n return url\n \ndef unwrap(url):\n \"\"\n url = str(url).strip()\n if url[:1] == '<' and url[-1:] == '>':\n  url = url[1:-1].strip()\n if url[:4] == 'URL:': url = url[4:].strip()\n return url\n \n_typeprog = None\ndef splittype(url):\n \"\"\n global _typeprog\n if _typeprog is None:\n  import re\n  _typeprog = re.compile('^([^/:]+):')\n  \n match = _typeprog.match(url)\n if match:\n  scheme = match.group(1)\n  return scheme.lower(), url[len(scheme) + 1:]\n return None, url\n \n_hostprog = None\ndef splithost(url):\n \"\"\n global _hostprog\n if _hostprog is None:\n  import re\n  _hostprog = re.compile('^//([^/?]*)(.*)$')\n  \n match = _hostprog.match(url)\n if match:\n  host_port = match.group(1)\n  path = match.group(2)\n  if path and not path.startswith('/'):\n   path = '/' + path\n  return host_port, path\n return None, url\n \n_userprog = None\ndef splituser(host):\n \"\"\n global _userprog\n if _userprog is None:\n  import re\n  _userprog = re.compile('^(.*)@(.*)$')\n  \n match = _userprog.match(host)\n if match: return match.group(1, 2)\n return None, host\n \n_passwdprog = None\ndef splitpasswd(user):\n \"\"\n global _passwdprog\n if _passwdprog is None:\n  import re\n  _passwdprog = re.compile('^([^:]*):(.*)$',re.S)\n  \n match = _passwdprog.match(user)\n if match: return match.group(1, 2)\n return user, None\n \n \n_portprog = None\ndef splitport(host):\n \"\"\n global _portprog\n if _portprog is None:\n  import re\n  _portprog = re.compile('^(.*):([0-9]+)$')\n  \n match = _portprog.match(host)\n if match: return match.group(1, 2)\n return host, None\n \n_nportprog = None\ndef splitnport(host, defport=-1):\n \"\"\n global _nportprog\n if _nportprog is None:\n  import re\n  _nportprog = re.compile('^(.*):(.*)$')\n  \n match = _nportprog.match(host)\n if match:\n  host, port = match.group(1, 2)\n  try:\n   if not port: raise ValueError(\"no digits\")\n   nport = int(port)\n  except ValueError:\n   nport = None\n  return host, nport\n return host, defport\n \n_queryprog = None\ndef splitquery(url):\n \"\"\n global _queryprog\n if _queryprog is None:\n  import re\n  _queryprog = re.compile('^(.*)\\?([^?]*)$')\n  \n match = _queryprog.match(url)\n if match: return match.group(1, 2)\n return url, None\n \n_tagprog = None\ndef splittag(url):\n \"\"\n global _tagprog\n if _tagprog is None:\n  import re\n  _tagprog = re.compile('^(.*)#([^#]*)$')\n  \n match = _tagprog.match(url)\n if match: return match.group(1, 2)\n return url, None\n \ndef splitattr(url):\n \"\"\n words = url.split(';')\n return words[0], words[1:]\n \n_valueprog = None\ndef splitvalue(attr):\n \"\"\n global _valueprog\n if _valueprog is None:\n  import re\n  _valueprog = re.compile('^([^=]*)=(.*)$')\n  \n match = _valueprog.match(attr)\n if match: return match.group(1, 2)\n return attr, None\n"], "site-packages.pygame.time": [".py", "class _clock():\n def __init__(self):\n  pass\n  \n def tick(self, framerate):\n  pass\n  \n  \ndef Clock():\n return _clock()\n \ndef get_ticks(t):\n pass\n"], "browser.websocket": [".py", "from browser import window\nimport javascript\n\nWebSocket = javascript.JSConstructor(window.WebSocket)"], "_imp": [".py", "\"\"\n\n\nclass __loader__(object):pass\n\ndef _fix_co_filename(*args,**kw):\n raise NotImplementedError(\"%s:not implemented\" % ('_imp.py:_fix_co_filename'))\n \ndef acquire_lock(*args,**kw):\n \"\"\n pass \n \n \ndef extension_suffixes(*args,**kw):\n \"\"\n return ['.pyd']\n \ndef get_frozen_object(*args,**kw):\n raise NotImplementedError(\"%s:not implemented\" % ('_imp.py:get_frozen_object'))\n \ndef init_builtin(module,*args,**kw):\n return __import__(module)\n \ndef init_frozen(*args,**kw):\n raise NotImplementedError(\"%s:not implemented\" % ('_imp.py:init_frozen'))\n \ndef is_builtin(*args,**kw):\n raise NotImplementedError(\"%s:not implemented\" % ('_imp.py:is_builtin'))\n \ndef is_frozen(*args,**kw):\n raise NotImplementedError(\"%s:not implemented\" % ('_imp.py:is_frozen'))\n \ndef is_frozen_package(*args,**kw):\n raise NotImplementedError(\"%s:not implemented\" % ('_imp.py:is_frozen_package'))\n \ndef load_dynamic(*args,**kw):\n raise NotImplementedError(\"%s:not implemented\" % ('_imp.py:load_dynamic'))\n \ndef lock_held(*args,**kw):\n \"\"\n \n return False\n \n \ndef release_lock(*args,**kw):\n \"\"\n \n pass \n \n"], "bisect": [".py", "\"\"\n\ndef insort_right(a, x, lo=0, hi=None):\n \"\"\n \n if lo < 0:\n  raise ValueError('lo must be non-negative')\n if hi is None:\n  hi = len(a)\n while lo < hi:\n  mid = (lo+hi)//2\n  if x < a[mid]: hi = mid\n  else: lo = mid+1\n a.insert(lo, x)\n \ninsort = insort_right \n\ndef bisect_right(a, x, lo=0, hi=None):\n \"\"\n \n if lo < 0:\n  raise ValueError('lo must be non-negative')\n if hi is None:\n  hi = len(a)\n while lo < hi:\n  mid = (lo+hi)//2\n  if x < a[mid]: hi = mid\n  else: lo = mid+1\n return lo\n \nbisect = bisect_right \n\ndef insort_left(a, x, lo=0, hi=None):\n \"\"\n \n if lo < 0:\n  raise ValueError('lo must be non-negative')\n if hi is None:\n  hi = len(a)\n while lo < hi:\n  mid = (lo+hi)//2\n  if a[mid] < x: lo = mid+1\n  else: hi = mid\n a.insert(lo, x)\n \n \ndef bisect_left(a, x, lo=0, hi=None):\n \"\"\n \n if lo < 0:\n  raise ValueError('lo must be non-negative')\n if hi is None:\n  hi = len(a)\n while lo < hi:\n  mid = (lo+hi)//2\n  if a[mid] < x: lo = mid+1\n  else: hi = mid\n return lo\n \n \ntry:\n from _bisect import *\nexcept ImportError:\n pass\n"], "signal": [".py", "\"\"\n\nCTRL_BREAK_EVENT=1\nCTRL_C_EVENT=0\nNSIG=23\nSIGABRT=22\nSIGBREAK=21\nSIGFPE=8\nSIGILL=4\nSIGINT=2\nSIGSEGV=11\nSIGTERM=15\nSIG_DFL=0\nSIG_IGN=1\n\ndef signal(signalnum, handler) :\n pass\n"], "site-packages.pygame.colordict": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTHECOLORS = {\n\"\" : (43, 43, 43, 255) ,\n\"\" : (255, 215, 0, 255) ,\n\"\" : (26, 26, 26, 255) ,\n\"\" : (255, 255, 0, 255) ,\n\"\" : (28, 28, 28, 255) ,\n\"\" : (156, 156, 156, 255) ,\n\"\" : (153, 153, 153, 255) ,\n\"\" : (143, 188, 143, 255) ,\n\"\" : (158, 158, 158, 255) ,\n\"\" : (166, 166, 166, 255) ,\n\"\" : (31, 31, 31, 255) ,\n\"\" : (171, 171, 171, 255) ,\n\"\" : (168, 168, 168, 255) ,\n\"\" : (176, 176, 176, 255) ,\n\"\" : (54, 54, 54, 255) ,\n\"\" : (139, 87, 66, 255) ,\n\"\" : (238, 149, 114, 255) ,\n\"\" : (205, 129, 98, 255) ,\n\"\" : (255, 160, 122, 255) ,\n\"\" : (82, 82, 82, 255) ,\n\"\" : (0, 139, 0, 255) ,\n\"\" : (77, 77, 77, 255) ,\n\"\" : (79, 79, 79, 255) ,\n\"\" : (0, 255, 0, 255) ,\n\"\" : (94, 94, 94, 255) ,\n\"\" : (0, 205, 0, 255) ,\n\"\" : (0, 238, 0, 255) ,\n\"\" : (151, 255, 255, 255) ,\n\"\" : (141, 238, 238, 255) ,\n\"\" : (121, 205, 205, 255) ,\n\"\" : (127, 255, 212, 255) ,\n\"\" : (102, 205, 170, 255) ,\n\"\" : (118, 238, 198, 255) ,\n\"\" : (255, 239, 213, 255) ,\n\"\" : (0, 0, 0, 255) ,\n\"\" : (205, 102, 0, 255) ,\n\"\" : (253, 245, 230, 255) ,\n\"\" : (139, 129, 76, 255) ,\n\"\" : (229, 229, 229, 255) ,\n\"\" : (255, 131, 250, 255) ,\n\"\" : (238, 122, 233, 255) ,\n\"\" : (205, 105, 201, 255) ,\n\"\" : (173, 173, 173, 255) ,\n\"\" : (165, 42, 42, 255) ,\n\"\" : (145, 44, 238, 255) ,\n\"\" : (204, 204, 204, 255) ,\n\"\" : (205, 192, 176, 255) ,\n\"\" : (238, 223, 204, 255) ,\n\"\" : (255, 239, 219, 255) ,\n\"\" : (205, 104, 137, 255) ,\n\"\" : (255, 105, 180, 255) ,\n\"\" : (224, 255, 255, 255) ,\n\"\" : (205, 91, 69, 255) ,\n\"\" : (20, 20, 20, 255) ,\n\"\" : (23, 23, 23, 255) ,\n\"\" : (82, 82, 82, 255) ,\n\"\" : (139, 125, 107, 255) ,\n\"\" : (0, 255, 255, 255) ,\n\"\" : (0, 0, 0, 255) ,\n\"\" : (3, 3, 3, 255) ,\n\"\" : (15, 15, 15, 255) ,\n\"\" : (255, 228, 196, 255) ,\n\"\" : (238, 213, 183, 255) ,\n\"\" : (205, 183, 158, 255) ,\n\"\" : (135, 206, 235, 255) ,\n\"\" : (190, 190, 190, 255) ,\n\"\" : (0, 206, 209, 255) ,\n\"\" : (139, 105, 105, 255) ,\n\"\" : (0, 154, 205, 255) ,\n\"\" : (161, 161, 161, 255) ,\n\"\" : (255, 106, 106, 255) ,\n\"\" : (199, 199, 199, 255) ,\n\"\" : (255, 182, 193, 255) ,\n\"\" : (224, 224, 224, 255) ,\n\"\" : (56, 56, 56, 255) ,\n\"\" : (255, 0, 0, 255) ,\n\"\" : (28, 28, 28, 255) ,\n\"\" : (205, 201, 165, 255) ,\n\"\" : (238, 233, 191, 255) ,\n\"\" : (255, 250, 205, 255) ,\n\"\" : (205, 85, 85, 255) ,\n\"\" : (255, 62, 150, 255) ,\n\"\" : (238, 174, 238, 255) ,\n\"\" : (255, 187, 255, 255) ,\n\"\" : (139, 137, 112, 255) ,\n\"\" : (252, 252, 252, 255) ,\n\"\" : (33, 33, 33, 255) ,\n\"\" : (140, 140, 140, 255) ,\n\"\" : (0, 139, 139, 255) ,\n\"\" : (139, 69, 19, 255) ,\n\"\" : (250, 250, 210, 255) ,\n\"\" : (138, 138, 138, 255) ,\n\"\" : (230, 230, 250, 255) ,\n\"\" : (102, 205, 0, 255) ,\n\"\" : (118, 238, 0, 255) ,\n\"\" : (127, 255, 0, 255) ,\n\"\" : (122, 122, 122, 255) ,\n\"\" : (41, 41, 41, 255) ,\n\"\" : (216, 191, 216, 255) ,\n\"\" : (69, 139, 0, 255) ,\n\"\" : (104, 34, 139, 255) ,\n\"\" : (107, 107, 107, 255) ,\n\"\" : (105, 105, 105, 255) ,\n\"\" : (43, 43, 43, 255) ,\n\"\" : (105, 105, 105, 255) ,\n\"\" : (16, 78, 139, 255) ,\n\"\" : (178, 58, 238, 255) ,\n\"\" : (154, 50, 205, 255) ,\n\"\" : (0, 0, 255, 255) ,\n\"\" : (238, 180, 180, 255) ,\n\"\" : (240, 255, 240, 255) ,\n\"\" : (46, 46, 46, 255) ,\n\"\" : (100, 149, 237, 255) ,\n\"\" : (232, 232, 232, 255) ,\n\"\" : (36, 36, 36, 255) ,\n\"\" : (38, 38, 38, 255) ,\n\"\" : (41, 41, 41, 255) ,\n\"\" : (139, 28, 98, 255) ,\n\"\" : (205, 41, 144, 255) ,\n\"\" : (238, 48, 167, 255) ,\n\"\" : (255, 52, 179, 255) ,\n\"\" : (33, 33, 33, 255) ,\n\"\" : (205, 173, 0, 255) ,\n\"\" : (238, 201, 0, 255) ,\n\"\" : (255, 215, 0, 255) ,\n\"\" : (201, 201, 201, 255) ,\n\"\" : (255, 130, 171, 255) ,\n\"\" : (238, 121, 159, 255) ,\n\"\" : (139, 117, 0, 255) ,\n\"\" : (105, 105, 105, 255) ,\n\"\" : (214, 214, 214, 255) ,\n\"\" : (147, 112, 219, 255) ,\n\"\" : (255, 193, 193, 255) ,\n\"\" : (178, 223, 238, 255) ,\n\"\" : (154, 192, 205, 255) ,\n\"\" : (145, 145, 145, 255) ,\n\"\" : (191, 239, 255, 255) ,\n\"\" : (104, 131, 139, 255) ,\n\"\" : (84, 84, 84, 255) ,\n\"\" : (74, 112, 139, 255) ,\n\"\" : (247, 247, 247, 255) ,\n\"\" : (135, 206, 255, 255) ,\n\"\" : (69, 69, 69, 255) ,\n\"\" : (108, 166, 205, 255) ,\n\"\" : (126, 192, 238, 255) ,\n\"\" : (255, 240, 245, 255) ,\n\"\" : (169, 169, 169, 255) ,\n\"\" : (205, 193, 197, 255) ,\n\"\" : (47, 79, 79, 255) ,\n\"\" : (139, 131, 134, 255) ,\n\"\" : (139, 10, 80, 255) ,\n\"\" : (252, 252, 252, 255) ,\n\"\" : (92, 92, 92, 255) ,\n\"\" : (139, 62, 47, 255) ,\n\"\" : (205, 0, 205, 255) ,\n\"\" : (96, 123, 139, 255) ,\n\"\" : (72, 209, 204, 255) ,\n\"\" : (87, 87, 87, 255) ,\n\"\" : (255, 250, 240, 255) ,\n\"\" : (99, 99, 99, 255) ,\n\"\" : (92, 92, 92, 255) ,\n\"\" : (94, 94, 94, 255) ,\n\"\" : (87, 87, 87, 255) ,\n\"\" : (66, 66, 66, 255) ,\n\"\" : (67, 110, 238, 255) ,\n\"\" : (84, 84, 84, 255) ,\n\"\" : (0, 245, 255, 255) ,\n\"\" : (79, 79, 79, 255) ,\n\"\" : (99, 184, 255, 255) ,\n\"\" : (139, 71, 38, 255) ,\n\"\" : (79, 148, 205, 255) ,\n\"\" : (238, 224, 229, 255) ,\n\"\" : (255, 130, 71, 255) ,\n\"\" : (54, 100, 139, 255) ,\n\"\" : (205, 104, 57, 255) ,\n\"\" : (69, 139, 116, 255) ,\n\"\" : (255, 255, 224, 255) ,\n\"\" : (238, 238, 209, 255) ,\n\"\" : (176, 196, 222, 255) ,\n\"\" : (139, 139, 122, 255) ,\n\"\" : (238, 0, 238, 255) ,\n\"\" : (176, 226, 255, 255) ,\n\"\" : (238, 221, 130, 255) ,\n\"\" : (139, 0, 139, 255) ,\n\"\" : (222, 222, 222, 255) ,\n\"\" : (173, 255, 47, 255) ,\n\"\" : (139, 121, 94, 255) ,\n\"\" : (82, 139, 139, 255) ,\n\"\" : (107, 142, 35, 255) ,\n\"\" : (255, 222, 173, 255) ,\n\"\" : (238, 207, 161, 255) ,\n\"\" : (255, 185, 15, 255) ,\n\"\" : (160, 82, 45, 255) ,\n\"\" : (0, 0, 255, 255) ,\n\"\" : (255, 255, 0, 255) ,\n\"\" : (156, 156, 156, 255) ,\n\"\" : (255, 0, 255, 255) ,\n\"\" : (133, 133, 133, 255) ,\n\"\" : (139, 37, 0, 255) ,\n\"\" : (152, 251, 152, 255) ,\n\"\" : (219, 219, 219, 255) ,\n\"\" : (204, 204, 204, 255) ,\n\"\" : (255, 245, 238, 255) ,\n\"\" : (65, 105, 225, 255) ,\n\"\" : (205, 38, 38, 255) ,\n\"\" : (0, 0, 139, 255) ,\n\"\" : (205, 133, 63, 255) ,\n\"\" : (153, 153, 153, 255) ,\n\"\" : (127, 255, 212, 255) ,\n\"\" : (135, 135, 135, 255) ,\n\"\" : (139, 90, 43, 255) ,\n\"\" : (184, 134, 11, 255) ,\n\"\" : (238, 154, 73, 255) ,\n\"\" : (255, 165, 79, 255) ,\n\"\" : (47, 79, 79, 255) ,\n\"\" : (58, 95, 205, 255) ,\n\"\" : (238, 0, 0, 255) ,\n\"\" : (255, 0, 0, 255) ,\n\"\" : (30, 144, 255, 255) ,\n\"\" : (139, 34, 82, 255) ,\n\"\" : (255, 255, 224, 255) ,\n\"\" : (187, 255, 255, 255) ,\n\"\" : (238, 44, 44, 255) ,\n\"\" : (102, 205, 170, 255) ,\n\"\" : (255, 250, 205, 255) ,\n\"\" : (210, 105, 30, 255) ,\n\"\" : (139, 71, 137, 255) ,\n\"\" : (176, 48, 96, 255) ,\n\"\" : (97, 97, 97, 255) ,\n\"\" : (139, 69, 0, 255) ,\n\"\" : (245, 255, 250, 255) ,\n\"\" : (255, 127, 0, 255) ,\n\"\" : (250, 235, 215, 255) ,\n\"\" : (238, 118, 0, 255) ,\n\"\" : (46, 46, 46, 255) ,\n\"\" : (48, 48, 48, 255) ,\n\"\" : (97, 97, 97, 255) ,\n\"\" : (255, 228, 181, 255) ,\n\"\" : (26, 26, 26, 255) ,\n\"\" : (255, 127, 36, 255) ,\n\"\" : (238, 118, 33, 255) ,\n\"\" : (205, 102, 29, 255) ,\n\"\" : (139, 69, 19, 255) ,\n\"\" : (38, 38, 38, 255) ,\n\"\" : (72, 61, 139, 255) ,\n\"\" : (135, 206, 250, 255) ,\n\"\" : (176, 176, 176, 255) ,\n\"\" : (173, 173, 173, 255) ,\n\"\" : (255, 20, 147, 255) ,\n\"\" : (166, 166, 166, 255) ,\n\"\" : (163, 163, 163, 255) ,\n\"\" : (171, 171, 171, 255) ,\n\"\" : (168, 168, 168, 255) ,\n\"\" : (64, 64, 64, 255) ,\n\"\" : (255, 127, 80, 255) ,\n\"\" : (161, 161, 161, 255) ,\n\"\" : (158, 158, 158, 255) ,\n\"\" : (139, 105, 20, 255) ,\n\"\" : (89, 89, 89, 255) ,\n\"\" : (227, 227, 227, 255) ,\n\"\" : (255, 193, 37, 255) ,\n\"\" : (238, 180, 34, 255) ,\n\"\" : (205, 155, 29, 255) ,\n\"\" : (0, 255, 127, 255) ,\n\"\" : (0, 238, 118, 255) ,\n\"\" : (0, 205, 102, 255) ,\n\"\" : (0, 139, 69, 255) ,\n\"\" : (255, 228, 225, 255) ,\n\"\" : (244, 164, 96, 255) ,\n\"\" : (77, 77, 77, 255) ,\n\"\" : (238, 229, 222, 255) ,\n\"\" : (205, 197, 191, 255) ,\n\"\" : (210, 180, 140, 255) ,\n\"\" : (255, 245, 238, 255) ,\n\"\" : (205, 183, 181, 255) ,\n\"\" : (255, 0, 255, 255) ,\n\"\" : (255, 192, 203, 255) ,\n\"\" : (238, 238, 224, 255) ,\n\"\" : (255, 255, 240, 255) ,\n\"\" : (209, 238, 238, 255) ,\n\"\" : (60, 179, 113, 255) ,\n\"\" : (139, 139, 131, 255) ,\n\"\" : (255, 140, 0, 255) ,\n\"\" : (176, 224, 230, 255) ,\n\"\" : (30, 144, 255, 255) ,\n\"\" : (242, 242, 242, 255) ,\n\"\" : (255, 48, 48, 255) ,\n\"\" : (18, 18, 18, 255) ,\n\"\" : (139, 125, 123, 255) ,\n\"\" : (255, 99, 71, 255) ,\n\"\" : (238, 99, 99, 255) ,\n\"\" : (92, 172, 238, 255) ,\n\"\" : (255, 255, 255, 255) ,\n\"\" : (139, 134, 130, 255) ,\n\"\" : (227, 227, 227, 255) ,\n\"\" : (224, 224, 224, 255) ,\n\"\" : (222, 222, 222, 255) ,\n\"\" : (219, 219, 219, 255) ,\n\"\" : (217, 217, 217, 255) ,\n\"\" : (214, 214, 214, 255) ,\n\"\" : (25, 25, 112, 255) ,\n\"\" : (209, 209, 209, 255) ,\n\"\" : (207, 207, 207, 255) ,\n\"\" : (205, 205, 0, 255) ,\n\"\" : (205, 205, 193, 255) ,\n\"\" : (56, 56, 56, 255) ,\n\"\" : (217, 217, 217, 255) ,\n\"\" : (205, 50, 120, 255) ,\n\"\" : (28, 134, 238, 255) ,\n\"\" : (107, 107, 107, 255) ,\n\"\" : (238, 121, 66, 255) ,\n\"\" : (184, 184, 184, 255) ,\n\"\" : (186, 186, 186, 255) ,\n\"\" : (179, 179, 179, 255) ,\n\"\" : (219, 112, 147, 255) ,\n\"\" : (119, 136, 153, 255) ,\n\"\" : (196, 196, 196, 255) ,\n\"\" : (189, 189, 189, 255) ,\n\"\" : (198, 226, 255, 255) ,\n\"\" : (255, 181, 197, 255) ,\n\"\" : (171, 130, 255, 255) ,\n\"\" : (205, 145, 158, 255) ,\n\"\" : (139, 131, 120, 255) ,\n\"\" : (255, 174, 185, 255) ,\n\"\" : (224, 238, 224, 255) ,\n\"\" : (139, 134, 78, 255) ,\n\"\" : (110, 139, 61, 255) ,\n\"\" : (115, 115, 115, 255) ,\n\"\" : (159, 182, 205, 255) ,\n\"\" : (202, 255, 112, 255) ,\n\"\" : (255, 246, 143, 255) ,\n\"\" : (238, 230, 133, 255) ,\n\"\" : (205, 198, 115, 255) ,\n\"\" : (255, 240, 245, 255) ,\n\"\" : (131, 139, 131, 255) ,\n\"\" : (205, 112, 84, 255) ,\n\"\" : (238, 130, 98, 255) ,\n\"\" : (235, 235, 235, 255) ,\n\"\" : (139, 76, 57, 255) ,\n\"\" : (125, 125, 125, 255) ,\n\"\" : (122, 122, 122, 255) ,\n\"\" : (250, 240, 230, 255) ,\n\"\" : (255, 211, 155, 255) ,\n\"\" : (0, 255, 0, 255) ,\n\"\" : (120, 120, 120, 255) ,\n\"\" : (138, 43, 226, 255) ,\n\"\" : (238, 59, 59, 255) ,\n\"\" : (205, 51, 51, 255) ,\n\"\" : (255, 218, 185, 255) ,\n\"\" : (139, 35, 35, 255) ,\n\"\" : (139, 26, 26, 255) ,\n\"\" : (240, 255, 255, 255) ,\n\"\" : (193, 205, 205, 255) ,\n\"\" : (224, 238, 238, 255) ,\n\"\" : (131, 139, 139, 255) ,\n\"\" : (139, 54, 38, 255) ,\n\"\" : (139, 90, 0, 255) ,\n\"\" : (178, 34, 34, 255) ,\n\"\" : (205, 92, 92, 255) ,\n\"\" : (255, 165, 0, 255) ,\n\"\" : (205, 133, 0, 255) ,\n\"\" : (238, 154, 0, 255) ,\n\"\" : (85, 107, 47, 255) ,\n\"\" : (5, 5, 5, 255) ,\n\"\" : (112, 128, 144, 255) ,\n\"\" : (207, 207, 207, 255) ,\n\"\" : (139, 0, 0, 255) ,\n\"\" : (8, 8, 8, 255) ,\n\"\" : (202, 225, 255, 255) ,\n\"\" : (188, 210, 238, 255) ,\n\"\" : (162, 181, 205, 255) ,\n\"\" : (110, 123, 139, 255) ,\n\"\" : (205, 79, 57, 255) ,\n\"\" : (110, 110, 110, 255) ,\n\"\" : (139, 101, 8, 255) ,\n\"\" : (127, 127, 127, 255) ,\n\"\" : (139, 139, 0, 255) ,\n\"\" : (186, 85, 211, 255) ,\n\"\" : (238, 238, 0, 255) ,\n\"\" : (238, 173, 14, 255) ,\n\"\" : (205, 149, 12, 255) ,\n\"\" : (127, 255, 0, 255) ,\n\"\" : (0, 0, 205, 255) ,\n\"\" : (10, 10, 10, 255) ,\n\"\" : (0, 255, 127, 255) ,\n\"\" : (255, 165, 0, 255) ,\n\"\" : (13, 13, 13, 255) ,\n\"\" : (255, 160, 122, 255) ,\n\"\" : (48, 48, 48, 255) ,\n\"\" : (64, 224, 208, 255) ,\n\"\" : (32, 178, 170, 255) ,\n\"\" : (20, 20, 20, 255) ,\n\"\" : (23, 23, 23, 255) ,\n\"\" : (15, 15, 15, 255) ,\n\"\" : (18, 18, 18, 255) ,\n\"\" : (10, 10, 10, 255) ,\n\"\" : (13, 13, 13, 255) ,\n\"\" : (5, 5, 5, 255) ,\n\"\" : (8, 8, 8, 255) ,\n\"\" : (0, 0, 0, 255) ,\n\"\" : (3, 3, 3, 255) ,\n\"\" : (127, 127, 127, 255) ,\n\"\" : (218, 165, 32, 255) ,\n\"\" : (148, 148, 148, 255) ,\n\"\" : (150, 150, 150, 255) ,\n\"\" : (130, 130, 130, 255) ,\n\"\" : (138, 138, 138, 255) ,\n\"\" : (122, 55, 139, 255) ,\n\"\" : (143, 143, 143, 255) ,\n\"\" : (205, 179, 139, 255) ,\n\"\" : (224, 102, 255, 255) ,\n\"\" : (130, 130, 130, 255) ,\n\"\" : (180, 82, 205, 255) ,\n\"\" : (209, 95, 238, 255) ,\n\"\" : (0, 238, 238, 255) ,\n\"\" : (0, 205, 205, 255) ,\n\"\" : (59, 59, 59, 255) ,\n\"\" : (0, 255, 255, 255) ,\n\"\" : (0, 100, 0, 255) ,\n\"\" : (61, 61, 61, 255) ,\n\"\" : (0, 139, 139, 255) ,\n\"\" : (148, 0, 211, 255) ,\n\"\" : (139, 119, 101, 255) ,\n\"\" : (71, 71, 71, 255) ,\n\"\" : (71, 60, 139, 255) ,\n\"\" : (105, 89, 205, 255) ,\n\"\" : (255, 218, 185, 255) ,\n\"\" : (238, 203, 173, 255) ,\n\"\" : (205, 175, 149, 255) ,\n\"\" : (74, 74, 74, 255) ,\n\"\" : (175, 238, 238, 255) ,\n\"\" : (169, 169, 169, 255) ,\n\"\" : (64, 64, 64, 255) ,\n\"\" : (139, 0, 139, 255) ,\n\"\" : (238, 232, 170, 255) ,\n\"\" : (163, 163, 163, 255) ,\n\"\" : (31, 31, 31, 255) ,\n\"\" : (205, 16, 118, 255) ,\n\"\" : (201, 201, 201, 255) ,\n\"\" : (212, 212, 212, 255) ,\n\"\" : (238, 18, 137, 255) ,\n\"\" : (139, 115, 85, 255) ,\n\"\" : (139, 71, 93, 255) ,\n\"\" : (255, 20, 147, 255) ,\n\"\" : (122, 103, 238, 255) ,\n\"\" : (117, 117, 117, 255) ,\n\"\" : (39, 64, 139, 255) ,\n\"\" : (154, 205, 50, 255) ,\n\"\" : (72, 118, 255, 255) ,\n\"\" : (131, 111, 255, 255) ,\n\"\" : (205, 190, 112, 255) ,\n\"\" : (238, 220, 130, 255) ,\n\"\" : (0, 0, 128, 255) ,\n\"\" : (218, 112, 214, 255) ,\n\"\" : (248, 248, 255, 255) ,\n\"\" : (160, 32, 240, 255) ,\n\"\" : (189, 183, 107, 255) ,\n\"\" : (115, 115, 115, 255) ,\n\"\" : (240, 240, 240, 255) ,\n\"\" : (139, 126, 102, 255) ,\n\"\" : (245, 245, 245, 255) ,\n\"\" : (247, 247, 247, 255) ,\n\"\" : (255, 231, 186, 255) ,\n\"\" : (232, 232, 232, 255) ,\n\"\" : (205, 186, 150, 255) ,\n\"\" : (238, 216, 174, 255) ,\n\"\" : (139, 58, 58, 255) ,\n\"\" : (238, 106, 80, 255) ,\n\"\" : (255, 114, 86, 255) ,\n\"\" : (208, 32, 144, 255) ,\n\"\" : (205, 155, 155, 255) ,\n\"\" : (0, 178, 238, 255) ,\n\"\" : (0, 191, 255, 255) ,\n\"\" : (255, 228, 196, 255) ,\n\"\" : (125, 125, 125, 255) ,\n\"\" : (240, 230, 140, 255) ,\n\"\" : (245, 222, 179, 255) ,\n\"\" : (132, 112, 255, 255) ,\n\"\" : (137, 104, 205, 255) ,\n\"\" : (140, 140, 140, 255) ,\n\"\" : (0, 191, 255, 255) ,\n\"\" : (250, 250, 250, 255) ,\n\"\" : (70, 130, 180, 255) ,\n\"\" : (240, 248, 255, 255) ,\n\"\" : (164, 211, 238, 255) ,\n\"\" : (141, 182, 205, 255) ,\n\"\" : (119, 136, 153, 255) ,\n\"\" : (0, 0, 205, 255) ,\n\"\" : (0, 0, 238, 255) ,\n\"\" : (220, 220, 220, 255) ,\n\"\" : (194, 194, 194, 255) ,\n\"\" : (125, 38, 205, 255) ,\n\"\" : (139, 102, 139, 255) ,\n\"\" : (143, 143, 143, 255) ,\n\"\" : (205, 150, 205, 255) ,\n\"\" : (221, 160, 221, 255) ,\n\"\" : (211, 211, 211, 255) ,\n\"\" : (123, 104, 238, 255) ,\n\"\" : (255, 228, 225, 255) ,\n\"\" : (224, 255, 255, 255) ,\n\"\" : (181, 181, 181, 255) ,\n\"\" : (233, 150, 122, 255) ,\n\"\" : (245, 245, 220, 255) ,\n\"\" : (61, 61, 61, 255) ,\n\"\" : (240, 255, 255, 255) ,\n\"\" : (240, 255, 240, 255) ,\n\"\" : (185, 211, 238, 255) ,\n\"\" : (24, 116, 205, 255) ,\n\"\" : (108, 123, 139, 255) ,\n\"\" : (69, 69, 69, 255) ,\n\"\" : (180, 205, 205, 255) ,\n\"\" : (255, 248, 220, 255) ,\n\"\" : (255, 99, 71, 255) ,\n\"\" : (145, 145, 145, 255) ,\n\"\" : (199, 21, 133, 255) ,\n\"\" : (238, 92, 66, 255) ,\n\"\" : (139, 137, 137, 255) ,\n\"\" : (191, 191, 191, 255) ,\n\"\" : (238, 233, 233, 255) ,\n\"\" : (205, 201, 201, 255) ,\n\"\" : (255, 250, 250, 255) ,\n\"\" : (59, 59, 59, 255) ,\n\"\" : (205, 200, 177, 255) ,\n\"\" : (240, 128, 128, 255) ,\n\"\" : (255, 69, 0, 255) ,\n\"\" : (255, 222, 173, 255) ,\n\"\" : (159, 121, 238, 255) ,\n\"\" : (112, 128, 144, 255) ,\n\"\" : (238, 169, 184, 255) ,\n\"\" : (74, 74, 74, 255) ,\n\"\" : (71, 71, 71, 255) ,\n\"\" : (209, 209, 209, 255) ,\n\"\" : (222, 184, 135, 255) ,\n\"\" : (93, 71, 139, 255) ,\n\"\" : (0, 250, 154, 255) ,\n\"\" : (66, 66, 66, 255) ,\n\"\" : (54, 54, 54, 255) ,\n\"\" : (51, 51, 51, 255) ,\n\"\" : (255, 235, 205, 255) ,\n\"\" : (139, 99, 108, 255) ,\n\"\" : (199, 199, 199, 255) ,\n\"\" : (205, 133, 63, 255) ,\n\"\" : (194, 194, 194, 255) ,\n\"\" : (196, 196, 196, 255) ,\n\"\" : (255, 255, 255, 255) ,\n\"\" : (191, 191, 191, 255) ,\n\"\" : (184, 184, 184, 255) ,\n\"\" : (186, 186, 186, 255) ,\n\"\" : (179, 179, 179, 255) ,\n\"\" : (181, 181, 181, 255) ,\n\"\" : (211, 211, 211, 255) ,\n\"\" : (255, 255, 240, 255) ,\n\"\" : (117, 117, 117, 255) ,\n\"\" : (189, 189, 189, 255) ,\n\"\" : (205, 205, 180, 255) ,\n\"\" : (238, 162, 173, 255) ,\n\"\" : (205, 140, 149, 255) ,\n\"\" : (102, 139, 139, 255) ,\n\"\" : (139, 95, 101, 255) ,\n\"\" : (150, 205, 205, 255) ,\n\"\" : (46, 139, 87, 255) ,\n\"\" : (67, 205, 128, 255) ,\n\"\" : (78, 238, 148, 255) ,\n\"\" : (84, 255, 159, 255) ,\n\"\" : (174, 238, 238, 255) ,\n\"\" : (133, 133, 133, 255) ,\n\"\" : (139, 136, 120, 255) ,\n\"\" : (238, 232, 205, 255) ,\n\"\" : (162, 205, 90, 255) ,\n\"\" : (255, 248, 220, 255) ,\n\"\" : (50, 205, 50, 255) ,\n\"\" : (188, 238, 104, 255) ,\n\"\" : (190, 190, 190, 255) ,\n\"\" : (238, 58, 140, 255) ,\n\"\" : (255, 140, 105, 255) ,\n\"\" : (235, 235, 235, 255) ,\n\"\" : (237, 237, 237, 255) ,\n\"\" : (240, 240, 240, 255) ,\n\"\" : (242, 242, 242, 255) ,\n\"\" : (245, 245, 245, 255) ,\n\"\" : (212, 212, 212, 255) ,\n\"\" : (250, 250, 250, 255) ,\n\"\" : (255, 236, 139, 255) ,\n\"\" : (154, 255, 154, 255) ,\n\"\" : (205, 0, 0, 255) ,\n\"\" : (124, 205, 124, 255) ,\n\"\" : (144, 238, 144, 255) ,\n\"\" : (84, 139, 84, 255) ,\n\"\" : (95, 158, 160, 255) ,\n\"\" : (238, 130, 238, 255) ,\n\"\" : (238, 213, 210, 255) ,\n\"\" : (106, 90, 205, 255) ,\n\"\" : (110, 110, 110, 255) ,\n\"\" : (229, 229, 229, 255) ,\n\"\" : (89, 89, 89, 255) ,\n\"\" : (0, 197, 205, 255) ,\n\"\" : (0, 229, 238, 255) ,\n\"\" : (205, 170, 125, 255) ,\n\"\" : (238, 197, 145, 255) ,\n\"\" : (122, 139, 139, 255) ,\n\"\" : (188, 143, 143, 255) ,\n\"\" : (0, 134, 139, 255) ,\n\"\" : (245, 245, 245, 255) ,\n\"\" : (173, 216, 230, 255) ,\n\"\" : (102, 102, 102, 255) ,\n\"\" : (102, 102, 102, 255) ,\n\"\" : (193, 205, 193, 255) ,\n\"\" : (105, 105, 105, 255) ,\n\"\" : (120, 120, 120, 255) ,\n\"\" : (46, 139, 87, 255) ,\n\"\" : (139, 0, 0, 255) ,\n\"\" : (36, 36, 36, 255) ,\n\"\" : (255, 250, 250, 255) ,\n\"\" : (191, 62, 255, 255) ,\n\"\" : (148, 148, 148, 255) ,\n\"\" : (150, 150, 150, 255) ,\n\"\" : (83, 134, 139, 255) ,\n\"\" : (122, 197, 205, 255) ,\n\"\" : (142, 229, 238, 255) ,\n\"\" : (152, 245, 255, 255) ,\n\"\" : (105, 139, 34, 255) ,\n\"\" : (85, 26, 139, 255) ,\n\"\" : (51, 51, 51, 255) ,\n\"\" : (112, 112, 112, 255) ,\n\"\" : (155, 48, 255, 255) ,\n\"\" : (192, 255, 62, 255) ,\n\"\" : (179, 238, 58, 255) ,\n\"\" : (154, 205, 50, 255) ,\n\"\" : (205, 55, 0, 255) ,\n\"\" : (238, 64, 0, 255) ,\n\"\" : (255, 69, 0, 255) ,\n\"\" : (153, 50, 204, 255) ,\n\"\" : (205, 181, 205, 255) ,\n\"\" : (238, 210, 238, 255) ,\n\"\" : (255, 225, 255, 255) ,\n\"\" : (250, 128, 114, 255) ,\n\"\" : (237, 237, 237, 255) ,\n\"\" : (139, 123, 139, 255) ,\n\"\" : (99, 99, 99, 255) ,\n\"\" : (124, 252, 0, 255) ,\n\"\" : (205, 96, 144, 255) ,\n\"\" : (238, 106, 167, 255) ,\n\"\" : (255, 110, 180, 255) ,\n\"\" : (144, 238, 144, 255) ,\n\"\" : (139, 58, 98, 255) ,\n\"\" : (105, 139, 105, 255) ,\n\"\" : (155, 205, 155, 255) ,\n\"\" : (180, 238, 180, 255) ,\n\"\" : (193, 255, 193, 255) ,\n\"\" : (0, 104, 139, 255) ,\n\"\" : (112, 112, 112, 255) ,\n\"\" : (0, 0, 128, 255) ,\n\"\" : (0, 0, 139, 255) ,\n\"\" : (34, 139, 34, 255) ,\n\"\" : (135, 135, 135, 255) ,\n\"\" : (255, 255, 255, 255) ,\n\"\" : (255, 64, 64, 255) ,\n}\n"], "_html": [".js", "// creation of an HTML element\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\nvar $TagSumDict = $B.$TagSum.$dict\n\nfunction makeTagDict(tagName){\n    // return the dictionary for the class associated with tagName\n    var dict = {__class__:$B.$type,\n        __name__:tagName\n        }\n\n    dict.__init__ = function(){\n        var $ns=$B.$MakeArgs('pow',arguments,['self'],[],'args','kw')\n        var self = $ns['self']\n        var args = $ns['args']\n        if(args.length==1){\n            var first=args[0]\n            if(_b_.isinstance(first,[_b_.str,_b_.int,_b_.float])){\n                self.elt.appendChild(document.createTextNode(_b_.str(first)))\n            } else if(first.__class__===$TagSumDict){\n                for(var i=0, _len_i = first.children.length; i < _len_i;i++){\n                    self.elt.appendChild(first.children[i].elt)\n                }\n            } else { // argument is another DOMNode instance\n                try{self.elt.appendChild(first.elt)}\n                catch(err){throw _b_.ValueError('wrong element '+first)}\n            }\n        }\n\n        // attributes\n        var items = _b_.list(_b_.dict.$dict.items($ns['kw']))\n        for(var i=0, _len_i = items.length; i < _len_i;i++){\n            // keyword arguments\n            var arg = items[i][0]\n            var value = items[i][1]\n            if(arg.toLowerCase().substr(0,2)===\"on\"){ \n                // Event binding passed as argument \"onclick\", \"onfocus\"...\n                // Better use method bind of DOMNode objects\n                var js = '$B.DOMNode.bind(self,\"'\n                js += arg.toLowerCase().substr(2)\n                eval(js+'\",function(){'+value+'})')\n            }else if(arg.toLowerCase()==\"style\"){\n                $B.DOMNode.set_style(self,value)\n            } else {\n                if(value!==false){\n                    // option.selected=false sets it to true :-)\n                    try{\n                        arg = arg.toLowerCase().replace('_','-')\n                        self.elt.setAttribute(arg,value)\n                    }catch(err){\n                        throw _b_.ValueError(\"can't set attribute \"+arg)\n                    }\n                }\n            }\n        }\n    }\n\n    dict.__mro__ = [dict,$B.DOMNode,$B.builtins.object.$dict]\n\n    dict.__new__ = function(cls){\n        // __new__ must be defined explicitely : it returns an instance of\n        // DOMNode for the specified tagName\n        var res = $B.$DOMNode(document.createElement(tagName))\n        res.__class__ = cls.$dict\n        return res\n    }\n\n    return dict\n}\n\n\n// the classes used for tag sums, $TagSum and $TagSumClass \n// are defined in py_dom.js\n\nfunction makeFactory(tagName){\n    var factory = function(){\n        var res = $B.$DOMNode(document.createElement(tagName))\n        res.__class__ = dicts[tagName]\n        // apply __init__\n        var args = [res].concat(Array.prototype.slice.call(arguments))\n        dicts[tagName].__init__.apply(null,args)\n        return res\n    }\n    factory.__class__=$B.$factory\n    factory.$dict = dicts[tagName]\n    return factory\n}\n\n// All HTML 4, 5.x extracted from\n// https://w3c.github.io/elements-of-html/\n// HTML4.01 tags\nvar $tags = ['A','ABBR','ACRONYM','ADDRESS','APPLET','AREA','B','BASE',\n            'BASEFONT','BDO','BIG','BLOCKQUOTE','BODY','BR','BUTTON',\n            'CAPTION','CENTER','CITE','CODE','COL','COLGROUP','DD',\n            'DEL','DFN','DIR','DIV','DL','DT','EM','FIELDSET','FONT',\n            'FORM','FRAME','FRAMESET','H1','H2','H3','H4','H5','H6',\n            'HEAD','HR','HTML','I','IFRAME','IMG','INPUT','INS',\n            'ISINDEX','KBD','LABEL','LEGEND','LI','LINK','MAP','MENU',\n            'META','NOFRAMES','NOSCRIPT','OBJECT','OL','OPTGROUP',\n            'OPTION','P','PARAM','PRE','Q','S','SAMP','SCRIPT','SELECT',\n            'SMALL','SPAN','STRIKE','STRONG','STYLE','SUB','SUP',\n            'TABLE','TBODY','TD','TEXTAREA','TFOOT','TH','THEAD',\n            'TITLE','TR','TT','U','UL','VAR',\n            // HTML5 tags\n            'ARTICLE','ASIDE','AUDIO','BDI','CANVAS','COMMAND','DATA',\n            'DATALIST','EMBED','FIGCAPTION','FIGURE','FOOTER','HEADER',\n            'KEYGEN','MAIN','MARK','MATH','METER','NAV','OUTPUT',\n            'PROGRESS','RB','RP','RT','RTC','RUBY','SECTION','SOURCE',\n            'TEMPLATE','TIME','TRACK','VIDEO','WBR',\n             // HTML5.1 tags\n            'DETAILS','DIALOG','MENUITEM','PICTURE','SUMMARY']\n\n// create classes\nvar obj = new Object()\nvar dicts = {}\nfor(var i=0, _len_i = $tags.length; i < _len_i;i++){\n    var tag = $tags[i]\n    dicts[tag] = makeTagDict(tag)\n    obj[tag] = makeFactory(tag)\n    dicts[tag].$factory = obj[tag]\n}\n$B.tag_classes = dicts\nreturn obj\n})(__BRYTHON__)\n"], "_sys": [".js", "var $module=(function($B){\n    var _b_=$B.builtins\n    return {\n        modules :\n            {'__get__':function(){return _b_.dict($B.JSObject($B.imported))},\n             '__set__':0 // data descriptor, to force use of __get__\n            },\n        stderr : {\n            __get__:function(){return $B.stderr},\n            __set__:function(self, obj, value){$B.stderr = value},\n            write:function(data){_b_.getattr($B.stderr,\"write\")(data)}\n            },\n        stdout : {\n            __get__:function(){return $B.stdout},\n            __set__:function(self, obj, value){$B.stdout = value},\n            write:function(data){_b_.getattr($B.stdout,\"write\")(data)}\n            },\n        stdin : $B.stdin\n    }\n})(__BRYTHON__)\n"], "browser.session_storage": [".py", "\nimport sys\nfrom javascript import JSObject\nfrom .local_storage import LocalStorage\n\nclass SessionStorage(LocalStorage):\n\n storage_type = \"session_storage\"\n \n def __init__(self):\n  if not sys.has_session_storage:\n   raise EnvironmentError(\"SessionStorage not available\")\n  self.store = JSObject(__BRYTHON__.session_storage)\n  \nif sys.has_session_storage:\n storage = SessionStorage()\n"], "pydoc": [".py", "\n\"\"\n__all__ = ['help']\n__author__ = \"Ka-Ping Yee <ping@lfw.org>\"\n__date__ = \"26 February 2001\"\n\n__credits__ = \"\"\"Guido van Rossum, for an excellent programming language.\nTommy Burnette, the original creator of manpy.\nPaul Prescod, for all his work on onlinehelp.\nRichard Chamberlain, for the first implementation of textdoc.\n\"\"\"\n\n\n\n\n\n\n\n\n\nimport builtins\nimport imp\nimport importlib.machinery\n\nimport inspect\nimport io\nimport os\n\n\nimport platform\nimport re\nimport sys\nimport time\nimport tokenize\nimport warnings\nfrom collections import deque\nfrom reprlib import Repr\n\n\n\n\n\n\ndef pathdirs():\n \"\"\n dirs = []\n normdirs = []\n for dir in sys.path:\n  dir = os.path.abspath(dir or '.')\n  normdir = os.path.normcase(dir)\n  if normdir not in normdirs and os.path.isdir(dir):\n   dirs.append(dir)\n   normdirs.append(normdir)\n return dirs\n \ndef getdoc(object):\n \"\"\n result = inspect.getdoc(object) or inspect.getcomments(object)\n return result and re.sub('^ *\\n', '', result.rstrip()) or ''\n \ndef splitdoc(doc):\n \"\"\n lines = doc.strip().split('\\n')\n if len(lines) == 1:\n  return lines[0], ''\n elif len(lines) >= 2 and not lines[1].rstrip():\n  return lines[0], '\\n'.join(lines[2:])\n return '', '\\n'.join(lines)\n \ndef classname(object, modname):\n \"\"\n name = object.__name__\n if object.__module__ != modname:\n  name = object.__module__ + '.' + name\n return name\n \ndef isdata(object):\n \"\"\n return not (inspect.ismodule(object) or inspect.isclass(object) or\n inspect.isroutine(object) or inspect.isframe(object) or\n inspect.istraceback(object) or inspect.iscode(object))\n \ndef replace(text, *pairs):\n \"\"\n while pairs:\n  text = pairs[1].join(text.split(pairs[0]))\n  pairs = pairs[2:]\n return text\n \ndef cram(text, maxlen):\n \"\"\n if len(text) > maxlen:\n  pre = max(0, (maxlen-3)//2)\n  post = max(0, maxlen-3-pre)\n  return text[:pre] + '...' + text[len(text)-post:]\n return text\n \n_re_stripid = re.compile(r' at 0x[0-9a-f]{6,16}(>+)$', re.IGNORECASE)\ndef stripid(text):\n \"\"\n \n \n \n return text\n \ndef _is_some_method(obj):\n return (inspect.isfunction(obj) or\n inspect.ismethod(obj) or\n inspect.isbuiltin(obj) or\n inspect.ismethoddescriptor(obj))\n \ndef allmethods(cl):\n methods = {}\n for key, value in inspect.getmembers(cl, _is_some_method):\n  methods[key] = 1\n for base in cl.__bases__:\n  methods.update(allmethods(base)) \n for key in methods.keys():\n  methods[key] = getattr(cl, key)\n return methods\n \ndef _split_list(s, predicate):\n \"\"\n \n yes = []\n no = []\n for x in s:\n  if predicate(x):\n   yes.append(x)\n  else:\n   no.append(x)\n return yes, no\n \ndef visiblename(name, all=None, obj=None):\n \"\"\n \n if name in {'__author__', '__builtins__', '__cached__', '__credits__',\n '__date__', '__doc__', '__file__', '__initializing__',\n '__loader__', '__module__', '__name__', '__package__',\n '__path__', '__qualname__', '__slots__', '__version__'}:\n  return 0\n  \n if name.startswith('__') and name.endswith('__'): return 1\n \n if name.startswith('_') and hasattr(obj, '_fields'):\n  return True\n if all is not None:\n \n  return name in all\n else:\n  return not name.startswith('_')\n  \ndef classify_class_attrs(object):\n \"\"\n results = []\n for (name, kind, cls, value) in inspect.classify_class_attrs(object):\n  if inspect.isdatadescriptor(value):\n   kind = 'data descriptor'\n  results.append((name, kind, cls, value))\n return results\n \n \n \ndef ispackage(path):\n \"\"\n if os.path.isdir(path):\n  for ext in ('.py', '.pyc', '.pyo'):\n   if os.path.isfile(os.path.join(path, '__init__' + ext)):\n    return True\n return False\n \ndef source_synopsis(file):\n line = file.readline()\n while line[:1] == '#' or not line.strip():\n  line = file.readline()\n  if not line: break\n line = line.strip()\n if line[:4] == 'r\"\"\"': line = line[1:]\n if line[:3] == '\"\"\"':\n  line = line[3:]\n  if line[-1:] == '\\\\': line = line[:-1]\n  while not line.strip():\n   line = file.readline()\n   if not line: break\n  result = line.split('\"\"\"')[0].strip()\n else: result = None\n return result\n \ndef synopsis(filename, cache={}):\n \"\"\n mtime = os.stat(filename).st_mtime\n lastupdate, result = cache.get(filename, (None, None))\n if lastupdate is None or lastupdate < mtime:\n  try:\n   file = tokenize.open(filename)\n  except IOError:\n  \n   return None\n  binary_suffixes = importlib.machinery.BYTECODE_SUFFIXES[:]\n  binary_suffixes += importlib.machinery.EXTENSION_SUFFIXES[:]\n  if any(filename.endswith(x) for x in binary_suffixes):\n  \n   file.close()\n   if any(filename.endswith(x) for x in\n   importlib.machinery.BYTECODE_SUFFIXES):\n    loader = importlib.machinery.SourcelessFileLoader('__temp__',\n    filename)\n   else:\n    loader = importlib.machinery.ExtensionFileLoader('__temp__',\n    filename)\n   try:\n    module = loader.load_module('__temp__')\n   except:\n    return None\n   result = (module.__doc__ or '').splitlines()[0]\n   del sys.modules['__temp__']\n  else:\n  \n   result = source_synopsis(file)\n   file.close()\n   \n  cache[filename] = (mtime, result)\n return result\n \nclass ErrorDuringImport(Exception):\n \"\"\n def __init__(self, filename, exc_info):\n  self.filename = filename\n  self.exc, self.value, self.tb = exc_info\n  \n def __str__(self):\n  exc = self.exc.__name__\n  return 'problem in %s - %s: %s' % (self.filename, exc, self.value)\n  \ndef importfile(path):\n \"\"\n magic = imp.get_magic()\n with open(path, 'rb') as file:\n  if file.read(len(magic)) == magic:\n   kind = imp.PY_COMPILED\n  else:\n   kind = imp.PY_SOURCE\n  file.seek(0)\n  filename = os.path.basename(path)\n  name, ext = os.path.splitext(filename)\n  try:\n   module = imp.load_module(name, file, path, (ext, 'r', kind))\n  except:\n   raise ErrorDuringImport(path, sys.exc_info())\n return module\n \ndef safeimport(path, forceload=0, cache={}):\n \"\"\n try:\n \n \n \n \n  if forceload and path in sys.modules:\n   if path not in sys.builtin_module_names:\n   \n   \n   \n   \n   \n    subs = [m for m in sys.modules if m.startswith(path + '.')]\n    for key in [path] + subs:\n    \n     cache[key] = sys.modules[key]\n     del sys.modules[key]\n  module = __import__(path)\n except:\n \n  (exc, value, tb) = info = sys.exc_info()\n  if path in sys.modules:\n  \n   raise ErrorDuringImport(sys.modules[path].__file__, info)\n  elif exc is SyntaxError:\n  \n   raise ErrorDuringImport(value.filename, info)\n   \n   \n  elif exc is ImportError and str(value) == str(path):\n  \n   return None\n  else:\n  \n   raise ErrorDuringImport(path, sys.exc_info())\n for part in path.split('.')[1:]:\n  try: module = getattr(module, part)\n  except AttributeError: return None\n return module\n \n \n \nclass Doc:\n\n PYTHONDOCS = os.environ.get(\"PYTHONDOCS\",\n \"http://docs.python.org/%d.%d/library\"\n % sys.version_info[:2])\n \n def document(self, object, name=None, *args):\n  \"\"\n  args = (object, name) + args\n  \n  \n  \n  \n  if inspect.isgetsetdescriptor(object): return self.docdata(*args)\n  if inspect.ismemberdescriptor(object): return self.docdata(*args)\n  try:\n   if inspect.ismodule(object): return self.docmodule(*args)\n   if inspect.isclass(object): return self.docclass(*args)\n   if inspect.isroutine(object): return self.docroutine(*args)\n  except AttributeError:\n   pass\n  if isinstance(object, property): return self.docproperty(*args)\n  return self.docother(*args)\n  \n def fail(self, object, name=None, *args):\n  \"\"\n  message = \"don't know how to document object%s of type %s\" % (\n  name and ' ' + repr(name), type(object).__name__)\n  raise TypeError(message)\n  \n docmodule = docclass = docroutine = docother = docproperty = docdata = fail\n \n def getdocloc(self, object):\n  \"\"\n  \n  try:\n   file = inspect.getabsfile(object)\n  except TypeError:\n   file = '(built-in)'\n   \n  docloc = os.environ.get(\"PYTHONDOCS\", self.PYTHONDOCS)\n  \n  basedir = os.path.join(sys.base_exec_prefix, \"lib\",\n  \"python%d.%d\" % sys.version_info[:2])\n  if (isinstance(object, type(os)) and\n  (object.__name__ in ('errno', 'exceptions', 'gc', 'imp',\n  'marshal', 'posix', 'signal', 'sys',\n  '_thread', 'zipimport') or\n  (file.startswith(basedir) and\n  not file.startswith(os.path.join(basedir, 'site-packages')))) and\n  object.__name__ not in ('xml.etree', 'test.pydoc_mod')):\n   if docloc.startswith(\"http://\"):\n    docloc = \"%s/%s\" % (docloc.rstrip(\"/\"), object.__name__)\n   else:\n    docloc = os.path.join(docloc, object.__name__ + \".html\")\n  else:\n   docloc = None\n  return docloc\n  \n  \n  \nclass HTMLRepr(Repr):\n \"\"\n def __init__(self):\n  Repr.__init__(self)\n  self.maxlist = self.maxtuple = 20\n  self.maxdict = 10\n  self.maxstring = self.maxother = 100\n  \n def escape(self, text):\n  return replace(text, '&', '&amp;', '<', '&lt;', '>', '&gt;')\n  \n def repr(self, object):\n  return Repr.repr(self, object)\n  \n def repr1(self, x, level):\n  if hasattr(type(x), '__name__'):\n   methodname = 'repr_' + '_'.join(type(x).__name__.split())\n   if hasattr(self, methodname):\n    return getattr(self, methodname)(x, level)\n  return self.escape(cram(stripid(repr(x)), self.maxother))\n  \n def repr_string(self, x, level):\n  test = cram(x, self.maxstring)\n  testrepr = repr(test)\n  if '\\\\' in test and '\\\\' not in replace(testrepr, r'\\\\', ''):\n  \n  \n   return 'r' + testrepr[0] + self.escape(test) + testrepr[0]\n  return re.sub(r'((\\\\[\\\\abfnrtv\\'\"]|\\\\[0-9]..|\\\\x..|\\\\u....)+)',\n  r'<font color=\"#c040c0\">\\1</font>',\n  self.escape(testrepr))\n  \n repr_str = repr_string\n \n def repr_instance(self, x, level):\n  try:\n   return self.escape(cram(stripid(repr(x)), self.maxstring))\n  except:\n   return self.escape('<%s instance>' % x.__class__.__name__)\n   \n repr_unicode = repr_string\n \nclass HTMLDoc(Doc):\n \"\"\n \n \n \n _repr_instance = HTMLRepr()\n repr = _repr_instance.repr\n escape = _repr_instance.escape\n \n def page(self, title, contents):\n  \"\"\n  return '''\\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html><head><title>Python: %s</title>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n</head><body bgcolor=\"#f0f0f8\">\n%s\n</body></html>'''  % (title, contents)\n  \n def heading(self, title, fgcol, bgcol, extras=''):\n  \"\"\n  return '''\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"heading\">\n<tr bgcolor=\"%s\">\n<td valign=bottom>&nbsp;<br>\n<font color=\"%s\" face=\"helvetica, arial\">&nbsp;<br>%s</font></td\n><td align=right valign=bottom\n><font color=\"%s\" face=\"helvetica, arial\">%s</font></td></tr></table>\n    '''  % (bgcol, fgcol, title, fgcol, extras or '&nbsp;')\n  \n def section(self, title, fgcol, bgcol, contents, width=6,\n prelude='', marginalia=None, gap='&nbsp;'):\n  \"\"\n  if marginalia is None:\n   marginalia = '<tt>' + '&nbsp;' * width + '</tt>'\n  result = '''<p>\n<table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"section\">\n<tr bgcolor=\"%s\">\n<td colspan=3 valign=bottom>&nbsp;<br>\n<font color=\"%s\" face=\"helvetica, arial\">%s</font></td></tr>\n    '''  % (bgcol, fgcol, title)\n  if prelude:\n   result = result + '''\n<tr bgcolor=\"%s\"><td rowspan=2>%s</td>\n<td colspan=2>%s</td></tr>\n<tr><td>%s</td>'''   % (bgcol, marginalia, prelude, gap)\n  else:\n   result = result + '''\n<tr><td bgcolor=\"%s\">%s</td><td>%s</td>'''   % (bgcol, marginalia, gap)\n   \n  return result + '\\n<td width=\"100%%\">%s</td></tr></table>' % contents\n  \n def bigsection(self, title, *args):\n  \"\"\n  title = '<big><strong>%s</strong></big>' % title\n  return self.section(title, *args)\n  \n def preformat(self, text):\n  \"\"\n  text = self.escape(text.expandtabs())\n  return replace(text, '\\n\\n', '\\n \\n', '\\n\\n', '\\n \\n',\n  ' ', '&nbsp;', '\\n', '<br>\\n')\n  \n def multicolumn(self, list, format, cols=4):\n  \"\"\n  result = ''\n  rows = (len(list)+cols-1)//cols\n  for col in range(cols):\n   result = result + '<td width=\"%d%%\" valign=top>' % (100//cols)\n   for i in range(rows*col, rows*col+rows):\n    if i < len(list):\n     result = result + format(list[i]) + '<br>\\n'\n   result = result + '</td>'\n  return '<table width=\"100%%\" summary=\"list\"><tr>%s</tr></table>' % result\n  \n def grey(self, text): return '<font color=\"#909090\">%s</font>' % text\n \n def namelink(self, name, *dicts):\n  \"\"\n  for dict in dicts:\n   if name in dict:\n    return '<a href=\"%s\">%s</a>' % (dict[name], name)\n  return name\n  \n def classlink(self, object, modname):\n  \"\"\n  name, module = object.__name__, sys.modules.get(object.__module__)\n  if hasattr(module, name) and getattr(module, name) is object:\n   return '<a href=\"%s.html#%s\">%s</a>' % (\n   module.__name__, name, classname(object, modname))\n  return classname(object, modname)\n  \n def modulelink(self, object):\n  \"\"\n  return '<a href=\"%s.html\">%s</a>' % (object.__name__, object.__name__)\n  \n def modpkglink(self, modpkginfo):\n  \"\"\n  name, path, ispackage, shadowed = modpkginfo\n  if shadowed:\n   return self.grey(name)\n  if path:\n   url = '%s.%s.html' % (path, name)\n  else:\n   url = '%s.html' % name\n  if ispackage:\n   text = '<strong>%s</strong>&nbsp;(package)' % name\n  else:\n   text = name\n  return '<a href=\"%s\">%s</a>' % (url, text)\n  \n def filelink(self, url, path):\n  \"\"\n  return '<a href=\"file:%s\">%s</a>' % (url, path)\n  \n def markup(self, text, escape=None, funcs={}, classes={}, methods={}):\n  \"\"\n  escape = escape or self.escape\n  results = []\n  here = 0\n  pattern = re.compile(r'\\b((http|ftp)://\\S+[\\w/]|'\n  r'RFC[- ]?(\\d+)|'\n  r'PEP[- ]?(\\d+)|'\n  r'(self\\.)?(\\w+))')\n  while True:\n   match = pattern.search(text, here)\n   if not match: break\n   start, end = match.span()\n   results.append(escape(text[here:start]))\n   \n   all, scheme, rfc, pep, selfdot, name = match.groups()\n   if scheme:\n    url = escape(all).replace('\"', '&quot;')\n    results.append('<a href=\"%s\">%s</a>' % (url, url))\n   elif rfc:\n    url = 'http://www.rfc-editor.org/rfc/rfc%d.txt' % int(rfc)\n    results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n   elif pep:\n    url = 'http://www.python.org/dev/peps/pep-%04d/' % int(pep)\n    results.append('<a href=\"%s\">%s</a>' % (url, escape(all)))\n   elif text[end:end+1] == '(':\n    results.append(self.namelink(name, methods, funcs, classes))\n   elif selfdot:\n    results.append('self.<strong>%s</strong>' % name)\n   else:\n    results.append(self.namelink(name, classes))\n   here = end\n  results.append(escape(text[here:]))\n  return ''.join(results)\n  \n  \n  \n def formattree(self, tree, modname, parent=None):\n  \"\"\n  result = ''\n  for entry in tree:\n   if type(entry) is type(()):\n    c, bases = entry\n    result = result + '<dt><font face=\"helvetica, arial\">'\n    result = result + self.classlink(c, modname)\n    if bases and bases != (parent,):\n     parents = []\n     for base in bases:\n      parents.append(self.classlink(base, modname))\n     result = result + '(' + ', '.join(parents) + ')'\n    result = result + '\\n</font></dt>'\n   elif type(entry) is type([]):\n    result = result + '<dd>\\n%s</dd>\\n' % self.formattree(\n    entry, modname, c)\n  return '<dl>\\n%s</dl>\\n' % result\n  \n def docmodule(self, object, name=None, mod=None, *ignored):\n  \"\"\n  name = object.__name__ \n  try:\n   all = object.__all__\n  except AttributeError:\n   all = None\n  parts = name.split('.')\n  links = []\n  for i in range(len(parts)-1):\n   links.append(\n   '<a href=\"%s.html\"><font color=\"#ffffff\">%s</font></a>' %\n   ('.'.join(parts[:i+1]), parts[i]))\n  linkedname = '.'.join(links + parts[-1:])\n  head = '<big><big><strong>%s</strong></big></big>' % linkedname\n  try:\n   path = inspect.getabsfile(object)\n   url = path\n   if sys.platform == 'win32':\n    import nturl2path\n    url = nturl2path.pathname2url(path)\n   filelink = self.filelink(url, path)\n  except TypeError:\n   filelink = '(built-in)'\n  info = []\n  if hasattr(object, '__version__'):\n   version = str(object.__version__)\n   if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':\n    version = version[11:-1].strip()\n   info.append('version %s' % self.escape(version))\n  if hasattr(object, '__date__'):\n   info.append(self.escape(str(object.__date__)))\n  if info:\n   head = head + ' (%s)' % ', '.join(info)\n  docloc = self.getdocloc(object)\n  if docloc is not None:\n   docloc = '<br><a href=\"%(docloc)s\">Module Reference</a>' % locals()\n  else:\n   docloc = ''\n  result = self.heading(\n  head, '#ffffff', '#7799ee',\n  '<a href=\".\">index</a><br>' + filelink + docloc)\n  \n  modules = inspect.getmembers(object, inspect.ismodule)\n  \n  classes, cdict = [], {}\n  for key, value in inspect.getmembers(object, inspect.isclass):\n  \n   if (all is not None or\n   (inspect.getmodule(value) or object) is object):\n    if visiblename(key, all, object):\n     classes.append((key, value))\n     cdict[key] = cdict[value] = '#' + key\n  for key, value in classes:\n   for base in value.__bases__:\n    key, modname = base.__name__, base.__module__\n    module = sys.modules.get(modname)\n    if modname != name and module and hasattr(module, key):\n     if getattr(module, key) is base:\n      if not key in cdict:\n       cdict[key] = cdict[base] = modname + '.html#' + key\n  funcs, fdict = [], {}\n  for key, value in inspect.getmembers(object, inspect.isroutine):\n  \n   if (all is not None or\n   inspect.isbuiltin(value) or inspect.getmodule(value) is object):\n    if visiblename(key, all, object):\n     funcs.append((key, value))\n     fdict[key] = '#-' + key\n     if inspect.isfunction(value): fdict[value] = fdict[key]\n  data = []\n  for key, value in inspect.getmembers(object, isdata):\n   if visiblename(key, all, object):\n    data.append((key, value))\n    \n  doc = self.markup(getdoc(object), self.preformat, fdict, cdict)\n  doc = doc and '<tt>%s</tt>' % doc\n  result = result + '<p>%s</p>\\n' % doc\n  \n  if hasattr(object, '__path__'):\n   modpkgs = []\n   for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):\n    modpkgs.append((modname, name, ispkg, 0))\n   modpkgs.sort()\n   contents = self.multicolumn(modpkgs, self.modpkglink)\n   result = result + self.bigsection(\n   'Package Contents', '#ffffff', '#aa55cc', contents)\n  elif modules:\n   contents = self.multicolumn(\n   modules, lambda t: self.modulelink(t[1]))\n   result = result + self.bigsection(\n   'Modules', '#ffffff', '#aa55cc', contents)\n   \n  if classes:\n   classlist = [value for (key, value) in classes]\n   contents = [\n   self.formattree(inspect.getclasstree(classlist, 1), name)]\n   for key, value in classes:\n    contents.append(self.document(value, key, name, fdict, cdict))\n   result = result + self.bigsection(\n   'Classes', '#ffffff', '#ee77aa', ' '.join(contents))\n  if funcs:\n   contents = []\n   for key, value in funcs:\n    contents.append(self.document(value, key, name, fdict, cdict))\n   result = result + self.bigsection(\n   'Functions', '#ffffff', '#eeaa77', ' '.join(contents))\n  if data:\n   contents = []\n   for key, value in data:\n    contents.append(self.document(value, key))\n   result = result + self.bigsection(\n   'Data', '#ffffff', '#55aa55', '<br>\\n'.join(contents))\n  if hasattr(object, '__author__'):\n   contents = self.markup(str(object.__author__), self.preformat)\n   result = result + self.bigsection(\n   'Author', '#ffffff', '#7799ee', contents)\n  if hasattr(object, '__credits__'):\n   contents = self.markup(str(object.__credits__), self.preformat)\n   result = result + self.bigsection(\n   'Credits', '#ffffff', '#7799ee', contents)\n   \n  return result\n  \n def docclass(self, object, name=None, mod=None, funcs={}, classes={},\n *ignored):\n  \"\"\n  print('docclass')\n  realname = object.__name__\n  name = name or realname\n  bases = object.__bases__\n  \n  contents = []\n  push = contents.append\n  \n  \n  class HorizontalRule:\n   def __init__(self):\n    self.needone = 0\n   def maybe(self):\n    if self.needone:\n     push('<hr>\\n')\n    self.needone = 1\n  hr = HorizontalRule()\n  \n  \n  mro = deque(inspect.getmro(object))\n  if len(mro) > 2:\n   hr.maybe()\n   push('<dl><dt>Method resolution order:</dt>\\n')\n   for base in mro:\n    push('<dd>%s</dd>\\n' % self.classlink(base,\n    object.__module__))\n   push('</dl>\\n')\n   \n  def spill(msg, attrs, predicate):\n   ok, attrs = _split_list(attrs, predicate)\n   if ok:\n    hr.maybe()\n    push(msg)\n    for name, kind, homecls, value in ok:\n     try:\n      value = getattr(object, name)\n     except Exception:\n     \n     \n      push(self._docdescriptor(name, value, mod))\n     else:\n      push(self.document(value, name, mod,\n      funcs, classes, mdict, object))\n     push('\\n')\n   return attrs\n   \n  def spilldescriptors(msg, attrs, predicate):\n   ok, attrs = _split_list(attrs, predicate)\n   if ok:\n    hr.maybe()\n    push(msg)\n    for name, kind, homecls, value in ok:\n     push(self._docdescriptor(name, value, mod))\n   return attrs\n   \n  def spilldata(msg, attrs, predicate):\n   ok, attrs = _split_list(attrs, predicate)\n   if ok:\n    hr.maybe()\n    push(msg)\n    for name, kind, homecls, value in ok:\n     base = self.docother(getattr(object, name), name, mod)\n     if callable(value) or inspect.isdatadescriptor(value):\n      doc = getattr(value, \"__doc__\", None)\n     else:\n      doc = None\n     if doc is None:\n      push('<dl><dt>%s</dl>\\n' % base)\n     else:\n      doc = self.markup(getdoc(value), self.preformat,\n      funcs, classes, mdict)\n      doc = '<dd><tt>%s</tt>' % doc\n      push('<dl><dt>%s%s</dl>\\n' % (base, doc))\n     push('\\n')\n   return attrs\n   \n  attrs = [(name, kind, cls, value)\n  for name, kind, cls, value in classify_class_attrs(object)\n  if visiblename(name, obj=object)]\n  \n  mdict = {}\n  for key, kind, homecls, value in attrs:\n   mdict[key] = anchor = '#' + name + '-' + key\n   try:\n    value = getattr(object, name)\n   except Exception:\n   \n   \n    pass\n   try:\n   \n   \n    mdict[value] = anchor\n   except TypeError:\n    pass\n    \n  while attrs:\n   if mro:\n    thisclass = mro.popleft()\n   else:\n    thisclass = attrs[0][2]\n   attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)\n   \n   if thisclass is builtins.object:\n    attrs = inherited\n    continue\n   elif thisclass is object:\n    tag = 'defined here'\n   else:\n    tag = 'inherited from %s' % self.classlink(thisclass,\n    object.__module__)\n   tag += ':<br>\\n'\n   \n   \n   attrs.sort(key=lambda t: t[0])\n   \n   \n   attrs = spill('Methods %s' % tag, attrs,\n   lambda t: t[1] == 'method')\n   attrs = spill('Class methods %s' % tag, attrs,\n   lambda t: t[1] == 'class method')\n   attrs = spill('Static methods %s' % tag, attrs,\n   lambda t: t[1] == 'static method')\n   attrs = spilldescriptors('Data descriptors %s' % tag, attrs,\n   lambda t: t[1] == 'data descriptor')\n   attrs = spilldata('Data and other attributes %s' % tag, attrs,\n   lambda t: t[1] == 'data')\n   assert attrs == []\n   attrs = inherited\n   \n  contents = ''.join(contents)\n  \n  if name == realname:\n   title = '<a name=\"%s\">class <strong>%s</strong></a>' % (\n   name, realname)\n  else:\n   title = '<strong>%s</strong> = <a name=\"%s\">class %s</a>' % (\n   name, name, realname)\n  if bases:\n   parents = []\n   for base in bases:\n    parents.append(self.classlink(base, object.__module__))\n   title = title + '(%s)' % ', '.join(parents)\n  doc = self.markup(getdoc(object), self.preformat, funcs, classes, mdict)\n  doc = doc and '<tt>%s<br>&nbsp;</tt>' % doc\n  \n  return self.section(title, '#000000', '#ffc8d8', contents, 3, doc)\n  \n def formatvalue(self, object):\n  \"\"\n  return self.grey('=' + self.repr(object))\n  \n def docroutine(self, object, name=None, mod=None,\n funcs={}, classes={}, methods={}, cl=None):\n  \"\"\n  realname = object.__name__\n  name = name or realname\n  anchor = (cl and cl.__name__ or '') + '-' + name\n  note = ''\n  skipdocs = 0\n  if inspect.ismethod(object):\n   imclass = object.__self__.__class__\n   if cl:\n    if imclass is not cl:\n     note = ' from ' + self.classlink(imclass, mod)\n   else:\n    if object.__self__ is not None:\n     note = ' method of %s instance' % self.classlink(\n     object.__self__.__class__, mod)\n    else:\n     note = ' unbound %s method' % self.classlink(imclass,mod)\n   object = object.__func__\n   \n  if name == realname:\n   title = '<a name=\"%s\"><strong>%s</strong></a>' % (anchor, realname)\n  else:\n   if (cl and realname in cl.__dict__ and\n   cl.__dict__[realname] is object):\n    reallink = '<a href=\"#%s\">%s</a>' % (\n    cl.__name__ + '-' + realname, realname)\n    skipdocs = 1\n   else:\n    reallink = realname\n   title = '<a name=\"%s\"><strong>%s</strong></a> = %s' % (\n   anchor, name, reallink)\n  if inspect.isfunction(object):\n   args, varargs, kwonlyargs, kwdefaults, varkw, defaults, ann = inspect.getfullargspec(object)\n   argspec = inspect.formatargspec(\n   args, varargs, kwonlyargs, kwdefaults, varkw, defaults, ann,\n   formatvalue=self.formatvalue,\n   formatannotation=inspect.formatannotationrelativeto(object))\n   if realname == '<lambda>':\n    title = '<strong>%s</strong> <em>lambda</em> ' % name\n    \n    \n    \n    argspec = argspec[1:-1] \n  else:\n   argspec = '(...)'\n   \n  decl = title + argspec + (note and self.grey(\n  '<font face=\"helvetica, arial\">%s</font>' % note))\n  \n  if skipdocs:\n   return '<dl><dt>%s</dt></dl>\\n' % decl\n  else:\n   doc = self.markup(\n   getdoc(object), self.preformat, funcs, classes, methods)\n   doc = doc and '<dd><tt>%s</tt></dd>' % doc\n   return '<dl><dt>%s</dt>%s</dl>\\n' % (decl, doc)\n   \n def _docdescriptor(self, name, value, mod):\n  results = []\n  push = results.append\n  \n  if name:\n   push('<dl><dt><strong>%s</strong></dt>\\n' % name)\n  if value.__doc__ is not None:\n   doc = self.markup(getdoc(value), self.preformat)\n   push('<dd><tt>%s</tt></dd>\\n' % doc)\n  push('</dl>\\n')\n  \n  return ''.join(results)\n  \n def docproperty(self, object, name=None, mod=None, cl=None):\n  \"\"\n  return self._docdescriptor(name, object, mod)\n  \n def docother(self, object, name=None, mod=None, *ignored):\n  \"\"\n  lhs = name and '<strong>%s</strong> = ' % name or ''\n  return lhs + self.repr(object)\n  \n def docdata(self, object, name=None, mod=None, cl=None):\n  \"\"\n  return self._docdescriptor(name, object, mod)\n  \n def index(self, dir, shadowed=None):\n  \"\"\n  modpkgs = []\n  if shadowed is None: shadowed = {}\n  for importer, name, ispkg in pkgutil.iter_modules([dir]):\n   if any((0xD800 <= ord(ch) <= 0xDFFF) for ch in name):\n   \n    continue\n   modpkgs.append((name, '', ispkg, name in shadowed))\n   shadowed[name] = 1\n   \n  modpkgs.sort()\n  contents = self.multicolumn(modpkgs, self.modpkglink)\n  return self.bigsection(dir, '#ffffff', '#ee77aa', contents)\n  \n  \n  \nclass TextRepr(Repr):\n \"\"\n def __init__(self):\n  Repr.__init__(self)\n  self.maxlist = self.maxtuple = 20\n  self.maxdict = 10\n  self.maxstring = self.maxother = 100\n  \n  \n  \n  \n  \n  \n  \n  \n def repr_string(self, x, level):\n  test = cram(x, self.maxstring)\n  testrepr = repr(test)\n  if '\\\\' in test and '\\\\' not in replace(testrepr, r'\\\\', ''):\n  \n  \n   return 'r' + testrepr[0] + test + testrepr[0]\n  return testrepr\n  \n repr_str = repr_string\n \n def repr_instance(self, x, level):\n  try:\n   return cram(stripid(repr(x)), self.maxstring)\n  except:\n   return '<%s instance>' % x.__class__.__name__\n   \nclass TextDoc(Doc):\n \"\"\n \n \n \n _repr_instance = TextRepr()\n repr = _repr_instance.repr\n \n def bold(self, text):\n  \"\"\n  return ''.join(ch + '\\b' + ch for ch in text)\n  \n def indent(self, text, prefix='    '):\n  \"\"\n  if not text: return ''\n  lines = [prefix + line for line in text.split('\\n')]\n  if lines: lines[-1] = lines[-1].rstrip()\n  return '\\n'.join(lines)\n  \n def section(self, title, contents):\n  \"\"\n  clean_contents = self.indent(contents).rstrip()\n  return self.bold(title) + '\\n' + clean_contents + '\\n\\n'\n  \n  \n  \n def formattree(self, tree, modname, parent=None, prefix=''):\n  \"\"\n  result = ''\n  for entry in tree:\n   if type(entry) is type(()):\n    c, bases = entry\n    result = result + prefix + classname(c, modname)\n    if bases and bases != (parent,):\n     parents = (classname(c, modname) for c in bases)\n     result = result + '(%s)' % ', '.join(parents)\n    result = result + '\\n'\n   elif type(entry) is type([]):\n    result = result + self.formattree(\n    entry, modname, c, prefix + '    ')\n  return result\n  \n def docmodule(self, object, name=None, mod=None):\n  \"\"\n  name = object.__name__ \n  synop, desc = splitdoc(getdoc(object))\n  result = self.section('NAME', name + (synop and ' - ' + synop))\n  all = getattr(object, '__all__', None)\n  docloc = self.getdocloc(object)\n  if docloc is not None:\n   result = result + self.section('MODULE REFERENCE', docloc + \"\"\"\n\nThe following documentation is automatically generated from the Python\nsource files.  It may be incomplete, incorrect or include features that\nare considered implementation detail and may vary between Python\nimplementations.  When in doubt, consult the module reference at the\nlocation listed above.\n\"\"\"   )\n   \n  if desc:\n   result = result + self.section('DESCRIPTION', desc)\n   \n  classes = []\n  for key, value in inspect.getmembers(object, inspect.isclass):\n  \n   if (all is not None\n   or (inspect.getmodule(value) or object) is object):\n    if visiblename(key, all, object):\n     classes.append((key, value))\n  funcs = []\n  for key, value in inspect.getmembers(object, inspect.isroutine):\n  \n   if (all is not None or\n   inspect.isbuiltin(value) or inspect.getmodule(value) is object):\n    if visiblename(key, all, object):\n     funcs.append((key, value))\n  data = []\n  for key, value in inspect.getmembers(object, isdata):\n   if visiblename(key, all, object):\n    data.append((key, value))\n    \n  modpkgs = []\n  modpkgs_names = set()\n  if hasattr(object, '__path__'):\n   for importer, modname, ispkg in pkgutil.iter_modules(object.__path__):\n    modpkgs_names.add(modname)\n    if ispkg:\n     modpkgs.append(modname + ' (package)')\n    else:\n     modpkgs.append(modname)\n     \n   modpkgs.sort()\n   result = result + self.section(\n   'PACKAGE CONTENTS', '\\n'.join(modpkgs))\n   \n   \n  submodules = []\n  for key, value in inspect.getmembers(object, inspect.ismodule):\n   if value.__name__.startswith(name + '.') and key not in modpkgs_names:\n    submodules.append(key)\n  if submodules:\n   submodules.sort()\n   result = result + self.section(\n   'SUBMODULES', '\\n'.join(submodules))\n   \n  if classes:\n   classlist = [value for key, value in classes]\n   contents = [self.formattree(\n   inspect.getclasstree(classlist, 1), name)]\n   for key, value in classes:\n    contents.append(self.document(value, key, name))\n   result = result + self.section('CLASSES', '\\n'.join(contents))\n   \n  if funcs:\n   contents = []\n   for key, value in funcs:\n    contents.append(self.document(value, key, name))\n   result = result + self.section('FUNCTIONS', '\\n'.join(contents))\n   \n  if data:\n   contents = []\n   for key, value in data:\n    contents.append(self.docother(value, key, name, maxlen=70))\n   result = result + self.section('DATA', '\\n'.join(contents))\n   \n  if hasattr(object, '__version__'):\n   version = str(object.__version__)\n   if version[:11] == '$' + 'Revision: ' and version[-1:] == '$':\n    version = version[11:-1].strip()\n   result = result + self.section('VERSION', version)\n  if hasattr(object, '__date__'):\n   result = result + self.section('DATE', str(object.__date__))\n  if hasattr(object, '__author__'):\n   result = result + self.section('AUTHOR', str(object.__author__))\n  if hasattr(object, '__credits__'):\n   result = result + self.section('CREDITS', str(object.__credits__))\n  try:\n   file = inspect.getabsfile(object)\n  except TypeError:\n   file = '(built-in)'\n  result = result + self.section('FILE', file)\n  return result\n  \n def docclass(self, object, name=None, mod=None, *ignored):\n  \"\"\n  realname = object.__name__\n  name = name or realname\n  bases = object.__bases__\n  \n  def makename(c, m=object.__module__):\n   return classname(c, m)\n   \n  if name == realname:\n   title = 'class ' + self.bold(realname)\n  else:\n   title = self.bold(name) + ' = class ' + realname\n  if bases:\n   parents = map(makename, bases)\n   title = title + '(%s)' % ', '.join(parents)\n   \n  doc = getdoc(object)\n  contents = doc and [doc + '\\n'] or []\n  push = contents.append\n  \n  \n  mro = deque(inspect.getmro(object))\n  if len(mro) > 2:\n   push(\"Method resolution order:\")\n   for base in mro:\n    push('    ' + makename(base))\n   push('')\n   \n   \n  class HorizontalRule:\n   def __init__(self):\n    self.needone = 0\n   def maybe(self):\n    if self.needone:\n     push('-' * 70)\n    self.needone = 1\n  hr = HorizontalRule()\n  \n  def spill(msg, attrs, predicate):\n   ok, attrs = _split_list(attrs, predicate)\n   if ok:\n    hr.maybe()\n    push(msg)\n    for name, kind, homecls, value in ok:\n     try:\n      value = getattr(object, name)\n     except Exception:\n     \n     \n      push(self._docdescriptor(name, value, mod))\n     else:\n      push(self.document(value,\n      name, mod, object))\n   return attrs\n   \n  def spilldescriptors(msg, attrs, predicate):\n   ok, attrs = _split_list(attrs, predicate)\n   if ok:\n    hr.maybe()\n    push(msg)\n    for name, kind, homecls, value in ok:\n     push(self._docdescriptor(name, value, mod))\n   return attrs\n   \n  def spilldata(msg, attrs, predicate):\n   ok, attrs = _split_list(attrs, predicate)\n   if ok:\n    hr.maybe()\n    push(msg)\n    for name, kind, homecls, value in ok:\n     if callable(value) or inspect.isdatadescriptor(value):\n      doc = getdoc(value)\n     else:\n      doc = None\n     push(self.docother(getattr(object, name),\n     name, mod, maxlen=70, doc=doc) + '\\n')\n   return attrs\n   \n  attrs = [(name, kind, cls, value)\n  for name, kind, cls, value in classify_class_attrs(object)\n  if visiblename(name, obj=object)]\n  \n  while attrs:\n   if mro:\n    thisclass = mro.popleft()\n   else:\n    thisclass = attrs[0][2]\n   attrs, inherited = _split_list(attrs, lambda t: t[2] is thisclass)\n   \n   if thisclass is builtins.object:\n    attrs = inherited\n    continue\n   elif thisclass is object:\n    tag = \"defined here\"\n   else:\n    tag = \"inherited from %s\" % classname(thisclass,\n    object.__module__)\n    \n    \n   attrs.sort()\n   \n   \n   attrs = spill(\"Methods %s:\\n\" % tag, attrs,\n   lambda t: t[1] == 'method')\n   attrs = spill(\"Class methods %s:\\n\" % tag, attrs,\n   lambda t: t[1] == 'class method')\n   attrs = spill(\"Static methods %s:\\n\" % tag, attrs,\n   lambda t: t[1] == 'static method')\n   attrs = spilldescriptors(\"Data descriptors %s:\\n\" % tag, attrs,\n   lambda t: t[1] == 'data descriptor')\n   attrs = spilldata(\"Data and other attributes %s:\\n\" % tag, attrs,\n   lambda t: t[1] == 'data')\n   assert attrs == []\n   attrs = inherited\n   \n  contents = '\\n'.join(contents)\n  if not contents:\n   return title + '\\n'\n  return title + '\\n' + self.indent(contents.rstrip(), ' |  ') + '\\n'\n  \n def formatvalue(self, object):\n  \"\"\n  return '=' + self.repr(object)\n  \n def docroutine(self, object, name=None, mod=None, cl=None):\n  \"\"\n  realname = object.__name__\n  name = name or realname\n  note = ''\n  skipdocs = 0\n  if inspect.ismethod(object):\n   imclass = object.__self__.__class__\n   if cl:\n    if imclass is not cl:\n     note = ' from ' + classname(imclass, mod)\n   else:\n    if object.__self__ is not None:\n     note = ' method of %s instance' % classname(\n     object.__self__.__class__, mod)\n    else:\n     note = ' unbound %s method' % classname(imclass,mod)\n   object = object.__func__\n   \n  if name == realname:\n   title = self.bold(realname)\n  else:\n   if (cl and realname in cl.__dict__ and\n   cl.__dict__[realname] is object):\n    skipdocs = 1\n   title = self.bold(name) + ' = ' + realname\n  if inspect.isfunction(object):\n   args, varargs, varkw, defaults, kwonlyargs, kwdefaults, ann = inspect.getfullargspec(object)\n   argspec = inspect.formatargspec(\n   args, varargs, varkw, defaults, kwonlyargs, kwdefaults, ann,\n   formatvalue=self.formatvalue,\n   formatannotation=inspect.formatannotationrelativeto(object))\n   if realname == '<lambda>':\n    title = self.bold(name) + ' lambda '\n    \n    \n    \n    argspec = argspec[1:-1] \n  else:\n   argspec = '(...)'\n  decl = title + argspec + note\n  \n  if skipdocs:\n   return decl + '\\n'\n  else:\n   doc = getdoc(object) or ''\n   return decl + '\\n' + (doc and self.indent(doc).rstrip() + '\\n')\n   \n def _docdescriptor(self, name, value, mod):\n  results = []\n  push = results.append\n  \n  if name:\n   push(self.bold(name))\n   push('\\n')\n  doc = getdoc(value) or ''\n  if doc:\n   push(self.indent(doc))\n   push('\\n')\n  return ''.join(results)\n  \n def docproperty(self, object, name=None, mod=None, cl=None):\n  \"\"\n  return self._docdescriptor(name, object, mod)\n  \n def docdata(self, object, name=None, mod=None, cl=None):\n  \"\"\n  return self._docdescriptor(name, object, mod)\n  \n def docother(self, object, name=None, mod=None, parent=None, maxlen=None, doc=None):\n  \"\"\n  repr = self.repr(object)\n  if maxlen:\n   line = (name and name + ' = ' or '') + repr\n   chop = maxlen - len(line)\n   if chop < 0: repr = repr[:chop] + '...'\n  line = (name and self.bold(name) + ' = ' or '') + repr\n  if doc is not None:\n   line += '\\n' + self.indent(str(doc))\n  return line\n  \nclass _PlainTextDoc(TextDoc):\n \"\"\n def bold(self, text):\n  return text\n  \n  \n  \ndef pager(text):\n \"\"\n global pager\n pager = getpager()\n pager(text)\n \ndef getpager():\n \"\"\n if not hasattr(sys.stdout, \"isatty\"):\n  return plainpager\n if not sys.stdin.isatty() or not sys.stdout.isatty():\n  return plainpager\n if 'PAGER' in os.environ:\n  if sys.platform == 'win32': \n   return lambda text: tempfilepager(plain(text), os.environ['PAGER'])\n  elif os.environ.get('TERM') in ('dumb', 'emacs'):\n   return lambda text: pipepager(plain(text), os.environ['PAGER'])\n  else:\n   return lambda text: pipepager(text, os.environ['PAGER'])\n if os.environ.get('TERM') in ('dumb', 'emacs'):\n  return plainpager\n if sys.platform == 'win32' or sys.platform.startswith('os2'):\n  return lambda text: tempfilepager(plain(text), 'more <')\n if hasattr(os, 'system') and os.system('(less) 2>/dev/null') == 0:\n  return lambda text: pipepager(text, 'less')\n  \n import tempfile\n (fd, filename) = tempfile.mkstemp()\n os.close(fd)\n try:\n  if hasattr(os, 'system') and os.system('more \"%s\"' % filename) == 0:\n   return lambda text: pipepager(text, 'more')\n  else:\n   return ttypager\n finally:\n  os.unlink(filename)\n  \ndef plain(text):\n \"\"\n return re.sub('.\\b', '', text)\n \ndef pipepager(text, cmd):\n \"\"\n pipe = os.popen(cmd, 'w')\n try:\n  pipe.write(text)\n  pipe.close()\n except IOError:\n  pass \n  \ndef tempfilepager(text, cmd):\n \"\"\n import tempfile\n filename = tempfile.mktemp()\n file = open(filename, 'w')\n file.write(text)\n file.close()\n try:\n  os.system(cmd + ' \"' + filename + '\"')\n finally:\n  os.unlink(filename)\n  \ndef ttypager(text):\n \"\"\n lines = plain(text).split('\\n')\n try:\n  import tty\n  fd = sys.stdin.fileno()\n  old = tty.tcgetattr(fd)\n  tty.setcbreak(fd)\n  getchar = lambda: sys.stdin.read(1)\n except (ImportError, AttributeError):\n  tty = None\n  getchar = lambda: sys.stdin.readline()[:-1][:1]\n  \n try:\n  r = inc = os.environ.get('LINES', 25) - 1\n  sys.stdout.write('\\n'.join(lines[:inc]) + '\\n')\n  while lines[r:]:\n   sys.stdout.write('-- more --')\n   sys.stdout.flush()\n   c = getchar()\n   \n   if c in ('q', 'Q'):\n    sys.stdout.write('\\r          \\r')\n    break\n   elif c in ('\\r', '\\n'):\n    sys.stdout.write('\\r          \\r' + lines[r] + '\\n')\n    r = r + 1\n    continue\n   if c in ('b', 'B', '\\x1b'):\n    r = r - inc - inc\n    if r < 0: r = 0\n   sys.stdout.write('\\n' + '\\n'.join(lines[r:r+inc]) + '\\n')\n   r = r + inc\n   \n finally:\n  if tty:\n   tty.tcsetattr(fd, tty.TCSAFLUSH, old)\n   \ndef plainpager(text):\n \"\"\n sys.stdout.write(plain(text))\n \ndef describe(thing):\n \"\"\n if inspect.ismodule(thing):\n  if thing.__name__ in sys.builtin_module_names:\n   return 'built-in module ' + thing.__name__\n  if hasattr(thing, '__path__'):\n   return 'package ' + thing.__name__\n  else:\n   return 'module ' + thing.__name__\n if inspect.isbuiltin(thing):\n  return 'built-in function ' + thing.__name__\n if inspect.isgetsetdescriptor(thing):\n  return 'getset descriptor %s.%s.%s' % (\n  thing.__objclass__.__module__, thing.__objclass__.__name__,\n  thing.__name__)\n if inspect.ismemberdescriptor(thing):\n  return 'member descriptor %s.%s.%s' % (\n  thing.__objclass__.__module__, thing.__objclass__.__name__,\n  thing.__name__)\n if inspect.isclass(thing):\n  return 'class ' + thing.__name__\n if inspect.isfunction(thing):\n  return 'function ' + thing.__name__\n if inspect.ismethod(thing):\n  return 'method ' + thing.__name__\n return type(thing).__name__\n \ndef locate(path, forceload=0):\n \"\"\n parts = [part for part in path.split('.') if part]\n module, n = None, 0\n while n < len(parts):\n  nextmodule = safeimport('.'.join(parts[:n+1]), forceload)\n  if nextmodule: module, n = nextmodule, n + 1\n  else: break\n if module:\n  object = module\n else:\n  object = builtins\n for part in parts[n:]:\n  try:\n   object = getattr(object, part)\n  except AttributeError:\n   return None\n return object\n \n \n \ntext = TextDoc()\nplaintext = _PlainTextDoc()\nhtml = HTMLDoc()\n\ndef resolve(thing, forceload=0):\n \"\"\n if isinstance(thing, str):\n  object = locate(thing, forceload)\n  if not object:\n   raise ImportError('no Python documentation found for %r' % thing)\n  return object, thing\n else:\n  name = getattr(thing, '__name__', None)\n  return thing, name if isinstance(name, str) else None\n  \ndef render_doc(thing, title='Python Library Documentation: %s', forceload=0,\nrenderer=None):\n \"\"\n if renderer is None:\n  renderer = text\n object, name = resolve(thing, forceload)\n desc = describe(object)\n module = inspect.getmodule(object)\n if name and '.' in name:\n  desc += ' in ' + name[:name.rfind('.')]\n elif module and module is not object:\n  desc += ' in module ' + module.__name__\n  \n if not (inspect.ismodule(object) or\n inspect.isclass(object) or\n inspect.isroutine(object) or\n inspect.isgetsetdescriptor(object) or\n inspect.ismemberdescriptor(object) or\n isinstance(object, property)):\n \n \n  object = type(object)\n  desc += ' object'\n return title % desc + '\\n\\n' + renderer.document(object, name)\n \ndef doc(thing, title='Python Library Documentation: %s', forceload=0,\noutput=None):\n \"\"\n try:\n  if output is None:\n   pager(render_doc(thing, title, forceload))\n  else:\n   output.write(render_doc(thing, title, forceload, plaintext))\n except (ImportError, ErrorDuringImport) as value:\n  print(value)\n  \ndef writedoc(thing, forceload=0):\n \"\"\n try:\n  object, name = resolve(thing, forceload)\n  page = html.page(describe(object), html.document(object, name))\n  file = open(name + '.html', 'w', encoding='utf-8')\n  file.write(page)\n  file.close()\n  print('wrote', name + '.html')\n except (ImportError, ErrorDuringImport) as value:\n  print(value)\n  \ndef writedocs(dir, pkgpath='', done=None):\n \"\"\n if done is None: done = {}\n for importer, modname, ispkg in pkgutil.walk_packages([dir], pkgpath):\n  writedoc(modname)\n return\n \nclass Helper:\n\n\n\n\n\n\n\n\n\n\n\n\n keywords = {\n 'False': '',\n 'None': '',\n 'True': '',\n 'and': 'BOOLEAN',\n 'as': 'with',\n 'assert': ('assert', ''),\n 'break': ('break', 'while for'),\n 'class': ('class', 'CLASSES SPECIALMETHODS'),\n 'continue': ('continue', 'while for'),\n 'def': ('function', ''),\n 'del': ('del', 'BASICMETHODS'),\n 'elif': 'if',\n 'else': ('else', 'while for'),\n 'except': 'try',\n 'finally': 'try',\n 'for': ('for', 'break continue while'),\n 'from': 'import',\n 'global': ('global', 'nonlocal NAMESPACES'),\n 'if': ('if', 'TRUTHVALUE'),\n 'import': ('import', 'MODULES'),\n 'in': ('in', 'SEQUENCEMETHODS'),\n 'is': 'COMPARISON',\n 'lambda': ('lambda', 'FUNCTIONS'),\n 'nonlocal': ('nonlocal', 'global NAMESPACES'),\n 'not': 'BOOLEAN',\n 'or': 'BOOLEAN',\n 'pass': ('pass', ''),\n 'raise': ('raise', 'EXCEPTIONS'),\n 'return': ('return', 'FUNCTIONS'),\n 'try': ('try', 'EXCEPTIONS'),\n 'while': ('while', 'break continue if TRUTHVALUE'),\n 'with': ('with', 'CONTEXTMANAGERS EXCEPTIONS yield'),\n 'yield': ('yield', ''),\n }\n \n \n _symbols_inverse = {\n 'STRINGS' : (\"'\", \"'''\", \"r'\", \"b'\", '\"\"\"', '\"', 'r\"', 'b\"'),\n 'OPERATORS' : ('+', '-', '*', '**', '/', '//', '%', '<<', '>>', '&',\n '|', '^', '~', '<', '>', '<=', '>=', '==', '!=', '<>'),\n 'COMPARISON' : ('<', '>', '<=', '>=', '==', '!=', '<>'),\n 'UNARY' : ('-', '~'),\n 'AUGMENTEDASSIGNMENT' : ('+=', '-=', '*=', '/=', '%=', '&=', '|=',\n '^=', '<<=', '>>=', '**=', '//='),\n 'BITWISE' : ('<<', '>>', '&', '|', '^', '~'),\n 'COMPLEX' : ('j', 'J')\n }\n symbols = {\n '%': 'OPERATORS FORMATTING',\n '**': 'POWER',\n ',': 'TUPLES LISTS FUNCTIONS',\n '.': 'ATTRIBUTES FLOAT MODULES OBJECTS',\n '...': 'ELLIPSIS',\n ':': 'SLICINGS DICTIONARYLITERALS',\n '@': 'def class',\n '\\\\': 'STRINGS',\n '_': 'PRIVATENAMES',\n '__': 'PRIVATENAMES SPECIALMETHODS',\n '`': 'BACKQUOTES',\n '(': 'TUPLES FUNCTIONS CALLS',\n ')': 'TUPLES FUNCTIONS CALLS',\n '[': 'LISTS SUBSCRIPTS SLICINGS',\n ']': 'LISTS SUBSCRIPTS SLICINGS'\n }\n for topic, symbols_ in _symbols_inverse.items():\n  for symbol in symbols_:\n   topics = symbols.get(symbol, topic)\n   if topic not in topics:\n    topics = topics + ' ' + topic\n   symbols[symbol] = topics\n   \n topics = {\n 'TYPES': ('types', 'STRINGS UNICODE NUMBERS SEQUENCES MAPPINGS '\n 'FUNCTIONS CLASSES MODULES FILES inspect'),\n 'STRINGS': ('strings', 'str UNICODE SEQUENCES STRINGMETHODS '\n 'FORMATTING TYPES'),\n 'STRINGMETHODS': ('string-methods', 'STRINGS FORMATTING'),\n 'FORMATTING': ('formatstrings', 'OPERATORS'),\n 'UNICODE': ('strings', 'encodings unicode SEQUENCES STRINGMETHODS '\n 'FORMATTING TYPES'),\n 'NUMBERS': ('numbers', 'INTEGER FLOAT COMPLEX TYPES'),\n 'INTEGER': ('integers', 'int range'),\n 'FLOAT': ('floating', 'float math'),\n 'COMPLEX': ('imaginary', 'complex cmath'),\n 'SEQUENCES': ('typesseq', 'STRINGMETHODS FORMATTING range LISTS'),\n 'MAPPINGS': 'DICTIONARIES',\n 'FUNCTIONS': ('typesfunctions', 'def TYPES'),\n 'METHODS': ('typesmethods', 'class def CLASSES TYPES'),\n 'CODEOBJECTS': ('bltin-code-objects', 'compile FUNCTIONS TYPES'),\n 'TYPEOBJECTS': ('bltin-type-objects', 'types TYPES'),\n 'FRAMEOBJECTS': 'TYPES',\n 'TRACEBACKS': 'TYPES',\n 'NONE': ('bltin-null-object', ''),\n 'ELLIPSIS': ('bltin-ellipsis-object', 'SLICINGS'),\n 'FILES': ('bltin-file-objects', ''),\n 'SPECIALATTRIBUTES': ('specialattrs', ''),\n 'CLASSES': ('types', 'class SPECIALMETHODS PRIVATENAMES'),\n 'MODULES': ('typesmodules', 'import'),\n 'PACKAGES': 'import',\n 'EXPRESSIONS': ('operator-summary', 'lambda or and not in is BOOLEAN '\n 'COMPARISON BITWISE SHIFTING BINARY FORMATTING POWER '\n 'UNARY ATTRIBUTES SUBSCRIPTS SLICINGS CALLS TUPLES '\n 'LISTS DICTIONARIES'),\n 'OPERATORS': 'EXPRESSIONS',\n 'PRECEDENCE': 'EXPRESSIONS',\n 'OBJECTS': ('objects', 'TYPES'),\n 'SPECIALMETHODS': ('specialnames', 'BASICMETHODS ATTRIBUTEMETHODS '\n 'CALLABLEMETHODS SEQUENCEMETHODS MAPPINGMETHODS '\n 'NUMBERMETHODS CLASSES'),\n 'BASICMETHODS': ('customization', 'hash repr str SPECIALMETHODS'),\n 'ATTRIBUTEMETHODS': ('attribute-access', 'ATTRIBUTES SPECIALMETHODS'),\n 'CALLABLEMETHODS': ('callable-types', 'CALLS SPECIALMETHODS'),\n 'SEQUENCEMETHODS': ('sequence-types', 'SEQUENCES SEQUENCEMETHODS '\n 'SPECIALMETHODS'),\n 'MAPPINGMETHODS': ('sequence-types', 'MAPPINGS SPECIALMETHODS'),\n 'NUMBERMETHODS': ('numeric-types', 'NUMBERS AUGMENTEDASSIGNMENT '\n 'SPECIALMETHODS'),\n 'EXECUTION': ('execmodel', 'NAMESPACES DYNAMICFEATURES EXCEPTIONS'),\n 'NAMESPACES': ('naming', 'global nonlocal ASSIGNMENT DELETION DYNAMICFEATURES'),\n 'DYNAMICFEATURES': ('dynamic-features', ''),\n 'SCOPING': 'NAMESPACES',\n 'FRAMES': 'NAMESPACES',\n 'EXCEPTIONS': ('exceptions', 'try except finally raise'),\n 'CONVERSIONS': ('conversions', ''),\n 'IDENTIFIERS': ('identifiers', 'keywords SPECIALIDENTIFIERS'),\n 'SPECIALIDENTIFIERS': ('id-classes', ''),\n 'PRIVATENAMES': ('atom-identifiers', ''),\n 'LITERALS': ('atom-literals', 'STRINGS NUMBERS TUPLELITERALS '\n 'LISTLITERALS DICTIONARYLITERALS'),\n 'TUPLES': 'SEQUENCES',\n 'TUPLELITERALS': ('exprlists', 'TUPLES LITERALS'),\n 'LISTS': ('typesseq-mutable', 'LISTLITERALS'),\n 'LISTLITERALS': ('lists', 'LISTS LITERALS'),\n 'DICTIONARIES': ('typesmapping', 'DICTIONARYLITERALS'),\n 'DICTIONARYLITERALS': ('dict', 'DICTIONARIES LITERALS'),\n 'ATTRIBUTES': ('attribute-references', 'getattr hasattr setattr ATTRIBUTEMETHODS'),\n 'SUBSCRIPTS': ('subscriptions', 'SEQUENCEMETHODS'),\n 'SLICINGS': ('slicings', 'SEQUENCEMETHODS'),\n 'CALLS': ('calls', 'EXPRESSIONS'),\n 'POWER': ('power', 'EXPRESSIONS'),\n 'UNARY': ('unary', 'EXPRESSIONS'),\n 'BINARY': ('binary', 'EXPRESSIONS'),\n 'SHIFTING': ('shifting', 'EXPRESSIONS'),\n 'BITWISE': ('bitwise', 'EXPRESSIONS'),\n 'COMPARISON': ('comparisons', 'EXPRESSIONS BASICMETHODS'),\n 'BOOLEAN': ('booleans', 'EXPRESSIONS TRUTHVALUE'),\n 'ASSERTION': 'assert',\n 'ASSIGNMENT': ('assignment', 'AUGMENTEDASSIGNMENT'),\n 'AUGMENTEDASSIGNMENT': ('augassign', 'NUMBERMETHODS'),\n 'DELETION': 'del',\n 'RETURNING': 'return',\n 'IMPORTING': 'import',\n 'CONDITIONAL': 'if',\n 'LOOPING': ('compound', 'for while break continue'),\n 'TRUTHVALUE': ('truth', 'if while and or not BASICMETHODS'),\n 'DEBUGGING': ('debugger', 'pdb'),\n 'CONTEXTMANAGERS': ('context-managers', 'with'),\n }\n \n def __init__(self, input=None, output=None):\n  self._input = input\n  self._output = output\n  \n  \n  self.input = self._input or sys.stdin \n  self.output = self._output or sys.stdout \n  \n  \n  \n  \n  \n def __repr__(self):\n  if inspect.stack()[1][3] == '?':\n   self()\n   return ''\n  return '<pydoc.Helper instance>'\n  \n _GoInteractive = object()\n def __call__(self, request=_GoInteractive):\n  if request is not self._GoInteractive:\n   self.help(request)\n  else:\n   self.intro()\n   self.interact()\n   self.output.write('''\nYou are now leaving help and returning to the Python interpreter.\nIf you want to ask for help on a particular object directly from the\ninterpreter, you can type \"help(object)\".  Executing \"help('string')\"\nhas the same effect as typing a particular string at the help> prompt.\n'''   )\n   \n def interact(self):\n  self.output.write('\\n')\n  while True:\n   try:\n    request = self.getline('help> ')\n    if not request: break\n   except (KeyboardInterrupt, EOFError):\n    break\n   request = replace(request, '\"', '', \"'\", '').strip()\n   if request.lower() in ('q', 'quit'): break\n   self.help(request)\n   \n def getline(self, prompt):\n  \"\"\n  if self.input is sys.stdin:\n   return input(prompt)\n  else:\n   self.output.write(prompt)\n   self.output.flush()\n   return self.input.readline()\n   \n def help(self, request):\n  if type(request) is type(''):\n   request = request.strip()\n   if request == 'help': self.intro()\n   elif request == 'keywords': self.listkeywords()\n   elif request == 'symbols': self.listsymbols()\n   elif request == 'topics': self.listtopics()\n   elif request == 'modules': self.listmodules()\n   elif request[:8] == 'modules ':\n    self.listmodules(request.split()[1])\n   elif request in self.symbols: self.showsymbol(request)\n   elif request in ['True', 'False', 'None']:\n   \n    doc(eval(request), 'Help on %s:')\n   elif request in self.keywords: self.showtopic(request)\n   elif request in self.topics: self.showtopic(request)\n   elif request: doc(request, 'Help on %s:', output=self._output)\n  elif isinstance(request, Helper): self()\n  else: doc(request, 'Help on %s:', output=self._output)\n  self.output.write('\\n')\n  \n def intro(self):\n  self.output.write('''\nWelcome to Python %s!  This is the interactive help utility.\n\nIf this is your first time using Python, you should definitely check out\nthe tutorial on the Internet at http://docs.python.org/%s/tutorial/.\n\nEnter the name of any module, keyword, or topic to get help on writing\nPython programs and using Python modules.  To quit this help utility and\nreturn to the interpreter, just type \"quit\".\n\nTo get a list of available modules, keywords, or topics, type \"modules\",\n\"keywords\", or \"topics\".  Each module also comes with a one-line summary\nof what it does; to list the modules whose summaries contain a given word\nsuch as \"spam\", type \"modules spam\".\n'''  % tuple([sys.version[:3]]*2))\n  \n def list(self, items, columns=4, width=80):\n  items = list(sorted(items))\n  colw = width // columns\n  rows = (len(items) + columns - 1) // columns\n  for row in range(rows):\n   for col in range(columns):\n    i = col * rows + row\n    if i < len(items):\n     self.output.write(items[i])\n     if col < columns - 1:\n      self.output.write(' ' + ' ' * (colw - 1 - len(items[i])))\n   self.output.write('\\n')\n   \n def listkeywords(self):\n  self.output.write('''\nHere is a list of the Python keywords.  Enter any keyword to get more help.\n\n'''  )\n  self.list(self.keywords.keys())\n  \n def listsymbols(self):\n  self.output.write('''\nHere is a list of the punctuation symbols which Python assigns special meaning\nto. Enter any symbol to get more help.\n\n'''  )\n  self.list(self.symbols.keys())\n  \n def listtopics(self):\n  self.output.write('''\nHere is a list of available topics.  Enter any topic name to get more help.\n\n'''  )\n  self.list(self.topics.keys())\n  \n def showtopic(self, topic, more_xrefs=''):\n  try:\n   import pydoc_data.topics\n  except ImportError:\n   self.output.write('''\nSorry, topic and keyword documentation is not available because the\nmodule \"pydoc_data.topics\" could not be found.\n'''   )\n   return\n  target = self.topics.get(topic, self.keywords.get(topic))\n  if not target:\n   self.output.write('no documentation found for %s\\n' % repr(topic))\n   return\n  if type(target) is type(''):\n   return self.showtopic(target, more_xrefs)\n   \n  label, xrefs = target\n  try:\n   doc = pydoc_data.topics.topics[label]\n  except KeyError:\n   self.output.write('no documentation found for %s\\n' % repr(topic))\n   return\n  pager(doc.strip() + '\\n')\n  if more_xrefs:\n   xrefs = (xrefs or '') + ' ' + more_xrefs\n  if xrefs:\n   import formatter\n   buffer = io.StringIO()\n   formatter.DumbWriter(buffer).send_flowing_data(\n   'Related help topics: ' + ', '.join(xrefs.split()) + '\\n')\n   self.output.write('\\n%s\\n' % buffer.getvalue())\n   \n def _gettopic(self, topic, more_xrefs=''):\n  \"\"\n  try:\n   import pydoc_data.topics\n  except ImportError:\n   return('''\nSorry, topic and keyword documentation is not available because the\nmodule \"pydoc_data.topics\" could not be found.\n'''   , '')\n  target = self.topics.get(topic, self.keywords.get(topic))\n  if not target:\n   raise ValueError('could not find topic')\n  if isinstance(target, str):\n   return self._gettopic(target, more_xrefs)\n  label, xrefs = target\n  doc = pydoc_data.topics.topics[label]\n  if more_xrefs:\n   xrefs = (xrefs or '') + ' ' + more_xrefs\n  return doc, xrefs\n  \n def showsymbol(self, symbol):\n  target = self.symbols[symbol]\n  topic, _, xrefs = target.partition(' ')\n  self.showtopic(topic, xrefs)\n  \n def listmodules(self, key=''):\n  if key:\n   self.output.write('''\nHere is a list of matching modules.  Enter any module name to get more help.\n\n'''   )\n   apropos(key)\n  else:\n   self.output.write('''\nPlease wait a moment while I gather a list of all available modules...\n\n'''   )\n   modules = {}\n   def callback(path, modname, desc, modules=modules):\n    if modname and modname[-9:] == '.__init__':\n     modname = modname[:-9] + ' (package)'\n    if modname.find('.') < 0:\n     modules[modname] = 1\n   def onerror(modname):\n    callback(None, modname, None)\n   ModuleScanner().run(callback, onerror=onerror)\n   self.list(modules.keys())\n   self.output.write('''\nEnter any module name to get more help.  Or, type \"modules spam\" to search\nfor modules whose descriptions contain the word \"spam\".\n'''   )\n   \nhelp = Helper()\n\nclass Scanner:\n \"\"\n def __init__(self, roots, children, descendp):\n  self.roots = roots[:]\n  self.state = []\n  self.children = children\n  self.descendp = descendp\n  \n def next(self):\n  if not self.state:\n   if not self.roots:\n    return None\n   root = self.roots.pop(0)\n   self.state = [(root, self.children(root))]\n  node, children = self.state[-1]\n  if not children:\n   self.state.pop()\n   return self.next()\n  child = children.pop(0)\n  if self.descendp(child):\n   self.state.append((child, self.children(child)))\n  return child\n  \n  \nclass ModuleScanner:\n \"\"\n \n def run(self, callback, key=None, completer=None, onerror=None):\n  if key: key = key.lower()\n  self.quit = False\n  seen = {}\n  \n  for modname in sys.builtin_module_names:\n   if modname != '__main__':\n    seen[modname] = 1\n    if key is None:\n     callback(None, modname, '')\n    else:\n     name = __import__(modname).__doc__ or ''\n     desc = name.split('\\n')[0]\n     name = modname + ' - ' + desc\n     if name.lower().find(key) >= 0:\n      callback(None, modname, desc)\n      \n  for importer, modname, ispkg in pkgutil.walk_packages(onerror=onerror):\n   if self.quit:\n    break\n    \n   if key is None:\n    callback(None, modname, '')\n   else:\n    try:\n     loader = importer.find_module(modname)\n    except SyntaxError:\n    \n     continue\n    if hasattr(loader, 'get_source'):\n     try:\n      source = loader.get_source(modname)\n     except Exception:\n      if onerror:\n       onerror(modname)\n      continue\n     desc = source_synopsis(io.StringIO(source)) or ''\n     if hasattr(loader, 'get_filename'):\n      path = loader.get_filename(modname)\n     else:\n      path = None\n    else:\n     try:\n      module = loader.load_module(modname)\n     except ImportError:\n      if onerror:\n       onerror(modname)\n      continue\n     desc = (module.__doc__ or '').splitlines()[0]\n     path = getattr(module,'__file__',None)\n    name = modname + ' - ' + desc\n    if name.lower().find(key) >= 0:\n     callback(path, modname, desc)\n     \n  if completer:\n   completer()\n   \ndef apropos(key):\n \"\"\n def callback(path, modname, desc):\n  if modname[-9:] == '.__init__':\n   modname = modname[:-9] + ' (package)'\n  print(modname, desc and '- ' + desc)\n def onerror(modname):\n  pass\n with warnings.catch_warnings():\n  warnings.filterwarnings('ignore') \n  ModuleScanner().run(callback, key, onerror=onerror)\n  \n  \n  \ndef _start_server(urlhandler, port):\n \"\"\n import http.server\n import email.message\n import select\n import threading\n \n class DocHandler(http.server.BaseHTTPRequestHandler):\n \n  def do_GET(self):\n   \"\"\n   if self.path.endswith('.css'):\n    content_type = 'text/css'\n   else:\n    content_type = 'text/html'\n   self.send_response(200)\n   self.send_header('Content-Type', '%s; charset=UTF-8' % content_type)\n   self.end_headers()\n   self.wfile.write(self.urlhandler(\n   self.path, content_type).encode('utf-8'))\n   \n  def log_message(self, *args):\n  \n   pass\n   \n class DocServer(http.server.HTTPServer):\n \n  def __init__(self, port, callback):\n   self.host = (sys.platform == 'mac') and '127.0.0.1' or 'localhost'\n   self.address = ('', port)\n   self.callback = callback\n   self.base.__init__(self, self.address, self.handler)\n   self.quit = False\n   \n  def serve_until_quit(self):\n   while not self.quit:\n    rd, wr, ex = select.select([self.socket.fileno()], [], [], 1)\n    if rd:\n     self.handle_request()\n   self.server_close()\n   \n  def server_activate(self):\n   self.base.server_activate(self)\n   if self.callback:\n    self.callback(self)\n    \n class ServerThread(threading.Thread):\n \n  def __init__(self, urlhandler, port):\n   self.urlhandler = urlhandler\n   self.port = int(port)\n   threading.Thread.__init__(self)\n   self.serving = False\n   self.error = None\n   \n  def run(self):\n   \"\"\n   try:\n    DocServer.base = http.server.HTTPServer\n    DocServer.handler = DocHandler\n    DocHandler.MessageClass = email.message.Message\n    DocHandler.urlhandler = staticmethod(self.urlhandler)\n    docsvr = DocServer(self.port, self.ready)\n    self.docserver = docsvr\n    docsvr.serve_until_quit()\n   except Exception as e:\n    self.error = e\n    \n  def ready(self, server):\n   self.serving = True\n   self.host = server.host\n   self.port = server.server_port\n   self.url = 'http://%s:%d/' % (self.host, self.port)\n   \n  def stop(self):\n   \"\"\n   self.docserver.quit = True\n   self.serving = False\n   self.url = None\n   \n thread = ServerThread(urlhandler, port)\n thread.start()\n \n \n while not thread.error and not thread.serving:\n  time.sleep(.01)\n return thread\n \n \ndef _url_handler(url, content_type=\"text/html\"):\n \"\"\n class _HTMLDoc(HTMLDoc):\n \n  def page(self, title, contents):\n   \"\"\n   css_path = \"pydoc_data/_pydoc.css\"\n   css_link = (\n   '<link rel=\"stylesheet\" type=\"text/css\" href=\"%s\">' %\n   css_path)\n   return '''\\\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<html><head><title>Pydoc: %s</title>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n%s</head><body bgcolor=\"#f0f0f8\">%s<div style=\"clear:both;padding-top:.5em;\">%s</div>\n</body></html>'''   % (title, css_link, html_navbar(), contents)\n   \n  def filelink(self, url, path):\n   return '<a href=\"getfile?key=%s\">%s</a>' % (url, path)\n   \n   \n html = _HTMLDoc()\n \n def html_navbar():\n  version = html.escape(\"%s [%s, %s]\" % (platform.python_version(),\n  platform.python_build()[0],\n  platform.python_compiler()))\n  return \"\"\"\n            <div style='float:left'>\n                Python %s<br>%s\n            </div>\n            <div style='float:right'>\n                <div style='text-align:center'>\n                  <a href=\"index.html\">Module Index</a>\n                  : <a href=\"topics.html\">Topics</a>\n                  : <a href=\"keywords.html\">Keywords</a>\n                </div>\n                <div>\n                    <form action=\"get\" style='display:inline;'>\n                      <input type=text name=key size=15>\n                      <input type=submit value=\"Get\">\n                    </form>&nbsp;\n                    <form action=\"search\" style='display:inline;'>\n                      <input type=text name=key size=15>\n                      <input type=submit value=\"Search\">\n                    </form>\n                </div>\n            </div>\n            \"\"\"  % (version, html.escape(platform.platform(terse=True)))\n  \n def html_index():\n  \"\"\n  \n  def bltinlink(name):\n   return '<a href=\"%s.html\">%s</a>' % (name, name)\n   \n  heading = html.heading(\n  '<big><big><strong>Index of Modules</strong></big></big>',\n  '#ffffff', '#7799ee')\n  names = [name for name in sys.builtin_module_names\n  if name != '__main__']\n  contents = html.multicolumn(names, bltinlink)\n  contents = [heading, '<p>' + html.bigsection(\n  'Built-in Modules', '#ffffff', '#ee77aa', contents)]\n  \n  seen = {}\n  for dir in sys.path:\n   contents.append(html.index(dir, seen))\n   \n  contents.append(\n  '<p align=right><font color=\"#909090\" face=\"helvetica,'\n  'arial\"><strong>pydoc</strong> by Ka-Ping Yee'\n  '&lt;ping@lfw.org&gt;</font>')\n  return 'Index of Modules', ''.join(contents)\n  \n def html_search(key):\n  \"\"\n  \n  search_result = []\n  \n  def callback(path, modname, desc):\n   if modname[-9:] == '.__init__':\n    modname = modname[:-9] + ' (package)'\n   search_result.append((modname, desc and '- ' + desc))\n   \n  with warnings.catch_warnings():\n   warnings.filterwarnings('ignore') \n   ModuleScanner().run(callback, key)\n   \n   \n  def bltinlink(name):\n   return '<a href=\"%s.html\">%s</a>' % (name, name)\n   \n  results = []\n  heading = html.heading(\n  '<big><big><strong>Search Results</strong></big></big>',\n  '#ffffff', '#7799ee')\n  for name, desc in search_result:\n   results.append(bltinlink(name) + desc)\n  contents = heading + html.bigsection(\n  'key = %s' % key, '#ffffff', '#ee77aa', '<br>'.join(results))\n  return 'Search Results', contents\n  \n def html_getfile(path):\n  \"\"\n  path = path.replace('%20', ' ')\n  with tokenize.open(path) as fp:\n   lines = html.escape(fp.read())\n  body = '<pre>%s</pre>' % lines\n  heading = html.heading(\n  '<big><big><strong>File Listing</strong></big></big>',\n  '#ffffff', '#7799ee')\n  contents = heading + html.bigsection(\n  'File: %s' % path, '#ffffff', '#ee77aa', body)\n  return 'getfile %s' % path, contents\n  \n def html_topics():\n  \"\"\n  \n  def bltinlink(name):\n   return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n   \n  heading = html.heading(\n  '<big><big><strong>INDEX</strong></big></big>',\n  '#ffffff', '#7799ee')\n  names = sorted(Helper.topics.keys())\n  \n  contents = html.multicolumn(names, bltinlink)\n  contents = heading + html.bigsection(\n  'Topics', '#ffffff', '#ee77aa', contents)\n  return 'Topics', contents\n  \n def html_keywords():\n  \"\"\n  heading = html.heading(\n  '<big><big><strong>INDEX</strong></big></big>',\n  '#ffffff', '#7799ee')\n  names = sorted(Helper.keywords.keys())\n  \n  def bltinlink(name):\n   return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n   \n  contents = html.multicolumn(names, bltinlink)\n  contents = heading + html.bigsection(\n  'Keywords', '#ffffff', '#ee77aa', contents)\n  return 'Keywords', contents\n  \n def html_topicpage(topic):\n  \"\"\n  buf = io.StringIO()\n  htmlhelp = Helper(buf, buf)\n  contents, xrefs = htmlhelp._gettopic(topic)\n  if topic in htmlhelp.keywords:\n   title = 'KEYWORD'\n  else:\n   title = 'TOPIC'\n  heading = html.heading(\n  '<big><big><strong>%s</strong></big></big>' % title,\n  '#ffffff', '#7799ee')\n  contents = '<pre>%s</pre>' % html.markup(contents)\n  contents = html.bigsection(topic , '#ffffff','#ee77aa', contents)\n  if xrefs:\n   xrefs = sorted(xrefs.split())\n   \n   def bltinlink(name):\n    return '<a href=\"topic?key=%s\">%s</a>' % (name, name)\n    \n   xrefs = html.multicolumn(xrefs, bltinlink)\n   xrefs = html.section('Related help topics: ',\n   '#ffffff', '#ee77aa', xrefs)\n  return ('%s %s' % (title, topic),\n  ''.join((heading, contents, xrefs)))\n  \n def html_getobj(url):\n  obj = locate(url, forceload=1)\n  if obj is None and url != 'None':\n   raise ValueError('could not find object')\n  title = describe(obj)\n  content = html.document(obj, url)\n  return title, content\n  \n def html_error(url, exc):\n  heading = html.heading(\n  '<big><big><strong>Error</strong></big></big>',\n  '#ffffff', '#7799ee')\n  contents = '<br>'.join(html.escape(line) for line in\n  format_exception_only(type(exc), exc))\n  contents = heading + html.bigsection(url, '#ffffff', '#bb0000',\n  contents)\n  return \"Error - %s\" % url, contents\n  \n def get_html_page(url):\n  \"\"\n  complete_url = url\n  if url.endswith('.html'):\n   url = url[:-5]\n  try:\n   if url in (\"\", \"index\"):\n    title, content = html_index()\n   elif url == \"topics\":\n    title, content = html_topics()\n   elif url == \"keywords\":\n    title, content = html_keywords()\n   elif '=' in url:\n    op, _, url = url.partition('=')\n    if op == \"search?key\":\n     title, content = html_search(url)\n    elif op == \"getfile?key\":\n     title, content = html_getfile(url)\n    elif op == \"topic?key\":\n    \n     try:\n      title, content = html_topicpage(url)\n     except ValueError:\n      title, content = html_getobj(url)\n    elif op == \"get?key\":\n    \n     if url in (\"\", \"index\"):\n      title, content = html_index()\n     else:\n      try:\n       title, content = html_getobj(url)\n      except ValueError:\n       title, content = html_topicpage(url)\n    else:\n     raise ValueError('bad pydoc url')\n   else:\n    title, content = html_getobj(url)\n  except Exception as exc:\n  \n   title, content = html_error(complete_url, exc)\n  return html.page(title, content)\n  \n if url.startswith('/'):\n  url = url[1:]\n if content_type == 'text/css':\n  path_here = os.path.dirname(os.path.realpath(__file__))\n  css_path = os.path.join(path_here, url)\n  with open(css_path) as fp:\n   return ''.join(fp.readlines())\n elif content_type == 'text/html':\n  return get_html_page(url)\n  \n raise TypeError('unknown content type %r for url %s' % (content_type, url))\n \n \ndef browse(port=0, *, open_browser=True):\n \"\"\n import webbrowser\n serverthread = _start_server(_url_handler, port)\n if serverthread.error:\n  print(serverthread.error)\n  return\n if serverthread.serving:\n  server_help_msg = 'Server commands: [b]rowser, [q]uit'\n  if open_browser:\n   webbrowser.open(serverthread.url)\n  try:\n   print('Server ready at', serverthread.url)\n   print(server_help_msg)\n   while serverthread.serving:\n    cmd = input('server> ')\n    cmd = cmd.lower()\n    if cmd == 'q':\n     break\n    elif cmd == 'b':\n     webbrowser.open(serverthread.url)\n    else:\n     print(server_help_msg)\n  except (KeyboardInterrupt, EOFError):\n   print()\n  finally:\n   if serverthread.serving:\n    serverthread.stop()\n    print('Server stopped')\n    \n    \n    \n    \ndef ispath(x):\n return isinstance(x, str) and x.find(os.sep) >= 0\n \ndef cli():\n \"\"\n import getopt\n class BadUsage(Exception): pass\n \n \n \n if '' not in sys.path:\n  scriptdir = os.path.dirname(sys.argv[0])\n  if scriptdir in sys.path:\n   sys.path.remove(scriptdir)\n  sys.path.insert(0, '.')\n  \n try:\n  opts, args = getopt.getopt(sys.argv[1:], 'bk:p:w')\n  writing = False\n  start_server = False\n  open_browser = False\n  port = None\n  for opt, val in opts:\n   if opt == '-b':\n    start_server = True\n    open_browser = True\n   if opt == '-k':\n    apropos(val)\n    return\n   if opt == '-p':\n    start_server = True\n    port = val\n   if opt == '-w':\n    writing = True\n    \n  if start_server:\n   if port is None:\n    port = 0\n   browse(port, open_browser=open_browser)\n   return\n   \n  if not args: raise BadUsage\n  for arg in args:\n   if ispath(arg) and not os.path.exists(arg):\n    print('file %r does not exist' % arg)\n    break\n   try:\n    if ispath(arg) and os.path.isfile(arg):\n     arg = importfile(arg)\n    if writing:\n     if ispath(arg) and os.path.isdir(arg):\n      writedocs(arg)\n     else:\n      writedoc(arg)\n    else:\n     help.help(arg)\n   except ErrorDuringImport as value:\n    print(value)\n    \n except (getopt.error, BadUsage):\n  cmd = os.path.splitext(os.path.basename(sys.argv[0]))[0]\n  print(\"\"\"pydoc - the Python documentation tool\n\n{cmd} <name> ...\n    Show text documentation on something.  <name> may be the name of a\n    Python keyword, topic, function, module, or package, or a dotted\n    reference to a class or function within a module or module in a\n    package.  If <name> contains a '{sep}', it is used as the path to a\n    Python source file to document. If name is 'keywords', 'topics',\n    or 'modules', a listing of these things is displayed.\n\n{cmd} -k <keyword>\n    Search for a keyword in the synopsis lines of all available modules.\n\n{cmd} -p <port>\n    Start an HTTP server on the given port on the local machine.  Port\n    number 0 can be used to get an arbitrary unused port.\n\n{cmd} -b\n    Start an HTTP server on an arbitrary unused port and open a Web browser\n    to interactively browse documentation.  The -p option can be used with\n    the -b option to explicitly specify the server port.\n\n{cmd} -w <name> ...\n    Write out the HTML documentation for a module to a file in the current\n    directory.  If <name> contains a '{sep}', it is treated as a filename; if\n    it names a directory, documentation is written for all the contents.\n\"\"\"  .format(cmd=cmd, sep=os.sep))\n  \nif __name__ == '__main__':\n cli()\n"], "threading": [".py", "\"\"\n\nimport sys as _sys\nimport _thread\n\nfrom time import sleep as _sleep\ntry:\n from time import monotonic as _time\nexcept ImportError:\n from time import time as _time\nfrom traceback import format_exc as _format_exc\nfrom _weakrefset import WeakSet\n\n\n\n\n\n\n\n\n\n\n\n__all__ = ['active_count', 'Condition', 'current_thread', 'enumerate', 'Event',\n'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Thread', 'Barrier',\n'Timer', 'ThreadError', 'setprofile', 'settrace', 'local', 'stack_size']\n\n\n_start_new_thread = _thread.start_new_thread\n_allocate_lock = _thread.allocate_lock\nget_ident = _thread.get_ident\nThreadError = _thread.error\ntry:\n _CRLock = _thread.RLock\nexcept AttributeError:\n _CRLock = None\nTIMEOUT_MAX = _thread.TIMEOUT_MAX\ndel _thread\n\n\n\n\n_profile_hook = None\n_trace_hook = None\n\ndef setprofile(func):\n \"\"\n global _profile_hook\n _profile_hook = func\n \ndef settrace(func):\n \"\"\n global _trace_hook\n _trace_hook = func\n \n \n \nLock = _allocate_lock\n\ndef RLock(*args, **kwargs):\n \"\"\n if _CRLock is None:\n  return _PyRLock(*args, **kwargs)\n return _CRLock(*args, **kwargs)\n \nclass _RLock:\n \"\"\n \n def __init__(self):\n  self._block = _allocate_lock()\n  self._owner = None\n  self._count = 0\n  \n def __repr__(self):\n  owner = self._owner\n  try:\n   owner = _active[owner].name\n  except KeyError:\n   pass\n  return \"<%s owner=%r count=%d>\" % (\n  self.__class__.__name__, owner, self._count)\n  \n def acquire(self, blocking=True, timeout=-1):\n  \"\"\n  me = get_ident()\n  if self._owner == me:\n   self._count = self._count + 1\n   return 1\n  rc = self._block.acquire(blocking, timeout)\n  if rc:\n   self._owner = me\n   self._count = 1\n  return rc\n  \n __enter__ = acquire\n \n def release(self):\n  \"\"\n  if self._owner != get_ident():\n   raise RuntimeError(\"cannot release un-acquired lock\")\n  self._count = count = self._count - 1\n  if not count:\n   self._owner = None\n   self._block.release()\n   \n def __exit__(self, t, v, tb):\n  self.release()\n  \n  \n  \n def _acquire_restore(self, state):\n  self._block.acquire()\n  self._count, self._owner = state\n  \n def _release_save(self):\n  if self._count == 0:\n   raise RuntimeError(\"cannot release un-acquired lock\")\n  count = self._count\n  self._count = 0\n  owner = self._owner\n  self._owner = None\n  self._block.release()\n  return (count, owner)\n  \n def _is_owned(self):\n  return self._owner == get_ident()\n  \n_PyRLock = _RLock\n\n\nclass Condition:\n \"\"\n \n def __init__(self, lock=None):\n  if lock is None:\n   lock = RLock()\n  self._lock = lock\n  \n  self.acquire = lock.acquire\n  self.release = lock.release\n  \n  \n  \n  try:\n   self._release_save = lock._release_save\n  except AttributeError:\n   pass\n  try:\n   self._acquire_restore = lock._acquire_restore\n  except AttributeError:\n   pass\n  try:\n   self._is_owned = lock._is_owned\n  except AttributeError:\n   pass\n  self._waiters = []\n  \n def __enter__(self):\n  return self._lock.__enter__()\n  \n def __exit__(self, *args):\n  return self._lock.__exit__(*args)\n  \n def __repr__(self):\n  return \"<Condition(%s, %d)>\" % (self._lock, len(self._waiters))\n  \n def _release_save(self):\n  self._lock.release() \n  \n def _acquire_restore(self, x):\n  self._lock.acquire() \n  \n def _is_owned(self):\n \n \n  if self._lock.acquire(0):\n   self._lock.release()\n   return False\n  else:\n   return True\n   \n def wait(self, timeout=None):\n  \"\"\n  if not self._is_owned():\n   raise RuntimeError(\"cannot wait on un-acquired lock\")\n  waiter = _allocate_lock()\n  waiter.acquire()\n  self._waiters.append(waiter)\n  saved_state = self._release_save()\n  try: \n   if timeout is None:\n    waiter.acquire()\n    gotit = True\n   else:\n    if timeout > 0:\n     gotit = waiter.acquire(True, timeout)\n    else:\n     gotit = waiter.acquire(False)\n    if not gotit:\n     try:\n      self._waiters.remove(waiter)\n     except ValueError:\n      pass\n   return gotit\n  finally:\n   self._acquire_restore(saved_state)\n   \n def wait_for(self, predicate, timeout=None):\n  \"\"\n  endtime = None\n  waittime = timeout\n  result = predicate()\n  while not result:\n   if waittime is not None:\n    if endtime is None:\n     endtime = _time() + waittime\n    else:\n     waittime = endtime - _time()\n     if waittime <= 0:\n      break\n   self.wait(waittime)\n   result = predicate()\n  return result\n  \n def notify(self, n=1):\n  \"\"\n  if not self._is_owned():\n   raise RuntimeError(\"cannot notify on un-acquired lock\")\n  __waiters = self._waiters\n  waiters = __waiters[:n]\n  if not waiters:\n   return\n  for waiter in waiters:\n   waiter.release()\n   try:\n    __waiters.remove(waiter)\n   except ValueError:\n    pass\n    \n def notify_all(self):\n  \"\"\n  self.notify(len(self._waiters))\n  \n notifyAll = notify_all\n \n \nclass Semaphore:\n \"\"\n \n \n \n def __init__(self, value=1):\n  if value < 0:\n   raise ValueError(\"semaphore initial value must be >= 0\")\n  self._cond = Condition(Lock())\n  self._value = value\n  \n def acquire(self, blocking=True, timeout=None):\n  \"\"\n  if not blocking and timeout is not None:\n   raise ValueError(\"can't specify timeout for non-blocking acquire\")\n  rc = False\n  endtime = None\n  with self._cond:\n   while self._value == 0:\n    if not blocking:\n     break\n    if timeout is not None:\n     if endtime is None:\n      endtime = _time() + timeout\n     else:\n      timeout = endtime - _time()\n      if timeout <= 0:\n       break\n    self._cond.wait(timeout)\n   else:\n    self._value = self._value - 1\n    rc = True\n  return rc\n  \n __enter__ = acquire\n \n def release(self):\n  \"\"\n  with self._cond:\n   self._value = self._value + 1\n   self._cond.notify()\n   \n def __exit__(self, t, v, tb):\n  self.release()\n  \n  \nclass BoundedSemaphore(Semaphore):\n \"\"\n \n def __init__(self, value=1):\n  Semaphore.__init__(self, value)\n  self._initial_value = value\n  \n def release(self):\n  \"\"\n  with self._cond:\n   if self._value >= self._initial_value:\n    raise ValueError(\"Semaphore released too many times\")\n   self._value += 1\n   self._cond.notify()\n   \n   \nclass Event:\n \"\"\n \n \n \n def __init__(self):\n  self._cond = Condition(Lock())\n  self._flag = False\n  \n def _reset_internal_locks(self):\n \n  self._cond.__init__()\n  \n def is_set(self):\n  \"\"\n  return self._flag\n  \n isSet = is_set\n \n def set(self):\n  \"\"\n  self._cond.acquire()\n  try:\n   self._flag = True\n   self._cond.notify_all()\n  finally:\n   self._cond.release()\n   \n def clear(self):\n  \"\"\n  self._cond.acquire()\n  try:\n   self._flag = False\n  finally:\n   self._cond.release()\n   \n def wait(self, timeout=None):\n  \"\"\n  self._cond.acquire()\n  try:\n   signaled = self._flag\n   if not signaled:\n    signaled = self._cond.wait(timeout)\n   return signaled\n  finally:\n   self._cond.release()\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \nclass Barrier:\n \"\"\n \n def __init__(self, parties, action=None, timeout=None):\n  \"\"\n  self._cond = Condition(Lock())\n  self._action = action\n  self._timeout = timeout\n  self._parties = parties\n  self._state = 0 \n  self._count = 0\n  \n def wait(self, timeout=None):\n  \"\"\n  if timeout is None:\n   timeout = self._timeout\n  with self._cond:\n   self._enter() \n   index = self._count\n   self._count += 1\n   try:\n    if index + 1 == self._parties:\n    \n     self._release()\n    else:\n    \n     self._wait(timeout)\n    return index\n   finally:\n    self._count -= 1\n    \n    self._exit()\n    \n    \n    \n def _enter(self):\n  while self._state in (-1, 1):\n  \n   self._cond.wait()\n   \n  if self._state < 0:\n   raise BrokenBarrierError\n  assert self._state == 0\n  \n  \n  \n def _release(self):\n  try:\n   if self._action:\n    self._action()\n    \n   self._state = 1\n   self._cond.notify_all()\n  except:\n  \n   self._break()\n   raise\n   \n   \n   \n def _wait(self, timeout):\n  if not self._cond.wait_for(lambda : self._state != 0, timeout):\n  \n   self._break()\n   raise BrokenBarrierError\n  if self._state < 0:\n   raise BrokenBarrierError\n  assert self._state == 1\n  \n  \n  \n def _exit(self):\n  if self._count == 0:\n   if self._state in (-1, 1):\n   \n    self._state = 0\n    self._cond.notify_all()\n    \n def reset(self):\n  \"\"\n  with self._cond:\n   if self._count > 0:\n    if self._state == 0:\n    \n     self._state = -1\n    elif self._state == -2:\n    \n    \n     self._state = -1\n   else:\n    self._state = 0\n   self._cond.notify_all()\n   \n def abort(self):\n  \"\"\n  with self._cond:\n   self._break()\n   \n def _break(self):\n \n \n  self._state = -2\n  self._cond.notify_all()\n  \n @property\n def parties(self):\n  \"\"\n  return self._parties\n  \n @property\n def n_waiting(self):\n  \"\"\n  \n  \n  if self._state == 0:\n   return self._count\n  return 0\n  \n @property\n def broken(self):\n  \"\"\n  return self._state == -2\n  \n  \nclass BrokenBarrierError(RuntimeError):\n pass\n \n \n \n_counter = 0\ndef _newname(template=\"Thread-%d\"):\n global _counter\n _counter = _counter + 1\n return template % _counter\n \n \n_active_limbo_lock = _allocate_lock()\n_active = {} \n_limbo = {}\n\n\n_dangling = WeakSet()\n\n\n\nclass Thread:\n \"\"\n \n __initialized = False\n \n \n \n \n __exc_info = _sys.exc_info\n \n \n \n \n def __init__(self, group=None, target=None, name=None,\n args=(), kwargs=None, *, daemon=None):\n  \"\"\n  assert group is None, \"group argument must be None for now\"\n  if kwargs is None:\n   kwargs = {}\n  self._target = target\n  self._name = str(name or _newname())\n  self._args = args\n  self._kwargs = kwargs\n  if daemon is not None:\n   self._daemonic = daemon\n  else:\n   self._daemonic = current_thread().daemon\n  self._ident = None\n  self._started = Event()\n  self._stopped = False\n  self._block = Condition(Lock())\n  self._initialized = True\n  \n  \n  self._stderr = _sys.stderr\n  _dangling.add(self)\n  \n def _reset_internal_locks(self):\n \n \n  if hasattr(self, '_block'): \n   self._block.__init__()\n  self._started._reset_internal_locks()\n  \n def __repr__(self):\n  assert self._initialized, \"Thread.__init__() was not called\"\n  status = \"initial\"\n  if self._started.is_set():\n   status = \"started\"\n  if self._stopped:\n   status = \"stopped\"\n  if self._daemonic:\n   status += \" daemon\"\n  if self._ident is not None:\n   status += \" %s\" % self._ident\n  return \"<%s(%s, %s)>\" % (self.__class__.__name__, self._name, status)\n  \n def start(self):\n  \"\"\n  if not self._initialized:\n   raise RuntimeError(\"thread.__init__() not called\")\n   \n  if self._started.is_set():\n   raise RuntimeError(\"threads can only be started once\")\n  with _active_limbo_lock:\n   _limbo[self] = self\n  try:\n   _start_new_thread(self._bootstrap, ())\n  except Exception:\n   with _active_limbo_lock:\n    del _limbo[self]\n   raise\n  self._started.wait()\n  \n def run(self):\n  \"\"\n  try:\n   if self._target:\n    self._target(*self._args, **self._kwargs)\n  finally:\n  \n  \n   del self._target, self._args, self._kwargs\n   \n def _bootstrap(self):\n \n \n \n \n \n \n \n \n \n \n \n \n  try:\n   self._bootstrap_inner()\n  except:\n   if self._daemonic and _sys is None:\n    return\n   raise\n   \n def _set_ident(self):\n  self._ident = get_ident()\n  \n def _bootstrap_inner(self):\n  try:\n   self._set_ident()\n   self._started.set()\n   with _active_limbo_lock:\n    _active[self._ident] = self\n    del _limbo[self]\n    \n   if _trace_hook:\n    _sys.settrace(_trace_hook)\n   if _profile_hook:\n    _sys.setprofile(_profile_hook)\n    \n   try:\n    self.run()\n   except SystemExit:\n    pass\n   except:\n   \n   \n   \n   \n    if _sys:\n     _sys.stderr.write(\"Exception in thread %s:\\n%s\\n\" %\n     (self.name, _format_exc()))\n    else:\n    \n    \n    \n     exc_type, exc_value, exc_tb = self._exc_info()\n     try:\n      print((\n      \"Exception in thread \" + self.name +\n      \" (most likely raised during interpreter shutdown):\"), file=self._stderr)\n      print((\n      \"Traceback (most recent call last):\"), file=self._stderr)\n      while exc_tb:\n       print((\n       '  File \"%s\", line %s, in %s' %\n       (exc_tb.tb_frame.f_code.co_filename,\n       exc_tb.tb_lineno,\n       exc_tb.tb_frame.f_code.co_name)), file=self._stderr)\n       exc_tb = exc_tb.tb_next\n      print((\"%s: %s\" % (exc_type, exc_value)), file=self._stderr)\n      \n      \n     finally:\n      del exc_type, exc_value, exc_tb\n   finally:\n   \n   \n   \n   \n   \n    pass\n  finally:\n   with _active_limbo_lock:\n    self._stop()\n    try:\n    \n    \n     del _active[get_ident()]\n    except:\n     pass\n     \n def _stop(self):\n  self._block.acquire()\n  self._stopped = True\n  self._block.notify_all()\n  self._block.release()\n  \n def _delete(self):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  try:\n   with _active_limbo_lock:\n    del _active[get_ident()]\n    \n    \n    \n    \n  except KeyError:\n   if 'dummy_threading' not in _sys.modules:\n    raise\n    \n def join(self, timeout=None):\n  \"\"\n  if not self._initialized:\n   raise RuntimeError(\"Thread.__init__() not called\")\n  if not self._started.is_set():\n   raise RuntimeError(\"cannot join thread before it is started\")\n  if self is current_thread():\n   raise RuntimeError(\"cannot join current thread\")\n   \n  self._block.acquire()\n  try:\n   if timeout is None:\n    while not self._stopped:\n     self._block.wait()\n   else:\n    deadline = _time() + timeout\n    while not self._stopped:\n     delay = deadline - _time()\n     if delay <= 0:\n      break\n     self._block.wait(delay)\n  finally:\n   self._block.release()\n   \n @property\n def name(self):\n  \"\"\n  assert self._initialized, \"Thread.__init__() not called\"\n  return self._name\n  \n @name.setter\n def name(self, name):\n  assert self._initialized, \"Thread.__init__() not called\"\n  self._name = str(name)\n  \n @property\n def ident(self):\n  \"\"\n  assert self._initialized, \"Thread.__init__() not called\"\n  return self._ident\n  \n def is_alive(self):\n  \"\"\n  assert self._initialized, \"Thread.__init__() not called\"\n  return self._started.is_set() and not self._stopped\n  \n isAlive = is_alive\n \n @property\n def daemon(self):\n  \"\"\n  assert self._initialized, \"Thread.__init__() not called\"\n  return self._daemonic\n  \n @daemon.setter\n def daemon(self, daemonic):\n  if not self._initialized:\n   raise RuntimeError(\"Thread.__init__() not called\")\n  if self._started.is_set():\n   raise RuntimeError(\"cannot set daemon status of active thread\");\n  self._daemonic = daemonic\n  \n def isDaemon(self):\n  return self.daemon\n  \n def setDaemon(self, daemonic):\n  self.daemon = daemonic\n  \n def getName(self):\n  return self.name\n  \n def setName(self, name):\n  self.name = name\n  \n  \n  \nclass Timer(Thread):\n \"\"\n \n def __init__(self, interval, function, args=None, kwargs=None):\n  Thread.__init__(self)\n  self.interval = interval\n  self.function = function\n  self.args = args if args is not None else []\n  self.kwargs = kwargs if kwargs is not None else {}\n  self.finished = Event()\n  \n def cancel(self):\n  \"\"\n  self.finished.set()\n  \n def run(self):\n  self.finished.wait(self.interval)\n  if not self.finished.is_set():\n   self.function(*self.args, **self.kwargs)\n  self.finished.set()\n  \n  \n  \n  \nclass _MainThread(Thread):\n\n def __init__(self):\n  Thread.__init__(self, name=\"MainThread\", daemon=False)\n  self._started.set()\n  self._set_ident()\n  with _active_limbo_lock:\n   _active[self._ident] = self\n   \n def _exitfunc(self):\n  self._stop()\n  t = _pickSomeNonDaemonThread()\n  while t:\n   t.join()\n   t = _pickSomeNonDaemonThread()\n  self._delete()\n  \ndef _pickSomeNonDaemonThread():\n for t in enumerate():\n  if not t.daemon and t.is_alive():\n   return t\n return None\n \n \n \n \n \n \n \n \n \n \nclass _DummyThread(Thread):\n\n def __init__(self):\n  Thread.__init__(self, name=_newname(\"Dummy-%d\"), daemon=True)\n  \n  \n  \n  \n  del self._block\n  \n  self._started.set()\n  self._set_ident()\n  with _active_limbo_lock:\n   _active[self._ident] = self\n   \n def _stop(self):\n  pass\n  \n def join(self, timeout=None):\n  assert False, \"cannot join a dummy thread\"\n  \n  \n  \n  \ndef current_thread():\n \"\"\n try:\n  return _active[get_ident()]\n except KeyError:\n  return _DummyThread()\n  \ncurrentThread = current_thread\n\ndef active_count():\n \"\"\n with _active_limbo_lock:\n  return len(_active) + len(_limbo)\n  \nactiveCount = active_count\n\ndef _enumerate():\n\n return list(_active.values()) + list(_limbo.values())\n \ndef enumerate():\n \"\"\n with _active_limbo_lock:\n  return list(_active.values()) + list(_limbo.values())\n  \nfrom _thread import stack_size\n\n\n\n\n\n_shutdown = _MainThread()._exitfunc\n\n\n\n\ntry:\n from _thread import _local as local\nexcept ImportError:\n from _threading_local import local\n \n \ndef _after_fork():\n\n\n\n\n\n\n global _active_limbo_lock\n _active_limbo_lock = _allocate_lock()\n \n \n new_active = {}\n current = current_thread()\n with _active_limbo_lock:\n  for thread in _enumerate():\n  \n  \n   thread._reset_internal_locks()\n   if thread is current:\n   \n   \n    ident = get_ident()\n    thread._ident = ident\n    new_active[ident] = thread\n   else:\n   \n    thread._stop()\n    \n  _limbo.clear()\n  _active.clear()\n  _active.update(new_active)\n  assert len(_active) == 1\n"], "token": [".py", "\"\"\n\n__all__ = ['tok_name', 'ISTERMINAL', 'ISNONTERMINAL', 'ISEOF']\n\n\n\n\n\n\n\n\n\nENDMARKER = 0\nNAME = 1\nNUMBER = 2\nSTRING = 3\nNEWLINE = 4\nINDENT = 5\nDEDENT = 6\nLPAR = 7\nRPAR = 8\nLSQB = 9\nRSQB = 10\nCOLON = 11\nCOMMA = 12\nSEMI = 13\nPLUS = 14\nMINUS = 15\nSTAR = 16\nSLASH = 17\nVBAR = 18\nAMPER = 19\nLESS = 20\nGREATER = 21\nEQUAL = 22\nDOT = 23\nPERCENT = 24\nLBRACE = 25\nRBRACE = 26\nEQEQUAL = 27\nNOTEQUAL = 28\nLESSEQUAL = 29\nGREATEREQUAL = 30\nTILDE = 31\nCIRCUMFLEX = 32\nLEFTSHIFT = 33\nRIGHTSHIFT = 34\nDOUBLESTAR = 35\nPLUSEQUAL = 36\nMINEQUAL = 37\nSTAREQUAL = 38\nSLASHEQUAL = 39\nPERCENTEQUAL = 40\nAMPEREQUAL = 41\nVBAREQUAL = 42\nCIRCUMFLEXEQUAL = 43\nLEFTSHIFTEQUAL = 44\nRIGHTSHIFTEQUAL = 45\nDOUBLESTAREQUAL = 46\nDOUBLESLASH = 47\nDOUBLESLASHEQUAL = 48\nAT = 49\nRARROW = 50\nELLIPSIS = 51\nOP = 52\nERRORTOKEN = 53\nN_TOKENS = 54\nNT_OFFSET = 256\n\n\ntok_name = {value: name\nfor name, value in globals().items()\nif isinstance(value, int) and not name.startswith('_')}\n__all__.extend(tok_name.values())\n\ndef ISTERMINAL(x):\n return x < NT_OFFSET\n \ndef ISNONTERMINAL(x):\n return x >= NT_OFFSET\n \ndef ISEOF(x):\n return x == ENDMARKER\n \n \ndef _main():\n import re\n import sys\n args = sys.argv[1:]\n inFileName = args and args[0] or \"Include/token.h\"\n outFileName = \"Lib/token.py\"\n if len(args) > 1:\n  outFileName = args[1]\n try:\n  fp = open(inFileName)\n except IOError as err:\n  sys.stdout.write(\"I/O error: %s\\n\" % str(err))\n  sys.exit(1)\n lines = fp.read().split(\"\\n\")\n fp.close()\n prog = re.compile(\n \"#define[ \\t][ \\t]*([A-Z0-9][A-Z0-9_]*)[ \\t][ \\t]*([0-9][0-9]*)\",\n re.IGNORECASE)\n tokens = {}\n for line in lines:\n  match = prog.match(line)\n  if match:\n   name, val = match.group(1, 2)\n   val = int(val)\n   tokens[val] = name \n keys = sorted(tokens.keys())\n \n try:\n  fp = open(outFileName)\n except IOError as err:\n  sys.stderr.write(\"I/O error: %s\\n\" % str(err))\n  sys.exit(2)\n format = fp.read().split(\"\\n\")\n fp.close()\n try:\n  start = format.index(\"#--start constants--\") + 1\n  end = format.index(\"#--end constants--\")\n except ValueError:\n  sys.stderr.write(\"target does not contain format markers\")\n  sys.exit(3)\n lines = []\n for val in keys:\n  lines.append(\"%s = %d\" % (tokens[val], val))\n format[start:end] = lines\n try:\n  fp = open(outFileName, 'w')\n except IOError as err:\n  sys.stderr.write(\"I/O error: %s\\n\" % str(err))\n  sys.exit(4)\n fp.write(\"\\n\".join(format))\n fp.close()\n \n \nif __name__ == \"__main__\":\n _main()\n"], "multiprocessing.dummy.connection": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__ = [ 'Client', 'Listener', 'Pipe' ]\n\nfrom queue import Queue\n\n\nfamilies = [None]\n\n\nclass Listener(object):\n\n def __init__(self, address=None, family=None, backlog=1):\n  self._backlog_queue = Queue(backlog)\n  \n def accept(self):\n  return Connection(*self._backlog_queue.get())\n  \n def close(self):\n  self._backlog_queue = None\n  \n address = property(lambda self: self._backlog_queue)\n \n def __enter__(self):\n  return self\n  \n def __exit__(self, exc_type, exc_value, exc_tb):\n  self.close()\n  \n  \ndef Client(address):\n _in, _out = Queue(), Queue()\n address.put((_out, _in))\n return Connection(_in, _out)\n \n \ndef Pipe(duplex=True):\n a, b = Queue(), Queue()\n return Connection(a, b), Connection(b, a)\n \n \nclass Connection(object):\n\n def __init__(self, _in, _out):\n  self._out = _out\n  self._in = _in\n  self.send = self.send_bytes = _out.put\n  self.recv = self.recv_bytes = _in.get\n  \n def poll(self, timeout=0.0):\n  if self._in.qsize() > 0:\n   return True\n  if timeout <= 0.0:\n   return False\n  self._in.not_empty.acquire()\n  self._in.not_empty.wait(timeout)\n  self._in.not_empty.release()\n  return self._in.qsize() > 0\n  \n def close(self):\n  pass\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self, exc_type, exc_value, exc_tb):\n  self.close()\n"], "importlib.basehook": [".py", "from javascript import JSObject\nfrom browser import window\nimport urllib.request\n\nclass TempMod:\n def __init__(self, name):\n  self.name=name\n  \n  \nclass BaseHook:\n def __init__(self, fullname=None, path=None):\n  self._fullname=fullname\n  self._path=path \n  self._modpath=''\n  self._module=''\n  \n def find_module(self, name=None, path=None):\n  if name is None:\n   name=self._fullname\n   \n  for _i in ('libs/%s.js' % name, 'Lib/%s.py' % name, \n  'Lib/%s/__init__.py' % name):\n   _path=\"%s%s\" % (__BRYTHON__.brython_path, _i)\n   try:\n    _fp,_,_headers=urllib.request.urlopen(_path)\n    if _headers['status'] != 200:\n     continue \n    self._module=_fp.read()\n    self._modpath=_path\n    return self\n   except urllib.error.HTTPError as e:\n    print(str(e))\n    self._modpath=''\n    self._module=''\n    \n  raise ImportError\n  \n def is_package(self):\n  return '.' in self._fullname\n  \n def load_module(self, name):\n  if name is None:\n   name=self._fullname\n  window.eval('__BRYTHON__.imported[\"%s\"]={}' % name)\n  return JSObject(__BRYTHON__.run_py)(TempMod(name),\n  self._modpath, self._module)\n"], "decimal": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\n\n__all__ = [\n\n'Decimal', 'Context',\n\n\n'DefaultContext', 'BasicContext', 'ExtendedContext',\n\n\n'DecimalException', 'Clamped', 'InvalidOperation', 'DivisionByZero',\n'Inexact', 'Rounded', 'Subnormal', 'Overflow', 'Underflow',\n'FloatOperation',\n\n\n'ROUND_DOWN', 'ROUND_HALF_UP', 'ROUND_HALF_EVEN', 'ROUND_CEILING',\n'ROUND_FLOOR', 'ROUND_UP', 'ROUND_HALF_DOWN', 'ROUND_05UP',\n\n\n'setcontext', 'getcontext', 'localcontext',\n\n\n'MAX_PREC', 'MAX_EMAX', 'MIN_EMIN', 'MIN_ETINY',\n\n\n'HAVE_THREADS'\n]\n\n__version__ = '1.70' \n\n\nimport copy as _copy\nimport math as _math\nimport numbers as _numbers\nimport sys\n\ntry:\n from collections import namedtuple as _namedtuple\n DecimalTuple = _namedtuple('DecimalTuple', 'sign digits exponent')\nexcept ImportError:\n DecimalTuple = lambda *args: args\n \n \nROUND_DOWN = 'ROUND_DOWN'\nROUND_HALF_UP = 'ROUND_HALF_UP'\nROUND_HALF_EVEN = 'ROUND_HALF_EVEN'\nROUND_CEILING = 'ROUND_CEILING'\nROUND_FLOOR = 'ROUND_FLOOR'\nROUND_UP = 'ROUND_UP'\nROUND_HALF_DOWN = 'ROUND_HALF_DOWN'\nROUND_05UP = 'ROUND_05UP'\n\n\nHAVE_THREADS = True\nif sys.maxsize == 2**63-1:\n MAX_PREC = 999999999999999999\n MAX_EMAX = 999999999999999999\n MIN_EMIN = -999999999999999999\nelse:\n MAX_PREC = 425000000\n MAX_EMAX = 425000000\n MIN_EMIN = -425000000\n \nMIN_ETINY = MIN_EMIN - (MAX_PREC-1)\n\n\n\nclass DecimalException(ArithmeticError):\n \"\"\n def handle(self, context, *args):\n  pass\n  \n  \nclass Clamped(DecimalException):\n \"\"\n \n \n pass\n \nclass InvalidOperation(DecimalException):\n \"\"\n def handle(self, context, *args):\n  if args:\n   ans = _dec_from_triple(args[0]._sign, args[0]._int, 'n', True)\n   return ans._fix_nan(context)\n  return _NaN\n  \nclass ConversionSyntax(InvalidOperation):\n \"\"\n def handle(self, context, *args):\n  return _NaN\n  \nclass DivisionByZero(DecimalException, ZeroDivisionError):\n \"\"\n \n def handle(self, context, sign, *args):\n  return _SignedInfinity[sign]\n  \nclass DivisionImpossible(InvalidOperation):\n \"\"\n \n def handle(self, context, *args):\n  return _NaN\n  \nclass DivisionUndefined(InvalidOperation, ZeroDivisionError):\n \"\"\n \n def handle(self, context, *args):\n  return _NaN\n  \nclass Inexact(DecimalException):\n \"\"\n \n \n pass\n \nclass InvalidContext(InvalidOperation):\n \"\"\n \n def handle(self, context, *args):\n  return _NaN\n  \nclass Rounded(DecimalException):\n \"\"\n \n pass\n \nclass Subnormal(DecimalException):\n \"\"\n \n pass\n \nclass Overflow(Inexact, Rounded):\n \"\"\n \n def handle(self, context, sign, *args):\n  if context.rounding in (ROUND_HALF_UP, ROUND_HALF_EVEN,\n  ROUND_HALF_DOWN, ROUND_UP):\n   return _SignedInfinity[sign]\n  if sign == 0:\n   if context.rounding == ROUND_CEILING:\n    return _SignedInfinity[sign]\n   return _dec_from_triple(sign, '9'*context.prec,\n   context.Emax-context.prec+1)\n  if sign == 1:\n   if context.rounding == ROUND_FLOOR:\n    return _SignedInfinity[sign]\n   return _dec_from_triple(sign, '9'*context.prec,\n   context.Emax-context.prec+1)\n   \n   \nclass Underflow(Inexact, Rounded, Subnormal):\n \"\"\n \n pass\n \nclass FloatOperation(DecimalException, TypeError):\n \"\"\n \n pass\n \n \n_signals = [Clamped, DivisionByZero, Inexact, Overflow, Rounded,\nUnderflow, InvalidOperation, Subnormal, FloatOperation]\n\n\n_condition_map = {ConversionSyntax:InvalidOperation,\nDivisionImpossible:InvalidOperation,\nDivisionUndefined:InvalidOperation,\nInvalidContext:InvalidOperation}\n\n\n_rounding_modes = (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_CEILING,\nROUND_FLOOR, ROUND_UP, ROUND_HALF_DOWN, ROUND_05UP)\n\n\n\n\n\n\n\n\n\ntry:\n import threading\nexcept ImportError:\n\n class MockThreading(object):\n  def local(self, sys=sys):\n   return sys.modules[__name__]\n threading = MockThreading()\n del MockThreading\n \ntry:\n threading.local\n \nexcept AttributeError:\n\n\n\n if hasattr(threading.current_thread(), '__decimal_context__'):\n  del threading.current_thread().__decimal_context__\n  \n def setcontext(context):\n  \"\"\n  if context in (DefaultContext, BasicContext, ExtendedContext):\n   context = context.copy()\n   context.clear_flags()\n  threading.current_thread().__decimal_context__ = context\n  \n def getcontext():\n  \"\"\n  try:\n   return threading.current_thread().__decimal_context__\n  except AttributeError:\n   context = Context()\n   threading.current_thread().__decimal_context__ = context\n   return context\n   \nelse:\n\n local = threading.local()\n if hasattr(local, '__decimal_context__'):\n  del local.__decimal_context__\n  \n def getcontext(_local=local):\n  \"\"\n  try:\n   return _local.__decimal_context__\n  except AttributeError:\n   context = Context()\n   _local.__decimal_context__ = context\n   return context\n   \n def setcontext(context, _local=local):\n  \"\"\n  if context in (DefaultContext, BasicContext, ExtendedContext):\n   context = context.copy()\n   context.clear_flags()\n  _local.__decimal_context__ = context\n  \n del threading, local \n \ndef localcontext(ctx=None):\n \"\"\n if ctx is None: ctx = getcontext()\n return _ContextManager(ctx)\n \n \n \n \n \n \n \n \nclass Decimal(object):\n \"\"\n \n __slots__ = ('_exp','_int','_sign', '_is_special')\n \n \n \n \n \n def __new__(cls, value=\"0\", context=None):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  self = object.__new__(cls)\n  \n  \n  \n  if isinstance(value, str):\n   value=value.strip().lower()\n   \n   if value.startswith(\"-\"):\n    self._sign = 1\n    value=value[1:]\n   else:\n    self._sign = 0\n    \n   if value in ('', 'nan'):\n    self._is_special = True\n    self._int = ''\n    \n    \n    \n    \n    self._exp='n'\n    return self\n    \n   if value in ('inf', 'infinity'):\n    self._int = '0'\n    self._exp = 'F'\n    self._is_special = True\n    return self\n    \n   import _jsre as re\n   _m=re.match(\"^\\d*\\.?\\d*(e\\+?\\d*)?$\", value)\n   if not _m:\n    self._is_special = True\n    self._int = ''\n    self._exp='n'\n    return self\n    \n   if '.' in value:\n    intpart, fracpart=value.split('.')\n    if 'e' in fracpart:\n     fracpart, exp=fracpart.split('e')\n     exp=int(exp)\n    else:\n     exp=0\n     \n     \n    self._int = intpart+fracpart\n    self._exp = exp - len(fracpart)\n    self._is_special = False\n    return self\n   else:\n   \n    self._is_special = False\n    if 'e' in value:\n     self._int, _exp=value.split('e')\n     self._exp=int(_exp)\n     \n    else:\n     self._int = value\n     self._exp = 0\n    return self\n    \n    \n    \n   if context is None:\n    context = getcontext()\n   return context._raise_error(ConversionSyntax,\n   \"Invalid literal for Decimal: %r\" % value)\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  if isinstance(value, int):\n   if value >= 0:\n    self._sign = 0\n   else:\n    self._sign = 1\n   self._exp = 0\n   self._int = str(abs(value))\n   self._is_special = False\n   return self\n   \n   \n  if isinstance(value, Decimal):\n   self._exp = value._exp\n   self._sign = value._sign\n   self._int = value._int\n   self._is_special = value._is_special\n   return self\n   \n   \n  if isinstance(value, _WorkRep):\n   self._sign = value.sign\n   self._int = str(value.int)\n   self._exp = int(value.exp)\n   self._is_special = False\n   return self\n   \n   \n  if isinstance(value, (list,tuple)):\n   if len(value) != 3:\n    raise ValueError('Invalid tuple size in creation of Decimal '\n    'from list or tuple.  The list or tuple '\n    'should have exactly three elements.')\n    \n   if not (isinstance(value[0], int) and value[0] in (0,1)):\n    raise ValueError(\"Invalid sign.  The first value in the tuple \"\n    \"should be an integer; either 0 for a \"\n    \"positive number or 1 for a negative number.\")\n   self._sign = value[0]\n   if value[2] == 'F':\n   \n    self._int = '0'\n    self._exp = value[2]\n    self._is_special = True\n   else:\n   \n    digits = []\n    for digit in value[1]:\n     if isinstance(digit, int) and 0 <= digit <= 9:\n     \n      if digits or digit != 0:\n       digits.append(digit)\n     else:\n      raise ValueError(\"The second value in the tuple must \"\n      \"be composed of integers in the range \"\n      \"0 through 9.\")\n    if value[2] in ('n', 'N'):\n    \n     self._int = ''.join(map(str, digits))\n     self._exp = value[2]\n     self._is_special = True\n    elif isinstance(value[2], int):\n    \n     self._int = ''.join(map(str, digits or [0]))\n     self._exp = value[2]\n     self._is_special = False\n    else:\n     raise ValueError(\"The third value in the tuple must \"\n     \"be an integer, or one of the \"\n     \"strings 'F', 'n', 'N'.\")\n   return self\n   \n  if isinstance(value, float):\n   if context is None:\n    context = getcontext()\n   context._raise_error(FloatOperation,\n   \"strict semantics for mixing floats and Decimals are \"\n   \"enabled\")\n   value = Decimal.from_float(value)\n   self._exp = value._exp\n   self._sign = value._sign\n   self._int = value._int\n   self._is_special = value._is_special\n   return self\n   \n  raise TypeError(\"Cannot convert %r to Decimal\" % value)\n  \n  \n  \n def from_float(cls, f):\n  \"\"\n  if isinstance(f, int): \n   return cls(f)\n  if not isinstance(f, float):\n   raise TypeError(\"argument must be int or float.\")\n  if _math.isinf(f) or _math.isnan(f):\n   return cls(repr(f))\n  if _math.copysign(1.0, f) == 1.0:\n   sign = 0\n  else:\n   sign = 1\n  n, d = abs(f).as_integer_ratio()\n  k = d.bit_length() - 1\n  result = _dec_from_triple(sign, str(n*5**k), -k)\n  if cls is Decimal:\n   return result\n  else:\n   return cls(result)\n from_float = classmethod(from_float)\n \n def _isnan(self):\n  \"\"\n  if self._is_special:\n   exp = self._exp\n   if exp == 'n':\n    return 1\n   elif exp == 'N':\n    return 2\n  return 0\n  \n def _isinfinity(self):\n  \"\"\n  if self._exp == 'F':\n   if self._sign:\n    return -1\n   return 1\n  return 0\n  \n def _check_nans(self, other=None, context=None):\n  \"\"\n  \n  self_is_nan = self._isnan()\n  if other is None:\n   other_is_nan = False\n  else:\n   other_is_nan = other._isnan()\n   \n  if self_is_nan or other_is_nan:\n   if context is None:\n    context = getcontext()\n    \n   if self_is_nan == 2:\n    return context._raise_error(InvalidOperation, 'sNaN',\n    self)\n   if other_is_nan == 2:\n    return context._raise_error(InvalidOperation, 'sNaN',\n    other)\n   if self_is_nan:\n    return self._fix_nan(context)\n    \n   return other._fix_nan(context)\n  return 0\n  \n def _compare_check_nans(self, other, context):\n  \"\"\n  if context is None:\n   context = getcontext()\n   \n  if self._is_special or other._is_special:\n   if self.is_snan():\n    return context._raise_error(InvalidOperation,\n    'comparison involving sNaN',\n    self)\n   elif other.is_snan():\n    return context._raise_error(InvalidOperation,\n    'comparison involving sNaN',\n    other)\n   elif self.is_qnan():\n    return context._raise_error(InvalidOperation,\n    'comparison involving NaN',\n    self)\n   elif other.is_qnan():\n    return context._raise_error(InvalidOperation,\n    'comparison involving NaN',\n    other)\n  return 0\n  \n def __bool__(self):\n  \"\"\n  return self._is_special or self._int != '0'\n  \n def _cmp(self, other):\n  \"\"\n  \n  if self._is_special or other._is_special:\n   self_inf = self._isinfinity()\n   other_inf = other._isinfinity()\n   if self_inf == other_inf:\n    return 0\n   elif self_inf < other_inf:\n    return -1\n   else:\n    return 1\n    \n    \n  if not self:\n   if not other:\n    return 0\n   else:\n    return -((-1)**other._sign)\n  if not other:\n   return (-1)**self._sign\n   \n   \n  if other._sign < self._sign:\n   return -1\n  if self._sign < other._sign:\n   return 1\n   \n  self_adjusted = self.adjusted()\n  other_adjusted = other.adjusted()\n  if self_adjusted == other_adjusted:\n   self_padded = self._int + '0'*(self._exp - other._exp)\n   other_padded = other._int + '0'*(other._exp - self._exp)\n   if self_padded == other_padded:\n    return 0\n   elif self_padded < other_padded:\n    return -(-1)**self._sign\n   else:\n    return (-1)**self._sign\n  elif self_adjusted > other_adjusted:\n   return (-1)**self._sign\n  else: \n   return -((-1)**self._sign)\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def __eq__(self, other, context=None):\n  self, other = _convert_for_comparison(self, other, equality_op=True)\n  if other is NotImplemented:\n   return other\n  if self._check_nans(other, context):\n   return False\n  return self._cmp(other) == 0\n  \n def __ne__(self, other, context=None):\n  self, other = _convert_for_comparison(self, other, equality_op=True)\n  if other is NotImplemented:\n   return other\n  if self._check_nans(other, context):\n   return True\n  return self._cmp(other) != 0\n  \n  \n def __lt__(self, other, context=None):\n  self, other = _convert_for_comparison(self, other)\n  if other is NotImplemented:\n   return other\n  ans = self._compare_check_nans(other, context)\n  if ans:\n   return False\n  return self._cmp(other) < 0\n  \n def __le__(self, other, context=None):\n  self, other = _convert_for_comparison(self, other)\n  if other is NotImplemented:\n   return other\n  ans = self._compare_check_nans(other, context)\n  if ans:\n   return False\n  return self._cmp(other) <= 0\n  \n def __gt__(self, other, context=None):\n  self, other = _convert_for_comparison(self, other)\n  if other is NotImplemented:\n   return other\n  ans = self._compare_check_nans(other, context)\n  if ans:\n   return False\n  return self._cmp(other) > 0\n  \n def __ge__(self, other, context=None):\n  self, other = _convert_for_comparison(self, other)\n  if other is NotImplemented:\n   return other\n  ans = self._compare_check_nans(other, context)\n  if ans:\n   return False\n  return self._cmp(other) >= 0\n  \n def compare(self, other, context=None):\n  \"\"\n  other = _convert_other(other, raiseit=True)\n  \n  \n  if (self._is_special or other and other._is_special):\n   ans = self._check_nans(other, context)\n   if ans:\n    return ans\n    \n  return Decimal(self._cmp(other))\n  \n def __hash__(self):\n  \"\"\n  \n  \n  \n  \n  \n  if self._is_special:\n   if self.is_snan():\n    raise TypeError('Cannot hash a signaling NaN value.')\n   elif self.is_nan():\n    return _PyHASH_NAN\n   else:\n    if self._sign:\n     return -_PyHASH_INF\n    else:\n     return _PyHASH_INF\n     \n  if self._exp >= 0:\n   exp_hash = pow(10, self._exp, _PyHASH_MODULUS)\n  else:\n   exp_hash = pow(_PyHASH_10INV, -self._exp, _PyHASH_MODULUS)\n  hash_ = int(self._int) * exp_hash % _PyHASH_MODULUS\n  ans = hash_ if self >= 0 else -hash_\n  return -2 if ans == -1 else ans\n  \n def as_tuple(self):\n  \"\"\n  return DecimalTuple(self._sign, tuple(map(int, self._int)), self._exp)\n  \n def __repr__(self):\n  \"\"\n  \n  return \"Decimal('%s')\" % str(self)\n  \n def __str__(self, eng=False, context=None):\n  \"\"\n  \n  sign = ['', '-'][self._sign]\n  if self._is_special:\n   if self._exp == 'F':\n    return sign + 'Infinity'\n   elif self._exp == 'n':\n    return sign + 'NaN' + self._int\n   else: \n    return sign + 'sNaN' + self._int\n    \n    \n  leftdigits = self._exp + len(self._int)\n  \n  \n  \n  \n  if self._exp <= 0 and leftdigits > -6:\n  \n   dotplace = leftdigits\n  elif not eng:\n  \n   dotplace = 1\n  elif self._int == '0':\n  \n   dotplace = (leftdigits + 1) % 3 - 1\n  else:\n  \n   dotplace = (leftdigits - 1) % 3 + 1\n   \n  if dotplace <= 0:\n   intpart = '0'\n   fracpart = '.' + '0'*(-dotplace) + self._int\n  elif dotplace >= len(self._int):\n   intpart = self._int+'0'*(dotplace-len(self._int))\n   fracpart = ''\n  else:\n   intpart = self._int[:dotplace]\n   fracpart = '.' + self._int[dotplace:]\n  if leftdigits == dotplace:\n   exp = ''\n  else:\n   if context is None:\n    context = getcontext()\n   exp = ['e', 'E'][context.capitals] + \"%+d\" % (leftdigits-dotplace)\n   \n  return sign + intpart + fracpart + exp\n  \n def to_eng_string(self, context=None):\n  \"\"\n  return self.__str__(eng=True, context=context)\n  \n def __neg__(self, context=None):\n  \"\"\n  if self._is_special:\n   ans = self._check_nans(context=context)\n   if ans:\n    return ans\n    \n  if context is None:\n   context = getcontext()\n   \n  if not self and context.rounding != ROUND_FLOOR:\n  \n  \n   ans = self.copy_abs()\n  else:\n   ans = self.copy_negate()\n   \n  return ans._fix(context)\n  \n def __pos__(self, context=None):\n  \"\"\n  if self._is_special:\n   ans = self._check_nans(context=context)\n   if ans:\n    return ans\n    \n  if context is None:\n   context = getcontext()\n   \n  if not self and context.rounding != ROUND_FLOOR:\n  \n   ans = self.copy_abs()\n  else:\n   ans = Decimal(self)\n   \n  return ans._fix(context)\n  \n def __abs__(self, round=True, context=None):\n  \"\"\n  if not round:\n   return self.copy_abs()\n   \n  if self._is_special:\n   ans = self._check_nans(context=context)\n   if ans:\n    return ans\n    \n  if self._sign:\n   ans = self.__neg__(context=context)\n  else:\n   ans = self.__pos__(context=context)\n   \n  return ans\n  \n def __add__(self, other, context=None):\n  \"\"\n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n   \n  if context is None:\n   context = getcontext()\n   \n  if self._is_special or other._is_special:\n   ans = self._check_nans(other, context)\n   if ans:\n    return ans\n    \n   if self._isinfinity():\n   \n    if self._sign != other._sign and other._isinfinity():\n     return context._raise_error(InvalidOperation, '-INF + INF')\n    return Decimal(self)\n   if other._isinfinity():\n    return Decimal(other) \n    \n  exp = min(self._exp, other._exp)\n  negativezero = 0\n  if context.rounding == ROUND_FLOOR and self._sign != other._sign:\n  \n   negativezero = 1\n   \n  if not self and not other:\n   sign = min(self._sign, other._sign)\n   if negativezero:\n    sign = 1\n   ans = _dec_from_triple(sign, '0', exp)\n   ans = ans._fix(context)\n   return ans\n  if not self:\n   exp = max(exp, other._exp - context.prec-1)\n   ans = other._rescale(exp, context.rounding)\n   ans = ans._fix(context)\n   return ans\n  if not other:\n   exp = max(exp, self._exp - context.prec-1)\n   ans = self._rescale(exp, context.rounding)\n   ans = ans._fix(context)\n   return ans\n   \n  op1 = _WorkRep(self)\n  op2 = _WorkRep(other)\n  op1, op2 = _normalize(op1, op2, context.prec)\n  \n  result = _WorkRep()\n  if op1.sign != op2.sign:\n  \n   if op1.int == op2.int:\n    ans = _dec_from_triple(negativezero, '0', exp)\n    ans = ans._fix(context)\n    return ans\n   if op1.int < op2.int:\n    op1, op2 = op2, op1\n    \n   if op1.sign == 1:\n    result.sign = 1\n    op1.sign, op2.sign = op2.sign, op1.sign\n   else:\n    result.sign = 0\n    \n  elif op1.sign == 1:\n   result.sign = 1\n   op1.sign, op2.sign = (0, 0)\n  else:\n   result.sign = 0\n   \n   \n  if op2.sign == 0:\n   result.int = op1.int + op2.int\n  else:\n   result.int = op1.int - op2.int\n   \n  result.exp = op1.exp\n  ans = Decimal(result)\n  ans = ans._fix(context)\n  return ans\n  \n __radd__ = __add__\n \n def __sub__(self, other, context=None):\n  \"\"\n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n   \n  if self._is_special or other._is_special:\n   ans = self._check_nans(other, context=context)\n   if ans:\n    return ans\n    \n    \n  return self.__add__(other.copy_negate(), context=context)\n  \n def __rsub__(self, other, context=None):\n  \"\"\n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n   \n  return other.__sub__(self, context=context)\n  \n def __mul__(self, other, context=None):\n  \"\"\n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n   \n  if context is None:\n   context = getcontext()\n   \n  resultsign = self._sign ^ other._sign\n  \n  if self._is_special or other._is_special:\n   ans = self._check_nans(other, context)\n   if ans:\n    return ans\n    \n   if self._isinfinity():\n    if not other:\n     return context._raise_error(InvalidOperation, '(+-)INF * 0')\n    return _SignedInfinity[resultsign]\n    \n   if other._isinfinity():\n    if not self:\n     return context._raise_error(InvalidOperation, '0 * (+-)INF')\n    return _SignedInfinity[resultsign]\n    \n  resultexp = self._exp + other._exp\n  \n  \n  if not self or not other:\n   ans = _dec_from_triple(resultsign, '0', resultexp)\n   \n   ans = ans._fix(context)\n   return ans\n   \n   \n  if self._int == '1':\n   ans = _dec_from_triple(resultsign, other._int, resultexp)\n   ans = ans._fix(context)\n   return ans\n  if other._int == '1':\n   ans = _dec_from_triple(resultsign, self._int, resultexp)\n   ans = ans._fix(context)\n   return ans\n   \n  op1 = _WorkRep(self)\n  op2 = _WorkRep(other)\n  \n  ans = _dec_from_triple(resultsign, str(op1.int * op2.int), resultexp)\n  ans = ans._fix(context)\n  \n  return ans\n __rmul__ = __mul__\n \n def __truediv__(self, other, context=None):\n  \"\"\n  other = _convert_other(other)\n  if other is NotImplemented:\n   return NotImplemented\n   \n  if context is None:\n   context = getcontext()\n   \n  sign = self._sign ^ other._sign\n  \n  if self._is_special or other._is_special:\n   ans = self._check_nans(other, context)\n   if ans:\n    return ans\n    \n   if self._isinfinity() and other._isinfinity():\n    return context._raise_error(InvalidOperation, '(+-)INF/(+-)INF')\n    \n   if self._isinfinity():\n    return _SignedInfinity[sign]\n    \n   if other._isinfinity():\n    context._raise_error(Clamped, 'Division by infinity')\n    return _dec_from_triple(sign, '0', context.Etiny())\n    \n    \n  if not other:\n   if not self:\n    return context._raise_error(DivisionUndefined, '0 / 0')\n   return context._raise_error(DivisionByZero, 'x / 0', sign)\n   \n  if not self:\n   exp = self._exp - other._exp\n   coeff = 0\n  else:\n  \n   shift = len(other._int) - len(self._int) + context.prec + 1\n   exp = self._exp - other._exp - shift\n   op1 = _WorkRep(self)\n   op2 = _WorkRep(other)\n   if shift >= 0:\n    coeff, remainder = divmod(op1.int * 10**shift, op2.int)\n   else:\n    coeff, remainder = divmod(op1.int, op2.int * 10**-shift)\n   if remainder:\n   \n    if coeff % 5 == 0:\n     coeff += 1\n   else:\n   \n    ideal_exp = self._exp - other._exp\n    while exp < ideal_exp and coeff % 10 == 0:\n     coeff //= 10\n     exp += 1\n     \n  ans = _dec_from_triple(sign, str(coeff), exp)\n  return ans._fix(context)\n  \n def _divide(self, other, context):\n  \"\"\n  sign = self._sign ^ other._sign\n  if other._isinfinity():\n   ideal_exp = self._exp\n  else:\n   ideal_exp = min(self._exp, other._exp)\n   \n  expdiff = self.adjusted() - other.adjusted()\n  if not self or other._isinfinity() or expdiff <= -2:\n   return (_dec_from_triple(sign, '0', 0),\n   self._rescale(ideal_exp, context.rounding))\n  if expdiff <= context.prec:\n   op1 = _WorkRep(self)\n   op2 = _WorkRep(other)\n   if op1.exp >= op2.exp:\n    op1.int *= 10**(op1.exp - op2.exp)\n   else:\n    op2.int *= 10**(op2.exp - op1.exp)\n   q, r = divmod(op1.int, op2.int)\n   if q < 10**context.prec:\n    return (_dec_from_triple(sign, str(q), 0),\n    _dec_from_triple(self._sign, str(r), ideal_exp))\n    \n    \n  ans = context._raise_error(DivisionImpossible,\n  'quotient too large in //, % or divmod')\n  return ans, ans\n  \n def __rtruediv__(self, other, context=None):\n  \"\"\n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n  return other.__truediv__(self, context=context)\n  \n def __divmod__(self, other, context=None):\n  \"\"\n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n   \n  if context is None:\n   context = getcontext()\n   \n  ans = self._check_nans(other, context)\n  if ans:\n   return (ans, ans)\n   \n  sign = self._sign ^ other._sign\n  if self._isinfinity():\n   if other._isinfinity():\n    ans = context._raise_error(InvalidOperation, 'divmod(INF, INF)')\n    return ans, ans\n   else:\n    return (_SignedInfinity[sign],\n    context._raise_error(InvalidOperation, 'INF % x'))\n    \n  if not other:\n   if not self:\n    ans = context._raise_error(DivisionUndefined, 'divmod(0, 0)')\n    return ans, ans\n   else:\n    return (context._raise_error(DivisionByZero, 'x // 0', sign),\n    context._raise_error(InvalidOperation, 'x % 0'))\n    \n  quotient, remainder = self._divide(other, context)\n  remainder = remainder._fix(context)\n  return quotient, remainder\n  \n def __rdivmod__(self, other, context=None):\n  \"\"\n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n  return other.__divmod__(self, context=context)\n  \n def __mod__(self, other, context=None):\n  \"\"\n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n   \n  if context is None:\n   context = getcontext()\n   \n  ans = self._check_nans(other, context)\n  if ans:\n   return ans\n   \n  if self._isinfinity():\n   return context._raise_error(InvalidOperation, 'INF % x')\n  elif not other:\n   if self:\n    return context._raise_error(InvalidOperation, 'x % 0')\n   else:\n    return context._raise_error(DivisionUndefined, '0 % 0')\n    \n  remainder = self._divide(other, context)[1]\n  remainder = remainder._fix(context)\n  return remainder\n  \n def __rmod__(self, other, context=None):\n  \"\"\n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n  return other.__mod__(self, context=context)\n  \n def remainder_near(self, other, context=None):\n  \"\"\n  if context is None:\n   context = getcontext()\n   \n  other = _convert_other(other, raiseit=True)\n  \n  ans = self._check_nans(other, context)\n  if ans:\n   return ans\n   \n   \n  if self._isinfinity():\n   return context._raise_error(InvalidOperation,\n   'remainder_near(infinity, x)')\n   \n   \n  if not other:\n   if self:\n    return context._raise_error(InvalidOperation,\n    'remainder_near(x, 0)')\n   else:\n    return context._raise_error(DivisionUndefined,\n    'remainder_near(0, 0)')\n    \n    \n  if other._isinfinity():\n   ans = Decimal(self)\n   return ans._fix(context)\n   \n   \n  ideal_exponent = min(self._exp, other._exp)\n  if not self:\n   ans = _dec_from_triple(self._sign, '0', ideal_exponent)\n   return ans._fix(context)\n   \n   \n  expdiff = self.adjusted() - other.adjusted()\n  if expdiff >= context.prec + 1:\n  \n   return context._raise_error(DivisionImpossible)\n  if expdiff <= -2:\n  \n   ans = self._rescale(ideal_exponent, context.rounding)\n   return ans._fix(context)\n   \n   \n  op1 = _WorkRep(self)\n  op2 = _WorkRep(other)\n  if op1.exp >= op2.exp:\n   op1.int *= 10**(op1.exp - op2.exp)\n  else:\n   op2.int *= 10**(op2.exp - op1.exp)\n  q, r = divmod(op1.int, op2.int)\n  \n  \n  \n  if 2*r + (q&1) > op2.int:\n   r -= op2.int\n   q += 1\n   \n  if q >= 10**context.prec:\n   return context._raise_error(DivisionImpossible)\n   \n   \n  sign = self._sign\n  if r < 0:\n   sign = 1-sign\n   r = -r\n   \n  ans = _dec_from_triple(sign, str(r), ideal_exponent)\n  return ans._fix(context)\n  \n def __floordiv__(self, other, context=None):\n  \"\"\n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n   \n  if context is None:\n   context = getcontext()\n   \n  ans = self._check_nans(other, context)\n  if ans:\n   return ans\n   \n  if self._isinfinity():\n   if other._isinfinity():\n    return context._raise_error(InvalidOperation, 'INF // INF')\n   else:\n    return _SignedInfinity[self._sign ^ other._sign]\n    \n  if not other:\n   if self:\n    return context._raise_error(DivisionByZero, 'x // 0',\n    self._sign ^ other._sign)\n   else:\n    return context._raise_error(DivisionUndefined, '0 // 0')\n    \n  return self._divide(other, context)[0]\n  \n def __rfloordiv__(self, other, context=None):\n  \"\"\n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n  return other.__floordiv__(self, context=context)\n  \n def __float__(self):\n  \"\"\n  if self._isnan():\n   if self.is_snan():\n    raise ValueError(\"Cannot convert signaling NaN to float\")\n   s = \"-nan\" if self._sign else \"nan\"\n  else:\n   s = str(self)\n  return float(s)\n  \n def __int__(self):\n  \"\"\n  if self._is_special:\n   if self._isnan():\n    raise ValueError(\"Cannot convert NaN to integer\")\n   elif self._isinfinity():\n    raise OverflowError(\"Cannot convert infinity to integer\")\n  s = (-1)**self._sign\n  if self._exp >= 0:\n   return s*int(self._int)*10**self._exp\n  else:\n   return s*int(self._int[:self._exp] or '0')\n   \n __trunc__ = __int__\n \n def real(self):\n  return self\n real = property(real)\n \n def imag(self):\n  return Decimal(0)\n imag = property(imag)\n \n def conjugate(self):\n  return self\n  \n def __complex__(self):\n  return complex(float(self))\n  \n def _fix_nan(self, context):\n  \"\"\n  payload = self._int\n  \n  \n  \n  max_payload_len = context.prec - context.clamp\n  if len(payload) > max_payload_len:\n   payload = payload[len(payload)-max_payload_len:].lstrip('0')\n   return _dec_from_triple(self._sign, payload, self._exp, True)\n  return Decimal(self)\n  \n def _fix(self, context):\n  \"\"\n  \n  if self._is_special:\n   if self._isnan():\n   \n    return self._fix_nan(context)\n   else:\n   \n    return Decimal(self)\n    \n    \n    \n  Etiny = context.Etiny()\n  Etop = context.Etop()\n  if not self:\n   exp_max = [context.Emax, Etop][context.clamp]\n   new_exp = min(max(self._exp, Etiny), exp_max)\n   if new_exp != self._exp:\n    context._raise_error(Clamped)\n    return _dec_from_triple(self._sign, '0', new_exp)\n   else:\n    return Decimal(self)\n    \n    \n    \n  exp_min = len(self._int) + self._exp - context.prec\n  if exp_min > Etop:\n  \n   ans = context._raise_error(Overflow, 'above Emax', self._sign)\n   context._raise_error(Inexact)\n   context._raise_error(Rounded)\n   return ans\n   \n  self_is_subnormal = exp_min < Etiny\n  if self_is_subnormal:\n   exp_min = Etiny\n   \n   \n  if self._exp < exp_min:\n   digits = len(self._int) + self._exp - exp_min\n   if digits < 0:\n    self = _dec_from_triple(self._sign, '1', exp_min-1)\n    digits = 0\n   rounding_method = self._pick_rounding_function[context.rounding]\n   changed = rounding_method(self, digits)\n   coeff = self._int[:digits] or '0'\n   if changed > 0:\n    coeff = str(int(coeff)+1)\n    if len(coeff) > context.prec:\n     coeff = coeff[:-1]\n     exp_min += 1\n     \n     \n   if exp_min > Etop:\n    ans = context._raise_error(Overflow, 'above Emax', self._sign)\n   else:\n    ans = _dec_from_triple(self._sign, coeff, exp_min)\n    \n    \n    \n   if changed and self_is_subnormal:\n    context._raise_error(Underflow)\n   if self_is_subnormal:\n    context._raise_error(Subnormal)\n   if changed:\n    context._raise_error(Inexact)\n   context._raise_error(Rounded)\n   if not ans:\n   \n    context._raise_error(Clamped)\n   return ans\n   \n  if self_is_subnormal:\n   context._raise_error(Subnormal)\n   \n   \n  if context.clamp == 1 and self._exp > Etop:\n   context._raise_error(Clamped)\n   self_padded = self._int + '0'*(self._exp - Etop)\n   return _dec_from_triple(self._sign, self_padded, Etop)\n   \n   \n  return Decimal(self)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _round_down(self, prec):\n  \"\"\n  if _all_zeros(self._int, prec):\n   return 0\n  else:\n   return -1\n   \n def _round_up(self, prec):\n  \"\"\n  return -self._round_down(prec)\n  \n def _round_half_up(self, prec):\n  \"\"\n  if self._int[prec] in '56789':\n   return 1\n  elif _all_zeros(self._int, prec):\n   return 0\n  else:\n   return -1\n   \n def _round_half_down(self, prec):\n  \"\"\n  if _exact_half(self._int, prec):\n   return -1\n  else:\n   return self._round_half_up(prec)\n   \n def _round_half_even(self, prec):\n  \"\"\n  if _exact_half(self._int, prec) and (prec == 0 or self._int[prec-1] in '02468'):\n   return -1\n  else:\n   return self._round_half_up(prec)\n   \n def _round_ceiling(self, prec):\n  \"\"\n  if self._sign:\n   return self._round_down(prec)\n  else:\n   return -self._round_down(prec)\n   \n def _round_floor(self, prec):\n  \"\"\n  if not self._sign:\n   return self._round_down(prec)\n  else:\n   return -self._round_down(prec)\n   \n def _round_05up(self, prec):\n  \"\"\n  if prec and self._int[prec-1] not in '05':\n   return self._round_down(prec)\n  else:\n   return -self._round_down(prec)\n   \n _pick_rounding_function = dict(\n ROUND_DOWN = _round_down,\n ROUND_UP = _round_up,\n ROUND_HALF_UP = _round_half_up,\n ROUND_HALF_DOWN = _round_half_down,\n ROUND_HALF_EVEN = _round_half_even,\n ROUND_CEILING = _round_ceiling,\n ROUND_FLOOR = _round_floor,\n ROUND_05UP = _round_05up,\n )\n \n def __round__(self, n=None):\n  \"\"\n  if n is not None:\n  \n   if not isinstance(n, int):\n    raise TypeError('Second argument to round should be integral')\n   exp = _dec_from_triple(0, '1', -n)\n   return self.quantize(exp)\n   \n   \n  if self._is_special:\n   if self.is_nan():\n    raise ValueError(\"cannot round a NaN\")\n   else:\n    raise OverflowError(\"cannot round an infinity\")\n  return int(self._rescale(0, ROUND_HALF_EVEN))\n  \n def __floor__(self):\n  \"\"\n  if self._is_special:\n   if self.is_nan():\n    raise ValueError(\"cannot round a NaN\")\n   else:\n    raise OverflowError(\"cannot round an infinity\")\n  return int(self._rescale(0, ROUND_FLOOR))\n  \n def __ceil__(self):\n  \"\"\n  if self._is_special:\n   if self.is_nan():\n    raise ValueError(\"cannot round a NaN\")\n   else:\n    raise OverflowError(\"cannot round an infinity\")\n  return int(self._rescale(0, ROUND_CEILING))\n  \n def fma(self, other, third, context=None):\n  \"\"\n  \n  other = _convert_other(other, raiseit=True)\n  third = _convert_other(third, raiseit=True)\n  \n  \n  \n  if self._is_special or other._is_special:\n   if context is None:\n    context = getcontext()\n   if self._exp == 'N':\n    return context._raise_error(InvalidOperation, 'sNaN', self)\n   if other._exp == 'N':\n    return context._raise_error(InvalidOperation, 'sNaN', other)\n   if self._exp == 'n':\n    product = self\n   elif other._exp == 'n':\n    product = other\n   elif self._exp == 'F':\n    if not other:\n     return context._raise_error(InvalidOperation,\n     'INF * 0 in fma')\n    product = _SignedInfinity[self._sign ^ other._sign]\n   elif other._exp == 'F':\n    if not self:\n     return context._raise_error(InvalidOperation,\n     '0 * INF in fma')\n    product = _SignedInfinity[self._sign ^ other._sign]\n  else:\n   product = _dec_from_triple(self._sign ^ other._sign,\n   str(int(self._int) * int(other._int)),\n   self._exp + other._exp)\n   \n  return product.__add__(third, context)\n  \n def _power_modulo(self, other, modulo, context=None):\n  \"\"\n  \n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n  modulo = _convert_other(modulo)\n  if modulo is NotImplemented:\n   return modulo\n   \n  if context is None:\n   context = getcontext()\n   \n   \n   \n  self_is_nan = self._isnan()\n  other_is_nan = other._isnan()\n  modulo_is_nan = modulo._isnan()\n  if self_is_nan or other_is_nan or modulo_is_nan:\n   if self_is_nan == 2:\n    return context._raise_error(InvalidOperation, 'sNaN',\n    self)\n   if other_is_nan == 2:\n    return context._raise_error(InvalidOperation, 'sNaN',\n    other)\n   if modulo_is_nan == 2:\n    return context._raise_error(InvalidOperation, 'sNaN',\n    modulo)\n   if self_is_nan:\n    return self._fix_nan(context)\n   if other_is_nan:\n    return other._fix_nan(context)\n   return modulo._fix_nan(context)\n   \n   \n  if not (self._isinteger() and\n  other._isinteger() and\n  modulo._isinteger()):\n   return context._raise_error(InvalidOperation,\n   'pow() 3rd argument not allowed '\n   'unless all arguments are integers')\n  if other < 0:\n   return context._raise_error(InvalidOperation,\n   'pow() 2nd argument cannot be '\n   'negative when 3rd argument specified')\n  if not modulo:\n   return context._raise_error(InvalidOperation,\n   'pow() 3rd argument cannot be 0')\n   \n   \n   \n  if modulo.adjusted() >= context.prec:\n   return context._raise_error(InvalidOperation,\n   'insufficient precision: pow() 3rd '\n   'argument must not have more than '\n   'precision digits')\n   \n   \n   \n  if not other and not self:\n   return context._raise_error(InvalidOperation,\n   'at least one of pow() 1st argument '\n   'and 2nd argument must be nonzero ;'\n   '0**0 is not defined')\n   \n   \n  if other._iseven():\n   sign = 0\n  else:\n   sign = self._sign\n   \n   \n   \n  modulo = abs(int(modulo))\n  base = _WorkRep(self.to_integral_value())\n  exponent = _WorkRep(other.to_integral_value())\n  \n  \n  base = (base.int % modulo * pow(10, base.exp, modulo)) % modulo\n  for i in range(exponent.exp):\n   base = pow(base, 10, modulo)\n  base = pow(base, exponent.int, modulo)\n  \n  return _dec_from_triple(sign, str(base), 0)\n  \n def _power_exact(self, other, p):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  x = _WorkRep(self)\n  xc, xe = x.int, x.exp\n  while xc % 10 == 0:\n   xc //= 10\n   xe += 1\n   \n  y = _WorkRep(other)\n  yc, ye = y.int, y.exp\n  while yc % 10 == 0:\n   yc //= 10\n   ye += 1\n   \n   \n   \n  if xc == 1:\n   xe *= yc\n   \n   while xe % 10 == 0:\n    xe //= 10\n    ye += 1\n   if ye < 0:\n    return None\n   exponent = xe * 10**ye\n   if y.sign == 1:\n    exponent = -exponent\n    \n   if other._isinteger() and other._sign == 0:\n    ideal_exponent = self._exp*int(other)\n    zeros = min(exponent-ideal_exponent, p-1)\n   else:\n    zeros = 0\n   return _dec_from_triple(0, '1' + '0'*zeros, exponent-zeros)\n   \n   \n   \n  if y.sign == 1:\n   last_digit = xc % 10\n   if last_digit in (2,4,6,8):\n   \n    if xc & -xc != xc:\n     return None\n     \n    e = _nbits(xc)-1\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    emax = p*93//65\n    if ye >= len(str(emax)):\n     return None\n     \n     \n    e = _decimal_lshift_exact(e * yc, ye)\n    xe = _decimal_lshift_exact(xe * yc, ye)\n    if e is None or xe is None:\n     return None\n     \n    if e > emax:\n     return None\n    xc = 5**e\n    \n   elif last_digit == 5:\n   \n   \n    e = _nbits(xc)*28//65\n    xc, remainder = divmod(5**e, xc)\n    if remainder:\n     return None\n    while xc % 5 == 0:\n     xc //= 5\n     e -= 1\n     \n     \n     \n     \n    emax = p*10//3\n    if ye >= len(str(emax)):\n     return None\n     \n    e = _decimal_lshift_exact(e * yc, ye)\n    xe = _decimal_lshift_exact(xe * yc, ye)\n    if e is None or xe is None:\n     return None\n     \n    if e > emax:\n     return None\n    xc = 2**e\n   else:\n    return None\n    \n   if xc >= 10**p:\n    return None\n   xe = -e-xe\n   return _dec_from_triple(0, str(xc), xe)\n   \n   \n  if ye >= 0:\n   m, n = yc*10**ye, 1\n  else:\n   if xe != 0 and len(str(abs(yc*xe))) <= -ye:\n    return None\n   xc_bits = _nbits(xc)\n   if xc != 1 and len(str(abs(yc)*xc_bits)) <= -ye:\n    return None\n   m, n = yc, 10**(-ye)\n   while m % 2 == n % 2 == 0:\n    m //= 2\n    n //= 2\n   while m % 5 == n % 5 == 0:\n    m //= 5\n    n //= 5\n    \n    \n  if n > 1:\n  \n   if xc != 1 and xc_bits <= n:\n    return None\n    \n   xe, rem = divmod(xe, n)\n   if rem != 0:\n    return None\n    \n    \n   a = 1 << -(-_nbits(xc)//n) \n   while True:\n    q, r = divmod(xc, a**(n-1))\n    if a <= q:\n     break\n    else:\n     a = (a*(n-1) + q)//n\n   if not (a == q and r == 0):\n    return None\n   xc = a\n   \n   \n   \n   \n   \n   \n  if xc > 1 and m > p*100//_log10_lb(xc):\n   return None\n  xc = xc**m\n  xe *= m\n  if xc > 10**p:\n   return None\n   \n   \n   \n   \n  str_xc = str(xc)\n  if other._isinteger() and other._sign == 0:\n   ideal_exponent = self._exp*int(other)\n   zeros = min(xe-ideal_exponent, p-len(str_xc))\n  else:\n   zeros = 0\n  return _dec_from_triple(0, str_xc+'0'*zeros, xe-zeros)\n  \n def __pow__(self, other, modulo=None, context=None):\n  \"\"\n  \n  if modulo is not None:\n   return self._power_modulo(other, modulo, context)\n   \n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n   \n  if context is None:\n   context = getcontext()\n   \n   \n  ans = self._check_nans(other, context)\n  if ans:\n   return ans\n   \n   \n  if not other:\n   if not self:\n    return context._raise_error(InvalidOperation, '0 ** 0')\n   else:\n    return _One\n    \n    \n  result_sign = 0\n  if self._sign == 1:\n   if other._isinteger():\n    if not other._iseven():\n     result_sign = 1\n   else:\n   \n   \n    if self:\n     return context._raise_error(InvalidOperation,\n     'x ** y with x negative and y not an integer')\n     \n   self = self.copy_negate()\n   \n   \n  if not self:\n   if other._sign == 0:\n    return _dec_from_triple(result_sign, '0', 0)\n   else:\n    return _SignedInfinity[result_sign]\n    \n    \n  if self._isinfinity():\n   if other._sign == 0:\n    return _SignedInfinity[result_sign]\n   else:\n    return _dec_from_triple(result_sign, '0', 0)\n    \n    \n    \n    \n  if self == _One:\n   if other._isinteger():\n   \n   \n   \n   \n    if other._sign == 1:\n     multiplier = 0\n    elif other > context.prec:\n     multiplier = context.prec\n    else:\n     multiplier = int(other)\n     \n    exp = self._exp * multiplier\n    if exp < 1-context.prec:\n     exp = 1-context.prec\n     context._raise_error(Rounded)\n   else:\n    context._raise_error(Inexact)\n    context._raise_error(Rounded)\n    exp = 1-context.prec\n    \n   return _dec_from_triple(result_sign, '1'+'0'*-exp, exp)\n   \n   \n  self_adj = self.adjusted()\n  \n  \n  \n  if other._isinfinity():\n   if (other._sign == 0) == (self_adj < 0):\n    return _dec_from_triple(result_sign, '0', 0)\n   else:\n    return _SignedInfinity[result_sign]\n    \n    \n    \n  ans = None\n  exact = False\n  \n  \n  \n  \n  \n  \n  bound = self._log10_exp_bound() + other.adjusted()\n  if (self_adj >= 0) == (other._sign == 0):\n  \n  \n   if bound >= len(str(context.Emax)):\n    ans = _dec_from_triple(result_sign, '1', context.Emax+1)\n  else:\n  \n  \n   Etiny = context.Etiny()\n   if bound >= len(str(-Etiny)):\n    ans = _dec_from_triple(result_sign, '1', Etiny-1)\n    \n    \n  if ans is None:\n   ans = self._power_exact(other, context.prec + 1)\n   if ans is not None:\n    if result_sign == 1:\n     ans = _dec_from_triple(1, ans._int, ans._exp)\n    exact = True\n    \n    \n  if ans is None:\n   p = context.prec\n   x = _WorkRep(self)\n   xc, xe = x.int, x.exp\n   y = _WorkRep(other)\n   yc, ye = y.int, y.exp\n   if y.sign == 1:\n    yc = -yc\n    \n    \n    \n   extra = 3\n   while True:\n    coeff, exp = _dpower(xc, xe, yc, ye, p+extra)\n    if coeff % (5*10**(len(str(coeff))-p-1)):\n     break\n    extra += 3\n    \n   ans = _dec_from_triple(result_sign, str(coeff), exp)\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  if exact and not other._isinteger():\n  \n  \n   if len(ans._int) <= context.prec:\n    expdiff = context.prec + 1 - len(ans._int)\n    ans = _dec_from_triple(ans._sign, ans._int+'0'*expdiff,\n    ans._exp-expdiff)\n    \n    \n   newcontext = context.copy()\n   newcontext.clear_flags()\n   for exception in _signals:\n    newcontext.traps[exception] = 0\n    \n    \n   ans = ans._fix(newcontext)\n   \n   \n   newcontext._raise_error(Inexact)\n   if newcontext.flags[Subnormal]:\n    newcontext._raise_error(Underflow)\n    \n    \n    \n    \n    \n    \n   if newcontext.flags[Overflow]:\n    context._raise_error(Overflow, 'above Emax', ans._sign)\n   for exception in Underflow, Subnormal, Inexact, Rounded, Clamped:\n    if newcontext.flags[exception]:\n     context._raise_error(exception)\n     \n  else:\n   ans = ans._fix(context)\n   \n  return ans\n  \n def __rpow__(self, other, context=None):\n  \"\"\n  other = _convert_other(other)\n  if other is NotImplemented:\n   return other\n  return other.__pow__(self, context=context)\n  \n def normalize(self, context=None):\n  \"\"\n  \n  if context is None:\n   context = getcontext()\n   \n  if self._is_special:\n   ans = self._check_nans(context=context)\n   if ans:\n    return ans\n    \n  dup = self._fix(context)\n  if dup._isinfinity():\n   return dup\n   \n  if not dup:\n   return _dec_from_triple(dup._sign, '0', 0)\n  exp_max = [context.Emax, context.Etop()][context.clamp]\n  end = len(dup._int)\n  exp = dup._exp\n  while dup._int[end-1] == '0' and exp < exp_max:\n   exp += 1\n   end -= 1\n  return _dec_from_triple(dup._sign, dup._int[:end], exp)\n  \n def quantize(self, exp, rounding=None, context=None, watchexp=True):\n  \"\"\n  exp = _convert_other(exp, raiseit=True)\n  \n  if context is None:\n   context = getcontext()\n  if rounding is None:\n   rounding = context.rounding\n   \n  if self._is_special or exp._is_special:\n   ans = self._check_nans(exp, context)\n   if ans:\n    return ans\n    \n   if exp._isinfinity() or self._isinfinity():\n    if exp._isinfinity() and self._isinfinity():\n     return Decimal(self) \n    return context._raise_error(InvalidOperation,\n    'quantize with one INF')\n    \n    \n  if not watchexp:\n   ans = self._rescale(exp._exp, rounding)\n   \n   if ans._exp > self._exp:\n    context._raise_error(Rounded)\n    if ans != self:\n     context._raise_error(Inexact)\n   return ans\n   \n   \n  if not (context.Etiny() <= exp._exp <= context.Emax):\n   return context._raise_error(InvalidOperation,\n   'target exponent out of bounds in quantize')\n   \n  if not self:\n   ans = _dec_from_triple(self._sign, '0', exp._exp)\n   return ans._fix(context)\n   \n  self_adjusted = self.adjusted()\n  if self_adjusted > context.Emax:\n   return context._raise_error(InvalidOperation,\n   'exponent of quantize result too large for current context')\n  if self_adjusted - exp._exp + 1 > context.prec:\n   return context._raise_error(InvalidOperation,\n   'quantize result has too many digits for current context')\n   \n  ans = self._rescale(exp._exp, rounding)\n  if ans.adjusted() > context.Emax:\n   return context._raise_error(InvalidOperation,\n   'exponent of quantize result too large for current context')\n  if len(ans._int) > context.prec:\n   return context._raise_error(InvalidOperation,\n   'quantize result has too many digits for current context')\n   \n   \n  if ans and ans.adjusted() < context.Emin:\n   context._raise_error(Subnormal)\n  if ans._exp > self._exp:\n   if ans != self:\n    context._raise_error(Inexact)\n   context._raise_error(Rounded)\n   \n   \n   \n  ans = ans._fix(context)\n  return ans\n  \n def same_quantum(self, other, context=None):\n  \"\"\n  other = _convert_other(other, raiseit=True)\n  if self._is_special or other._is_special:\n   return (self.is_nan() and other.is_nan() or\n   self.is_infinite() and other.is_infinite())\n  return self._exp == other._exp\n  \n def _rescale(self, exp, rounding):\n  \"\"\n  if self._is_special:\n   return Decimal(self)\n  if not self:\n   return _dec_from_triple(self._sign, '0', exp)\n   \n  if self._exp >= exp:\n  \n   return _dec_from_triple(self._sign,\n   self._int + '0'*(self._exp - exp), exp)\n   \n   \n   \n  digits = len(self._int) + self._exp - exp\n  if digits < 0:\n   self = _dec_from_triple(self._sign, '1', exp-1)\n   digits = 0\n  this_function = self._pick_rounding_function[rounding]\n  changed = this_function(self, digits)\n  coeff = self._int[:digits] or '0'\n  if changed == 1:\n   coeff = str(int(coeff)+1)\n  return _dec_from_triple(self._sign, coeff, exp)\n  \n def _round(self, places, rounding):\n  \"\"\n  if places <= 0:\n   raise ValueError(\"argument should be at least 1 in _round\")\n  if self._is_special or not self:\n   return Decimal(self)\n  ans = self._rescale(self.adjusted()+1-places, rounding)\n  \n  \n  \n  \n  if ans.adjusted() != self.adjusted():\n   ans = ans._rescale(ans.adjusted()+1-places, rounding)\n  return ans\n  \n def to_integral_exact(self, rounding=None, context=None):\n  \"\"\n  if self._is_special:\n   ans = self._check_nans(context=context)\n   if ans:\n    return ans\n   return Decimal(self)\n  if self._exp >= 0:\n   return Decimal(self)\n  if not self:\n   return _dec_from_triple(self._sign, '0', 0)\n  if context is None:\n   context = getcontext()\n  if rounding is None:\n   rounding = context.rounding\n  ans = self._rescale(0, rounding)\n  if ans != self:\n   context._raise_error(Inexact)\n  context._raise_error(Rounded)\n  return ans\n  \n def to_integral_value(self, rounding=None, context=None):\n  \"\"\n  if context is None:\n   context = getcontext()\n  if rounding is None:\n   rounding = context.rounding\n  if self._is_special:\n   ans = self._check_nans(context=context)\n   if ans:\n    return ans\n   return Decimal(self)\n  if self._exp >= 0:\n   return Decimal(self)\n  else:\n   return self._rescale(0, rounding)\n   \n   \n to_integral = to_integral_value\n \n def sqrt(self, context=None):\n  \"\"\n  if context is None:\n   context = getcontext()\n   \n  if self._is_special:\n   ans = self._check_nans(context=context)\n   if ans:\n    return ans\n    \n   if self._isinfinity() and self._sign == 0:\n    return Decimal(self)\n    \n  if not self:\n  \n   ans = _dec_from_triple(self._sign, '0', self._exp // 2)\n   return ans._fix(context)\n   \n  if self._sign == 1:\n   return context._raise_error(InvalidOperation, 'sqrt(-x), x > 0')\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  prec = context.prec+1\n  \n  \n  \n  \n  \n  op = _WorkRep(self)\n  e = op.exp >> 1\n  if op.exp & 1:\n   c = op.int * 10\n   l = (len(self._int) >> 1) + 1\n  else:\n   c = op.int\n   l = len(self._int)+1 >> 1\n   \n   \n  shift = prec-l\n  if shift >= 0:\n   c *= 100**shift\n   exact = True\n  else:\n   c, remainder = divmod(c, 100**-shift)\n   exact = not remainder\n  e -= shift\n  \n  \n  n = 10**prec\n  while True:\n   q = c//n\n   if n <= q:\n    break\n   else:\n    n = n + q >> 1\n  exact = exact and n*n == c\n  \n  if exact:\n  \n   if shift >= 0:\n   \n    n //= 10**shift\n   else:\n    n *= 10**-shift\n   e += shift\n  else:\n  \n   if n % 5 == 0:\n    n += 1\n    \n  ans = _dec_from_triple(0, str(n), e)\n  \n  \n  context = context._shallow_copy()\n  rounding = context._set_rounding(ROUND_HALF_EVEN)\n  ans = ans._fix(context)\n  context.rounding = rounding\n  \n  return ans\n  \n def max(self, other, context=None):\n  \"\"\n  other = _convert_other(other, raiseit=True)\n  \n  if context is None:\n   context = getcontext()\n   \n  if self._is_special or other._is_special:\n  \n  \n   sn = self._isnan()\n   on = other._isnan()\n   if sn or on:\n    if on == 1 and sn == 0:\n     return self._fix(context)\n    if sn == 1 and on == 0:\n     return other._fix(context)\n    return self._check_nans(other, context)\n    \n  c = self._cmp(other)\n  if c == 0:\n  \n  \n  \n  \n  \n  \n  \n  \n   c = self.compare_total(other)\n   \n  if c == -1:\n   ans = other\n  else:\n   ans = self\n   \n  return ans._fix(context)\n  \n def min(self, other, context=None):\n  \"\"\n  other = _convert_other(other, raiseit=True)\n  \n  if context is None:\n   context = getcontext()\n   \n  if self._is_special or other._is_special:\n  \n  \n   sn = self._isnan()\n   on = other._isnan()\n   if sn or on:\n    if on == 1 and sn == 0:\n     return self._fix(context)\n    if sn == 1 and on == 0:\n     return other._fix(context)\n    return self._check_nans(other, context)\n    \n  c = self._cmp(other)\n  if c == 0:\n   c = self.compare_total(other)\n   \n  if c == -1:\n   ans = self\n  else:\n   ans = other\n   \n  return ans._fix(context)\n  \n def _isinteger(self):\n  \"\"\n  if self._is_special:\n   return False\n  if self._exp >= 0:\n   return True\n  rest = self._int[self._exp:]\n  return rest == '0'*len(rest)\n  \n def _iseven(self):\n  \"\"\n  if not self or self._exp > 0:\n   return True\n  return self._int[-1+self._exp] in '02468'\n  \n def adjusted(self):\n  \"\"\n  try:\n   return self._exp + len(self._int) - 1\n   \n  except TypeError:\n   return 0\n   \n def canonical(self):\n  \"\"\n  return self\n  \n def compare_signal(self, other, context=None):\n  \"\"\n  other = _convert_other(other, raiseit = True)\n  ans = self._compare_check_nans(other, context)\n  if ans:\n   return ans\n  return self.compare(other, context=context)\n  \n def compare_total(self, other, context=None):\n  \"\"\n  other = _convert_other(other, raiseit=True)\n  \n  \n  if self._sign and not other._sign:\n   return _NegativeOne\n  if not self._sign and other._sign:\n   return _One\n  sign = self._sign\n  \n  \n  self_nan = self._isnan()\n  other_nan = other._isnan()\n  if self_nan or other_nan:\n   if self_nan == other_nan:\n   \n    self_key = len(self._int), self._int\n    other_key = len(other._int), other._int\n    if self_key < other_key:\n     if sign:\n      return _One\n     else:\n      return _NegativeOne\n    if self_key > other_key:\n     if sign:\n      return _NegativeOne\n     else:\n      return _One\n    return _Zero\n    \n   if sign:\n    if self_nan == 1:\n     return _NegativeOne\n    if other_nan == 1:\n     return _One\n    if self_nan == 2:\n     return _NegativeOne\n    if other_nan == 2:\n     return _One\n   else:\n    if self_nan == 1:\n     return _One\n    if other_nan == 1:\n     return _NegativeOne\n    if self_nan == 2:\n     return _One\n    if other_nan == 2:\n     return _NegativeOne\n     \n  if self < other:\n   return _NegativeOne\n  if self > other:\n   return _One\n   \n  if self._exp < other._exp:\n   if sign:\n    return _One\n   else:\n    return _NegativeOne\n  if self._exp > other._exp:\n   if sign:\n    return _NegativeOne\n   else:\n    return _One\n  return _Zero\n  \n  \n def compare_total_mag(self, other, context=None):\n  \"\"\n  other = _convert_other(other, raiseit=True)\n  \n  s = self.copy_abs()\n  o = other.copy_abs()\n  return s.compare_total(o)\n  \n def copy_abs(self):\n  \"\"\n  return _dec_from_triple(0, self._int, self._exp, self._is_special)\n  \n def copy_negate(self):\n  \"\"\n  if self._sign:\n   return _dec_from_triple(0, self._int, self._exp, self._is_special)\n  else:\n   return _dec_from_triple(1, self._int, self._exp, self._is_special)\n   \n def copy_sign(self, other, context=None):\n  \"\"\n  other = _convert_other(other, raiseit=True)\n  return _dec_from_triple(other._sign, self._int,\n  self._exp, self._is_special)\n  \n def exp(self, context=None):\n  \"\"\n  \n  if context is None:\n   context = getcontext()\n   \n   \n  ans = self._check_nans(context=context)\n  if ans:\n   return ans\n   \n   \n  if self._isinfinity() == -1:\n   return _Zero\n   \n   \n  if not self:\n   return _One\n   \n   \n  if self._isinfinity() == 1:\n   return Decimal(self)\n   \n   \n   \n   \n   \n  p = context.prec\n  adj = self.adjusted()\n  \n  \n  \n  \n  \n  \n  if self._sign == 0 and adj > len(str((context.Emax+1)*3)):\n  \n   ans = _dec_from_triple(0, '1', context.Emax+1)\n  elif self._sign == 1 and adj > len(str((-context.Etiny()+1)*3)):\n  \n   ans = _dec_from_triple(0, '1', context.Etiny()-1)\n  elif self._sign == 0 and adj < -p:\n  \n   ans = _dec_from_triple(0, '1' + '0'*(p-1) + '1', -p)\n  elif self._sign == 1 and adj < -p-1:\n  \n   ans = _dec_from_triple(0, '9'*(p+1), -p-1)\n   \n  else:\n   op = _WorkRep(self)\n   c, e = op.int, op.exp\n   if op.sign == 1:\n    c = -c\n    \n    \n    \n    \n   extra = 3\n   while True:\n    coeff, exp = _dexp(c, e, p+extra)\n    if coeff % (5*10**(len(str(coeff))-p-1)):\n     break\n    extra += 3\n    \n   ans = _dec_from_triple(0, str(coeff), exp)\n   \n   \n   \n  context = context._shallow_copy()\n  rounding = context._set_rounding(ROUND_HALF_EVEN)\n  ans = ans._fix(context)\n  context.rounding = rounding\n  \n  return ans\n  \n def is_canonical(self):\n  \"\"\n  return True\n  \n def is_finite(self):\n  \"\"\n  return not self._is_special\n  \n def is_infinite(self):\n  \"\"\n  return self._exp == 'F'\n  \n def is_nan(self):\n  \"\"\n  return self._exp in ('n', 'N')\n  \n def is_normal(self, context=None):\n  \"\"\n  if self._is_special or not self:\n   return False\n  if context is None:\n   context = getcontext()\n  return context.Emin <= self.adjusted()\n  \n def is_qnan(self):\n  \"\"\n  return self._exp == 'n'\n  \n def is_signed(self):\n  \"\"\n  return self._sign == 1\n  \n def is_snan(self):\n  \"\"\n  return self._exp == 'N'\n  \n def is_subnormal(self, context=None):\n  \"\"\n  if self._is_special or not self:\n   return False\n  if context is None:\n   context = getcontext()\n  return self.adjusted() < context.Emin\n  \n def is_zero(self):\n  \"\"\n  return not self._is_special and self._int == '0'\n  \n def _ln_exp_bound(self):\n  \"\"\n  \n  \n  adj = self._exp + len(self._int) - 1\n  if adj >= 1:\n  \n   return len(str(adj*23//10)) - 1\n  if adj <= -2:\n  \n   return len(str((-1-adj)*23//10)) - 1\n  op = _WorkRep(self)\n  c, e = op.int, op.exp\n  if adj == 0:\n  \n   num = str(c-10**-e)\n   den = str(c)\n   return len(num) - len(den) - (num < den)\n   \n  return e + len(str(10**-e - c)) - 1\n  \n  \n def ln(self, context=None):\n  \"\"\n  \n  if context is None:\n   context = getcontext()\n   \n   \n  ans = self._check_nans(context=context)\n  if ans:\n   return ans\n   \n   \n  if not self:\n   return _NegativeInfinity\n   \n   \n  if self._isinfinity() == 1:\n   return _Infinity\n   \n   \n  if self == _One:\n   return _Zero\n   \n   \n  if self._sign == 1:\n   return context._raise_error(InvalidOperation,\n   'ln of a negative value')\n   \n   \n  op = _WorkRep(self)\n  c, e = op.int, op.exp\n  p = context.prec\n  \n  \n  \n  places = p - self._ln_exp_bound() + 2 \n  while True:\n   coeff = _dlog(c, e, places)\n   \n   if coeff % (5*10**(len(str(abs(coeff)))-p-1)):\n    break\n   places += 3\n  ans = _dec_from_triple(int(coeff<0), str(abs(coeff)), -places)\n  \n  context = context._shallow_copy()\n  rounding = context._set_rounding(ROUND_HALF_EVEN)\n  ans = ans._fix(context)\n  context.rounding = rounding\n  return ans\n  \n def _log10_exp_bound(self):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  adj = self._exp + len(self._int) - 1\n  if adj >= 1:\n  \n   return len(str(adj))-1\n  if adj <= -2:\n  \n   return len(str(-1-adj))-1\n  op = _WorkRep(self)\n  c, e = op.int, op.exp\n  if adj == 0:\n  \n   num = str(c-10**-e)\n   den = str(231*c)\n   return len(num) - len(den) - (num < den) + 2\n   \n  num = str(10**-e-c)\n  return len(num) + e - (num < \"231\") - 1\n  \n def log10(self, context=None):\n  \"\"\n  \n  if context is None:\n   context = getcontext()\n   \n   \n  ans = self._check_nans(context=context)\n  if ans:\n   return ans\n   \n   \n  if not self:\n   return _NegativeInfinity\n   \n   \n  if self._isinfinity() == 1:\n   return _Infinity\n   \n   \n  if self._sign == 1:\n   return context._raise_error(InvalidOperation,\n   'log10 of a negative value')\n   \n   \n  if self._int[0] == '1' and self._int[1:] == '0'*(len(self._int) - 1):\n  \n   ans = Decimal(self._exp + len(self._int) - 1)\n  else:\n  \n   op = _WorkRep(self)\n   c, e = op.int, op.exp\n   p = context.prec\n   \n   \n   \n   places = p-self._log10_exp_bound()+2\n   while True:\n    coeff = _dlog10(c, e, places)\n    \n    if coeff % (5*10**(len(str(abs(coeff)))-p-1)):\n     break\n    places += 3\n   ans = _dec_from_triple(int(coeff<0), str(abs(coeff)), -places)\n   \n  context = context._shallow_copy()\n  rounding = context._set_rounding(ROUND_HALF_EVEN)\n  ans = ans._fix(context)\n  context.rounding = rounding\n  return ans\n  \n def logb(self, context=None):\n  \"\"\n  \n  ans = self._check_nans(context=context)\n  if ans:\n   return ans\n   \n  if context is None:\n   context = getcontext()\n   \n   \n  if self._isinfinity():\n   return _Infinity\n   \n   \n  if not self:\n   return context._raise_error(DivisionByZero, 'logb(0)', 1)\n   \n   \n   \n   \n  ans = Decimal(self.adjusted())\n  return ans._fix(context)\n  \n def _islogical(self):\n  \"\"\n  if self._sign != 0 or self._exp != 0:\n   return False\n  for dig in self._int:\n   if dig not in '01':\n    return False\n  return True\n  \n def _fill_logical(self, context, opa, opb):\n  dif = context.prec - len(opa)\n  if dif > 0:\n   opa = '0'*dif + opa\n  elif dif < 0:\n   opa = opa[-context.prec:]\n  dif = context.prec - len(opb)\n  if dif > 0:\n   opb = '0'*dif + opb\n  elif dif < 0:\n   opb = opb[-context.prec:]\n  return opa, opb\n  \n def logical_and(self, other, context=None):\n  \"\"\n  if context is None:\n   context = getcontext()\n   \n  other = _convert_other(other, raiseit=True)\n  \n  if not self._islogical() or not other._islogical():\n   return context._raise_error(InvalidOperation)\n   \n   \n  (opa, opb) = self._fill_logical(context, self._int, other._int)\n  \n  \n  result = \"\".join([str(int(a)&int(b)) for a,b in zip(opa,opb)])\n  return _dec_from_triple(0, result.lstrip('0') or '0', 0)\n  \n def logical_invert(self, context=None):\n  \"\"\n  if context is None:\n   context = getcontext()\n  return self.logical_xor(_dec_from_triple(0,'1'*context.prec,0),\n  context)\n  \n def logical_or(self, other, context=None):\n  \"\"\n  if context is None:\n   context = getcontext()\n   \n  other = _convert_other(other, raiseit=True)\n  \n  if not self._islogical() or not other._islogical():\n   return context._raise_error(InvalidOperation)\n   \n   \n  (opa, opb) = self._fill_logical(context, self._int, other._int)\n  \n  \n  result = \"\".join([str(int(a)|int(b)) for a,b in zip(opa,opb)])\n  return _dec_from_triple(0, result.lstrip('0') or '0', 0)\n  \n def logical_xor(self, other, context=None):\n  \"\"\n  if context is None:\n   context = getcontext()\n   \n  other = _convert_other(other, raiseit=True)\n  \n  if not self._islogical() or not other._islogical():\n   return context._raise_error(InvalidOperation)\n   \n   \n  (opa, opb) = self._fill_logical(context, self._int, other._int)\n  \n  \n  result = \"\".join([str(int(a)^int(b)) for a,b in zip(opa,opb)])\n  return _dec_from_triple(0, result.lstrip('0') or '0', 0)\n  \n def max_mag(self, other, context=None):\n  \"\"\n  other = _convert_other(other, raiseit=True)\n  \n  if context is None:\n   context = getcontext()\n   \n  if self._is_special or other._is_special:\n  \n  \n   sn = self._isnan()\n   on = other._isnan()\n   if sn or on:\n    if on == 1 and sn == 0:\n     return self._fix(context)\n    if sn == 1 and on == 0:\n     return other._fix(context)\n    return self._check_nans(other, context)\n    \n  c = self.copy_abs()._cmp(other.copy_abs())\n  if c == 0:\n   c = self.compare_total(other)\n   \n  if c == -1:\n   ans = other\n  else:\n   ans = self\n   \n  return ans._fix(context)\n  \n def min_mag(self, other, context=None):\n  \"\"\n  other = _convert_other(other, raiseit=True)\n  \n  if context is None:\n   context = getcontext()\n   \n  if self._is_special or other._is_special:\n  \n  \n   sn = self._isnan()\n   on = other._isnan()\n   if sn or on:\n    if on == 1 and sn == 0:\n     return self._fix(context)\n    if sn == 1 and on == 0:\n     return other._fix(context)\n    return self._check_nans(other, context)\n    \n  c = self.copy_abs()._cmp(other.copy_abs())\n  if c == 0:\n   c = self.compare_total(other)\n   \n  if c == -1:\n   ans = self\n  else:\n   ans = other\n   \n  return ans._fix(context)\n  \n def next_minus(self, context=None):\n  \"\"\n  if context is None:\n   context = getcontext()\n   \n  ans = self._check_nans(context=context)\n  if ans:\n   return ans\n   \n  if self._isinfinity() == -1:\n   return _NegativeInfinity\n  if self._isinfinity() == 1:\n   return _dec_from_triple(0, '9'*context.prec, context.Etop())\n   \n  context = context.copy()\n  context._set_rounding(ROUND_FLOOR)\n  context._ignore_all_flags()\n  new_self = self._fix(context)\n  if new_self != self:\n   return new_self\n  return self.__sub__(_dec_from_triple(0, '1', context.Etiny()-1),\n  context)\n  \n def next_plus(self, context=None):\n  \"\"\n  if context is None:\n   context = getcontext()\n   \n  ans = self._check_nans(context=context)\n  if ans:\n   return ans\n   \n  if self._isinfinity() == 1:\n   return _Infinity\n  if self._isinfinity() == -1:\n   return _dec_from_triple(1, '9'*context.prec, context.Etop())\n   \n  context = context.copy()\n  context._set_rounding(ROUND_CEILING)\n  context._ignore_all_flags()\n  new_self = self._fix(context)\n  if new_self != self:\n   return new_self\n  return self.__add__(_dec_from_triple(0, '1', context.Etiny()-1),\n  context)\n  \n def next_toward(self, other, context=None):\n  \"\"\n  other = _convert_other(other, raiseit=True)\n  \n  if context is None:\n   context = getcontext()\n   \n  ans = self._check_nans(other, context)\n  if ans:\n   return ans\n   \n  comparison = self._cmp(other)\n  if comparison == 0:\n   return self.copy_sign(other)\n   \n  if comparison == -1:\n   ans = self.next_plus(context)\n  else: \n   ans = self.next_minus(context)\n   \n   \n  if ans._isinfinity():\n   context._raise_error(Overflow,\n   'Infinite result from next_toward',\n   ans._sign)\n   context._raise_error(Inexact)\n   context._raise_error(Rounded)\n  elif ans.adjusted() < context.Emin:\n   context._raise_error(Underflow)\n   context._raise_error(Subnormal)\n   context._raise_error(Inexact)\n   context._raise_error(Rounded)\n   \n   \n   if not ans:\n    context._raise_error(Clamped)\n    \n  return ans\n  \n def number_class(self, context=None):\n  \"\"\n  if self.is_snan():\n   return \"sNaN\"\n  if self.is_qnan():\n   return \"NaN\"\n  inf = self._isinfinity()\n  if inf == 1:\n   return \"+Infinity\"\n  if inf == -1:\n   return \"-Infinity\"\n  if self.is_zero():\n   if self._sign:\n    return \"-Zero\"\n   else:\n    return \"+Zero\"\n  if context is None:\n   context = getcontext()\n  if self.is_subnormal(context=context):\n   if self._sign:\n    return \"-Subnormal\"\n   else:\n    return \"+Subnormal\"\n    \n  if self._sign:\n   return \"-Normal\"\n  else:\n   return \"+Normal\"\n   \n def radix(self):\n  \"\"\n  return Decimal(10)\n  \n def rotate(self, other, context=None):\n  \"\"\n  if context is None:\n   context = getcontext()\n   \n  other = _convert_other(other, raiseit=True)\n  \n  ans = self._check_nans(other, context)\n  if ans:\n   return ans\n   \n  if other._exp != 0:\n   return context._raise_error(InvalidOperation)\n  if not (-context.prec <= int(other) <= context.prec):\n   return context._raise_error(InvalidOperation)\n   \n  if self._isinfinity():\n   return Decimal(self)\n   \n   \n  torot = int(other)\n  rotdig = self._int\n  topad = context.prec - len(rotdig)\n  if topad > 0:\n   rotdig = '0'*topad + rotdig\n  elif topad < 0:\n   rotdig = rotdig[-topad:]\n   \n   \n  rotated = rotdig[torot:] + rotdig[:torot]\n  return _dec_from_triple(self._sign,\n  rotated.lstrip('0') or '0', self._exp)\n  \n def scaleb(self, other, context=None):\n  \"\"\n  if context is None:\n   context = getcontext()\n   \n  other = _convert_other(other, raiseit=True)\n  \n  ans = self._check_nans(other, context)\n  if ans:\n   return ans\n   \n  if other._exp != 0:\n   return context._raise_error(InvalidOperation)\n  liminf = -2 * (context.Emax + context.prec)\n  limsup = 2 * (context.Emax + context.prec)\n  if not (liminf <= int(other) <= limsup):\n   return context._raise_error(InvalidOperation)\n   \n  if self._isinfinity():\n   return Decimal(self)\n   \n  d = _dec_from_triple(self._sign, self._int, self._exp + int(other))\n  d = d._fix(context)\n  return d\n  \n def shift(self, other, context=None):\n  \"\"\n  if context is None:\n   context = getcontext()\n   \n  other = _convert_other(other, raiseit=True)\n  \n  ans = self._check_nans(other, context)\n  if ans:\n   return ans\n   \n  if other._exp != 0:\n   return context._raise_error(InvalidOperation)\n  if not (-context.prec <= int(other) <= context.prec):\n   return context._raise_error(InvalidOperation)\n   \n  if self._isinfinity():\n   return Decimal(self)\n   \n   \n  torot = int(other)\n  rotdig = self._int\n  topad = context.prec - len(rotdig)\n  if topad > 0:\n   rotdig = '0'*topad + rotdig\n  elif topad < 0:\n   rotdig = rotdig[-topad:]\n   \n   \n  if torot < 0:\n   shifted = rotdig[:torot]\n  else:\n   shifted = rotdig + '0'*torot\n   shifted = shifted[-context.prec:]\n   \n  return _dec_from_triple(self._sign,\n  shifted.lstrip('0') or '0', self._exp)\n  \n  \n def __reduce__(self):\n  return (self.__class__, (str(self),))\n  \n def __copy__(self):\n  if type(self) is Decimal:\n   return self \n  return self.__class__(str(self))\n  \n def __deepcopy__(self, memo):\n  if type(self) is Decimal:\n   return self \n  return self.__class__(str(self))\n  \n  \n  \n def __format__(self, specifier, context=None, _localeconv=None):\n  \"\"\n  \n  \n  \n  \n  \n  \n  if context is None:\n   context = getcontext()\n   \n  spec = _parse_format_specifier(specifier, _localeconv=_localeconv)\n  \n  \n  if self._is_special:\n   sign = _format_sign(self._sign, spec)\n   body = str(self.copy_abs())\n   return _format_align(sign, body, spec)\n   \n   \n  if spec['type'] is None:\n   spec['type'] = ['g', 'G'][context.capitals]\n   \n   \n  if spec['type'] == '%':\n   self = _dec_from_triple(self._sign, self._int, self._exp+2)\n   \n   \n  rounding = context.rounding\n  precision = spec['precision']\n  if precision is not None:\n   if spec['type'] in 'eE':\n    self = self._round(precision+1, rounding)\n   elif spec['type'] in 'fF%':\n    self = self._rescale(-precision, rounding)\n   elif spec['type'] in 'gG' and len(self._int) > precision:\n    self = self._round(precision, rounding)\n    \n    \n  if not self and self._exp > 0 and spec['type'] in 'fF%':\n   self = self._rescale(0, rounding)\n   \n   \n  leftdigits = self._exp + len(self._int)\n  if spec['type'] in 'eE':\n   if not self and precision is not None:\n    dotplace = 1 - precision\n   else:\n    dotplace = 1\n  elif spec['type'] in 'fF%':\n   dotplace = leftdigits\n  elif spec['type'] in 'gG':\n   if self._exp <= 0 and leftdigits > -6:\n    dotplace = leftdigits\n   else:\n    dotplace = 1\n    \n    \n  if dotplace < 0:\n   intpart = '0'\n   fracpart = '0'*(-dotplace) + self._int\n  elif dotplace > len(self._int):\n   intpart = self._int + '0'*(dotplace-len(self._int))\n   fracpart = ''\n  else:\n   intpart = self._int[:dotplace] or '0'\n   fracpart = self._int[dotplace:]\n  exp = leftdigits-dotplace\n  \n  \n  \n  return _format_number(self._sign, intpart, fracpart, exp, spec)\n  \ndef _dec_from_triple(sign, coefficient, exponent, special=False):\n \"\"\n \n self = object.__new__(Decimal)\n self._sign = sign\n self._int = coefficient\n self._exp = exponent\n self._is_special = special\n \n return self\n \n \n \n \n_numbers.Number.register(Decimal)\n\n\n\n\nclass _ContextManager(object):\n \"\"\n def __init__(self, new_context):\n  self.new_context = new_context.copy()\n def __enter__(self):\n  self.saved_context = getcontext()\n  setcontext(self.new_context)\n  return self.new_context\n def __exit__(self, t, v, tb):\n  setcontext(self.saved_context)\n  \nclass Context(object):\n \"\"\n \n def __init__(self, prec=None, rounding=None, Emin=None, Emax=None,\n capitals=None, clamp=None, flags=None, traps=None,\n _ignored_flags=None):\n \n \n  try:\n   dc = DefaultContext\n  except NameError:\n   pass\n   \n  self.prec = prec if prec is not None else dc.prec\n  self.rounding = rounding if rounding is not None else dc.rounding\n  self.Emin = Emin if Emin is not None else dc.Emin\n  self.Emax = Emax if Emax is not None else dc.Emax\n  self.capitals = capitals if capitals is not None else dc.capitals\n  self.clamp = clamp if clamp is not None else dc.clamp\n  \n  if _ignored_flags is None:\n   self._ignored_flags = []\n  else:\n   self._ignored_flags = _ignored_flags\n   \n  if traps is None:\n   self.traps = dc.traps.copy()\n  elif not isinstance(traps, dict):\n   self.traps = dict((s, int(s in traps)) for s in _signals + traps)\n  else:\n   self.traps = traps\n   \n  if flags is None:\n   self.flags = dict.fromkeys(_signals, 0)\n  elif not isinstance(flags, dict):\n   self.flags = dict((s, int(s in flags)) for s in _signals + flags)\n  else:\n   self.flags = flags\n   \n def _set_integer_check(self, name, value, vmin, vmax):\n  if not isinstance(value, int):\n   raise TypeError(\"%s must be an integer\" % name)\n  if vmin == '-inf':\n   if value > vmax:\n    raise ValueError(\"%s must be in [%s, %d]. got: %s\" % (name, vmin, vmax, value))\n  elif vmax == 'inf':\n   if value < vmin:\n    raise ValueError(\"%s must be in [%d, %s]. got: %s\" % (name, vmin, vmax, value))\n  else:\n   if value < vmin or value > vmax:\n    raise ValueError(\"%s must be in [%d, %d]. got %s\" % (name, vmin, vmax, value))\n  return object.__setattr__(self, name, value)\n  \n def _set_signal_dict(self, name, d):\n  if not isinstance(d, dict):\n   raise TypeError(\"%s must be a signal dict\" % d)\n  for key in d:\n   if not key in _signals:\n    raise KeyError(\"%s is not a valid signal dict\" % d)\n  for key in _signals:\n   if not key in d:\n    raise KeyError(\"%s is not a valid signal dict\" % d)\n  return object.__setattr__(self, name, d)\n  \n def __setattr__(self, name, value):\n  if name == 'prec':\n   return self._set_integer_check(name, value, 1, 'inf')\n  elif name == 'Emin':\n   return self._set_integer_check(name, value, '-inf', 0)\n  elif name == 'Emax':\n   return self._set_integer_check(name, value, 0, 'inf')\n  elif name == 'capitals':\n   return self._set_integer_check(name, value, 0, 1)\n  elif name == 'clamp':\n   return self._set_integer_check(name, value, 0, 1)\n  elif name == 'rounding':\n   if not value in _rounding_modes:\n   \n   \n    raise TypeError(\"%s: invalid rounding mode\" % value)\n   return object.__setattr__(self, name, value)\n  elif name == 'flags' or name == 'traps':\n   return self._set_signal_dict(name, value)\n  elif name == '_ignored_flags':\n   return object.__setattr__(self, name, value)\n  else:\n   raise AttributeError(\n   \"'decimal.Context' object has no attribute '%s'\" % name)\n   \n def __delattr__(self, name):\n  raise AttributeError(\"%s cannot be deleted\" % name)\n  \n  \n def __reduce__(self):\n  flags = [sig for sig, v in self.flags.items() if v]\n  traps = [sig for sig, v in self.traps.items() if v]\n  return (self.__class__,\n  (self.prec, self.rounding, self.Emin, self.Emax,\n  self.capitals, self.clamp, flags, traps))\n  \n def __repr__(self):\n  \"\"\n  s = []\n  s.append('Context(prec=%(prec)d, rounding=%(rounding)s, '\n  'Emin=%(Emin)d, Emax=%(Emax)d, capitals=%(capitals)d, '\n  'clamp=%(clamp)d'\n  % vars(self))\n  names = [f.__name__ for f, v in self.flags.items() if v]\n  s.append('flags=[' + ', '.join(names) + ']')\n  names = [t.__name__ for t, v in self.traps.items() if v]\n  s.append('traps=[' + ', '.join(names) + ']')\n  return ', '.join(s) + ')'\n  \n def clear_flags(self):\n  \"\"\n  for flag in self.flags:\n   self.flags[flag] = 0\n   \n def clear_traps(self):\n  \"\"\n  for flag in self.traps:\n   self.traps[flag] = 0\n   \n def _shallow_copy(self):\n  \"\"\n  nc = Context(self.prec, self.rounding, self.Emin, self.Emax,\n  self.capitals, self.clamp, self.flags, self.traps,\n  self._ignored_flags)\n  return nc\n  \n def copy(self):\n  \"\"\n  nc = Context(self.prec, self.rounding, self.Emin, self.Emax,\n  self.capitals, self.clamp,\n  self.flags.copy(), self.traps.copy(),\n  self._ignored_flags)\n  return nc\n __copy__ = copy\n \n def _raise_error(self, condition, explanation = None, *args):\n  \"\"\n  error = _condition_map.get(condition, condition)\n  if error in self._ignored_flags:\n  \n   return error().handle(self, *args)\n   \n  self.flags[error] = 1\n  if not self.traps[error]:\n  \n   return condition().handle(self, *args)\n   \n   \n   \n  raise error(explanation)\n  \n def _ignore_all_flags(self):\n  \"\"\n  return self._ignore_flags(*_signals)\n  \n def _ignore_flags(self, *flags):\n  \"\"\n  \n  \n  self._ignored_flags = (self._ignored_flags + list(flags))\n  return list(flags)\n  \n def _regard_flags(self, *flags):\n  \"\"\n  if flags and isinstance(flags[0], (tuple,list)):\n   flags = flags[0]\n  for flag in flags:\n   self._ignored_flags.remove(flag)\n   \n   \n __hash__ = None\n \n def Etiny(self):\n  \"\"\n  return int(self.Emin - self.prec + 1)\n  \n def Etop(self):\n  \"\"\n  return int(self.Emax - self.prec + 1)\n  \n def _set_rounding(self, type):\n  \"\"\n  rounding = self.rounding\n  self.rounding= type\n  return rounding\n  \n def create_decimal(self, num='0'):\n  \"\"\n  \n  if isinstance(num, str) and num != num.strip():\n   return self._raise_error(ConversionSyntax,\n   \"no trailing or leading whitespace is \"\n   \"permitted.\")\n   \n  d = Decimal(num, context=self)\n  if d._isnan() and len(d._int) > self.prec - self.clamp:\n   return self._raise_error(ConversionSyntax,\n   \"diagnostic info too long in NaN\")\n  return d._fix(self)\n  \n def create_decimal_from_float(self, f):\n  \"\"\n  d = Decimal.from_float(f) \n  return d._fix(self) \n  \n  \n def abs(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.__abs__(context=self)\n  \n def add(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  r = a.__add__(b, context=self)\n  if r is NotImplemented:\n   raise TypeError(\"Unable to convert %s to Decimal\" % b)\n  else:\n   return r\n   \n def _apply(self, a):\n  return str(a._fix(self))\n  \n def canonical(self, a):\n  \"\"\n  if not isinstance(a, Decimal):\n   raise TypeError(\"canonical requires a Decimal as an argument.\")\n  return a.canonical()\n  \n def compare(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.compare(b, context=self)\n  \n def compare_signal(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.compare_signal(b, context=self)\n  \n def compare_total(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.compare_total(b)\n  \n def compare_total_mag(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.compare_total_mag(b)\n  \n def copy_abs(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.copy_abs()\n  \n def copy_decimal(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return Decimal(a)\n  \n def copy_negate(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.copy_negate()\n  \n def copy_sign(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.copy_sign(b)\n  \n def divide(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  r = a.__truediv__(b, context=self)\n  if r is NotImplemented:\n   raise TypeError(\"Unable to convert %s to Decimal\" % b)\n  else:\n   return r\n   \n def divide_int(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  r = a.__floordiv__(b, context=self)\n  if r is NotImplemented:\n   raise TypeError(\"Unable to convert %s to Decimal\" % b)\n  else:\n   return r\n   \n def divmod(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  r = a.__divmod__(b, context=self)\n  if r is NotImplemented:\n   raise TypeError(\"Unable to convert %s to Decimal\" % b)\n  else:\n   return r\n   \n def exp(self, a):\n  \"\"\n  a =_convert_other(a, raiseit=True)\n  return a.exp(context=self)\n  \n def fma(self, a, b, c):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.fma(b, c, context=self)\n  \n def is_canonical(self, a):\n  \"\"\n  if not isinstance(a, Decimal):\n   raise TypeError(\"is_canonical requires a Decimal as an argument.\")\n  return a.is_canonical()\n  \n def is_finite(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.is_finite()\n  \n def is_infinite(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.is_infinite()\n  \n def is_nan(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.is_nan()\n  \n def is_normal(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.is_normal(context=self)\n  \n def is_qnan(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.is_qnan()\n  \n def is_signed(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.is_signed()\n  \n def is_snan(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.is_snan()\n  \n def is_subnormal(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.is_subnormal(context=self)\n  \n def is_zero(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.is_zero()\n  \n def ln(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.ln(context=self)\n  \n def log10(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.log10(context=self)\n  \n def logb(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.logb(context=self)\n  \n def logical_and(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.logical_and(b, context=self)\n  \n def logical_invert(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.logical_invert(context=self)\n  \n def logical_or(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.logical_or(b, context=self)\n  \n def logical_xor(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.logical_xor(b, context=self)\n  \n def max(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.max(b, context=self)\n  \n def max_mag(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.max_mag(b, context=self)\n  \n def min(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.min(b, context=self)\n  \n def min_mag(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.min_mag(b, context=self)\n  \n def minus(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.__neg__(context=self)\n  \n def multiply(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  r = a.__mul__(b, context=self)\n  if r is NotImplemented:\n   raise TypeError(\"Unable to convert %s to Decimal\" % b)\n  else:\n   return r\n   \n def next_minus(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.next_minus(context=self)\n  \n def next_plus(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.next_plus(context=self)\n  \n def next_toward(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.next_toward(b, context=self)\n  \n def normalize(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.normalize(context=self)\n  \n def number_class(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.number_class(context=self)\n  \n def plus(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.__pos__(context=self)\n  \n def power(self, a, b, modulo=None):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  r = a.__pow__(b, modulo, context=self)\n  if r is NotImplemented:\n   raise TypeError(\"Unable to convert %s to Decimal\" % b)\n  else:\n   return r\n   \n def quantize(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.quantize(b, context=self)\n  \n def radix(self):\n  \"\"\n  return Decimal(10)\n  \n def remainder(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  r = a.__mod__(b, context=self)\n  if r is NotImplemented:\n   raise TypeError(\"Unable to convert %s to Decimal\" % b)\n  else:\n   return r\n   \n def remainder_near(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.remainder_near(b, context=self)\n  \n def rotate(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.rotate(b, context=self)\n  \n def same_quantum(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.same_quantum(b)\n  \n def scaleb (self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.scaleb(b, context=self)\n  \n def shift(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.shift(b, context=self)\n  \n def sqrt(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.sqrt(context=self)\n  \n def subtract(self, a, b):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  r = a.__sub__(b, context=self)\n  if r is NotImplemented:\n   raise TypeError(\"Unable to convert %s to Decimal\" % b)\n  else:\n   return r\n   \n def to_eng_string(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.to_eng_string(context=self)\n  \n def to_sci_string(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.__str__(context=self)\n  \n def to_integral_exact(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.to_integral_exact(context=self)\n  \n def to_integral_value(self, a):\n  \"\"\n  a = _convert_other(a, raiseit=True)\n  return a.to_integral_value(context=self)\n  \n  \n to_integral = to_integral_value\n \nclass _WorkRep(object):\n __slots__ = ('sign','int','exp')\n \n \n \n \n def __init__(self, value=None):\n  if value is None:\n   self.sign = None\n   self.int = 0\n   self.exp = None\n  elif isinstance(value, Decimal):\n   self.sign = value._sign\n   self.int = int(value._int)\n   self.exp = value._exp\n  else:\n  \n   self.sign = value[0]\n   self.int = value[1]\n   self.exp = value[2]\n   \n def __repr__(self):\n  return \"(%r, %r, %r)\" % (self.sign, self.int, self.exp)\n  \n __str__ = __repr__\n \n \n \ndef _normalize(op1, op2, prec = 0):\n \"\"\n if op1.exp < op2.exp:\n  tmp = op2\n  other = op1\n else:\n  tmp = op1\n  other = op2\n  \n  \n  \n  \n  \n  \n tmp_len = len(str(tmp.int))\n other_len = len(str(other.int))\n exp = tmp.exp + min(-1, tmp_len - prec - 2)\n if other_len + other.exp - 1 < exp:\n  other.int = 1\n  other.exp = exp\n  \n tmp.int *= 10 ** (tmp.exp - other.exp)\n tmp.exp = other.exp\n return op1, op2\n \n \n \n_nbits = int.bit_length\n\ndef _decimal_lshift_exact(n, e):\n \"\"\n if n == 0:\n  return 0\n elif e >= 0:\n  return n * 10**e\n else:\n \n  str_n = str(abs(n))\n  val_n = len(str_n) - len(str_n.rstrip('0'))\n  return None if val_n < -e else n // 10**-e\n  \ndef _sqrt_nearest(n, a):\n \"\"\n if n <= 0 or a <= 0:\n  raise ValueError(\"Both arguments to _sqrt_nearest should be positive.\")\n  \n b=0\n while a != b:\n  b, a = a, a--n//a>>1\n return a\n \ndef _rshift_nearest(x, shift):\n \"\"\n b, q = 1 << shift, x >> shift\n return q + (2*(x & (b-1)) + (q&1) > b)\n \ndef _div_nearest(a, b):\n \"\"\n q, r = divmod(a, b)\n return q + (2*r + (q&1) > b)\n \ndef _ilog(x, M, L = 8):\n \"\"\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n y = x-M\n \n R = 0\n while (R <= L and abs(y) << L-R >= M or\n R > L and abs(y) >> R-L >= M):\n  y = _div_nearest((M*y) << 1,\n  M + _sqrt_nearest(M*(M+_rshift_nearest(y, R)), M))\n  R += 1\n  \n  \n T = -int(-10*len(str(M))//(3*L))\n yshift = _rshift_nearest(y, R)\n w = _div_nearest(M, T)\n for k in range(T-1, 0, -1):\n  w = _div_nearest(M, k) - _div_nearest(yshift*w, M)\n  \n return _div_nearest(w*y, M)\n \ndef _dlog10(c, e, p):\n \"\"\n \n \n \n p += 2\n \n \n \n \n \n l = len(str(c))\n f = e+l - (e+l >= 1)\n \n if p > 0:\n  M = 10**p\n  k = e+p-f\n  if k >= 0:\n   c *= 10**k\n  else:\n   c = _div_nearest(c, 10**-k)\n   \n  log_d = _ilog(c, M) \n  log_10 = _log10_digits(p) \n  log_d = _div_nearest(log_d*M, log_10)\n  log_tenpower = f*M \n else:\n  log_d = 0 \n  log_tenpower = _div_nearest(f, 10**-p) \n  \n return _div_nearest(log_tenpower+log_d, 100)\n \ndef _dlog(c, e, p):\n \"\"\n \n \n \n p += 2\n \n \n \n \n l = len(str(c))\n f = e+l - (e+l >= 1)\n \n \n if p > 0:\n  k = e+p-f\n  if k >= 0:\n   c *= 10**k\n  else:\n   c = _div_nearest(c, 10**-k) \n   \n   \n  log_d = _ilog(c, 10**p) \n else:\n \n  log_d = 0\n  \n  \n if f:\n  extra = len(str(abs(f)))-1\n  if p + extra >= 0:\n  \n  \n   f_log_ten = _div_nearest(f*_log10_digits(p+extra), 10**extra)\n  else:\n   f_log_ten = 0\n else:\n  f_log_ten = 0\n  \n  \n return _div_nearest(f_log_ten + log_d, 100)\n \nclass _Log10Memoize(object):\n \"\"\n def __init__(self):\n  self.digits = \"23025850929940456840179914546843642076011014886\"\n  \n def getdigits(self, p):\n  \"\"\n  \n  \n  \n  \n  if p < 0:\n   raise ValueError(\"p should be nonnegative\")\n   \n  if p >= len(self.digits):\n  \n  \n   extra = 3\n   while True:\n   \n    M = 10**(p+extra+2)\n    digits = str(_div_nearest(_ilog(10*M, M), 100))\n    if digits[-extra:] != '0'*extra:\n     break\n    extra += 3\n    \n    \n   self.digits = digits.rstrip('0')[:-1]\n  return int(self.digits[:p+1])\n  \n_log10_digits = _Log10Memoize().getdigits\n\ndef _iexp(x, M, L=8):\n \"\"\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n R = _nbits((x<<L)//M)\n \n \n T = -int(-10*len(str(M))//(3*L))\n y = _div_nearest(x, T)\n Mshift = M<<R\n for i in range(T-1, 0, -1):\n  y = _div_nearest(x*(Mshift + y), Mshift * i)\n  \n  \n for k in range(R-1, -1, -1):\n  Mshift = M<<(k+2)\n  y = _div_nearest(y*(y+Mshift), Mshift)\n  \n return M+y\n \ndef _dexp(c, e, p):\n \"\"\n \n \n p += 2\n \n \n extra = max(0, e + len(str(c)) - 1)\n q = p + extra\n \n \n \n shift = e+q\n if shift >= 0:\n  cshift = c*10**shift\n else:\n  cshift = c//10**-shift\n quot, rem = divmod(cshift, _log10_digits(q))\n \n \n rem = _div_nearest(rem, 10**extra)\n \n \n return _div_nearest(_iexp(rem, 10**p), 1000), quot - p + 3\n \ndef _dpower(xc, xe, yc, ye, p):\n \"\"\n \n \n b = len(str(abs(yc))) + ye\n \n \n lxc = _dlog(xc, xe, p+b+1)\n \n \n shift = ye-b\n if shift >= 0:\n  pc = lxc*yc*10**shift\n else:\n  pc = _div_nearest(lxc*yc, 10**-shift)\n  \n if pc == 0:\n \n \n  if ((len(str(xc)) + xe >= 1) == (yc > 0)): \n   coeff, exp = 10**(p-1)+1, 1-p\n  else:\n   coeff, exp = 10**p-1, -p\n else:\n  coeff, exp = _dexp(pc, -(p+1), p+1)\n  coeff = _div_nearest(coeff, 10)\n  exp += 1\n  \n return coeff, exp\n \ndef _log10_lb(c, correction = {\n'1': 100, '2': 70, '3': 53, '4': 40, '5': 31,\n'6': 23, '7': 16, '8': 10, '9': 5}):\n \"\"\n if c <= 0:\n  raise ValueError(\"The argument to _log10_lb should be nonnegative.\")\n str_c = str(c)\n return 100*len(str_c) - correction[str_c[0]]\n \n \n \ndef _convert_other(other, raiseit=False, allow_float=False):\n \"\"\n if isinstance(other, Decimal):\n  return other\n if isinstance(other, int):\n  return Decimal(other)\n if allow_float and isinstance(other, float):\n  return Decimal.from_float(other)\n  \n if raiseit:\n  raise TypeError(\"Unable to convert %s to Decimal\" % other)\n return NotImplemented\n \ndef _convert_for_comparison(self, other, equality_op=False):\n \"\"\n if isinstance(other, Decimal):\n  return self, other\n  \n  \n  \n  \n  \n if isinstance(other, _numbers.Rational):\n  if not self._is_special:\n   self = _dec_from_triple(self._sign,\n   str(int(self._int) * other.denominator),\n   self._exp)\n  return self, Decimal(other.numerator)\n  \n  \n  \n  \n if equality_op and isinstance(other, _numbers.Complex) and other.imag == 0:\n  other = other.real\n if isinstance(other, float):\n  context = getcontext()\n  if equality_op:\n   context.flags[FloatOperation] = 1\n  else:\n   context._raise_error(FloatOperation,\n   \"strict semantics for mixing floats and Decimals are enabled\")\n  return self, Decimal.from_float(other)\n return NotImplemented, NotImplemented\n \n \n \n \n \n \n \nDefaultContext = Context(\nprec=17, rounding=ROUND_HALF_EVEN,\ntraps=[DivisionByZero, Overflow, InvalidOperation],\nflags=[],\nEmax=308,\nEmin=-324,\ncapitals=1,\nclamp=0\n)\n\n\n\n\n\n\nBasicContext = Context(\nprec=9, rounding=ROUND_HALF_UP,\ntraps=[DivisionByZero, Overflow, InvalidOperation, Clamped, Underflow],\nflags=[],\n)\n\nExtendedContext = Context(\nprec=9, rounding=ROUND_HALF_EVEN,\ntraps=[],\nflags=[],\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport _jsre as re\n_all_zeros = re.compile('0*$').match\n_exact_half = re.compile('50*$').match\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndel re\n\n\n\n\ntry:\n import locale as _locale\nexcept ImportError:\n pass\n \ndef _parse_format_specifier(format_spec, _localeconv=None):\n \"\"\n m = _parse_format_specifier_regex.match(format_spec)\n if m is None:\n  raise ValueError(\"Invalid format specifier: \" + format_spec)\n  \n  \n format_dict = m.groupdict()\n \n \n \n fill = format_dict['fill']\n align = format_dict['align']\n format_dict['zeropad'] = (format_dict['zeropad'] is not None)\n if format_dict['zeropad']:\n  if fill is not None:\n   raise ValueError(\"Fill character conflicts with '0'\"\n   \" in format specifier: \" + format_spec)\n  if align is not None:\n   raise ValueError(\"Alignment conflicts with '0' in \"\n   \"format specifier: \" + format_spec)\n format_dict['fill'] = fill or ' '\n \n \n \n format_dict['align'] = align or '>'\n \n \n if format_dict['sign'] is None:\n  format_dict['sign'] = '-'\n  \n  \n format_dict['minimumwidth'] = int(format_dict['minimumwidth'] or '0')\n if format_dict['precision'] is not None:\n  format_dict['precision'] = int(format_dict['precision'])\n  \n  \n  \n if format_dict['precision'] == 0:\n  if format_dict['type'] is None or format_dict['type'] in 'gGn':\n   format_dict['precision'] = 1\n   \n   \n   \n if format_dict['type'] == 'n':\n \n  format_dict['type'] = 'g'\n  if _localeconv is None:\n   _localeconv = _locale.localeconv()\n  if format_dict['thousands_sep'] is not None:\n   raise ValueError(\"Explicit thousands separator conflicts with \"\n   \"'n' type in format specifier: \" + format_spec)\n  format_dict['thousands_sep'] = _localeconv['thousands_sep']\n  format_dict['grouping'] = _localeconv['grouping']\n  format_dict['decimal_point'] = _localeconv['decimal_point']\n else:\n  if format_dict['thousands_sep'] is None:\n   format_dict['thousands_sep'] = ''\n  format_dict['grouping'] = [3, 0]\n  format_dict['decimal_point'] = '.'\n  \n return format_dict\n \ndef _format_align(sign, body, spec):\n \"\"\n \n minimumwidth = spec['minimumwidth']\n fill = spec['fill']\n padding = fill*(minimumwidth - len(sign) - len(body))\n \n align = spec['align']\n if align == '<':\n  result = sign + body + padding\n elif align == '>':\n  result = padding + sign + body\n elif align == '=':\n  result = sign + padding + body\n elif align == '^':\n  half = len(padding)//2\n  result = padding[:half] + sign + body + padding[half:]\n else:\n  raise ValueError('Unrecognised alignment field')\n  \n return result\n \ndef _group_lengths(grouping):\n \"\"\n \n \n \n \n \n \n \n \n from itertools import chain, repeat\n if not grouping:\n  return []\n elif grouping[-1] == 0 and len(grouping) >= 2:\n  return chain(grouping[:-1], repeat(grouping[-2]))\n elif grouping[-1] == _locale.CHAR_MAX:\n  return grouping[:-1]\n else:\n  raise ValueError('unrecognised format for grouping')\n  \ndef _insert_thousands_sep(digits, spec, min_width=1):\n \"\"\n \n sep = spec['thousands_sep']\n grouping = spec['grouping']\n \n groups = []\n for l in _group_lengths(grouping):\n  if l <= 0:\n   raise ValueError(\"group length should be positive\")\n   \n  l = min(max(len(digits), min_width, 1), l)\n  groups.append('0'*(l - len(digits)) + digits[-l:])\n  digits = digits[:-l]\n  min_width -= l\n  if not digits and min_width <= 0:\n   break\n  min_width -= len(sep)\n else:\n  l = max(len(digits), min_width, 1)\n  groups.append('0'*(l - len(digits)) + digits[-l:])\n return sep.join(reversed(groups))\n \ndef _format_sign(is_negative, spec):\n \"\"\n \n if is_negative:\n  return '-'\n elif spec['sign'] in ' +':\n  return spec['sign']\n else:\n  return ''\n  \ndef _format_number(is_negative, intpart, fracpart, exp, spec):\n \"\"\n \n sign = _format_sign(is_negative, spec)\n \n if fracpart or spec['alt']:\n  fracpart = spec['decimal_point'] + fracpart\n  \n if exp != 0 or spec['type'] in 'eE':\n  echar = {'E': 'E', 'e': 'e', 'G': 'E', 'g': 'e'}[spec['type']]\n  fracpart += \"{0}{1:+}\".format(echar, exp)\n if spec['type'] == '%':\n  fracpart += '%'\n  \n if spec['zeropad']:\n  min_width = spec['minimumwidth'] - len(fracpart) - len(sign)\n else:\n  min_width = 0\n intpart = _insert_thousands_sep(intpart, spec, min_width)\n \n return _format_align(sign, intpart+fracpart, spec)\n \n \n \n \n \n_Infinity = Decimal('Inf')\n_NegativeInfinity = Decimal('-Inf')\n_NaN = Decimal('NaN')\n_Zero = Decimal(0)\n_One = Decimal(1)\n_NegativeOne = Decimal(-1)\n\n\n_SignedInfinity = (_Infinity, _NegativeInfinity)\n\n\n\n_PyHASH_MODULUS = sys.hash_info.modulus\n\n_PyHASH_INF = sys.hash_info.inf\n_PyHASH_NAN = sys.hash_info.nan\n\n\n_PyHASH_10INV = pow(10, _PyHASH_MODULUS - 2, _PyHASH_MODULUS)\ndel sys\n\ntry:\n import _decimal\nexcept ImportError:\n pass\nelse:\n s1 = set(dir())\n s2 = set(dir(_decimal))\n for name in s1 - s2:\n  del globals()[name]\n del s1, s2, name\n from _decimal import *\n \nif __name__ == '__main__':\n import doctest, decimal\n doctest.testmod(decimal)\n"], "dis": [".js", "var $module=(function($B){\n\nvar mod = {\n    dis:function(src){\n        $B.$py_module_path['__main__'] = $B.brython_path\n        return __BRYTHON__.py2js(src,'__main__','__main__','__builtins__').to_js()\n    }\n}\nreturn mod\n\n})(__BRYTHON__)"], "jqueryui.jquery-ui": [".js", "/*! jQuery UI - v1.11.2 - 2014-10-16\n* http://jqueryui.com\n* Includes: core.js, widget.js, mouse.js, position.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, draggable.js, droppable.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js, menu.js, progressbar.js, resizable.js, selectable.js, selectmenu.js, slider.js, sortable.js, spinner.js, tabs.js, tooltip.js\n* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */\n\n(function( factory ) {\n    if ( typeof define === \"function\" && define.amd ) {\n\n        // AMD. Register as an anonymous module.\n        define([ \"jquery\" ], factory );\n    } else {\n\n        // Browser globals\n        factory( jQuery );\n    }\n}(function( $ ) {\n/*!\n * jQuery UI Core 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/ui-core/\n */\n\n\n// $.ui might exist from components with no dependencies, e.g., $.ui.position\n$.ui = $.ui || {};\n\n$.extend( $.ui, {\n    version: \"1.11.2\",\n\n    keyCode: {\n        BACKSPACE: 8,\n        COMMA: 188,\n        DELETE: 46,\n        DOWN: 40,\n        END: 35,\n        ENTER: 13,\n        ESCAPE: 27,\n        HOME: 36,\n        LEFT: 37,\n        PAGE_DOWN: 34,\n        PAGE_UP: 33,\n        PERIOD: 190,\n        RIGHT: 39,\n        SPACE: 32,\n        TAB: 9,\n        UP: 38\n    }\n});\n\n// plugins\n$.fn.extend({\n    scrollParent: function( includeHidden ) {\n        var position = this.css( \"position\" ),\n            excludeStaticParent = position === \"absolute\",\n            overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,\n            scrollParent = this.parents().filter( function() {\n                var parent = $( this );\n                if ( excludeStaticParent && parent.css( \"position\" ) === \"static\" ) {\n                    return false;\n                }\n                return overflowRegex.test( parent.css( \"overflow\" ) + parent.css( \"overflow-y\" ) + parent.css( \"overflow-x\" ) );\n            }).eq( 0 );\n\n        return position === \"fixed\" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;\n    },\n\n    uniqueId: (function() {\n        var uuid = 0;\n\n        return function() {\n            return this.each(function() {\n                if ( !this.id ) {\n                    this.id = \"ui-id-\" + ( ++uuid );\n                }\n            });\n        };\n    })(),\n\n    removeUniqueId: function() {\n        return this.each(function() {\n            if ( /^ui-id-\\d+$/.test( this.id ) ) {\n                $( this ).removeAttr( \"id\" );\n            }\n        });\n    }\n});\n\n// selectors\nfunction focusable( element, isTabIndexNotNaN ) {\n    var map, mapName, img,\n        nodeName = element.nodeName.toLowerCase();\n    if ( \"area\" === nodeName ) {\n        map = element.parentNode;\n        mapName = map.name;\n        if ( !element.href || !mapName || map.nodeName.toLowerCase() !== \"map\" ) {\n            return false;\n        }\n        img = $( \"img[usemap='#\" + mapName + \"']\" )[ 0 ];\n        return !!img && visible( img );\n    }\n    return ( /input|select|textarea|button|object/.test( nodeName ) ?\n        !element.disabled :\n        \"a\" === nodeName ?\n            element.href || isTabIndexNotNaN :\n            isTabIndexNotNaN) &&\n        // the element and all of its ancestors must be visible\n        visible( element );\n}\n\nfunction visible( element ) {\n    return $.expr.filters.visible( element ) &&\n        !$( element ).parents().addBack().filter(function() {\n            return $.css( this, \"visibility\" ) === \"hidden\";\n        }).length;\n}\n\n$.extend( $.expr[ \":\" ], {\n    data: $.expr.createPseudo ?\n        $.expr.createPseudo(function( dataName ) {\n            return function( elem ) {\n                return !!$.data( elem, dataName );\n            };\n        }) :\n        // support: jQuery <1.8\n        function( elem, i, match ) {\n            return !!$.data( elem, match[ 3 ] );\n        },\n\n    focusable: function( element ) {\n        return focusable( element, !isNaN( $.attr( element, \"tabindex\" ) ) );\n    },\n\n    tabbable: function( element ) {\n        var tabIndex = $.attr( element, \"tabindex\" ),\n            isTabIndexNaN = isNaN( tabIndex );\n        return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );\n    }\n});\n\n// support: jQuery <1.8\nif ( !$( \"<a>\" ).outerWidth( 1 ).jquery ) {\n    $.each( [ \"Width\", \"Height\" ], function( i, name ) {\n        var side = name === \"Width\" ? [ \"Left\", \"Right\" ] : [ \"Top\", \"Bottom\" ],\n            type = name.toLowerCase(),\n            orig = {\n                innerWidth: $.fn.innerWidth,\n                innerHeight: $.fn.innerHeight,\n                outerWidth: $.fn.outerWidth,\n                outerHeight: $.fn.outerHeight\n            };\n\n        function reduce( elem, size, border, margin ) {\n            $.each( side, function() {\n                size -= parseFloat( $.css( elem, \"padding\" + this ) ) || 0;\n                if ( border ) {\n                    size -= parseFloat( $.css( elem, \"border\" + this + \"Width\" ) ) || 0;\n                }\n                if ( margin ) {\n                    size -= parseFloat( $.css( elem, \"margin\" + this ) ) || 0;\n                }\n            });\n            return size;\n        }\n\n        $.fn[ \"inner\" + name ] = function( size ) {\n            if ( size === undefined ) {\n                return orig[ \"inner\" + name ].call( this );\n            }\n\n            return this.each(function() {\n                $( this ).css( type, reduce( this, size ) + \"px\" );\n            });\n        };\n\n        $.fn[ \"outer\" + name] = function( size, margin ) {\n            if ( typeof size !== \"number\" ) {\n                return orig[ \"outer\" + name ].call( this, size );\n            }\n\n            return this.each(function() {\n                $( this).css( type, reduce( this, size, true, margin ) + \"px\" );\n            });\n        };\n    });\n}\n\n// support: jQuery <1.8\nif ( !$.fn.addBack ) {\n    $.fn.addBack = function( selector ) {\n        return this.add( selector == null ?\n            this.prevObject : this.prevObject.filter( selector )\n        );\n    };\n}\n\n// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)\nif ( $( \"<a>\" ).data( \"a-b\", \"a\" ).removeData( \"a-b\" ).data( \"a-b\" ) ) {\n    $.fn.removeData = (function( removeData ) {\n        return function( key ) {\n            if ( arguments.length ) {\n                return removeData.call( this, $.camelCase( key ) );\n            } else {\n                return removeData.call( this );\n            }\n        };\n    })( $.fn.removeData );\n}\n\n// deprecated\n$.ui.ie = !!/msie [\\w.]+/.exec( navigator.userAgent.toLowerCase() );\n\n$.fn.extend({\n    focus: (function( orig ) {\n        return function( delay, fn ) {\n            return typeof delay === \"number\" ?\n                this.each(function() {\n                    var elem = this;\n                    setTimeout(function() {\n                        $( elem ).focus();\n                        if ( fn ) {\n                            fn.call( elem );\n                        }\n                    }, delay );\n                }) :\n                orig.apply( this, arguments );\n        };\n    })( $.fn.focus ),\n\n    disableSelection: (function() {\n        var eventType = \"onselectstart\" in document.createElement( \"div\" ) ?\n            \"selectstart\" :\n            \"mousedown\";\n\n        return function() {\n            return this.bind( eventType + \".ui-disableSelection\", function( event ) {\n                event.preventDefault();\n            });\n        };\n    })(),\n\n    enableSelection: function() {\n        return this.unbind( \".ui-disableSelection\" );\n    },\n\n    zIndex: function( zIndex ) {\n        if ( zIndex !== undefined ) {\n            return this.css( \"zIndex\", zIndex );\n        }\n\n        if ( this.length ) {\n            var elem = $( this[ 0 ] ), position, value;\n            while ( elem.length && elem[ 0 ] !== document ) {\n                // Ignore z-index if position is set to a value where z-index is ignored by the browser\n                // This makes behavior of this function consistent across browsers\n                // WebKit always returns auto if the element is positioned\n                position = elem.css( \"position\" );\n                if ( position === \"absolute\" || position === \"relative\" || position === \"fixed\" ) {\n                    // IE returns 0 when zIndex is not specified\n                    // other browsers return a string\n                    // we ignore the case of nested elements with an explicit value of 0\n                    // <div style=\"z-index: -10;\"><div style=\"z-index: 0;\"></div></div>\n                    value = parseInt( elem.css( \"zIndex\" ), 10 );\n                    if ( !isNaN( value ) && value !== 0 ) {\n                        return value;\n                    }\n                }\n                elem = elem.parent();\n            }\n        }\n\n        return 0;\n    }\n});\n\n// $.ui.plugin is deprecated. Use $.widget() extensions instead.\n$.ui.plugin = {\n    add: function( module, option, set ) {\n        var i,\n            proto = $.ui[ module ].prototype;\n        for ( i in set ) {\n            proto.plugins[ i ] = proto.plugins[ i ] || [];\n            proto.plugins[ i ].push( [ option, set[ i ] ] );\n        }\n    },\n    call: function( instance, name, args, allowDisconnected ) {\n        var i,\n            set = instance.plugins[ name ];\n\n        if ( !set ) {\n            return;\n        }\n\n        if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {\n            return;\n        }\n\n        for ( i = 0; i < set.length; i++ ) {\n            if ( instance.options[ set[ i ][ 0 ] ] ) {\n                set[ i ][ 1 ].apply( instance.element, args );\n            }\n        }\n    }\n};\n\n\n/*!\n * jQuery UI Widget 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/jQuery.widget/\n */\n\n\nvar widget_uuid = 0,\n    widget_slice = Array.prototype.slice;\n\n$.cleanData = (function( orig ) {\n    return function( elems ) {\n        var events, elem, i;\n        for ( i = 0; (elem = elems[i]) != null; i++ ) {\n            try {\n\n                // Only trigger remove when necessary to save time\n                events = $._data( elem, \"events\" );\n                if ( events && events.remove ) {\n                    $( elem ).triggerHandler( \"remove\" );\n                }\n\n            // http://bugs.jquery.com/ticket/8235\n            } catch ( e ) {}\n        }\n        orig( elems );\n    };\n})( $.cleanData );\n\n$.widget = function( name, base, prototype ) {\n    var fullName, existingConstructor, constructor, basePrototype,\n        // proxiedPrototype allows the provided prototype to remain unmodified\n        // so that it can be used as a mixin for multiple widgets (#8876)\n        proxiedPrototype = {},\n        namespace = name.split( \".\" )[ 0 ];\n\n    name = name.split( \".\" )[ 1 ];\n    fullName = namespace + \"-\" + name;\n\n    if ( !prototype ) {\n        prototype = base;\n        base = $.Widget;\n    }\n\n    // create selector for plugin\n    $.expr[ \":\" ][ fullName.toLowerCase() ] = function( elem ) {\n        return !!$.data( elem, fullName );\n    };\n\n    $[ namespace ] = $[ namespace ] || {};\n    existingConstructor = $[ namespace ][ name ];\n    constructor = $[ namespace ][ name ] = function( options, element ) {\n        // allow instantiation without \"new\" keyword\n        if ( !this._createWidget ) {\n            return new constructor( options, element );\n        }\n\n        // allow instantiation without initializing for simple inheritance\n        // must use \"new\" keyword (the code above always passes args)\n        if ( arguments.length ) {\n            this._createWidget( options, element );\n        }\n    };\n    // extend with the existing constructor to carry over any static properties\n    $.extend( constructor, existingConstructor, {\n        version: prototype.version,\n        // copy the object used to create the prototype in case we need to\n        // redefine the widget later\n        _proto: $.extend( {}, prototype ),\n        // track widgets that inherit from this widget in case this widget is\n        // redefined after a widget inherits from it\n        _childConstructors: []\n    });\n\n    basePrototype = new base();\n    // we need to make the options hash a property directly on the new instance\n    // otherwise we'll modify the options hash on the prototype that we're\n    // inheriting from\n    basePrototype.options = $.widget.extend( {}, basePrototype.options );\n    $.each( prototype, function( prop, value ) {\n        if ( !$.isFunction( value ) ) {\n            proxiedPrototype[ prop ] = value;\n            return;\n        }\n        proxiedPrototype[ prop ] = (function() {\n            var _super = function() {\n                    return base.prototype[ prop ].apply( this, arguments );\n                },\n                _superApply = function( args ) {\n                    return base.prototype[ prop ].apply( this, args );\n                };\n            return function() {\n                var __super = this._super,\n                    __superApply = this._superApply,\n                    returnValue;\n\n                this._super = _super;\n                this._superApply = _superApply;\n\n                returnValue = value.apply( this, arguments );\n\n                this._super = __super;\n                this._superApply = __superApply;\n\n                return returnValue;\n            };\n        })();\n    });\n    constructor.prototype = $.widget.extend( basePrototype, {\n        // TODO: remove support for widgetEventPrefix\n        // always use the name + a colon as the prefix, e.g., draggable:start\n        // don't prefix for widgets that aren't DOM-based\n        widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name\n    }, proxiedPrototype, {\n        constructor: constructor,\n        namespace: namespace,\n        widgetName: name,\n        widgetFullName: fullName\n    });\n\n    // If this widget is being redefined then we need to find all widgets that\n    // are inheriting from it and redefine all of them so that they inherit from\n    // the new version of this widget. We're essentially trying to replace one\n    // level in the prototype chain.\n    if ( existingConstructor ) {\n        $.each( existingConstructor._childConstructors, function( i, child ) {\n            var childPrototype = child.prototype;\n\n            // redefine the child widget using the same prototype that was\n            // originally used, but inherit from the new version of the base\n            $.widget( childPrototype.namespace + \".\" + childPrototype.widgetName, constructor, child._proto );\n        });\n        // remove the list of existing child constructors from the old constructor\n        // so the old child constructors can be garbage collected\n        delete existingConstructor._childConstructors;\n    } else {\n        base._childConstructors.push( constructor );\n    }\n\n    $.widget.bridge( name, constructor );\n\n    return constructor;\n};\n\n$.widget.extend = function( target ) {\n    var input = widget_slice.call( arguments, 1 ),\n        inputIndex = 0,\n        inputLength = input.length,\n        key,\n        value;\n    for ( ; inputIndex < inputLength; inputIndex++ ) {\n        for ( key in input[ inputIndex ] ) {\n            value = input[ inputIndex ][ key ];\n            if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\n                // Clone objects\n                if ( $.isPlainObject( value ) ) {\n                    target[ key ] = $.isPlainObject( target[ key ] ) ?\n                        $.widget.extend( {}, target[ key ], value ) :\n                        // Don't extend strings, arrays, etc. with objects\n                        $.widget.extend( {}, value );\n                // Copy everything else by reference\n                } else {\n                    target[ key ] = value;\n                }\n            }\n        }\n    }\n    return target;\n};\n\n$.widget.bridge = function( name, object ) {\n    var fullName = object.prototype.widgetFullName || name;\n    $.fn[ name ] = function( options ) {\n        var isMethodCall = typeof options === \"string\",\n            args = widget_slice.call( arguments, 1 ),\n            returnValue = this;\n\n        // allow multiple hashes to be passed on init\n        options = !isMethodCall && args.length ?\n            $.widget.extend.apply( null, [ options ].concat(args) ) :\n            options;\n\n        if ( isMethodCall ) {\n            this.each(function() {\n                var methodValue,\n                    instance = $.data( this, fullName );\n                if ( options === \"instance\" ) {\n                    returnValue = instance;\n                    return false;\n                }\n                if ( !instance ) {\n                    return $.error( \"cannot call methods on \" + name + \" prior to initialization; \" +\n                        \"attempted to call method '\" + options + \"'\" );\n                }\n                if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === \"_\" ) {\n                    return $.error( \"no such method '\" + options + \"' for \" + name + \" widget instance\" );\n                }\n                methodValue = instance[ options ].apply( instance, args );\n                if ( methodValue !== instance && methodValue !== undefined ) {\n                    returnValue = methodValue && methodValue.jquery ?\n                        returnValue.pushStack( methodValue.get() ) :\n                        methodValue;\n                    return false;\n                }\n            });\n        } else {\n            this.each(function() {\n                var instance = $.data( this, fullName );\n                if ( instance ) {\n                    instance.option( options || {} );\n                    if ( instance._init ) {\n                        instance._init();\n                    }\n                } else {\n                    $.data( this, fullName, new object( options, this ) );\n                }\n            });\n        }\n\n        return returnValue;\n    };\n};\n\n$.Widget = function( /* options, element */ ) {};\n$.Widget._childConstructors = [];\n\n$.Widget.prototype = {\n    widgetName: \"widget\",\n    widgetEventPrefix: \"\",\n    defaultElement: \"<div>\",\n    options: {\n        disabled: false,\n\n        // callbacks\n        create: null\n    },\n    _createWidget: function( options, element ) {\n        element = $( element || this.defaultElement || this )[ 0 ];\n        this.element = $( element );\n        this.uuid = widget_uuid++;\n        this.eventNamespace = \".\" + this.widgetName + this.uuid;\n\n        this.bindings = $();\n        this.hoverable = $();\n        this.focusable = $();\n\n        if ( element !== this ) {\n            $.data( element, this.widgetFullName, this );\n            this._on( true, this.element, {\n                remove: function( event ) {\n                    if ( event.target === element ) {\n                        this.destroy();\n                    }\n                }\n            });\n            this.document = $( element.style ?\n                // element within the document\n                element.ownerDocument :\n                // element is window or document\n                element.document || element );\n            this.window = $( this.document[0].defaultView || this.document[0].parentWindow );\n        }\n\n        this.options = $.widget.extend( {},\n            this.options,\n            this._getCreateOptions(),\n            options );\n\n        this._create();\n        this._trigger( \"create\", null, this._getCreateEventData() );\n        this._init();\n    },\n    _getCreateOptions: $.noop,\n    _getCreateEventData: $.noop,\n    _create: $.noop,\n    _init: $.noop,\n\n    destroy: function() {\n        this._destroy();\n        // we can probably remove the unbind calls in 2.0\n        // all event bindings should go through this._on()\n        this.element\n            .unbind( this.eventNamespace )\n            .removeData( this.widgetFullName )\n            // support: jquery <1.6.3\n            // http://bugs.jquery.com/ticket/9413\n            .removeData( $.camelCase( this.widgetFullName ) );\n        this.widget()\n            .unbind( this.eventNamespace )\n            .removeAttr( \"aria-disabled\" )\n            .removeClass(\n                this.widgetFullName + \"-disabled \" +\n                \"ui-state-disabled\" );\n\n        // clean up events and states\n        this.bindings.unbind( this.eventNamespace );\n        this.hoverable.removeClass( \"ui-state-hover\" );\n        this.focusable.removeClass( \"ui-state-focus\" );\n    },\n    _destroy: $.noop,\n\n    widget: function() {\n        return this.element;\n    },\n\n    option: function( key, value ) {\n        var options = key,\n            parts,\n            curOption,\n            i;\n\n        if ( arguments.length === 0 ) {\n            // don't return a reference to the internal hash\n            return $.widget.extend( {}, this.options );\n        }\n\n        if ( typeof key === \"string\" ) {\n            // handle nested keys, e.g., \"foo.bar\" => { foo: { bar: ___ } }\n            options = {};\n            parts = key.split( \".\" );\n            key = parts.shift();\n            if ( parts.length ) {\n                curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\n                for ( i = 0; i < parts.length - 1; i++ ) {\n                    curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\n                    curOption = curOption[ parts[ i ] ];\n                }\n                key = parts.pop();\n                if ( arguments.length === 1 ) {\n                    return curOption[ key ] === undefined ? null : curOption[ key ];\n                }\n                curOption[ key ] = value;\n            } else {\n                if ( arguments.length === 1 ) {\n                    return this.options[ key ] === undefined ? null : this.options[ key ];\n                }\n                options[ key ] = value;\n            }\n        }\n\n        this._setOptions( options );\n\n        return this;\n    },\n    _setOptions: function( options ) {\n        var key;\n\n        for ( key in options ) {\n            this._setOption( key, options[ key ] );\n        }\n\n        return this;\n    },\n    _setOption: function( key, value ) {\n        this.options[ key ] = value;\n\n        if ( key === \"disabled\" ) {\n            this.widget()\n                .toggleClass( this.widgetFullName + \"-disabled\", !!value );\n\n            // If the widget is becoming disabled, then nothing is interactive\n            if ( value ) {\n                this.hoverable.removeClass( \"ui-state-hover\" );\n                this.focusable.removeClass( \"ui-state-focus\" );\n            }\n        }\n\n        return this;\n    },\n\n    enable: function() {\n        return this._setOptions({ disabled: false });\n    },\n    disable: function() {\n        return this._setOptions({ disabled: true });\n    },\n\n    _on: function( suppressDisabledCheck, element, handlers ) {\n        var delegateElement,\n            instance = this;\n\n        // no suppressDisabledCheck flag, shuffle arguments\n        if ( typeof suppressDisabledCheck !== \"boolean\" ) {\n            handlers = element;\n            element = suppressDisabledCheck;\n            suppressDisabledCheck = false;\n        }\n\n        // no element argument, shuffle and use this.element\n        if ( !handlers ) {\n            handlers = element;\n            element = this.element;\n            delegateElement = this.widget();\n        } else {\n            element = delegateElement = $( element );\n            this.bindings = this.bindings.add( element );\n        }\n\n        $.each( handlers, function( event, handler ) {\n            function handlerProxy() {\n                // allow widgets to customize the disabled handling\n                // - disabled as an array instead of boolean\n                // - disabled class as method for disabling individual parts\n                if ( !suppressDisabledCheck &&\n                        ( instance.options.disabled === true ||\n                            $( this ).hasClass( \"ui-state-disabled\" ) ) ) {\n                    return;\n                }\n                return ( typeof handler === \"string\" ? instance[ handler ] : handler )\n                    .apply( instance, arguments );\n            }\n\n            // copy the guid so direct unbinding works\n            if ( typeof handler !== \"string\" ) {\n                handlerProxy.guid = handler.guid =\n                    handler.guid || handlerProxy.guid || $.guid++;\n            }\n\n            var match = event.match( /^([\\w:-]*)\\s*(.*)$/ ),\n                eventName = match[1] + instance.eventNamespace,\n                selector = match[2];\n            if ( selector ) {\n                delegateElement.delegate( selector, eventName, handlerProxy );\n            } else {\n                element.bind( eventName, handlerProxy );\n            }\n        });\n    },\n\n    _off: function( element, eventName ) {\n        eventName = (eventName || \"\").split( \" \" ).join( this.eventNamespace + \" \" ) +\n            this.eventNamespace;\n        element.unbind( eventName ).undelegate( eventName );\n\n        // Clear the stack to avoid memory leaks (#10056)\n        this.bindings = $( this.bindings.not( element ).get() );\n        this.focusable = $( this.focusable.not( element ).get() );\n        this.hoverable = $( this.hoverable.not( element ).get() );\n    },\n\n    _delay: function( handler, delay ) {\n        function handlerProxy() {\n            return ( typeof handler === \"string\" ? instance[ handler ] : handler )\n                .apply( instance, arguments );\n        }\n        var instance = this;\n        return setTimeout( handlerProxy, delay || 0 );\n    },\n\n    _hoverable: function( element ) {\n        this.hoverable = this.hoverable.add( element );\n        this._on( element, {\n            mouseenter: function( event ) {\n                $( event.currentTarget ).addClass( \"ui-state-hover\" );\n            },\n            mouseleave: function( event ) {\n                $( event.currentTarget ).removeClass( \"ui-state-hover\" );\n            }\n        });\n    },\n\n    _focusable: function( element ) {\n        this.focusable = this.focusable.add( element );\n        this._on( element, {\n            focusin: function( event ) {\n                $( event.currentTarget ).addClass( \"ui-state-focus\" );\n            },\n            focusout: function( event ) {\n                $( event.currentTarget ).removeClass( \"ui-state-focus\" );\n            }\n        });\n    },\n\n    _trigger: function( type, event, data ) {\n        var prop, orig,\n            callback = this.options[ type ];\n\n        data = data || {};\n        event = $.Event( event );\n        event.type = ( type === this.widgetEventPrefix ?\n            type :\n            this.widgetEventPrefix + type ).toLowerCase();\n        // the original event may come from any element\n        // so we need to reset the target on the new event\n        event.target = this.element[ 0 ];\n\n        // copy original event properties over to the new event\n        orig = event.originalEvent;\n        if ( orig ) {\n            for ( prop in orig ) {\n                if ( !( prop in event ) ) {\n                    event[ prop ] = orig[ prop ];\n                }\n            }\n        }\n\n        this.element.trigger( event, data );\n        return !( $.isFunction( callback ) &&\n            callback.apply( this.element[0], [ event ].concat( data ) ) === false ||\n            event.isDefaultPrevented() );\n    }\n};\n\n$.each( { show: \"fadeIn\", hide: \"fadeOut\" }, function( method, defaultEffect ) {\n    $.Widget.prototype[ \"_\" + method ] = function( element, options, callback ) {\n        if ( typeof options === \"string\" ) {\n            options = { effect: options };\n        }\n        var hasOptions,\n            effectName = !options ?\n                method :\n                options === true || typeof options === \"number\" ?\n                    defaultEffect :\n                    options.effect || defaultEffect;\n        options = options || {};\n        if ( typeof options === \"number\" ) {\n            options = { duration: options };\n        }\n        hasOptions = !$.isEmptyObject( options );\n        options.complete = callback;\n        if ( options.delay ) {\n            element.delay( options.delay );\n        }\n        if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\n            element[ method ]( options );\n        } else if ( effectName !== method && element[ effectName ] ) {\n            element[ effectName ]( options.duration, options.easing, callback );\n        } else {\n            element.queue(function( next ) {\n                $( this )[ method ]();\n                if ( callback ) {\n                    callback.call( element[ 0 ] );\n                }\n                next();\n            });\n        }\n    };\n});\n\nvar widget = $.widget;\n\n\n/*!\n * jQuery UI Mouse 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/mouse/\n */\n\n\nvar mouseHandled = false;\n$( document ).mouseup( function() {\n    mouseHandled = false;\n});\n\nvar mouse = $.widget(\"ui.mouse\", {\n    version: \"1.11.2\",\n    options: {\n        cancel: \"input,textarea,button,select,option\",\n        distance: 1,\n        delay: 0\n    },\n    _mouseInit: function() {\n        var that = this;\n\n        this.element\n            .bind(\"mousedown.\" + this.widgetName, function(event) {\n                return that._mouseDown(event);\n            })\n            .bind(\"click.\" + this.widgetName, function(event) {\n                if (true === $.data(event.target, that.widgetName + \".preventClickEvent\")) {\n                    $.removeData(event.target, that.widgetName + \".preventClickEvent\");\n                    event.stopImmediatePropagation();\n                    return false;\n                }\n            });\n\n        this.started = false;\n    },\n\n    // TODO: make sure destroying one instance of mouse doesn't mess with\n    // other instances of mouse\n    _mouseDestroy: function() {\n        this.element.unbind(\".\" + this.widgetName);\n        if ( this._mouseMoveDelegate ) {\n            this.document\n                .unbind(\"mousemove.\" + this.widgetName, this._mouseMoveDelegate)\n                .unbind(\"mouseup.\" + this.widgetName, this._mouseUpDelegate);\n        }\n    },\n\n    _mouseDown: function(event) {\n        // don't let more than one widget handle mouseStart\n        if ( mouseHandled ) {\n            return;\n        }\n\n        this._mouseMoved = false;\n\n        // we may have missed mouseup (out of window)\n        (this._mouseStarted && this._mouseUp(event));\n\n        this._mouseDownEvent = event;\n\n        var that = this,\n            btnIsLeft = (event.which === 1),\n            // event.target.nodeName works around a bug in IE 8 with\n            // disabled inputs (#7620)\n            elIsCancel = (typeof this.options.cancel === \"string\" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);\n        if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\n            return true;\n        }\n\n        this.mouseDelayMet = !this.options.delay;\n        if (!this.mouseDelayMet) {\n            this._mouseDelayTimer = setTimeout(function() {\n                that.mouseDelayMet = true;\n            }, this.options.delay);\n        }\n\n        if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n            this._mouseStarted = (this._mouseStart(event) !== false);\n            if (!this._mouseStarted) {\n                event.preventDefault();\n                return true;\n            }\n        }\n\n        // Click event may never have fired (Gecko & Opera)\n        if (true === $.data(event.target, this.widgetName + \".preventClickEvent\")) {\n            $.removeData(event.target, this.widgetName + \".preventClickEvent\");\n        }\n\n        // these delegates are required to keep context\n        this._mouseMoveDelegate = function(event) {\n            return that._mouseMove(event);\n        };\n        this._mouseUpDelegate = function(event) {\n            return that._mouseUp(event);\n        };\n\n        this.document\n            .bind( \"mousemove.\" + this.widgetName, this._mouseMoveDelegate )\n            .bind( \"mouseup.\" + this.widgetName, this._mouseUpDelegate );\n\n        event.preventDefault();\n\n        mouseHandled = true;\n        return true;\n    },\n\n    _mouseMove: function(event) {\n        // Only check for mouseups outside the document if you've moved inside the document\n        // at least once. This prevents the firing of mouseup in the case of IE<9, which will\n        // fire a mousemove event if content is placed under the cursor. See #7778\n        // Support: IE <9\n        if ( this._mouseMoved ) {\n            // IE mouseup check - mouseup happened when mouse was out of window\n            if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {\n                return this._mouseUp(event);\n\n            // Iframe mouseup check - mouseup occurred in another document\n            } else if ( !event.which ) {\n                return this._mouseUp( event );\n            }\n        }\n\n        if ( event.which || event.button ) {\n            this._mouseMoved = true;\n        }\n\n        if (this._mouseStarted) {\n            this._mouseDrag(event);\n            return event.preventDefault();\n        }\n\n        if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\n            this._mouseStarted =\n                (this._mouseStart(this._mouseDownEvent, event) !== false);\n            (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));\n        }\n\n        return !this._mouseStarted;\n    },\n\n    _mouseUp: function(event) {\n        this.document\n            .unbind( \"mousemove.\" + this.widgetName, this._mouseMoveDelegate )\n            .unbind( \"mouseup.\" + this.widgetName, this._mouseUpDelegate );\n\n        if (this._mouseStarted) {\n            this._mouseStarted = false;\n\n            if (event.target === this._mouseDownEvent.target) {\n                $.data(event.target, this.widgetName + \".preventClickEvent\", true);\n            }\n\n            this._mouseStop(event);\n        }\n\n        mouseHandled = false;\n        return false;\n    },\n\n    _mouseDistanceMet: function(event) {\n        return (Math.max(\n                Math.abs(this._mouseDownEvent.pageX - event.pageX),\n                Math.abs(this._mouseDownEvent.pageY - event.pageY)\n            ) >= this.options.distance\n        );\n    },\n\n    _mouseDelayMet: function(/* event */) {\n        return this.mouseDelayMet;\n    },\n\n    // These are placeholder methods, to be overriden by extending plugin\n    _mouseStart: function(/* event */) {},\n    _mouseDrag: function(/* event */) {},\n    _mouseStop: function(/* event */) {},\n    _mouseCapture: function(/* event */) { return true; }\n});\n\n\n/*!\n * jQuery UI Position 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/position/\n */\n\n(function() {\n\n$.ui = $.ui || {};\n\nvar cachedScrollbarWidth, supportsOffsetFractions,\n    max = Math.max,\n    abs = Math.abs,\n    round = Math.round,\n    rhorizontal = /left|center|right/,\n    rvertical = /top|center|bottom/,\n    roffset = /[\\+\\-]\\d+(\\.[\\d]+)?%?/,\n    rposition = /^\\w+/,\n    rpercent = /%$/,\n    _position = $.fn.position;\n\nfunction getOffsets( offsets, width, height ) {\n    return [\n        parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\n        parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\n    ];\n}\n\nfunction parseCss( element, property ) {\n    return parseInt( $.css( element, property ), 10 ) || 0;\n}\n\nfunction getDimensions( elem ) {\n    var raw = elem[0];\n    if ( raw.nodeType === 9 ) {\n        return {\n            width: elem.width(),\n            height: elem.height(),\n            offset: { top: 0, left: 0 }\n        };\n    }\n    if ( $.isWindow( raw ) ) {\n        return {\n            width: elem.width(),\n            height: elem.height(),\n            offset: { top: elem.scrollTop(), left: elem.scrollLeft() }\n        };\n    }\n    if ( raw.preventDefault ) {\n        return {\n            width: 0,\n            height: 0,\n            offset: { top: raw.pageY, left: raw.pageX }\n        };\n    }\n    return {\n        width: elem.outerWidth(),\n        height: elem.outerHeight(),\n        offset: elem.offset()\n    };\n}\n\n$.position = {\n    scrollbarWidth: function() {\n        if ( cachedScrollbarWidth !== undefined ) {\n            return cachedScrollbarWidth;\n        }\n        var w1, w2,\n            div = $( \"<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>\" ),\n            innerDiv = div.children()[0];\n\n        $( \"body\" ).append( div );\n        w1 = innerDiv.offsetWidth;\n        div.css( \"overflow\", \"scroll\" );\n\n        w2 = innerDiv.offsetWidth;\n\n        if ( w1 === w2 ) {\n            w2 = div[0].clientWidth;\n        }\n\n        div.remove();\n\n        return (cachedScrollbarWidth = w1 - w2);\n    },\n    getScrollInfo: function( within ) {\n        var overflowX = within.isWindow || within.isDocument ? \"\" :\n                within.element.css( \"overflow-x\" ),\n            overflowY = within.isWindow || within.isDocument ? \"\" :\n                within.element.css( \"overflow-y\" ),\n            hasOverflowX = overflowX === \"scroll\" ||\n                ( overflowX === \"auto\" && within.width < within.element[0].scrollWidth ),\n            hasOverflowY = overflowY === \"scroll\" ||\n                ( overflowY === \"auto\" && within.height < within.element[0].scrollHeight );\n        return {\n            width: hasOverflowY ? $.position.scrollbarWidth() : 0,\n            height: hasOverflowX ? $.position.scrollbarWidth() : 0\n        };\n    },\n    getWithinInfo: function( element ) {\n        var withinElement = $( element || window ),\n            isWindow = $.isWindow( withinElement[0] ),\n            isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;\n        return {\n            element: withinElement,\n            isWindow: isWindow,\n            isDocument: isDocument,\n            offset: withinElement.offset() || { left: 0, top: 0 },\n            scrollLeft: withinElement.scrollLeft(),\n            scrollTop: withinElement.scrollTop(),\n\n            // support: jQuery 1.6.x\n            // jQuery 1.6 doesn't support .outerWidth/Height() on documents or windows\n            width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),\n            height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()\n        };\n    }\n};\n\n$.fn.position = function( options ) {\n    if ( !options || !options.of ) {\n        return _position.apply( this, arguments );\n    }\n\n    // make a copy, we don't want to modify arguments\n    options = $.extend( {}, options );\n\n    var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\n        target = $( options.of ),\n        within = $.position.getWithinInfo( options.within ),\n        scrollInfo = $.position.getScrollInfo( within ),\n        collision = ( options.collision || \"flip\" ).split( \" \" ),\n        offsets = {};\n\n    dimensions = getDimensions( target );\n    if ( target[0].preventDefault ) {\n        // force left top to allow flipping\n        options.at = \"left top\";\n    }\n    targetWidth = dimensions.width;\n    targetHeight = dimensions.height;\n    targetOffset = dimensions.offset;\n    // clone to reuse original targetOffset later\n    basePosition = $.extend( {}, targetOffset );\n\n    // force my and at to have valid horizontal and vertical positions\n    // if a value is missing or invalid, it will be converted to center\n    $.each( [ \"my\", \"at\" ], function() {\n        var pos = ( options[ this ] || \"\" ).split( \" \" ),\n            horizontalOffset,\n            verticalOffset;\n\n        if ( pos.length === 1) {\n            pos = rhorizontal.test( pos[ 0 ] ) ?\n                pos.concat( [ \"center\" ] ) :\n                rvertical.test( pos[ 0 ] ) ?\n                    [ \"center\" ].concat( pos ) :\n                    [ \"center\", \"center\" ];\n        }\n        pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \"center\";\n        pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \"center\";\n\n        // calculate offsets\n        horizontalOffset = roffset.exec( pos[ 0 ] );\n        verticalOffset = roffset.exec( pos[ 1 ] );\n        offsets[ this ] = [\n            horizontalOffset ? horizontalOffset[ 0 ] : 0,\n            verticalOffset ? verticalOffset[ 0 ] : 0\n        ];\n\n        // reduce to just the positions without the offsets\n        options[ this ] = [\n            rposition.exec( pos[ 0 ] )[ 0 ],\n            rposition.exec( pos[ 1 ] )[ 0 ]\n        ];\n    });\n\n    // normalize collision option\n    if ( collision.length === 1 ) {\n        collision[ 1 ] = collision[ 0 ];\n    }\n\n    if ( options.at[ 0 ] === \"right\" ) {\n        basePosition.left += targetWidth;\n    } else if ( options.at[ 0 ] === \"center\" ) {\n        basePosition.left += targetWidth / 2;\n    }\n\n    if ( options.at[ 1 ] === \"bottom\" ) {\n        basePosition.top += targetHeight;\n    } else if ( options.at[ 1 ] === \"center\" ) {\n        basePosition.top += targetHeight / 2;\n    }\n\n    atOffset = getOffsets( offsets.at, targetWidth, targetHeight );\n    basePosition.left += atOffset[ 0 ];\n    basePosition.top += atOffset[ 1 ];\n\n    return this.each(function() {\n        var collisionPosition, using,\n            elem = $( this ),\n            elemWidth = elem.outerWidth(),\n            elemHeight = elem.outerHeight(),\n            marginLeft = parseCss( this, \"marginLeft\" ),\n            marginTop = parseCss( this, \"marginTop\" ),\n            collisionWidth = elemWidth + marginLeft + parseCss( this, \"marginRight\" ) + scrollInfo.width,\n            collisionHeight = elemHeight + marginTop + parseCss( this, \"marginBottom\" ) + scrollInfo.height,\n            position = $.extend( {}, basePosition ),\n            myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );\n\n        if ( options.my[ 0 ] === \"right\" ) {\n            position.left -= elemWidth;\n        } else if ( options.my[ 0 ] === \"center\" ) {\n            position.left -= elemWidth / 2;\n        }\n\n        if ( options.my[ 1 ] === \"bottom\" ) {\n            position.top -= elemHeight;\n        } else if ( options.my[ 1 ] === \"center\" ) {\n            position.top -= elemHeight / 2;\n        }\n\n        position.left += myOffset[ 0 ];\n        position.top += myOffset[ 1 ];\n\n        // if the browser doesn't support fractions, then round for consistent results\n        if ( !supportsOffsetFractions ) {\n            position.left = round( position.left );\n            position.top = round( position.top );\n        }\n\n        collisionPosition = {\n            marginLeft: marginLeft,\n            marginTop: marginTop\n        };\n\n        $.each( [ \"left\", \"top\" ], function( i, dir ) {\n            if ( $.ui.position[ collision[ i ] ] ) {\n                $.ui.position[ collision[ i ] ][ dir ]( position, {\n                    targetWidth: targetWidth,\n                    targetHeight: targetHeight,\n                    elemWidth: elemWidth,\n                    elemHeight: elemHeight,\n                    collisionPosition: collisionPosition,\n                    collisionWidth: collisionWidth,\n                    collisionHeight: collisionHeight,\n                    offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\n                    my: options.my,\n                    at: options.at,\n                    within: within,\n                    elem: elem\n                });\n            }\n        });\n\n        if ( options.using ) {\n            // adds feedback as second argument to using callback, if present\n            using = function( props ) {\n                var left = targetOffset.left - position.left,\n                    right = left + targetWidth - elemWidth,\n                    top = targetOffset.top - position.top,\n                    bottom = top + targetHeight - elemHeight,\n                    feedback = {\n                        target: {\n                            element: target,\n                            left: targetOffset.left,\n                            top: targetOffset.top,\n                            width: targetWidth,\n                            height: targetHeight\n                        },\n                        element: {\n                            element: elem,\n                            left: position.left,\n                            top: position.top,\n                            width: elemWidth,\n                            height: elemHeight\n                        },\n                        horizontal: right < 0 ? \"left\" : left > 0 ? \"right\" : \"center\",\n                        vertical: bottom < 0 ? \"top\" : top > 0 ? \"bottom\" : \"middle\"\n                    };\n                if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\n                    feedback.horizontal = \"center\";\n                }\n                if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\n                    feedback.vertical = \"middle\";\n                }\n                if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\n                    feedback.important = \"horizontal\";\n                } else {\n                    feedback.important = \"vertical\";\n                }\n                options.using.call( this, props, feedback );\n            };\n        }\n\n        elem.offset( $.extend( position, { using: using } ) );\n    });\n};\n\n$.ui.position = {\n    fit: {\n        left: function( position, data ) {\n            var within = data.within,\n                withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\n                outerWidth = within.width,\n                collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n                overLeft = withinOffset - collisionPosLeft,\n                overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\n                newOverRight;\n\n            // element is wider than within\n            if ( data.collisionWidth > outerWidth ) {\n                // element is initially over the left side of within\n                if ( overLeft > 0 && overRight <= 0 ) {\n                    newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;\n                    position.left += overLeft - newOverRight;\n                // element is initially over right side of within\n                } else if ( overRight > 0 && overLeft <= 0 ) {\n                    position.left = withinOffset;\n                // element is initially over both left and right sides of within\n                } else {\n                    if ( overLeft > overRight ) {\n                        position.left = withinOffset + outerWidth - data.collisionWidth;\n                    } else {\n                        position.left = withinOffset;\n                    }\n                }\n            // too far left -> align with left edge\n            } else if ( overLeft > 0 ) {\n                position.left += overLeft;\n            // too far right -> align with right edge\n            } else if ( overRight > 0 ) {\n                position.left -= overRight;\n            // adjust based on position and margin\n            } else {\n                position.left = max( position.left - collisionPosLeft, position.left );\n            }\n        },\n        top: function( position, data ) {\n            var within = data.within,\n                withinOffset = within.isWindow ? within.scrollTop : within.offset.top,\n                outerHeight = data.within.height,\n                collisionPosTop = position.top - data.collisionPosition.marginTop,\n                overTop = withinOffset - collisionPosTop,\n                overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\n                newOverBottom;\n\n            // element is taller than within\n            if ( data.collisionHeight > outerHeight ) {\n                // element is initially over the top of within\n                if ( overTop > 0 && overBottom <= 0 ) {\n                    newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;\n                    position.top += overTop - newOverBottom;\n                // element is initially over bottom of within\n                } else if ( overBottom > 0 && overTop <= 0 ) {\n                    position.top = withinOffset;\n                // element is initially over both top and bottom of within\n                } else {\n                    if ( overTop > overBottom ) {\n                        position.top = withinOffset + outerHeight - data.collisionHeight;\n                    } else {\n                        position.top = withinOffset;\n                    }\n                }\n            // too far up -> align with top\n            } else if ( overTop > 0 ) {\n                position.top += overTop;\n            // too far down -> align with bottom edge\n            } else if ( overBottom > 0 ) {\n                position.top -= overBottom;\n            // adjust based on position and margin\n            } else {\n                position.top = max( position.top - collisionPosTop, position.top );\n            }\n        }\n    },\n    flip: {\n        left: function( position, data ) {\n            var within = data.within,\n                withinOffset = within.offset.left + within.scrollLeft,\n                outerWidth = within.width,\n                offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\n                collisionPosLeft = position.left - data.collisionPosition.marginLeft,\n                overLeft = collisionPosLeft - offsetLeft,\n                overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\n                myOffset = data.my[ 0 ] === \"left\" ?\n                    -data.elemWidth :\n                    data.my[ 0 ] === \"right\" ?\n                        data.elemWidth :\n                        0,\n                atOffset = data.at[ 0 ] === \"left\" ?\n                    data.targetWidth :\n                    data.at[ 0 ] === \"right\" ?\n                        -data.targetWidth :\n                        0,\n                offset = -2 * data.offset[ 0 ],\n                newOverRight,\n                newOverLeft;\n\n            if ( overLeft < 0 ) {\n                newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;\n                if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\n                    position.left += myOffset + atOffset + offset;\n                }\n            } else if ( overRight > 0 ) {\n                newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;\n                if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\n                    position.left += myOffset + atOffset + offset;\n                }\n            }\n        },\n        top: function( position, data ) {\n            var within = data.within,\n                withinOffset = within.offset.top + within.scrollTop,\n                outerHeight = within.height,\n                offsetTop = within.isWindow ? within.scrollTop : within.offset.top,\n                collisionPosTop = position.top - data.collisionPosition.marginTop,\n                overTop = collisionPosTop - offsetTop,\n                overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\n                top = data.my[ 1 ] === \"top\",\n                myOffset = top ?\n                    -data.elemHeight :\n                    data.my[ 1 ] === \"bottom\" ?\n                        data.elemHeight :\n                        0,\n                atOffset = data.at[ 1 ] === \"top\" ?\n                    data.targetHeight :\n                    data.at[ 1 ] === \"bottom\" ?\n                        -data.targetHeight :\n                        0,\n                offset = -2 * data.offset[ 1 ],\n                newOverTop,\n                newOverBottom;\n            if ( overTop < 0 ) {\n                newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;\n                if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {\n                    position.top += myOffset + atOffset + offset;\n                }\n            } else if ( overBottom > 0 ) {\n                newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;\n                if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {\n                    position.top += myOffset + atOffset + offset;\n                }\n            }\n        }\n    },\n    flipfit: {\n        left: function() {\n            $.ui.position.flip.left.apply( this, arguments );\n            $.ui.position.fit.left.apply( this, arguments );\n        },\n        top: function() {\n            $.ui.position.flip.top.apply( this, arguments );\n            $.ui.position.fit.top.apply( this, arguments );\n        }\n    }\n};\n\n// fraction support test\n(function() {\n    var testElement, testElementParent, testElementStyle, offsetLeft, i,\n        body = document.getElementsByTagName( \"body\" )[ 0 ],\n        div = document.createElement( \"div\" );\n\n    //Create a \"fake body\" for testing based on method used in jQuery.support\n    testElement = document.createElement( body ? \"div\" : \"body\" );\n    testElementStyle = {\n        visibility: \"hidden\",\n        width: 0,\n        height: 0,\n        border: 0,\n        margin: 0,\n        background: \"none\"\n    };\n    if ( body ) {\n        $.extend( testElementStyle, {\n            position: \"absolute\",\n            left: \"-1000px\",\n            top: \"-1000px\"\n        });\n    }\n    for ( i in testElementStyle ) {\n        testElement.style[ i ] = testElementStyle[ i ];\n    }\n    testElement.appendChild( div );\n    testElementParent = body || document.documentElement;\n    testElementParent.insertBefore( testElement, testElementParent.firstChild );\n\n    div.style.cssText = \"position: absolute; left: 10.7432222px;\";\n\n    offsetLeft = $( div ).offset().left;\n    supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;\n\n    testElement.innerHTML = \"\";\n    testElementParent.removeChild( testElement );\n})();\n\n})();\n\nvar position = $.ui.position;\n\n\n/*!\n * jQuery UI Accordion 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/accordion/\n */\n\n\nvar accordion = $.widget( \"ui.accordion\", {\n    version: \"1.11.2\",\n    options: {\n        active: 0,\n        animate: {},\n        collapsible: false,\n        event: \"click\",\n        header: \"> li > :first-child,> :not(li):even\",\n        heightStyle: \"auto\",\n        icons: {\n            activeHeader: \"ui-icon-triangle-1-s\",\n            header: \"ui-icon-triangle-1-e\"\n        },\n\n        // callbacks\n        activate: null,\n        beforeActivate: null\n    },\n\n    hideProps: {\n        borderTopWidth: \"hide\",\n        borderBottomWidth: \"hide\",\n        paddingTop: \"hide\",\n        paddingBottom: \"hide\",\n        height: \"hide\"\n    },\n\n    showProps: {\n        borderTopWidth: \"show\",\n        borderBottomWidth: \"show\",\n        paddingTop: \"show\",\n        paddingBottom: \"show\",\n        height: \"show\"\n    },\n\n    _create: function() {\n        var options = this.options;\n        this.prevShow = this.prevHide = $();\n        this.element.addClass( \"ui-accordion ui-widget ui-helper-reset\" )\n            // ARIA\n            .attr( \"role\", \"tablist\" );\n\n        // don't allow collapsible: false and active: false / null\n        if ( !options.collapsible && (options.active === false || options.active == null) ) {\n            options.active = 0;\n        }\n\n        this._processPanels();\n        // handle negative values\n        if ( options.active < 0 ) {\n            options.active += this.headers.length;\n        }\n        this._refresh();\n    },\n\n    _getCreateEventData: function() {\n        return {\n            header: this.active,\n            panel: !this.active.length ? $() : this.active.next()\n        };\n    },\n\n    _createIcons: function() {\n        var icons = this.options.icons;\n        if ( icons ) {\n            $( \"<span>\" )\n                .addClass( \"ui-accordion-header-icon ui-icon \" + icons.header )\n                .prependTo( this.headers );\n            this.active.children( \".ui-accordion-header-icon\" )\n                .removeClass( icons.header )\n                .addClass( icons.activeHeader );\n            this.headers.addClass( \"ui-accordion-icons\" );\n        }\n    },\n\n    _destroyIcons: function() {\n        this.headers\n            .removeClass( \"ui-accordion-icons\" )\n            .children( \".ui-accordion-header-icon\" )\n                .remove();\n    },\n\n    _destroy: function() {\n        var contents;\n\n        // clean up main element\n        this.element\n            .removeClass( \"ui-accordion ui-widget ui-helper-reset\" )\n            .removeAttr( \"role\" );\n\n        // clean up headers\n        this.headers\n            .removeClass( \"ui-accordion-header ui-accordion-header-active ui-state-default \" +\n                \"ui-corner-all ui-state-active ui-state-disabled ui-corner-top\" )\n            .removeAttr( \"role\" )\n            .removeAttr( \"aria-expanded\" )\n            .removeAttr( \"aria-selected\" )\n            .removeAttr( \"aria-controls\" )\n            .removeAttr( \"tabIndex\" )\n            .removeUniqueId();\n\n        this._destroyIcons();\n\n        // clean up content panels\n        contents = this.headers.next()\n            .removeClass( \"ui-helper-reset ui-widget-content ui-corner-bottom \" +\n                \"ui-accordion-content ui-accordion-content-active ui-state-disabled\" )\n            .css( \"display\", \"\" )\n            .removeAttr( \"role\" )\n            .removeAttr( \"aria-hidden\" )\n            .removeAttr( \"aria-labelledby\" )\n            .removeUniqueId();\n\n        if ( this.options.heightStyle !== \"content\" ) {\n            contents.css( \"height\", \"\" );\n        }\n    },\n\n    _setOption: function( key, value ) {\n        if ( key === \"active\" ) {\n            // _activate() will handle invalid values and update this.options\n            this._activate( value );\n            return;\n        }\n\n        if ( key === \"event\" ) {\n            if ( this.options.event ) {\n                this._off( this.headers, this.options.event );\n            }\n            this._setupEvents( value );\n        }\n\n        this._super( key, value );\n\n        // setting collapsible: false while collapsed; open first panel\n        if ( key === \"collapsible\" && !value && this.options.active === false ) {\n            this._activate( 0 );\n        }\n\n        if ( key === \"icons\" ) {\n            this._destroyIcons();\n            if ( value ) {\n                this._createIcons();\n            }\n        }\n\n        // #5332 - opacity doesn't cascade to positioned elements in IE\n        // so we need to add the disabled class to the headers and panels\n        if ( key === \"disabled\" ) {\n            this.element\n                .toggleClass( \"ui-state-disabled\", !!value )\n                .attr( \"aria-disabled\", value );\n            this.headers.add( this.headers.next() )\n                .toggleClass( \"ui-state-disabled\", !!value );\n        }\n    },\n\n    _keydown: function( event ) {\n        if ( event.altKey || event.ctrlKey ) {\n            return;\n        }\n\n        var keyCode = $.ui.keyCode,\n            length = this.headers.length,\n            currentIndex = this.headers.index( event.target ),\n            toFocus = false;\n\n        switch ( event.keyCode ) {\n            case keyCode.RIGHT:\n            case keyCode.DOWN:\n                toFocus = this.headers[ ( currentIndex + 1 ) % length ];\n                break;\n            case keyCode.LEFT:\n            case keyCode.UP:\n                toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];\n                break;\n            case keyCode.SPACE:\n            case keyCode.ENTER:\n                this._eventHandler( event );\n                break;\n            case keyCode.HOME:\n                toFocus = this.headers[ 0 ];\n                break;\n            case keyCode.END:\n                toFocus = this.headers[ length - 1 ];\n                break;\n        }\n\n        if ( toFocus ) {\n            $( event.target ).attr( \"tabIndex\", -1 );\n            $( toFocus ).attr( \"tabIndex\", 0 );\n            toFocus.focus();\n            event.preventDefault();\n        }\n    },\n\n    _panelKeyDown: function( event ) {\n        if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {\n            $( event.currentTarget ).prev().focus();\n        }\n    },\n\n    refresh: function() {\n        var options = this.options;\n        this._processPanels();\n\n        // was collapsed or no panel\n        if ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {\n            options.active = false;\n            this.active = $();\n        // active false only when collapsible is true\n        } else if ( options.active === false ) {\n            this._activate( 0 );\n        // was active, but active panel is gone\n        } else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {\n            // all remaining panel are disabled\n            if ( this.headers.length === this.headers.find(\".ui-state-disabled\").length ) {\n                options.active = false;\n                this.active = $();\n            // activate previous panel\n            } else {\n                this._activate( Math.max( 0, options.active - 1 ) );\n            }\n        // was active, active panel still exists\n        } else {\n            // make sure active index is correct\n            options.active = this.headers.index( this.active );\n        }\n\n        this._destroyIcons();\n\n        this._refresh();\n    },\n\n    _processPanels: function() {\n        var prevHeaders = this.headers,\n            prevPanels = this.panels;\n\n        this.headers = this.element.find( this.options.header )\n            .addClass( \"ui-accordion-header ui-state-default ui-corner-all\" );\n\n        this.panels = this.headers.next()\n            .addClass( \"ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom\" )\n            .filter( \":not(.ui-accordion-content-active)\" )\n            .hide();\n\n        // Avoid memory leaks (#10056)\n        if ( prevPanels ) {\n            this._off( prevHeaders.not( this.headers ) );\n            this._off( prevPanels.not( this.panels ) );\n        }\n    },\n\n    _refresh: function() {\n        var maxHeight,\n            options = this.options,\n            heightStyle = options.heightStyle,\n            parent = this.element.parent();\n\n        this.active = this._findActive( options.active )\n            .addClass( \"ui-accordion-header-active ui-state-active ui-corner-top\" )\n            .removeClass( \"ui-corner-all\" );\n        this.active.next()\n            .addClass( \"ui-accordion-content-active\" )\n            .show();\n\n        this.headers\n            .attr( \"role\", \"tab\" )\n            .each(function() {\n                var header = $( this ),\n                    headerId = header.uniqueId().attr( \"id\" ),\n                    panel = header.next(),\n                    panelId = panel.uniqueId().attr( \"id\" );\n                header.attr( \"aria-controls\", panelId );\n                panel.attr( \"aria-labelledby\", headerId );\n            })\n            .next()\n                .attr( \"role\", \"tabpanel\" );\n\n        this.headers\n            .not( this.active )\n            .attr({\n                \"aria-selected\": \"false\",\n                \"aria-expanded\": \"false\",\n                tabIndex: -1\n            })\n            .next()\n                .attr({\n                    \"aria-hidden\": \"true\"\n                })\n                .hide();\n\n        // make sure at least one header is in the tab order\n        if ( !this.active.length ) {\n            this.headers.eq( 0 ).attr( \"tabIndex\", 0 );\n        } else {\n            this.active.attr({\n                \"aria-selected\": \"true\",\n                \"aria-expanded\": \"true\",\n                tabIndex: 0\n            })\n            .next()\n                .attr({\n                    \"aria-hidden\": \"false\"\n                });\n        }\n\n        this._createIcons();\n\n        this._setupEvents( options.event );\n\n        if ( heightStyle === \"fill\" ) {\n            maxHeight = parent.height();\n            this.element.siblings( \":visible\" ).each(function() {\n                var elem = $( this ),\n                    position = elem.css( \"position\" );\n\n                if ( position === \"absolute\" || position === \"fixed\" ) {\n                    return;\n                }\n                maxHeight -= elem.outerHeight( true );\n            });\n\n            this.headers.each(function() {\n                maxHeight -= $( this ).outerHeight( true );\n            });\n\n            this.headers.next()\n                .each(function() {\n                    $( this ).height( Math.max( 0, maxHeight -\n                        $( this ).innerHeight() + $( this ).height() ) );\n                })\n                .css( \"overflow\", \"auto\" );\n        } else if ( heightStyle === \"auto\" ) {\n            maxHeight = 0;\n            this.headers.next()\n                .each(function() {\n                    maxHeight = Math.max( maxHeight, $( this ).css( \"height\", \"\" ).height() );\n                })\n                .height( maxHeight );\n        }\n    },\n\n    _activate: function( index ) {\n        var active = this._findActive( index )[ 0 ];\n\n        // trying to activate the already active panel\n        if ( active === this.active[ 0 ] ) {\n            return;\n        }\n\n        // trying to collapse, simulate a click on the currently active header\n        active = active || this.active[ 0 ];\n\n        this._eventHandler({\n            target: active,\n            currentTarget: active,\n            preventDefault: $.noop\n        });\n    },\n\n    _findActive: function( selector ) {\n        return typeof selector === \"number\" ? this.headers.eq( selector ) : $();\n    },\n\n    _setupEvents: function( event ) {\n        var events = {\n            keydown: \"_keydown\"\n        };\n        if ( event ) {\n            $.each( event.split( \" \" ), function( index, eventName ) {\n                events[ eventName ] = \"_eventHandler\";\n            });\n        }\n\n        this._off( this.headers.add( this.headers.next() ) );\n        this._on( this.headers, events );\n        this._on( this.headers.next(), { keydown: \"_panelKeyDown\" });\n        this._hoverable( this.headers );\n        this._focusable( this.headers );\n    },\n\n    _eventHandler: function( event ) {\n        var options = this.options,\n            active = this.active,\n            clicked = $( event.currentTarget ),\n            clickedIsActive = clicked[ 0 ] === active[ 0 ],\n            collapsing = clickedIsActive && options.collapsible,\n            toShow = collapsing ? $() : clicked.next(),\n            toHide = active.next(),\n            eventData = {\n                oldHeader: active,\n                oldPanel: toHide,\n                newHeader: collapsing ? $() : clicked,\n                newPanel: toShow\n            };\n\n        event.preventDefault();\n\n        if (\n                // click on active header, but not collapsible\n                ( clickedIsActive && !options.collapsible ) ||\n                // allow canceling activation\n                ( this._trigger( \"beforeActivate\", event, eventData ) === false ) ) {\n            return;\n        }\n\n        options.active = collapsing ? false : this.headers.index( clicked );\n\n        // when the call to ._toggle() comes after the class changes\n        // it causes a very odd bug in IE 8 (see #6720)\n        this.active = clickedIsActive ? $() : clicked;\n        this._toggle( eventData );\n\n        // switch classes\n        // corner classes on the previously active header stay after the animation\n        active.removeClass( \"ui-accordion-header-active ui-state-active\" );\n        if ( options.icons ) {\n            active.children( \".ui-accordion-header-icon\" )\n                .removeClass( options.icons.activeHeader )\n                .addClass( options.icons.header );\n        }\n\n        if ( !clickedIsActive ) {\n            clicked\n                .removeClass( \"ui-corner-all\" )\n                .addClass( \"ui-accordion-header-active ui-state-active ui-corner-top\" );\n            if ( options.icons ) {\n                clicked.children( \".ui-accordion-header-icon\" )\n                    .removeClass( options.icons.header )\n                    .addClass( options.icons.activeHeader );\n            }\n\n            clicked\n                .next()\n                .addClass( \"ui-accordion-content-active\" );\n        }\n    },\n\n    _toggle: function( data ) {\n        var toShow = data.newPanel,\n            toHide = this.prevShow.length ? this.prevShow : data.oldPanel;\n\n        // handle activating a panel during the animation for another activation\n        this.prevShow.add( this.prevHide ).stop( true, true );\n        this.prevShow = toShow;\n        this.prevHide = toHide;\n\n        if ( this.options.animate ) {\n            this._animate( toShow, toHide, data );\n        } else {\n            toHide.hide();\n            toShow.show();\n            this._toggleComplete( data );\n        }\n\n        toHide.attr({\n            \"aria-hidden\": \"true\"\n        });\n        toHide.prev().attr( \"aria-selected\", \"false\" );\n        // if we're switching panels, remove the old header from the tab order\n        // if we're opening from collapsed state, remove the previous header from the tab order\n        // if we're collapsing, then keep the collapsing header in the tab order\n        if ( toShow.length && toHide.length ) {\n            toHide.prev().attr({\n                \"tabIndex\": -1,\n                \"aria-expanded\": \"false\"\n            });\n        } else if ( toShow.length ) {\n            this.headers.filter(function() {\n                return $( this ).attr( \"tabIndex\" ) === 0;\n            })\n            .attr( \"tabIndex\", -1 );\n        }\n\n        toShow\n            .attr( \"aria-hidden\", \"false\" )\n            .prev()\n                .attr({\n                    \"aria-selected\": \"true\",\n                    tabIndex: 0,\n                    \"aria-expanded\": \"true\"\n                });\n    },\n\n    _animate: function( toShow, toHide, data ) {\n        var total, easing, duration,\n            that = this,\n            adjust = 0,\n            down = toShow.length &&\n                ( !toHide.length || ( toShow.index() < toHide.index() ) ),\n            animate = this.options.animate || {},\n            options = down && animate.down || animate,\n            complete = function() {\n                that._toggleComplete( data );\n            };\n\n        if ( typeof options === \"number\" ) {\n            duration = options;\n        }\n        if ( typeof options === \"string\" ) {\n            easing = options;\n        }\n        // fall back from options to animation in case of partial down settings\n        easing = easing || options.easing || animate.easing;\n        duration = duration || options.duration || animate.duration;\n\n        if ( !toHide.length ) {\n            return toShow.animate( this.showProps, duration, easing, complete );\n        }\n        if ( !toShow.length ) {\n            return toHide.animate( this.hideProps, duration, easing, complete );\n        }\n\n        total = toShow.show().outerHeight();\n        toHide.animate( this.hideProps, {\n            duration: duration,\n            easing: easing,\n            step: function( now, fx ) {\n                fx.now = Math.round( now );\n            }\n        });\n        toShow\n            .hide()\n            .animate( this.showProps, {\n                duration: duration,\n                easing: easing,\n                complete: complete,\n                step: function( now, fx ) {\n                    fx.now = Math.round( now );\n                    if ( fx.prop !== \"height\" ) {\n                        adjust += fx.now;\n                    } else if ( that.options.heightStyle !== \"content\" ) {\n                        fx.now = Math.round( total - toHide.outerHeight() - adjust );\n                        adjust = 0;\n                    }\n                }\n            });\n    },\n\n    _toggleComplete: function( data ) {\n        var toHide = data.oldPanel;\n\n        toHide\n            .removeClass( \"ui-accordion-content-active\" )\n            .prev()\n                .removeClass( \"ui-corner-top\" )\n                .addClass( \"ui-corner-all\" );\n\n        // Work around for rendering bug in IE (#5421)\n        if ( toHide.length ) {\n            toHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;\n        }\n        this._trigger( \"activate\", null, data );\n    }\n});\n\n\n/*!\n * jQuery UI Menu 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/menu/\n */\n\n\nvar menu = $.widget( \"ui.menu\", {\n    version: \"1.11.2\",\n    defaultElement: \"<ul>\",\n    delay: 300,\n    options: {\n        icons: {\n            submenu: \"ui-icon-carat-1-e\"\n        },\n        items: \"> *\",\n        menus: \"ul\",\n        position: {\n            my: \"left-1 top\",\n            at: \"right top\"\n        },\n        role: \"menu\",\n\n        // callbacks\n        blur: null,\n        focus: null,\n        select: null\n    },\n\n    _create: function() {\n        this.activeMenu = this.element;\n\n        // Flag used to prevent firing of the click handler\n        // as the event bubbles up through nested menus\n        this.mouseHandled = false;\n        this.element\n            .uniqueId()\n            .addClass( \"ui-menu ui-widget ui-widget-content\" )\n            .toggleClass( \"ui-menu-icons\", !!this.element.find( \".ui-icon\" ).length )\n            .attr({\n                role: this.options.role,\n                tabIndex: 0\n            });\n\n        if ( this.options.disabled ) {\n            this.element\n                .addClass( \"ui-state-disabled\" )\n                .attr( \"aria-disabled\", \"true\" );\n        }\n\n        this._on({\n            // Prevent focus from sticking to links inside menu after clicking\n            // them (focus should always stay on UL during navigation).\n            \"mousedown .ui-menu-item\": function( event ) {\n                event.preventDefault();\n            },\n            \"click .ui-menu-item\": function( event ) {\n                var target = $( event.target );\n                if ( !this.mouseHandled && target.not( \".ui-state-disabled\" ).length ) {\n                    this.select( event );\n\n                    // Only set the mouseHandled flag if the event will bubble, see #9469.\n                    if ( !event.isPropagationStopped() ) {\n                        this.mouseHandled = true;\n                    }\n\n                    // Open submenu on click\n                    if ( target.has( \".ui-menu\" ).length ) {\n                        this.expand( event );\n                    } else if ( !this.element.is( \":focus\" ) && $( this.document[ 0 ].activeElement ).closest( \".ui-menu\" ).length ) {\n\n                        // Redirect focus to the menu\n                        this.element.trigger( \"focus\", [ true ] );\n\n                        // If the active item is on the top level, let it stay active.\n                        // Otherwise, blur the active item since it is no longer visible.\n                        if ( this.active && this.active.parents( \".ui-menu\" ).length === 1 ) {\n                            clearTimeout( this.timer );\n                        }\n                    }\n                }\n            },\n            \"mouseenter .ui-menu-item\": function( event ) {\n                // Ignore mouse events while typeahead is active, see #10458.\n                // Prevents focusing the wrong item when typeahead causes a scroll while the mouse\n                // is over an item in the menu\n                if ( this.previousFilter ) {\n                    return;\n                }\n                var target = $( event.currentTarget );\n                // Remove ui-state-active class from siblings of the newly focused menu item\n                // to avoid a jump caused by adjacent elements both having a class with a border\n                target.siblings( \".ui-state-active\" ).removeClass( \"ui-state-active\" );\n                this.focus( event, target );\n            },\n            mouseleave: \"collapseAll\",\n            \"mouseleave .ui-menu\": \"collapseAll\",\n            focus: function( event, keepActiveItem ) {\n                // If there's already an active item, keep it active\n                // If not, activate the first item\n                var item = this.active || this.element.find( this.options.items ).eq( 0 );\n\n                if ( !keepActiveItem ) {\n                    this.focus( event, item );\n                }\n            },\n            blur: function( event ) {\n                this._delay(function() {\n                    if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {\n                        this.collapseAll( event );\n                    }\n                });\n            },\n            keydown: \"_keydown\"\n        });\n\n        this.refresh();\n\n        // Clicks outside of a menu collapse any open menus\n        this._on( this.document, {\n            click: function( event ) {\n                if ( this._closeOnDocumentClick( event ) ) {\n                    this.collapseAll( event );\n                }\n\n                // Reset the mouseHandled flag\n                this.mouseHandled = false;\n            }\n        });\n    },\n\n    _destroy: function() {\n        // Destroy (sub)menus\n        this.element\n            .removeAttr( \"aria-activedescendant\" )\n            .find( \".ui-menu\" ).addBack()\n                .removeClass( \"ui-menu ui-widget ui-widget-content ui-menu-icons ui-front\" )\n                .removeAttr( \"role\" )\n                .removeAttr( \"tabIndex\" )\n                .removeAttr( \"aria-labelledby\" )\n                .removeAttr( \"aria-expanded\" )\n                .removeAttr( \"aria-hidden\" )\n                .removeAttr( \"aria-disabled\" )\n                .removeUniqueId()\n                .show();\n\n        // Destroy menu items\n        this.element.find( \".ui-menu-item\" )\n            .removeClass( \"ui-menu-item\" )\n            .removeAttr( \"role\" )\n            .removeAttr( \"aria-disabled\" )\n            .removeUniqueId()\n            .removeClass( \"ui-state-hover\" )\n            .removeAttr( \"tabIndex\" )\n            .removeAttr( \"role\" )\n            .removeAttr( \"aria-haspopup\" )\n            .children().each( function() {\n                var elem = $( this );\n                if ( elem.data( \"ui-menu-submenu-carat\" ) ) {\n                    elem.remove();\n                }\n            });\n\n        // Destroy menu dividers\n        this.element.find( \".ui-menu-divider\" ).removeClass( \"ui-menu-divider ui-widget-content\" );\n    },\n\n    _keydown: function( event ) {\n        var match, prev, character, skip,\n            preventDefault = true;\n\n        switch ( event.keyCode ) {\n        case $.ui.keyCode.PAGE_UP:\n            this.previousPage( event );\n            break;\n        case $.ui.keyCode.PAGE_DOWN:\n            this.nextPage( event );\n            break;\n        case $.ui.keyCode.HOME:\n            this._move( \"first\", \"first\", event );\n            break;\n        case $.ui.keyCode.END:\n            this._move( \"last\", \"last\", event );\n            break;\n        case $.ui.keyCode.UP:\n            this.previous( event );\n            break;\n        case $.ui.keyCode.DOWN:\n            this.next( event );\n            break;\n        case $.ui.keyCode.LEFT:\n            this.collapse( event );\n            break;\n        case $.ui.keyCode.RIGHT:\n            if ( this.active && !this.active.is( \".ui-state-disabled\" ) ) {\n                this.expand( event );\n            }\n            break;\n        case $.ui.keyCode.ENTER:\n        case $.ui.keyCode.SPACE:\n            this._activate( event );\n            break;\n        case $.ui.keyCode.ESCAPE:\n            this.collapse( event );\n            break;\n        default:\n            preventDefault = false;\n            prev = this.previousFilter || \"\";\n            character = String.fromCharCode( event.keyCode );\n            skip = false;\n\n            clearTimeout( this.filterTimer );\n\n            if ( character === prev ) {\n                skip = true;\n            } else {\n                character = prev + character;\n            }\n\n            match = this._filterMenuItems( character );\n            match = skip && match.index( this.active.next() ) !== -1 ?\n                this.active.nextAll( \".ui-menu-item\" ) :\n                match;\n\n            // If no matches on the current filter, reset to the last character pressed\n            // to move down the menu to the first item that starts with that character\n            if ( !match.length ) {\n                character = String.fromCharCode( event.keyCode );\n                match = this._filterMenuItems( character );\n            }\n\n            if ( match.length ) {\n                this.focus( event, match );\n                this.previousFilter = character;\n                this.filterTimer = this._delay(function() {\n                    delete this.previousFilter;\n                }, 1000 );\n            } else {\n                delete this.previousFilter;\n            }\n        }\n\n        if ( preventDefault ) {\n            event.preventDefault();\n        }\n    },\n\n    _activate: function( event ) {\n        if ( !this.active.is( \".ui-state-disabled\" ) ) {\n            if ( this.active.is( \"[aria-haspopup='true']\" ) ) {\n                this.expand( event );\n            } else {\n                this.select( event );\n            }\n        }\n    },\n\n    refresh: function() {\n        var menus, items,\n            that = this,\n            icon = this.options.icons.submenu,\n            submenus = this.element.find( this.options.menus );\n\n        this.element.toggleClass( \"ui-menu-icons\", !!this.element.find( \".ui-icon\" ).length );\n\n        // Initialize nested menus\n        submenus.filter( \":not(.ui-menu)\" )\n            .addClass( \"ui-menu ui-widget ui-widget-content ui-front\" )\n            .hide()\n            .attr({\n                role: this.options.role,\n                \"aria-hidden\": \"true\",\n                \"aria-expanded\": \"false\"\n            })\n            .each(function() {\n                var menu = $( this ),\n                    item = menu.parent(),\n                    submenuCarat = $( \"<span>\" )\n                        .addClass( \"ui-menu-icon ui-icon \" + icon )\n                        .data( \"ui-menu-submenu-carat\", true );\n\n                item\n                    .attr( \"aria-haspopup\", \"true\" )\n                    .prepend( submenuCarat );\n                menu.attr( \"aria-labelledby\", item.attr( \"id\" ) );\n            });\n\n        menus = submenus.add( this.element );\n        items = menus.find( this.options.items );\n\n        // Initialize menu-items containing spaces and/or dashes only as dividers\n        items.not( \".ui-menu-item\" ).each(function() {\n            var item = $( this );\n            if ( that._isDivider( item ) ) {\n                item.addClass( \"ui-widget-content ui-menu-divider\" );\n            }\n        });\n\n        // Don't refresh list items that are already adapted\n        items.not( \".ui-menu-item, .ui-menu-divider\" )\n            .addClass( \"ui-menu-item\" )\n            .uniqueId()\n            .attr({\n                tabIndex: -1,\n                role: this._itemRole()\n            });\n\n        // Add aria-disabled attribute to any disabled menu item\n        items.filter( \".ui-state-disabled\" ).attr( \"aria-disabled\", \"true\" );\n\n        // If the active item has been removed, blur the menu\n        if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {\n            this.blur();\n        }\n    },\n\n    _itemRole: function() {\n        return {\n            menu: \"menuitem\",\n            listbox: \"option\"\n        }[ this.options.role ];\n    },\n\n    _setOption: function( key, value ) {\n        if ( key === \"icons\" ) {\n            this.element.find( \".ui-menu-icon\" )\n                .removeClass( this.options.icons.submenu )\n                .addClass( value.submenu );\n        }\n        if ( key === \"disabled\" ) {\n            this.element\n                .toggleClass( \"ui-state-disabled\", !!value )\n                .attr( \"aria-disabled\", value );\n        }\n        this._super( key, value );\n    },\n\n    focus: function( event, item ) {\n        var nested, focused;\n        this.blur( event, event && event.type === \"focus\" );\n\n        this._scrollIntoView( item );\n\n        this.active = item.first();\n        focused = this.active.addClass( \"ui-state-focus\" ).removeClass( \"ui-state-active\" );\n        // Only update aria-activedescendant if there's a role\n        // otherwise we assume focus is managed elsewhere\n        if ( this.options.role ) {\n            this.element.attr( \"aria-activedescendant\", focused.attr( \"id\" ) );\n        }\n\n        // Highlight active parent menu item, if any\n        this.active\n            .parent()\n            .closest( \".ui-menu-item\" )\n            .addClass( \"ui-state-active\" );\n\n        if ( event && event.type === \"keydown\" ) {\n            this._close();\n        } else {\n            this.timer = this._delay(function() {\n                this._close();\n            }, this.delay );\n        }\n\n        nested = item.children( \".ui-menu\" );\n        if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {\n            this._startOpening(nested);\n        }\n        this.activeMenu = item.parent();\n\n        this._trigger( \"focus\", event, { item: item } );\n    },\n\n    _scrollIntoView: function( item ) {\n        var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;\n        if ( this._hasScroll() ) {\n            borderTop = parseFloat( $.css( this.activeMenu[0], \"borderTopWidth\" ) ) || 0;\n            paddingTop = parseFloat( $.css( this.activeMenu[0], \"paddingTop\" ) ) || 0;\n            offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;\n            scroll = this.activeMenu.scrollTop();\n            elementHeight = this.activeMenu.height();\n            itemHeight = item.outerHeight();\n\n            if ( offset < 0 ) {\n                this.activeMenu.scrollTop( scroll + offset );\n            } else if ( offset + itemHeight > elementHeight ) {\n                this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );\n            }\n        }\n    },\n\n    blur: function( event, fromFocus ) {\n        if ( !fromFocus ) {\n            clearTimeout( this.timer );\n        }\n\n        if ( !this.active ) {\n            return;\n        }\n\n        this.active.removeClass( \"ui-state-focus\" );\n        this.active = null;\n\n        this._trigger( \"blur\", event, { item: this.active } );\n    },\n\n    _startOpening: function( submenu ) {\n        clearTimeout( this.timer );\n\n        // Don't open if already open fixes a Firefox bug that caused a .5 pixel\n        // shift in the submenu position when mousing over the carat icon\n        if ( submenu.attr( \"aria-hidden\" ) !== \"true\" ) {\n            return;\n        }\n\n        this.timer = this._delay(function() {\n            this._close();\n            this._open( submenu );\n        }, this.delay );\n    },\n\n    _open: function( submenu ) {\n        var position = $.extend({\n            of: this.active\n        }, this.options.position );\n\n        clearTimeout( this.timer );\n        this.element.find( \".ui-menu\" ).not( submenu.parents( \".ui-menu\" ) )\n            .hide()\n            .attr( \"aria-hidden\", \"true\" );\n\n        submenu\n            .show()\n            .removeAttr( \"aria-hidden\" )\n            .attr( \"aria-expanded\", \"true\" )\n            .position( position );\n    },\n\n    collapseAll: function( event, all ) {\n        clearTimeout( this.timer );\n        this.timer = this._delay(function() {\n            // If we were passed an event, look for the submenu that contains the event\n            var currentMenu = all ? this.element :\n                $( event && event.target ).closest( this.element.find( \".ui-menu\" ) );\n\n            // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway\n            if ( !currentMenu.length ) {\n                currentMenu = this.element;\n            }\n\n            this._close( currentMenu );\n\n            this.blur( event );\n            this.activeMenu = currentMenu;\n        }, this.delay );\n    },\n\n    // With no arguments, closes the currently active menu - if nothing is active\n    // it closes all menus.  If passed an argument, it will search for menus BELOW\n    _close: function( startMenu ) {\n        if ( !startMenu ) {\n            startMenu = this.active ? this.active.parent() : this.element;\n        }\n\n        startMenu\n            .find( \".ui-menu\" )\n                .hide()\n                .attr( \"aria-hidden\", \"true\" )\n                .attr( \"aria-expanded\", \"false\" )\n            .end()\n            .find( \".ui-state-active\" ).not( \".ui-state-focus\" )\n                .removeClass( \"ui-state-active\" );\n    },\n\n    _closeOnDocumentClick: function( event ) {\n        return !$( event.target ).closest( \".ui-menu\" ).length;\n    },\n\n    _isDivider: function( item ) {\n\n        // Match hyphen, em dash, en dash\n        return !/[^\\-\\u2014\\u2013\\s]/.test( item.text() );\n    },\n\n    collapse: function( event ) {\n        var newItem = this.active &&\n            this.active.parent().closest( \".ui-menu-item\", this.element );\n        if ( newItem && newItem.length ) {\n            this._close();\n            this.focus( event, newItem );\n        }\n    },\n\n    expand: function( event ) {\n        var newItem = this.active &&\n            this.active\n                .children( \".ui-menu \" )\n                .find( this.options.items )\n                .first();\n\n        if ( newItem && newItem.length ) {\n            this._open( newItem.parent() );\n\n            // Delay so Firefox will not hide activedescendant change in expanding submenu from AT\n            this._delay(function() {\n                this.focus( event, newItem );\n            });\n        }\n    },\n\n    next: function( event ) {\n        this._move( \"next\", \"first\", event );\n    },\n\n    previous: function( event ) {\n        this._move( \"prev\", \"last\", event );\n    },\n\n    isFirstItem: function() {\n        return this.active && !this.active.prevAll( \".ui-menu-item\" ).length;\n    },\n\n    isLastItem: function() {\n        return this.active && !this.active.nextAll( \".ui-menu-item\" ).length;\n    },\n\n    _move: function( direction, filter, event ) {\n        var next;\n        if ( this.active ) {\n            if ( direction === \"first\" || direction === \"last\" ) {\n                next = this.active\n                    [ direction === \"first\" ? \"prevAll\" : \"nextAll\" ]( \".ui-menu-item\" )\n                    .eq( -1 );\n            } else {\n                next = this.active\n                    [ direction + \"All\" ]( \".ui-menu-item\" )\n                    .eq( 0 );\n            }\n        }\n        if ( !next || !next.length || !this.active ) {\n            next = this.activeMenu.find( this.options.items )[ filter ]();\n        }\n\n        this.focus( event, next );\n    },\n\n    nextPage: function( event ) {\n        var item, base, height;\n\n        if ( !this.active ) {\n            this.next( event );\n            return;\n        }\n        if ( this.isLastItem() ) {\n            return;\n        }\n        if ( this._hasScroll() ) {\n            base = this.active.offset().top;\n            height = this.element.height();\n            this.active.nextAll( \".ui-menu-item\" ).each(function() {\n                item = $( this );\n                return item.offset().top - base - height < 0;\n            });\n\n            this.focus( event, item );\n        } else {\n            this.focus( event, this.activeMenu.find( this.options.items )\n                [ !this.active ? \"first\" : \"last\" ]() );\n        }\n    },\n\n    previousPage: function( event ) {\n        var item, base, height;\n        if ( !this.active ) {\n            this.next( event );\n            return;\n        }\n        if ( this.isFirstItem() ) {\n            return;\n        }\n        if ( this._hasScroll() ) {\n            base = this.active.offset().top;\n            height = this.element.height();\n            this.active.prevAll( \".ui-menu-item\" ).each(function() {\n                item = $( this );\n                return item.offset().top - base + height > 0;\n            });\n\n            this.focus( event, item );\n        } else {\n            this.focus( event, this.activeMenu.find( this.options.items ).first() );\n        }\n    },\n\n    _hasScroll: function() {\n        return this.element.outerHeight() < this.element.prop( \"scrollHeight\" );\n    },\n\n    select: function( event ) {\n        // TODO: It should never be possible to not have an active item at this\n        // point, but the tests don't trigger mouseenter before click.\n        this.active = this.active || $( event.target ).closest( \".ui-menu-item\" );\n        var ui = { item: this.active };\n        if ( !this.active.has( \".ui-menu\" ).length ) {\n            this.collapseAll( event, true );\n        }\n        this._trigger( \"select\", event, ui );\n    },\n\n    _filterMenuItems: function(character) {\n        var escapedCharacter = character.replace( /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\" ),\n            regex = new RegExp( \"^\" + escapedCharacter, \"i\" );\n\n        return this.activeMenu\n            .find( this.options.items )\n\n            // Only match on items, not dividers or other content (#10571)\n            .filter( \".ui-menu-item\" )\n            .filter(function() {\n                return regex.test( $.trim( $( this ).text() ) );\n            });\n    }\n});\n\n\n/*!\n * jQuery UI Autocomplete 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/autocomplete/\n */\n\n\n$.widget( \"ui.autocomplete\", {\n    version: \"1.11.2\",\n    defaultElement: \"<input>\",\n    options: {\n        appendTo: null,\n        autoFocus: false,\n        delay: 300,\n        minLength: 1,\n        position: {\n            my: \"left top\",\n            at: \"left bottom\",\n            collision: \"none\"\n        },\n        source: null,\n\n        // callbacks\n        change: null,\n        close: null,\n        focus: null,\n        open: null,\n        response: null,\n        search: null,\n        select: null\n    },\n\n    requestIndex: 0,\n    pending: 0,\n\n    _create: function() {\n        // Some browsers only repeat keydown events, not keypress events,\n        // so we use the suppressKeyPress flag to determine if we've already\n        // handled the keydown event. #7269\n        // Unfortunately the code for & in keypress is the same as the up arrow,\n        // so we use the suppressKeyPressRepeat flag to avoid handling keypress\n        // events when we know the keydown event was used to modify the\n        // search term. #7799\n        var suppressKeyPress, suppressKeyPressRepeat, suppressInput,\n            nodeName = this.element[ 0 ].nodeName.toLowerCase(),\n            isTextarea = nodeName === \"textarea\",\n            isInput = nodeName === \"input\";\n\n        this.isMultiLine =\n            // Textareas are always multi-line\n            isTextarea ? true :\n            // Inputs are always single-line, even if inside a contentEditable element\n            // IE also treats inputs as contentEditable\n            isInput ? false :\n            // All other element types are determined by whether or not they're contentEditable\n            this.element.prop( \"isContentEditable\" );\n\n        this.valueMethod = this.element[ isTextarea || isInput ? \"val\" : \"text\" ];\n        this.isNewMenu = true;\n\n        this.element\n            .addClass( \"ui-autocomplete-input\" )\n            .attr( \"autocomplete\", \"off\" );\n\n        this._on( this.element, {\n            keydown: function( event ) {\n                if ( this.element.prop( \"readOnly\" ) ) {\n                    suppressKeyPress = true;\n                    suppressInput = true;\n                    suppressKeyPressRepeat = true;\n                    return;\n                }\n\n                suppressKeyPress = false;\n                suppressInput = false;\n                suppressKeyPressRepeat = false;\n                var keyCode = $.ui.keyCode;\n                switch ( event.keyCode ) {\n                case keyCode.PAGE_UP:\n                    suppressKeyPress = true;\n                    this._move( \"previousPage\", event );\n                    break;\n                case keyCode.PAGE_DOWN:\n                    suppressKeyPress = true;\n                    this._move( \"nextPage\", event );\n                    break;\n                case keyCode.UP:\n                    suppressKeyPress = true;\n                    this._keyEvent( \"previous\", event );\n                    break;\n                case keyCode.DOWN:\n                    suppressKeyPress = true;\n                    this._keyEvent( \"next\", event );\n                    break;\n                case keyCode.ENTER:\n                    // when menu is open and has focus\n                    if ( this.menu.active ) {\n                        // #6055 - Opera still allows the keypress to occur\n                        // which causes forms to submit\n                        suppressKeyPress = true;\n                        event.preventDefault();\n                        this.menu.select( event );\n                    }\n                    break;\n                case keyCode.TAB:\n                    if ( this.menu.active ) {\n                        this.menu.select( event );\n                    }\n                    break;\n                case keyCode.ESCAPE:\n                    if ( this.menu.element.is( \":visible\" ) ) {\n                        if ( !this.isMultiLine ) {\n                            this._value( this.term );\n                        }\n                        this.close( event );\n                        // Different browsers have different default behavior for escape\n                        // Single press can mean undo or clear\n                        // Double press in IE means clear the whole form\n                        event.preventDefault();\n                    }\n                    break;\n                default:\n                    suppressKeyPressRepeat = true;\n                    // search timeout should be triggered before the input value is changed\n                    this._searchTimeout( event );\n                    break;\n                }\n            },\n            keypress: function( event ) {\n                if ( suppressKeyPress ) {\n                    suppressKeyPress = false;\n                    if ( !this.isMultiLine || this.menu.element.is( \":visible\" ) ) {\n                        event.preventDefault();\n                    }\n                    return;\n                }\n                if ( suppressKeyPressRepeat ) {\n                    return;\n                }\n\n                // replicate some key handlers to allow them to repeat in Firefox and Opera\n                var keyCode = $.ui.keyCode;\n                switch ( event.keyCode ) {\n                case keyCode.PAGE_UP:\n                    this._move( \"previousPage\", event );\n                    break;\n                case keyCode.PAGE_DOWN:\n                    this._move( \"nextPage\", event );\n                    break;\n                case keyCode.UP:\n                    this._keyEvent( \"previous\", event );\n                    break;\n                case keyCode.DOWN:\n                    this._keyEvent( \"next\", event );\n                    break;\n                }\n            },\n            input: function( event ) {\n                if ( suppressInput ) {\n                    suppressInput = false;\n                    event.preventDefault();\n                    return;\n                }\n                this._searchTimeout( event );\n            },\n            focus: function() {\n                this.selectedItem = null;\n                this.previous = this._value();\n            },\n            blur: function( event ) {\n                if ( this.cancelBlur ) {\n                    delete this.cancelBlur;\n                    return;\n                }\n\n                clearTimeout( this.searching );\n                this.close( event );\n                this._change( event );\n            }\n        });\n\n        this._initSource();\n        this.menu = $( \"<ul>\" )\n            .addClass( \"ui-autocomplete ui-front\" )\n            .appendTo( this._appendTo() )\n            .menu({\n                // disable ARIA support, the live region takes care of that\n                role: null\n            })\n            .hide()\n            .menu( \"instance\" );\n\n        this._on( this.menu.element, {\n            mousedown: function( event ) {\n                // prevent moving focus out of the text field\n                event.preventDefault();\n\n                // IE doesn't prevent moving focus even with event.preventDefault()\n                // so we set a flag to know when we should ignore the blur event\n                this.cancelBlur = true;\n                this._delay(function() {\n                    delete this.cancelBlur;\n                });\n\n                // clicking on the scrollbar causes focus to shift to the body\n                // but we can't detect a mouseup or a click immediately afterward\n                // so we have to track the next mousedown and close the menu if\n                // the user clicks somewhere outside of the autocomplete\n                var menuElement = this.menu.element[ 0 ];\n                if ( !$( event.target ).closest( \".ui-menu-item\" ).length ) {\n                    this._delay(function() {\n                        var that = this;\n                        this.document.one( \"mousedown\", function( event ) {\n                            if ( event.target !== that.element[ 0 ] &&\n                                    event.target !== menuElement &&\n                                    !$.contains( menuElement, event.target ) ) {\n                                that.close();\n                            }\n                        });\n                    });\n                }\n            },\n            menufocus: function( event, ui ) {\n                var label, item;\n                // support: Firefox\n                // Prevent accidental activation of menu items in Firefox (#7024 #9118)\n                if ( this.isNewMenu ) {\n                    this.isNewMenu = false;\n                    if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {\n                        this.menu.blur();\n\n                        this.document.one( \"mousemove\", function() {\n                            $( event.target ).trigger( event.originalEvent );\n                        });\n\n                        return;\n                    }\n                }\n\n                item = ui.item.data( \"ui-autocomplete-item\" );\n                if ( false !== this._trigger( \"focus\", event, { item: item } ) ) {\n                    // use value to match what will end up in the input, if it was a key event\n                    if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {\n                        this._value( item.value );\n                    }\n                }\n\n                // Announce the value in the liveRegion\n                label = ui.item.attr( \"aria-label\" ) || item.value;\n                if ( label && $.trim( label ).length ) {\n                    this.liveRegion.children().hide();\n                    $( \"<div>\" ).text( label ).appendTo( this.liveRegion );\n                }\n            },\n            menuselect: function( event, ui ) {\n                var item = ui.item.data( \"ui-autocomplete-item\" ),\n                    previous = this.previous;\n\n                // only trigger when focus was lost (click on menu)\n                if ( this.element[ 0 ] !== this.document[ 0 ].activeElement ) {\n                    this.element.focus();\n                    this.previous = previous;\n                    // #6109 - IE triggers two focus events and the second\n                    // is asynchronous, so we need to reset the previous\n                    // term synchronously and asynchronously :-(\n                    this._delay(function() {\n                        this.previous = previous;\n                        this.selectedItem = item;\n                    });\n                }\n\n                if ( false !== this._trigger( \"select\", event, { item: item } ) ) {\n                    this._value( item.value );\n                }\n                // reset the term after the select event\n                // this allows custom select handling to work properly\n                this.term = this._value();\n\n                this.close( event );\n                this.selectedItem = item;\n            }\n        });\n\n        this.liveRegion = $( \"<span>\", {\n                role: \"status\",\n                \"aria-live\": \"assertive\",\n                \"aria-relevant\": \"additions\"\n            })\n            .addClass( \"ui-helper-hidden-accessible\" )\n            .appendTo( this.document[ 0 ].body );\n\n        // turning off autocomplete prevents the browser from remembering the\n        // value when navigating through history, so we re-enable autocomplete\n        // if the page is unloaded before the widget is destroyed. #7790\n        this._on( this.window, {\n            beforeunload: function() {\n                this.element.removeAttr( \"autocomplete\" );\n            }\n        });\n    },\n\n    _destroy: function() {\n        clearTimeout( this.searching );\n        this.element\n            .removeClass( \"ui-autocomplete-input\" )\n            .removeAttr( \"autocomplete\" );\n        this.menu.element.remove();\n        this.liveRegion.remove();\n    },\n\n    _setOption: function( key, value ) {\n        this._super( key, value );\n        if ( key === \"source\" ) {\n            this._initSource();\n        }\n        if ( key === \"appendTo\" ) {\n            this.menu.element.appendTo( this._appendTo() );\n        }\n        if ( key === \"disabled\" && value && this.xhr ) {\n            this.xhr.abort();\n        }\n    },\n\n    _appendTo: function() {\n        var element = this.options.appendTo;\n\n        if ( element ) {\n            element = element.jquery || element.nodeType ?\n                $( element ) :\n                this.document.find( element ).eq( 0 );\n        }\n\n        if ( !element || !element[ 0 ] ) {\n            element = this.element.closest( \".ui-front\" );\n        }\n\n        if ( !element.length ) {\n            element = this.document[ 0 ].body;\n        }\n\n        return element;\n    },\n\n    _initSource: function() {\n        var array, url,\n            that = this;\n        if ( $.isArray( this.options.source ) ) {\n            array = this.options.source;\n            this.source = function( request, response ) {\n                response( $.ui.autocomplete.filter( array, request.term ) );\n            };\n        } else if ( typeof this.options.source === \"string\" ) {\n            url = this.options.source;\n            this.source = function( request, response ) {\n                if ( that.xhr ) {\n                    that.xhr.abort();\n                }\n                that.xhr = $.ajax({\n                    url: url,\n                    data: request,\n                    dataType: \"json\",\n                    success: function( data ) {\n                        response( data );\n                    },\n                    error: function() {\n                        response([]);\n                    }\n                });\n            };\n        } else {\n            this.source = this.options.source;\n        }\n    },\n\n    _searchTimeout: function( event ) {\n        clearTimeout( this.searching );\n        this.searching = this._delay(function() {\n\n            // Search if the value has changed, or if the user retypes the same value (see #7434)\n            var equalValues = this.term === this._value(),\n                menuVisible = this.menu.element.is( \":visible\" ),\n                modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;\n\n            if ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) ) {\n                this.selectedItem = null;\n                this.search( null, event );\n            }\n        }, this.options.delay );\n    },\n\n    search: function( value, event ) {\n        value = value != null ? value : this._value();\n\n        // always save the actual value, not the one passed as an argument\n        this.term = this._value();\n\n        if ( value.length < this.options.minLength ) {\n            return this.close( event );\n        }\n\n        if ( this._trigger( \"search\", event ) === false ) {\n            return;\n        }\n\n        return this._search( value );\n    },\n\n    _search: function( value ) {\n        this.pending++;\n        this.element.addClass( \"ui-autocomplete-loading\" );\n        this.cancelSearch = false;\n\n        this.source( { term: value }, this._response() );\n    },\n\n    _response: function() {\n        var index = ++this.requestIndex;\n\n        return $.proxy(function( content ) {\n            if ( index === this.requestIndex ) {\n                this.__response( content );\n            }\n\n            this.pending--;\n            if ( !this.pending ) {\n                this.element.removeClass( \"ui-autocomplete-loading\" );\n            }\n        }, this );\n    },\n\n    __response: function( content ) {\n        if ( content ) {\n            content = this._normalize( content );\n        }\n        this._trigger( \"response\", null, { content: content } );\n        if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {\n            this._suggest( content );\n            this._trigger( \"open\" );\n        } else {\n            // use ._close() instead of .close() so we don't cancel future searches\n            this._close();\n        }\n    },\n\n    close: function( event ) {\n        this.cancelSearch = true;\n        this._close( event );\n    },\n\n    _close: function( event ) {\n        if ( this.menu.element.is( \":visible\" ) ) {\n            this.menu.element.hide();\n            this.menu.blur();\n            this.isNewMenu = true;\n            this._trigger( \"close\", event );\n        }\n    },\n\n    _change: function( event ) {\n        if ( this.previous !== this._value() ) {\n            this._trigger( \"change\", event, { item: this.selectedItem } );\n        }\n    },\n\n    _normalize: function( items ) {\n        // assume all items have the right format when the first item is complete\n        if ( items.length && items[ 0 ].label && items[ 0 ].value ) {\n            return items;\n        }\n        return $.map( items, function( item ) {\n            if ( typeof item === \"string\" ) {\n                return {\n                    label: item,\n                    value: item\n                };\n            }\n            return $.extend( {}, item, {\n                label: item.label || item.value,\n                value: item.value || item.label\n            });\n        });\n    },\n\n    _suggest: function( items ) {\n        var ul = this.menu.element.empty();\n        this._renderMenu( ul, items );\n        this.isNewMenu = true;\n        this.menu.refresh();\n\n        // size and position menu\n        ul.show();\n        this._resizeMenu();\n        ul.position( $.extend({\n            of: this.element\n        }, this.options.position ) );\n\n        if ( this.options.autoFocus ) {\n            this.menu.next();\n        }\n    },\n\n    _resizeMenu: function() {\n        var ul = this.menu.element;\n        ul.outerWidth( Math.max(\n            // Firefox wraps long text (possibly a rounding bug)\n            // so we add 1px to avoid the wrapping (#7513)\n            ul.width( \"\" ).outerWidth() + 1,\n            this.element.outerWidth()\n        ) );\n    },\n\n    _renderMenu: function( ul, items ) {\n        var that = this;\n        $.each( items, function( index, item ) {\n            that._renderItemData( ul, item );\n        });\n    },\n\n    _renderItemData: function( ul, item ) {\n        return this._renderItem( ul, item ).data( \"ui-autocomplete-item\", item );\n    },\n\n    _renderItem: function( ul, item ) {\n        return $( \"<li>\" ).text( item.label ).appendTo( ul );\n    },\n\n    _move: function( direction, event ) {\n        if ( !this.menu.element.is( \":visible\" ) ) {\n            this.search( null, event );\n            return;\n        }\n        if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||\n                this.menu.isLastItem() && /^next/.test( direction ) ) {\n\n            if ( !this.isMultiLine ) {\n                this._value( this.term );\n            }\n\n            this.menu.blur();\n            return;\n        }\n        this.menu[ direction ]( event );\n    },\n\n    widget: function() {\n        return this.menu.element;\n    },\n\n    _value: function() {\n        return this.valueMethod.apply( this.element, arguments );\n    },\n\n    _keyEvent: function( keyEvent, event ) {\n        if ( !this.isMultiLine || this.menu.element.is( \":visible\" ) ) {\n            this._move( keyEvent, event );\n\n            // prevents moving cursor to beginning/end of the text field in some browsers\n            event.preventDefault();\n        }\n    }\n});\n\n$.extend( $.ui.autocomplete, {\n    escapeRegex: function( value ) {\n        return value.replace( /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\" );\n    },\n    filter: function( array, term ) {\n        var matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), \"i\" );\n        return $.grep( array, function( value ) {\n            return matcher.test( value.label || value.value || value );\n        });\n    }\n});\n\n// live region extension, adding a `messages` option\n// NOTE: This is an experimental API. We are still investigating\n// a full solution for string manipulation and internationalization.\n$.widget( \"ui.autocomplete\", $.ui.autocomplete, {\n    options: {\n        messages: {\n            noResults: \"No search results.\",\n            results: function( amount ) {\n                return amount + ( amount > 1 ? \" results are\" : \" result is\" ) +\n                    \" available, use up and down arrow keys to navigate.\";\n            }\n        }\n    },\n\n    __response: function( content ) {\n        var message;\n        this._superApply( arguments );\n        if ( this.options.disabled || this.cancelSearch ) {\n            return;\n        }\n        if ( content && content.length ) {\n            message = this.options.messages.results( content.length );\n        } else {\n            message = this.options.messages.noResults;\n        }\n        this.liveRegion.children().hide();\n        $( \"<div>\" ).text( message ).appendTo( this.liveRegion );\n    }\n});\n\nvar autocomplete = $.ui.autocomplete;\n\n\n/*!\n * jQuery UI Button 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/button/\n */\n\n\nvar lastActive,\n    baseClasses = \"ui-button ui-widget ui-state-default ui-corner-all\",\n    typeClasses = \"ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only\",\n    formResetHandler = function() {\n        var form = $( this );\n        setTimeout(function() {\n            form.find( \":ui-button\" ).button( \"refresh\" );\n        }, 1 );\n    },\n    radioGroup = function( radio ) {\n        var name = radio.name,\n            form = radio.form,\n            radios = $( [] );\n        if ( name ) {\n            name = name.replace( /'/g, \"\\\\'\" );\n            if ( form ) {\n                radios = $( form ).find( \"[name='\" + name + \"'][type=radio]\" );\n            } else {\n                radios = $( \"[name='\" + name + \"'][type=radio]\", radio.ownerDocument )\n                    .filter(function() {\n                        return !this.form;\n                    });\n            }\n        }\n        return radios;\n    };\n\n$.widget( \"ui.button\", {\n    version: \"1.11.2\",\n    defaultElement: \"<button>\",\n    options: {\n        disabled: null,\n        text: true,\n        label: null,\n        icons: {\n            primary: null,\n            secondary: null\n        }\n    },\n    _create: function() {\n        this.element.closest( \"form\" )\n            .unbind( \"reset\" + this.eventNamespace )\n            .bind( \"reset\" + this.eventNamespace, formResetHandler );\n\n        if ( typeof this.options.disabled !== \"boolean\" ) {\n            this.options.disabled = !!this.element.prop( \"disabled\" );\n        } else {\n            this.element.prop( \"disabled\", this.options.disabled );\n        }\n\n        this._determineButtonType();\n        this.hasTitle = !!this.buttonElement.attr( \"title\" );\n\n        var that = this,\n            options = this.options,\n            toggleButton = this.type === \"checkbox\" || this.type === \"radio\",\n            activeClass = !toggleButton ? \"ui-state-active\" : \"\";\n\n        if ( options.label === null ) {\n            options.label = (this.type === \"input\" ? this.buttonElement.val() : this.buttonElement.html());\n        }\n\n        this._hoverable( this.buttonElement );\n\n        this.buttonElement\n            .addClass( baseClasses )\n            .attr( \"role\", \"button\" )\n            .bind( \"mouseenter\" + this.eventNamespace, function() {\n                if ( options.disabled ) {\n                    return;\n                }\n                if ( this === lastActive ) {\n                    $( this ).addClass( \"ui-state-active\" );\n                }\n            })\n            .bind( \"mouseleave\" + this.eventNamespace, function() {\n                if ( options.disabled ) {\n                    return;\n                }\n                $( this ).removeClass( activeClass );\n            })\n            .bind( \"click\" + this.eventNamespace, function( event ) {\n                if ( options.disabled ) {\n                    event.preventDefault();\n                    event.stopImmediatePropagation();\n                }\n            });\n\n        // Can't use _focusable() because the element that receives focus\n        // and the element that gets the ui-state-focus class are different\n        this._on({\n            focus: function() {\n                this.buttonElement.addClass( \"ui-state-focus\" );\n            },\n            blur: function() {\n                this.buttonElement.removeClass( \"ui-state-focus\" );\n            }\n        });\n\n        if ( toggleButton ) {\n            this.element.bind( \"change\" + this.eventNamespace, function() {\n                that.refresh();\n            });\n        }\n\n        if ( this.type === \"checkbox\" ) {\n            this.buttonElement.bind( \"click\" + this.eventNamespace, function() {\n                if ( options.disabled ) {\n                    return false;\n                }\n            });\n        } else if ( this.type === \"radio\" ) {\n            this.buttonElement.bind( \"click\" + this.eventNamespace, function() {\n                if ( options.disabled ) {\n                    return false;\n                }\n                $( this ).addClass( \"ui-state-active\" );\n                that.buttonElement.attr( \"aria-pressed\", \"true\" );\n\n                var radio = that.element[ 0 ];\n                radioGroup( radio )\n                    .not( radio )\n                    .map(function() {\n                        return $( this ).button( \"widget\" )[ 0 ];\n                    })\n                    .removeClass( \"ui-state-active\" )\n                    .attr( \"aria-pressed\", \"false\" );\n            });\n        } else {\n            this.buttonElement\n                .bind( \"mousedown\" + this.eventNamespace, function() {\n                    if ( options.disabled ) {\n                        return false;\n                    }\n                    $( this ).addClass( \"ui-state-active\" );\n                    lastActive = this;\n                    that.document.one( \"mouseup\", function() {\n                        lastActive = null;\n                    });\n                })\n                .bind( \"mouseup\" + this.eventNamespace, function() {\n                    if ( options.disabled ) {\n                        return false;\n                    }\n                    $( this ).removeClass( \"ui-state-active\" );\n                })\n                .bind( \"keydown\" + this.eventNamespace, function(event) {\n                    if ( options.disabled ) {\n                        return false;\n                    }\n                    if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {\n                        $( this ).addClass( \"ui-state-active\" );\n                    }\n                })\n                // see #8559, we bind to blur here in case the button element loses\n                // focus between keydown and keyup, it would be left in an \"active\" state\n                .bind( \"keyup\" + this.eventNamespace + \" blur\" + this.eventNamespace, function() {\n                    $( this ).removeClass( \"ui-state-active\" );\n                });\n\n            if ( this.buttonElement.is(\"a\") ) {\n                this.buttonElement.keyup(function(event) {\n                    if ( event.keyCode === $.ui.keyCode.SPACE ) {\n                        // TODO pass through original event correctly (just as 2nd argument doesn't work)\n                        $( this ).click();\n                    }\n                });\n            }\n        }\n\n        this._setOption( \"disabled\", options.disabled );\n        this._resetButton();\n    },\n\n    _determineButtonType: function() {\n        var ancestor, labelSelector, checked;\n\n        if ( this.element.is(\"[type=checkbox]\") ) {\n            this.type = \"checkbox\";\n        } else if ( this.element.is(\"[type=radio]\") ) {\n            this.type = \"radio\";\n        } else if ( this.element.is(\"input\") ) {\n            this.type = \"input\";\n        } else {\n            this.type = \"button\";\n        }\n\n        if ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n            // we don't search against the document in case the element\n            // is disconnected from the DOM\n            ancestor = this.element.parents().last();\n            labelSelector = \"label[for='\" + this.element.attr(\"id\") + \"']\";\n            this.buttonElement = ancestor.find( labelSelector );\n            if ( !this.buttonElement.length ) {\n                ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();\n                this.buttonElement = ancestor.filter( labelSelector );\n                if ( !this.buttonElement.length ) {\n                    this.buttonElement = ancestor.find( labelSelector );\n                }\n            }\n            this.element.addClass( \"ui-helper-hidden-accessible\" );\n\n            checked = this.element.is( \":checked\" );\n            if ( checked ) {\n                this.buttonElement.addClass( \"ui-state-active\" );\n            }\n            this.buttonElement.prop( \"aria-pressed\", checked );\n        } else {\n            this.buttonElement = this.element;\n        }\n    },\n\n    widget: function() {\n        return this.buttonElement;\n    },\n\n    _destroy: function() {\n        this.element\n            .removeClass( \"ui-helper-hidden-accessible\" );\n        this.buttonElement\n            .removeClass( baseClasses + \" ui-state-active \" + typeClasses )\n            .removeAttr( \"role\" )\n            .removeAttr( \"aria-pressed\" )\n            .html( this.buttonElement.find(\".ui-button-text\").html() );\n\n        if ( !this.hasTitle ) {\n            this.buttonElement.removeAttr( \"title\" );\n        }\n    },\n\n    _setOption: function( key, value ) {\n        this._super( key, value );\n        if ( key === \"disabled\" ) {\n            this.widget().toggleClass( \"ui-state-disabled\", !!value );\n            this.element.prop( \"disabled\", !!value );\n            if ( value ) {\n                if ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n                    this.buttonElement.removeClass( \"ui-state-focus\" );\n                } else {\n                    this.buttonElement.removeClass( \"ui-state-focus ui-state-active\" );\n                }\n            }\n            return;\n        }\n        this._resetButton();\n    },\n\n    refresh: function() {\n        //See #8237 & #8828\n        var isDisabled = this.element.is( \"input, button\" ) ? this.element.is( \":disabled\" ) : this.element.hasClass( \"ui-button-disabled\" );\n\n        if ( isDisabled !== this.options.disabled ) {\n            this._setOption( \"disabled\", isDisabled );\n        }\n        if ( this.type === \"radio\" ) {\n            radioGroup( this.element[0] ).each(function() {\n                if ( $( this ).is( \":checked\" ) ) {\n                    $( this ).button( \"widget\" )\n                        .addClass( \"ui-state-active\" )\n                        .attr( \"aria-pressed\", \"true\" );\n                } else {\n                    $( this ).button( \"widget\" )\n                        .removeClass( \"ui-state-active\" )\n                        .attr( \"aria-pressed\", \"false\" );\n                }\n            });\n        } else if ( this.type === \"checkbox\" ) {\n            if ( this.element.is( \":checked\" ) ) {\n                this.buttonElement\n                    .addClass( \"ui-state-active\" )\n                    .attr( \"aria-pressed\", \"true\" );\n            } else {\n                this.buttonElement\n                    .removeClass( \"ui-state-active\" )\n                    .attr( \"aria-pressed\", \"false\" );\n            }\n        }\n    },\n\n    _resetButton: function() {\n        if ( this.type === \"input\" ) {\n            if ( this.options.label ) {\n                this.element.val( this.options.label );\n            }\n            return;\n        }\n        var buttonElement = this.buttonElement.removeClass( typeClasses ),\n            buttonText = $( \"<span></span>\", this.document[0] )\n                .addClass( \"ui-button-text\" )\n                .html( this.options.label )\n                .appendTo( buttonElement.empty() )\n                .text(),\n            icons = this.options.icons,\n            multipleIcons = icons.primary && icons.secondary,\n            buttonClasses = [];\n\n        if ( icons.primary || icons.secondary ) {\n            if ( this.options.text ) {\n                buttonClasses.push( \"ui-button-text-icon\" + ( multipleIcons ? \"s\" : ( icons.primary ? \"-primary\" : \"-secondary\" ) ) );\n            }\n\n            if ( icons.primary ) {\n                buttonElement.prepend( \"<span class='ui-button-icon-primary ui-icon \" + icons.primary + \"'></span>\" );\n            }\n\n            if ( icons.secondary ) {\n                buttonElement.append( \"<span class='ui-button-icon-secondary ui-icon \" + icons.secondary + \"'></span>\" );\n            }\n\n            if ( !this.options.text ) {\n                buttonClasses.push( multipleIcons ? \"ui-button-icons-only\" : \"ui-button-icon-only\" );\n\n                if ( !this.hasTitle ) {\n                    buttonElement.attr( \"title\", $.trim( buttonText ) );\n                }\n            }\n        } else {\n            buttonClasses.push( \"ui-button-text-only\" );\n        }\n        buttonElement.addClass( buttonClasses.join( \" \" ) );\n    }\n});\n\n$.widget( \"ui.buttonset\", {\n    version: \"1.11.2\",\n    options: {\n        items: \"button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)\"\n    },\n\n    _create: function() {\n        this.element.addClass( \"ui-buttonset\" );\n    },\n\n    _init: function() {\n        this.refresh();\n    },\n\n    _setOption: function( key, value ) {\n        if ( key === \"disabled\" ) {\n            this.buttons.button( \"option\", key, value );\n        }\n\n        this._super( key, value );\n    },\n\n    refresh: function() {\n        var rtl = this.element.css( \"direction\" ) === \"rtl\",\n            allButtons = this.element.find( this.options.items ),\n            existingButtons = allButtons.filter( \":ui-button\" );\n\n        // Initialize new buttons\n        allButtons.not( \":ui-button\" ).button();\n\n        // Refresh existing buttons\n        existingButtons.button( \"refresh\" );\n\n        this.buttons = allButtons\n            .map(function() {\n                return $( this ).button( \"widget\" )[ 0 ];\n            })\n                .removeClass( \"ui-corner-all ui-corner-left ui-corner-right\" )\n                .filter( \":first\" )\n                    .addClass( rtl ? \"ui-corner-right\" : \"ui-corner-left\" )\n                .end()\n                .filter( \":last\" )\n                    .addClass( rtl ? \"ui-corner-left\" : \"ui-corner-right\" )\n                .end()\n            .end();\n    },\n\n    _destroy: function() {\n        this.element.removeClass( \"ui-buttonset\" );\n        this.buttons\n            .map(function() {\n                return $( this ).button( \"widget\" )[ 0 ];\n            })\n                .removeClass( \"ui-corner-left ui-corner-right\" )\n            .end()\n            .button( \"destroy\" );\n    }\n});\n\nvar button = $.ui.button;\n\n\n/*!\n * jQuery UI Datepicker 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/datepicker/\n */\n\n\n$.extend($.ui, { datepicker: { version: \"1.11.2\" } });\n\nvar datepicker_instActive;\n\nfunction datepicker_getZindex( elem ) {\n    var position, value;\n    while ( elem.length && elem[ 0 ] !== document ) {\n        // Ignore z-index if position is set to a value where z-index is ignored by the browser\n        // This makes behavior of this function consistent across browsers\n        // WebKit always returns auto if the element is positioned\n        position = elem.css( \"position\" );\n        if ( position === \"absolute\" || position === \"relative\" || position === \"fixed\" ) {\n            // IE returns 0 when zIndex is not specified\n            // other browsers return a string\n            // we ignore the case of nested elements with an explicit value of 0\n            // <div style=\"z-index: -10;\"><div style=\"z-index: 0;\"></div></div>\n            value = parseInt( elem.css( \"zIndex\" ), 10 );\n            if ( !isNaN( value ) && value !== 0 ) {\n                return value;\n            }\n        }\n        elem = elem.parent();\n    }\n\n    return 0;\n}\n/* Date picker manager.\n   Use the singleton instance of this class, $.datepicker, to interact with the date picker.\n   Settings for (groups of) date pickers are maintained in an instance object,\n   allowing multiple different settings on the same page. */\n\nfunction Datepicker() {\n    this._curInst = null; // The current instance in use\n    this._keyEvent = false; // If the last event was a key event\n    this._disabledInputs = []; // List of date picker inputs that have been disabled\n    this._datepickerShowing = false; // True if the popup picker is showing , false if not\n    this._inDialog = false; // True if showing within a \"dialog\", false if not\n    this._mainDivId = \"ui-datepicker-div\"; // The ID of the main datepicker division\n    this._inlineClass = \"ui-datepicker-inline\"; // The name of the inline marker class\n    this._appendClass = \"ui-datepicker-append\"; // The name of the append marker class\n    this._triggerClass = \"ui-datepicker-trigger\"; // The name of the trigger marker class\n    this._dialogClass = \"ui-datepicker-dialog\"; // The name of the dialog marker class\n    this._disableClass = \"ui-datepicker-disabled\"; // The name of the disabled covering marker class\n    this._unselectableClass = \"ui-datepicker-unselectable\"; // The name of the unselectable cell marker class\n    this._currentClass = \"ui-datepicker-current-day\"; // The name of the current day marker class\n    this._dayOverClass = \"ui-datepicker-days-cell-over\"; // The name of the day hover marker class\n    this.regional = []; // Available regional settings, indexed by language code\n    this.regional[\"\"] = { // Default regional settings\n        closeText: \"Done\", // Display text for close link\n        prevText: \"Prev\", // Display text for previous month link\n        nextText: \"Next\", // Display text for next month link\n        currentText: \"Today\", // Display text for current month link\n        monthNames: [\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\n            \"July\",\"August\",\"September\",\"October\",\"November\",\"December\"], // Names of months for drop-down and formatting\n        monthNamesShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], // For formatting\n        dayNames: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"], // For formatting\n        dayNamesShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"], // For formatting\n        dayNamesMin: [\"Su\",\"Mo\",\"Tu\",\"We\",\"Th\",\"Fr\",\"Sa\"], // Column headings for days starting at Sunday\n        weekHeader: \"Wk\", // Column header for week of the year\n        dateFormat: \"mm/dd/yy\", // See format options on parseDate\n        firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...\n        isRTL: false, // True if right-to-left language, false if left-to-right\n        showMonthAfterYear: false, // True if the year select precedes month, false for month then year\n        yearSuffix: \"\" // Additional text to append to the year in the month headers\n    };\n    this._defaults = { // Global defaults for all the date picker instances\n        showOn: \"focus\", // \"focus\" for popup on focus,\n            // \"button\" for trigger button, or \"both\" for either\n        showAnim: \"fadeIn\", // Name of jQuery animation for popup\n        showOptions: {}, // Options for enhanced animations\n        defaultDate: null, // Used when field is blank: actual date,\n            // +/-number for offset from today, null for today\n        appendText: \"\", // Display text following the input box, e.g. showing the format\n        buttonText: \"...\", // Text for trigger button\n        buttonImage: \"\", // URL for trigger button image\n        buttonImageOnly: false, // True if the image appears alone, false if it appears on a button\n        hideIfNoPrevNext: false, // True to hide next/previous month links\n            // if not applicable, false to just disable them\n        navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links\n        gotoCurrent: false, // True if today link goes back to current selection instead\n        changeMonth: false, // True if month can be selected directly, false if only prev/next\n        changeYear: false, // True if year can be selected directly, false if only prev/next\n        yearRange: \"c-10:c+10\", // Range of years to display in drop-down,\n            // either relative to today's year (-nn:+nn), relative to currently displayed year\n            // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)\n        showOtherMonths: false, // True to show dates in other months, false to leave blank\n        selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable\n        showWeek: false, // True to show week of the year, false to not show it\n        calculateWeek: this.iso8601Week, // How to calculate the week of the year,\n            // takes a Date and returns the number of the week for it\n        shortYearCutoff: \"+10\", // Short year values < this are in the current century,\n            // > this are in the previous century,\n            // string value starting with \"+\" for current year + value\n        minDate: null, // The earliest selectable date, or null for no limit\n        maxDate: null, // The latest selectable date, or null for no limit\n        duration: \"fast\", // Duration of display/closure\n        beforeShowDay: null, // Function that takes a date and returns an array with\n            // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or \"\",\n            // [2] = cell title (optional), e.g. $.datepicker.noWeekends\n        beforeShow: null, // Function that takes an input field and\n            // returns a set of custom settings for the date picker\n        onSelect: null, // Define a callback function when a date is selected\n        onChangeMonthYear: null, // Define a callback function when the month or year is changed\n        onClose: null, // Define a callback function when the datepicker is closed\n        numberOfMonths: 1, // Number of months to show at a time\n        showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)\n        stepMonths: 1, // Number of months to step back/forward\n        stepBigMonths: 12, // Number of months to step back/forward for the big links\n        altField: \"\", // Selector for an alternate field to store selected dates into\n        altFormat: \"\", // The date format to use for the alternate field\n        constrainInput: true, // The input is constrained by the current date format\n        showButtonPanel: false, // True to show button panel, false to not show it\n        autoSize: false, // True to size the input for the date format, false to leave as is\n        disabled: false // The initial disabled state\n    };\n    $.extend(this._defaults, this.regional[\"\"]);\n    this.regional.en = $.extend( true, {}, this.regional[ \"\" ]);\n    this.regional[ \"en-US\" ] = $.extend( true, {}, this.regional.en );\n    this.dpDiv = datepicker_bindHover($(\"<div id='\" + this._mainDivId + \"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>\"));\n}\n\n$.extend(Datepicker.prototype, {\n    /* Class name added to elements to indicate already configured with a date picker. */\n    markerClassName: \"hasDatepicker\",\n\n    //Keep track of the maximum number of rows displayed (see #7043)\n    maxRows: 4,\n\n    // TODO rename to \"widget\" when switching to widget factory\n    _widgetDatepicker: function() {\n        return this.dpDiv;\n    },\n\n    /* Override the default settings for all instances of the date picker.\n     * @param  settings  object - the new settings to use as defaults (anonymous object)\n     * @return the manager object\n     */\n    setDefaults: function(settings) {\n        datepicker_extendRemove(this._defaults, settings || {});\n        return this;\n    },\n\n    /* Attach the date picker to a jQuery selection.\n     * @param  target    element - the target input field or division or span\n     * @param  settings  object - the new settings to use for this date picker instance (anonymous)\n     */\n    _attachDatepicker: function(target, settings) {\n        var nodeName, inline, inst;\n        nodeName = target.nodeName.toLowerCase();\n        inline = (nodeName === \"div\" || nodeName === \"span\");\n        if (!target.id) {\n            this.uuid += 1;\n            target.id = \"dp\" + this.uuid;\n        }\n        inst = this._newInst($(target), inline);\n        inst.settings = $.extend({}, settings || {});\n        if (nodeName === \"input\") {\n            this._connectDatepicker(target, inst);\n        } else if (inline) {\n            this._inlineDatepicker(target, inst);\n        }\n    },\n\n    /* Create a new instance object. */\n    _newInst: function(target, inline) {\n        var id = target[0].id.replace(/([^A-Za-z0-9_\\-])/g, \"\\\\\\\\$1\"); // escape jQuery meta chars\n        return {id: id, input: target, // associated target\n            selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection\n            drawMonth: 0, drawYear: 0, // month being drawn\n            inline: inline, // is datepicker inline or not\n            dpDiv: (!inline ? this.dpDiv : // presentation div\n            datepicker_bindHover($(\"<div class='\" + this._inlineClass + \" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>\")))};\n    },\n\n    /* Attach the date picker to an input field. */\n    _connectDatepicker: function(target, inst) {\n        var input = $(target);\n        inst.append = $([]);\n        inst.trigger = $([]);\n        if (input.hasClass(this.markerClassName)) {\n            return;\n        }\n        this._attachments(input, inst);\n        input.addClass(this.markerClassName).keydown(this._doKeyDown).\n            keypress(this._doKeyPress).keyup(this._doKeyUp);\n        this._autoSize(inst);\n        $.data(target, \"datepicker\", inst);\n        //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)\n        if( inst.settings.disabled ) {\n            this._disableDatepicker( target );\n        }\n    },\n\n    /* Make attachments based on settings. */\n    _attachments: function(input, inst) {\n        var showOn, buttonText, buttonImage,\n            appendText = this._get(inst, \"appendText\"),\n            isRTL = this._get(inst, \"isRTL\");\n\n        if (inst.append) {\n            inst.append.remove();\n        }\n        if (appendText) {\n            inst.append = $(\"<span class='\" + this._appendClass + \"'>\" + appendText + \"</span>\");\n            input[isRTL ? \"before\" : \"after\"](inst.append);\n        }\n\n        input.unbind(\"focus\", this._showDatepicker);\n\n        if (inst.trigger) {\n            inst.trigger.remove();\n        }\n\n        showOn = this._get(inst, \"showOn\");\n        if (showOn === \"focus\" || showOn === \"both\") { // pop-up date picker when in the marked field\n            input.focus(this._showDatepicker);\n        }\n        if (showOn === \"button\" || showOn === \"both\") { // pop-up date picker when button clicked\n            buttonText = this._get(inst, \"buttonText\");\n            buttonImage = this._get(inst, \"buttonImage\");\n            inst.trigger = $(this._get(inst, \"buttonImageOnly\") ?\n                $(\"<img/>\").addClass(this._triggerClass).\n                    attr({ src: buttonImage, alt: buttonText, title: buttonText }) :\n                $(\"<button type='button'></button>\").addClass(this._triggerClass).\n                    html(!buttonImage ? buttonText : $(\"<img/>\").attr(\n                    { src:buttonImage, alt:buttonText, title:buttonText })));\n            input[isRTL ? \"before\" : \"after\"](inst.trigger);\n            inst.trigger.click(function() {\n                if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {\n                    $.datepicker._hideDatepicker();\n                } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {\n                    $.datepicker._hideDatepicker();\n                    $.datepicker._showDatepicker(input[0]);\n                } else {\n                    $.datepicker._showDatepicker(input[0]);\n                }\n                return false;\n            });\n        }\n    },\n\n    /* Apply the maximum length for the date format. */\n    _autoSize: function(inst) {\n        if (this._get(inst, \"autoSize\") && !inst.inline) {\n            var findMax, max, maxI, i,\n                date = new Date(2009, 12 - 1, 20), // Ensure double digits\n                dateFormat = this._get(inst, \"dateFormat\");\n\n            if (dateFormat.match(/[DM]/)) {\n                findMax = function(names) {\n                    max = 0;\n                    maxI = 0;\n                    for (i = 0; i < names.length; i++) {\n                        if (names[i].length > max) {\n                            max = names[i].length;\n                            maxI = i;\n                        }\n                    }\n                    return maxI;\n                };\n                date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?\n                    \"monthNames\" : \"monthNamesShort\"))));\n                date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?\n                    \"dayNames\" : \"dayNamesShort\"))) + 20 - date.getDay());\n            }\n            inst.input.attr(\"size\", this._formatDate(inst, date).length);\n        }\n    },\n\n    /* Attach an inline date picker to a div. */\n    _inlineDatepicker: function(target, inst) {\n        var divSpan = $(target);\n        if (divSpan.hasClass(this.markerClassName)) {\n            return;\n        }\n        divSpan.addClass(this.markerClassName).append(inst.dpDiv);\n        $.data(target, \"datepicker\", inst);\n        this._setDate(inst, this._getDefaultDate(inst), true);\n        this._updateDatepicker(inst);\n        this._updateAlternate(inst);\n        //If disabled option is true, disable the datepicker before showing it (see ticket #5665)\n        if( inst.settings.disabled ) {\n            this._disableDatepicker( target );\n        }\n        // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements\n        // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height\n        inst.dpDiv.css( \"display\", \"block\" );\n    },\n\n    /* Pop-up the date picker in a \"dialog\" box.\n     * @param  input element - ignored\n     * @param  date    string or Date - the initial date to display\n     * @param  onSelect  function - the function to call when a date is selected\n     * @param  settings  object - update the dialog date picker instance's settings (anonymous object)\n     * @param  pos int[2] - coordinates for the dialog's position within the screen or\n     *                    event - with x/y coordinates or\n     *                    leave empty for default (screen centre)\n     * @return the manager object\n     */\n    _dialogDatepicker: function(input, date, onSelect, settings, pos) {\n        var id, browserWidth, browserHeight, scrollX, scrollY,\n            inst = this._dialogInst; // internal instance\n\n        if (!inst) {\n            this.uuid += 1;\n            id = \"dp\" + this.uuid;\n            this._dialogInput = $(\"<input type='text' id='\" + id +\n                \"' style='position: absolute; top: -100px; width: 0px;'/>\");\n            this._dialogInput.keydown(this._doKeyDown);\n            $(\"body\").append(this._dialogInput);\n            inst = this._dialogInst = this._newInst(this._dialogInput, false);\n            inst.settings = {};\n            $.data(this._dialogInput[0], \"datepicker\", inst);\n        }\n        datepicker_extendRemove(inst.settings, settings || {});\n        date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);\n        this._dialogInput.val(date);\n\n        this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);\n        if (!this._pos) {\n            browserWidth = document.documentElement.clientWidth;\n            browserHeight = document.documentElement.clientHeight;\n            scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;\n            scrollY = document.documentElement.scrollTop || document.body.scrollTop;\n            this._pos = // should use actual width/height below\n                [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];\n        }\n\n        // move input on screen for focus, but hidden behind dialog\n        this._dialogInput.css(\"left\", (this._pos[0] + 20) + \"px\").css(\"top\", this._pos[1] + \"px\");\n        inst.settings.onSelect = onSelect;\n        this._inDialog = true;\n        this.dpDiv.addClass(this._dialogClass);\n        this._showDatepicker(this._dialogInput[0]);\n        if ($.blockUI) {\n            $.blockUI(this.dpDiv);\n        }\n        $.data(this._dialogInput[0], \"datepicker\", inst);\n        return this;\n    },\n\n    /* Detach a datepicker from its control.\n     * @param  target    element - the target input field or division or span\n     */\n    _destroyDatepicker: function(target) {\n        var nodeName,\n            $target = $(target),\n            inst = $.data(target, \"datepicker\");\n\n        if (!$target.hasClass(this.markerClassName)) {\n            return;\n        }\n\n        nodeName = target.nodeName.toLowerCase();\n        $.removeData(target, \"datepicker\");\n        if (nodeName === \"input\") {\n            inst.append.remove();\n            inst.trigger.remove();\n            $target.removeClass(this.markerClassName).\n                unbind(\"focus\", this._showDatepicker).\n                unbind(\"keydown\", this._doKeyDown).\n                unbind(\"keypress\", this._doKeyPress).\n                unbind(\"keyup\", this._doKeyUp);\n        } else if (nodeName === \"div\" || nodeName === \"span\") {\n            $target.removeClass(this.markerClassName).empty();\n        }\n    },\n\n    /* Enable the date picker to a jQuery selection.\n     * @param  target    element - the target input field or division or span\n     */\n    _enableDatepicker: function(target) {\n        var nodeName, inline,\n            $target = $(target),\n            inst = $.data(target, \"datepicker\");\n\n        if (!$target.hasClass(this.markerClassName)) {\n            return;\n        }\n\n        nodeName = target.nodeName.toLowerCase();\n        if (nodeName === \"input\") {\n            target.disabled = false;\n            inst.trigger.filter(\"button\").\n                each(function() { this.disabled = false; }).end().\n                filter(\"img\").css({opacity: \"1.0\", cursor: \"\"});\n        } else if (nodeName === \"div\" || nodeName === \"span\") {\n            inline = $target.children(\".\" + this._inlineClass);\n            inline.children().removeClass(\"ui-state-disabled\");\n            inline.find(\"select.ui-datepicker-month, select.ui-datepicker-year\").\n                prop(\"disabled\", false);\n        }\n        this._disabledInputs = $.map(this._disabledInputs,\n            function(value) { return (value === target ? null : value); }); // delete entry\n    },\n\n    /* Disable the date picker to a jQuery selection.\n     * @param  target    element - the target input field or division or span\n     */\n    _disableDatepicker: function(target) {\n        var nodeName, inline,\n            $target = $(target),\n            inst = $.data(target, \"datepicker\");\n\n        if (!$target.hasClass(this.markerClassName)) {\n            return;\n        }\n\n        nodeName = target.nodeName.toLowerCase();\n        if (nodeName === \"input\") {\n            target.disabled = true;\n            inst.trigger.filter(\"button\").\n                each(function() { this.disabled = true; }).end().\n                filter(\"img\").css({opacity: \"0.5\", cursor: \"default\"});\n        } else if (nodeName === \"div\" || nodeName === \"span\") {\n            inline = $target.children(\".\" + this._inlineClass);\n            inline.children().addClass(\"ui-state-disabled\");\n            inline.find(\"select.ui-datepicker-month, select.ui-datepicker-year\").\n                prop(\"disabled\", true);\n        }\n        this._disabledInputs = $.map(this._disabledInputs,\n            function(value) { return (value === target ? null : value); }); // delete entry\n        this._disabledInputs[this._disabledInputs.length] = target;\n    },\n\n    /* Is the first field in a jQuery collection disabled as a datepicker?\n     * @param  target    element - the target input field or division or span\n     * @return boolean - true if disabled, false if enabled\n     */\n    _isDisabledDatepicker: function(target) {\n        if (!target) {\n            return false;\n        }\n        for (var i = 0; i < this._disabledInputs.length; i++) {\n            if (this._disabledInputs[i] === target) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    /* Retrieve the instance data for the target control.\n     * @param  target  element - the target input field or division or span\n     * @return  object - the associated instance data\n     * @throws  error if a jQuery problem getting data\n     */\n    _getInst: function(target) {\n        try {\n            return $.data(target, \"datepicker\");\n        }\n        catch (err) {\n            throw \"Missing instance data for this datepicker\";\n        }\n    },\n\n    /* Update or retrieve the settings for a date picker attached to an input field or division.\n     * @param  target  element - the target input field or division or span\n     * @param  name    object - the new settings to update or\n     *                string - the name of the setting to change or retrieve,\n     *                when retrieving also \"all\" for all instance settings or\n     *                \"defaults\" for all global defaults\n     * @param  value   any - the new value for the setting\n     *                (omit if above is an object or to retrieve a value)\n     */\n    _optionDatepicker: function(target, name, value) {\n        var settings, date, minDate, maxDate,\n            inst = this._getInst(target);\n\n        if (arguments.length === 2 && typeof name === \"string\") {\n            return (name === \"defaults\" ? $.extend({}, $.datepicker._defaults) :\n                (inst ? (name === \"all\" ? $.extend({}, inst.settings) :\n                this._get(inst, name)) : null));\n        }\n\n        settings = name || {};\n        if (typeof name === \"string\") {\n            settings = {};\n            settings[name] = value;\n        }\n\n        if (inst) {\n            if (this._curInst === inst) {\n                this._hideDatepicker();\n            }\n\n            date = this._getDateDatepicker(target, true);\n            minDate = this._getMinMaxDate(inst, \"min\");\n            maxDate = this._getMinMaxDate(inst, \"max\");\n            datepicker_extendRemove(inst.settings, settings);\n            // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided\n            if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {\n                inst.settings.minDate = this._formatDate(inst, minDate);\n            }\n            if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {\n                inst.settings.maxDate = this._formatDate(inst, maxDate);\n            }\n            if ( \"disabled\" in settings ) {\n                if ( settings.disabled ) {\n                    this._disableDatepicker(target);\n                } else {\n                    this._enableDatepicker(target);\n                }\n            }\n            this._attachments($(target), inst);\n            this._autoSize(inst);\n            this._setDate(inst, date);\n            this._updateAlternate(inst);\n            this._updateDatepicker(inst);\n        }\n    },\n\n    // change method deprecated\n    _changeDatepicker: function(target, name, value) {\n        this._optionDatepicker(target, name, value);\n    },\n\n    /* Redraw the date picker attached to an input field or division.\n     * @param  target  element - the target input field or division or span\n     */\n    _refreshDatepicker: function(target) {\n        var inst = this._getInst(target);\n        if (inst) {\n            this._updateDatepicker(inst);\n        }\n    },\n\n    /* Set the dates for a jQuery selection.\n     * @param  target element - the target input field or division or span\n     * @param  date    Date - the new date\n     */\n    _setDateDatepicker: function(target, date) {\n        var inst = this._getInst(target);\n        if (inst) {\n            this._setDate(inst, date);\n            this._updateDatepicker(inst);\n            this._updateAlternate(inst);\n        }\n    },\n\n    /* Get the date(s) for the first entry in a jQuery selection.\n     * @param  target element - the target input field or division or span\n     * @param  noDefault boolean - true if no default date is to be used\n     * @return Date - the current date\n     */\n    _getDateDatepicker: function(target, noDefault) {\n        var inst = this._getInst(target);\n        if (inst && !inst.inline) {\n            this._setDateFromField(inst, noDefault);\n        }\n        return (inst ? this._getDate(inst) : null);\n    },\n\n    /* Handle keystrokes. */\n    _doKeyDown: function(event) {\n        var onSelect, dateStr, sel,\n            inst = $.datepicker._getInst(event.target),\n            handled = true,\n            isRTL = inst.dpDiv.is(\".ui-datepicker-rtl\");\n\n        inst._keyEvent = true;\n        if ($.datepicker._datepickerShowing) {\n            switch (event.keyCode) {\n                case 9: $.datepicker._hideDatepicker();\n                        handled = false;\n                        break; // hide on tab out\n                case 13: sel = $(\"td.\" + $.datepicker._dayOverClass + \":not(.\" +\n                                    $.datepicker._currentClass + \")\", inst.dpDiv);\n                        if (sel[0]) {\n                            $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);\n                        }\n\n                        onSelect = $.datepicker._get(inst, \"onSelect\");\n                        if (onSelect) {\n                            dateStr = $.datepicker._formatDate(inst);\n\n                            // trigger custom callback\n                            onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);\n                        } else {\n                            $.datepicker._hideDatepicker();\n                        }\n\n                        return false; // don't submit the form\n                case 27: $.datepicker._hideDatepicker();\n                        break; // hide on escape\n                case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?\n                            -$.datepicker._get(inst, \"stepBigMonths\") :\n                            -$.datepicker._get(inst, \"stepMonths\")), \"M\");\n                        break; // previous month/year on page up/+ ctrl\n                case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?\n                            +$.datepicker._get(inst, \"stepBigMonths\") :\n                            +$.datepicker._get(inst, \"stepMonths\")), \"M\");\n                        break; // next month/year on page down/+ ctrl\n                case 35: if (event.ctrlKey || event.metaKey) {\n                            $.datepicker._clearDate(event.target);\n                        }\n                        handled = event.ctrlKey || event.metaKey;\n                        break; // clear on ctrl or command +end\n                case 36: if (event.ctrlKey || event.metaKey) {\n                            $.datepicker._gotoToday(event.target);\n                        }\n                        handled = event.ctrlKey || event.metaKey;\n                        break; // current on ctrl or command +home\n                case 37: if (event.ctrlKey || event.metaKey) {\n                            $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), \"D\");\n                        }\n                        handled = event.ctrlKey || event.metaKey;\n                        // -1 day on ctrl or command +left\n                        if (event.originalEvent.altKey) {\n                            $.datepicker._adjustDate(event.target, (event.ctrlKey ?\n                                -$.datepicker._get(inst, \"stepBigMonths\") :\n                                -$.datepicker._get(inst, \"stepMonths\")), \"M\");\n                        }\n                        // next month/year on alt +left on Mac\n                        break;\n                case 38: if (event.ctrlKey || event.metaKey) {\n                            $.datepicker._adjustDate(event.target, -7, \"D\");\n                        }\n                        handled = event.ctrlKey || event.metaKey;\n                        break; // -1 week on ctrl or command +up\n                case 39: if (event.ctrlKey || event.metaKey) {\n                            $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), \"D\");\n                        }\n                        handled = event.ctrlKey || event.metaKey;\n                        // +1 day on ctrl or command +right\n                        if (event.originalEvent.altKey) {\n                            $.datepicker._adjustDate(event.target, (event.ctrlKey ?\n                                +$.datepicker._get(inst, \"stepBigMonths\") :\n                                +$.datepicker._get(inst, \"stepMonths\")), \"M\");\n                        }\n                        // next month/year on alt +right\n                        break;\n                case 40: if (event.ctrlKey || event.metaKey) {\n                            $.datepicker._adjustDate(event.target, +7, \"D\");\n                        }\n                        handled = event.ctrlKey || event.metaKey;\n                        break; // +1 week on ctrl or command +down\n                default: handled = false;\n            }\n        } else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home\n            $.datepicker._showDatepicker(this);\n        } else {\n            handled = false;\n        }\n\n        if (handled) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    },\n\n    /* Filter entered characters - based on date format. */\n    _doKeyPress: function(event) {\n        var chars, chr,\n            inst = $.datepicker._getInst(event.target);\n\n        if ($.datepicker._get(inst, \"constrainInput\")) {\n            chars = $.datepicker._possibleChars($.datepicker._get(inst, \"dateFormat\"));\n            chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);\n            return event.ctrlKey || event.metaKey || (chr < \" \" || !chars || chars.indexOf(chr) > -1);\n        }\n    },\n\n    /* Synchronise manual entry and field/alternate field. */\n    _doKeyUp: function(event) {\n        var date,\n            inst = $.datepicker._getInst(event.target);\n\n        if (inst.input.val() !== inst.lastVal) {\n            try {\n                date = $.datepicker.parseDate($.datepicker._get(inst, \"dateFormat\"),\n                    (inst.input ? inst.input.val() : null),\n                    $.datepicker._getFormatConfig(inst));\n\n                if (date) { // only if valid\n                    $.datepicker._setDateFromField(inst);\n                    $.datepicker._updateAlternate(inst);\n                    $.datepicker._updateDatepicker(inst);\n                }\n            }\n            catch (err) {\n            }\n        }\n        return true;\n    },\n\n    /* Pop-up the date picker for a given input field.\n     * If false returned from beforeShow event handler do not show.\n     * @param  input  element - the input field attached to the date picker or\n     *                    event - if triggered by focus\n     */\n    _showDatepicker: function(input) {\n        input = input.target || input;\n        if (input.nodeName.toLowerCase() !== \"input\") { // find from button/image trigger\n            input = $(\"input\", input.parentNode)[0];\n        }\n\n        if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here\n            return;\n        }\n\n        var inst, beforeShow, beforeShowSettings, isFixed,\n            offset, showAnim, duration;\n\n        inst = $.datepicker._getInst(input);\n        if ($.datepicker._curInst && $.datepicker._curInst !== inst) {\n            $.datepicker._curInst.dpDiv.stop(true, true);\n            if ( inst && $.datepicker._datepickerShowing ) {\n                $.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );\n            }\n        }\n\n        beforeShow = $.datepicker._get(inst, \"beforeShow\");\n        beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};\n        if(beforeShowSettings === false){\n            return;\n        }\n        datepicker_extendRemove(inst.settings, beforeShowSettings);\n\n        inst.lastVal = null;\n        $.datepicker._lastInput = input;\n        $.datepicker._setDateFromField(inst);\n\n        if ($.datepicker._inDialog) { // hide cursor\n            input.value = \"\";\n        }\n        if (!$.datepicker._pos) { // position below input\n            $.datepicker._pos = $.datepicker._findPos(input);\n            $.datepicker._pos[1] += input.offsetHeight; // add the height\n        }\n\n        isFixed = false;\n        $(input).parents().each(function() {\n            isFixed |= $(this).css(\"position\") === \"fixed\";\n            return !isFixed;\n        });\n\n        offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};\n        $.datepicker._pos = null;\n        //to avoid flashes on Firefox\n        inst.dpDiv.empty();\n        // determine sizing offscreen\n        inst.dpDiv.css({position: \"absolute\", display: \"block\", top: \"-1000px\"});\n        $.datepicker._updateDatepicker(inst);\n        // fix width for dynamic number of date pickers\n        // and adjust position before showing\n        offset = $.datepicker._checkOffset(inst, offset, isFixed);\n        inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?\n            \"static\" : (isFixed ? \"fixed\" : \"absolute\")), display: \"none\",\n            left: offset.left + \"px\", top: offset.top + \"px\"});\n\n        if (!inst.inline) {\n            showAnim = $.datepicker._get(inst, \"showAnim\");\n            duration = $.datepicker._get(inst, \"duration\");\n            inst.dpDiv.css( \"z-index\", datepicker_getZindex( $( input ) ) + 1 );\n            $.datepicker._datepickerShowing = true;\n\n            if ( $.effects && $.effects.effect[ showAnim ] ) {\n                inst.dpDiv.show(showAnim, $.datepicker._get(inst, \"showOptions\"), duration);\n            } else {\n                inst.dpDiv[showAnim || \"show\"](showAnim ? duration : null);\n            }\n\n            if ( $.datepicker._shouldFocusInput( inst ) ) {\n                inst.input.focus();\n            }\n\n            $.datepicker._curInst = inst;\n        }\n    },\n\n    /* Generate the date picker content. */\n    _updateDatepicker: function(inst) {\n        this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)\n        datepicker_instActive = inst; // for delegate hover events\n        inst.dpDiv.empty().append(this._generateHTML(inst));\n        this._attachHandlers(inst);\n\n        var origyearshtml,\n            numMonths = this._getNumberOfMonths(inst),\n            cols = numMonths[1],\n            width = 17,\n            activeCell = inst.dpDiv.find( \".\" + this._dayOverClass + \" a\" );\n\n        if ( activeCell.length > 0 ) {\n            datepicker_handleMouseover.apply( activeCell.get( 0 ) );\n        }\n\n        inst.dpDiv.removeClass(\"ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4\").width(\"\");\n        if (cols > 1) {\n            inst.dpDiv.addClass(\"ui-datepicker-multi-\" + cols).css(\"width\", (width * cols) + \"em\");\n        }\n        inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? \"add\" : \"remove\") +\n            \"Class\"](\"ui-datepicker-multi\");\n        inst.dpDiv[(this._get(inst, \"isRTL\") ? \"add\" : \"remove\") +\n            \"Class\"](\"ui-datepicker-rtl\");\n\n        if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {\n            inst.input.focus();\n        }\n\n        // deffered render of the years select (to avoid flashes on Firefox)\n        if( inst.yearshtml ){\n            origyearshtml = inst.yearshtml;\n            setTimeout(function(){\n                //assure that inst.yearshtml didn't change.\n                if( origyearshtml === inst.yearshtml && inst.yearshtml ){\n                    inst.dpDiv.find(\"select.ui-datepicker-year:first\").replaceWith(inst.yearshtml);\n                }\n                origyearshtml = inst.yearshtml = null;\n            }, 0);\n        }\n    },\n\n    // #6694 - don't focus the input if it's already focused\n    // this breaks the change event in IE\n    // Support: IE and jQuery <1.9\n    _shouldFocusInput: function( inst ) {\n        return inst.input && inst.input.is( \":visible\" ) && !inst.input.is( \":disabled\" ) && !inst.input.is( \":focus\" );\n    },\n\n    /* Check positioning to remain on screen. */\n    _checkOffset: function(inst, offset, isFixed) {\n        var dpWidth = inst.dpDiv.outerWidth(),\n            dpHeight = inst.dpDiv.outerHeight(),\n            inputWidth = inst.input ? inst.input.outerWidth() : 0,\n            inputHeight = inst.input ? inst.input.outerHeight() : 0,\n            viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),\n            viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());\n\n        offset.left -= (this._get(inst, \"isRTL\") ? (dpWidth - inputWidth) : 0);\n        offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;\n        offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;\n\n        // now check if datepicker is showing outside window viewport - move to a better place if so.\n        offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?\n            Math.abs(offset.left + dpWidth - viewWidth) : 0);\n        offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?\n            Math.abs(dpHeight + inputHeight) : 0);\n\n        return offset;\n    },\n\n    /* Find an object's position on the screen. */\n    _findPos: function(obj) {\n        var position,\n            inst = this._getInst(obj),\n            isRTL = this._get(inst, \"isRTL\");\n\n        while (obj && (obj.type === \"hidden\" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {\n            obj = obj[isRTL ? \"previousSibling\" : \"nextSibling\"];\n        }\n\n        position = $(obj).offset();\n        return [position.left, position.top];\n    },\n\n    /* Hide the date picker from view.\n     * @param  input  element - the input field attached to the date picker\n     */\n    _hideDatepicker: function(input) {\n        var showAnim, duration, postProcess, onClose,\n            inst = this._curInst;\n\n        if (!inst || (input && inst !== $.data(input, \"datepicker\"))) {\n            return;\n        }\n\n        if (this._datepickerShowing) {\n            showAnim = this._get(inst, \"showAnim\");\n            duration = this._get(inst, \"duration\");\n            postProcess = function() {\n                $.datepicker._tidyDialog(inst);\n            };\n\n            // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed\n            if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {\n                inst.dpDiv.hide(showAnim, $.datepicker._get(inst, \"showOptions\"), duration, postProcess);\n            } else {\n                inst.dpDiv[(showAnim === \"slideDown\" ? \"slideUp\" :\n                    (showAnim === \"fadeIn\" ? \"fadeOut\" : \"hide\"))]((showAnim ? duration : null), postProcess);\n            }\n\n            if (!showAnim) {\n                postProcess();\n            }\n            this._datepickerShowing = false;\n\n            onClose = this._get(inst, \"onClose\");\n            if (onClose) {\n                onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : \"\"), inst]);\n            }\n\n            this._lastInput = null;\n            if (this._inDialog) {\n                this._dialogInput.css({ position: \"absolute\", left: \"0\", top: \"-100px\" });\n                if ($.blockUI) {\n                    $.unblockUI();\n                    $(\"body\").append(this.dpDiv);\n                }\n            }\n            this._inDialog = false;\n        }\n    },\n\n    /* Tidy up after a dialog display. */\n    _tidyDialog: function(inst) {\n        inst.dpDiv.removeClass(this._dialogClass).unbind(\".ui-datepicker-calendar\");\n    },\n\n    /* Close date picker if clicked elsewhere. */\n    _checkExternalClick: function(event) {\n        if (!$.datepicker._curInst) {\n            return;\n        }\n\n        var $target = $(event.target),\n            inst = $.datepicker._getInst($target[0]);\n\n        if ( ( ( $target[0].id !== $.datepicker._mainDivId &&\n                $target.parents(\"#\" + $.datepicker._mainDivId).length === 0 &&\n                !$target.hasClass($.datepicker.markerClassName) &&\n                !$target.closest(\".\" + $.datepicker._triggerClass).length &&\n                $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||\n            ( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {\n                $.datepicker._hideDatepicker();\n        }\n    },\n\n    /* Adjust one of the date sub-fields. */\n    _adjustDate: function(id, offset, period) {\n        var target = $(id),\n            inst = this._getInst(target[0]);\n\n        if (this._isDisabledDatepicker(target[0])) {\n            return;\n        }\n        this._adjustInstDate(inst, offset +\n            (period === \"M\" ? this._get(inst, \"showCurrentAtPos\") : 0), // undo positioning\n            period);\n        this._updateDatepicker(inst);\n    },\n\n    /* Action for current link. */\n    _gotoToday: function(id) {\n        var date,\n            target = $(id),\n            inst = this._getInst(target[0]);\n\n        if (this._get(inst, \"gotoCurrent\") && inst.currentDay) {\n            inst.selectedDay = inst.currentDay;\n            inst.drawMonth = inst.selectedMonth = inst.currentMonth;\n            inst.drawYear = inst.selectedYear = inst.currentYear;\n        } else {\n            date = new Date();\n            inst.selectedDay = date.getDate();\n            inst.drawMonth = inst.selectedMonth = date.getMonth();\n            inst.drawYear = inst.selectedYear = date.getFullYear();\n        }\n        this._notifyChange(inst);\n        this._adjustDate(target);\n    },\n\n    /* Action for selecting a new month/year. */\n    _selectMonthYear: function(id, select, period) {\n        var target = $(id),\n            inst = this._getInst(target[0]);\n\n        inst[\"selected\" + (period === \"M\" ? \"Month\" : \"Year\")] =\n        inst[\"draw\" + (period === \"M\" ? \"Month\" : \"Year\")] =\n            parseInt(select.options[select.selectedIndex].value,10);\n\n        this._notifyChange(inst);\n        this._adjustDate(target);\n    },\n\n    /* Action for selecting a day. */\n    _selectDay: function(id, month, year, td) {\n        var inst,\n            target = $(id);\n\n        if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {\n            return;\n        }\n\n        inst = this._getInst(target[0]);\n        inst.selectedDay = inst.currentDay = $(\"a\", td).html();\n        inst.selectedMonth = inst.currentMonth = month;\n        inst.selectedYear = inst.currentYear = year;\n        this._selectDate(id, this._formatDate(inst,\n            inst.currentDay, inst.currentMonth, inst.currentYear));\n    },\n\n    /* Erase the input field and hide the date picker. */\n    _clearDate: function(id) {\n        var target = $(id);\n        this._selectDate(target, \"\");\n    },\n\n    /* Update the input field with the selected date. */\n    _selectDate: function(id, dateStr) {\n        var onSelect,\n            target = $(id),\n            inst = this._getInst(target[0]);\n\n        dateStr = (dateStr != null ? dateStr : this._formatDate(inst));\n        if (inst.input) {\n            inst.input.val(dateStr);\n        }\n        this._updateAlternate(inst);\n\n        onSelect = this._get(inst, \"onSelect\");\n        if (onSelect) {\n            onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback\n        } else if (inst.input) {\n            inst.input.trigger(\"change\"); // fire the change event\n        }\n\n        if (inst.inline){\n            this._updateDatepicker(inst);\n        } else {\n            this._hideDatepicker();\n            this._lastInput = inst.input[0];\n            if (typeof(inst.input[0]) !== \"object\") {\n                inst.input.focus(); // restore focus\n            }\n            this._lastInput = null;\n        }\n    },\n\n    /* Update any alternate field to synchronise with the main field. */\n    _updateAlternate: function(inst) {\n        var altFormat, date, dateStr,\n            altField = this._get(inst, \"altField\");\n\n        if (altField) { // update alternate field too\n            altFormat = this._get(inst, \"altFormat\") || this._get(inst, \"dateFormat\");\n            date = this._getDate(inst);\n            dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));\n            $(altField).each(function() { $(this).val(dateStr); });\n        }\n    },\n\n    /* Set as beforeShowDay function to prevent selection of weekends.\n     * @param  date  Date - the date to customise\n     * @return [boolean, string] - is this date selectable?, what is its CSS class?\n     */\n    noWeekends: function(date) {\n        var day = date.getDay();\n        return [(day > 0 && day < 6), \"\"];\n    },\n\n    /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.\n     * @param  date  Date - the date to get the week for\n     * @return  number - the number of the week within the year that contains this date\n     */\n    iso8601Week: function(date) {\n        var time,\n            checkDate = new Date(date.getTime());\n\n        // Find Thursday of this week starting on Monday\n        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));\n\n        time = checkDate.getTime();\n        checkDate.setMonth(0); // Compare with Jan 1\n        checkDate.setDate(1);\n        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n    },\n\n    /* Parse a string value into a date object.\n     * See formatDate below for the possible formats.\n     *\n     * @param  format string - the expected format of the date\n     * @param  value string - the date in the above format\n     * @param  settings Object - attributes include:\n     *                    shortYearCutoff  number - the cutoff year for determining the century (optional)\n     *                    dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)\n     *                    dayNames        string[7] - names of the days from Sunday (optional)\n     *                    monthNamesShort string[12] - abbreviated names of the months (optional)\n     *                    monthNames        string[12] - names of the months (optional)\n     * @return  Date - the extracted date value or null if value is blank\n     */\n    parseDate: function (format, value, settings) {\n        if (format == null || value == null) {\n            throw \"Invalid arguments\";\n        }\n\n        value = (typeof value === \"object\" ? value.toString() : value + \"\");\n        if (value === \"\") {\n            return null;\n        }\n\n        var iFormat, dim, extra,\n            iValue = 0,\n            shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,\n            shortYearCutoff = (typeof shortYearCutoffTemp !== \"string\" ? shortYearCutoffTemp :\n                new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),\n            dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,\n            dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,\n            monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,\n            monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,\n            year = -1,\n            month = -1,\n            day = -1,\n            doy = -1,\n            literal = false,\n            date,\n            // Check whether a format character is doubled\n            lookAhead = function(match) {\n                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);\n                if (matches) {\n                    iFormat++;\n                }\n                return matches;\n            },\n            // Extract a number from the string value\n            getNumber = function(match) {\n                var isDoubled = lookAhead(match),\n                    size = (match === \"@\" ? 14 : (match === \"!\" ? 20 :\n                    (match === \"y\" && isDoubled ? 4 : (match === \"o\" ? 3 : 2)))),\n                    minSize = (match === \"y\" ? size : 1),\n                    digits = new RegExp(\"^\\\\d{\" + minSize + \",\" + size + \"}\"),\n                    num = value.substring(iValue).match(digits);\n                if (!num) {\n                    throw \"Missing number at position \" + iValue;\n                }\n                iValue += num[0].length;\n                return parseInt(num[0], 10);\n            },\n            // Extract a name from the string value and convert to an index\n            getName = function(match, shortNames, longNames) {\n                var index = -1,\n                    names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {\n                        return [ [k, v] ];\n                    }).sort(function (a, b) {\n                        return -(a[1].length - b[1].length);\n                    });\n\n                $.each(names, function (i, pair) {\n                    var name = pair[1];\n                    if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {\n                        index = pair[0];\n                        iValue += name.length;\n                        return false;\n                    }\n                });\n                if (index !== -1) {\n                    return index + 1;\n                } else {\n                    throw \"Unknown name at position \" + iValue;\n                }\n            },\n            // Confirm that a literal character matches the string value\n            checkLiteral = function() {\n                if (value.charAt(iValue) !== format.charAt(iFormat)) {\n                    throw \"Unexpected literal at position \" + iValue;\n                }\n                iValue++;\n            };\n\n        for (iFormat = 0; iFormat < format.length; iFormat++) {\n            if (literal) {\n                if (format.charAt(iFormat) === \"'\" && !lookAhead(\"'\")) {\n                    literal = false;\n                } else {\n                    checkLiteral();\n                }\n            } else {\n                switch (format.charAt(iFormat)) {\n                    case \"d\":\n                        day = getNumber(\"d\");\n                        break;\n                    case \"D\":\n                        getName(\"D\", dayNamesShort, dayNames);\n                        break;\n                    case \"o\":\n                        doy = getNumber(\"o\");\n                        break;\n                    case \"m\":\n                        month = getNumber(\"m\");\n                        break;\n                    case \"M\":\n                        month = getName(\"M\", monthNamesShort, monthNames);\n                        break;\n                    case \"y\":\n                        year = getNumber(\"y\");\n                        break;\n                    case \"@\":\n                        date = new Date(getNumber(\"@\"));\n                        year = date.getFullYear();\n                        month = date.getMonth() + 1;\n                        day = date.getDate();\n                        break;\n                    case \"!\":\n                        date = new Date((getNumber(\"!\") - this._ticksTo1970) / 10000);\n                        year = date.getFullYear();\n                        month = date.getMonth() + 1;\n                        day = date.getDate();\n                        break;\n                    case \"'\":\n                        if (lookAhead(\"'\")){\n                            checkLiteral();\n                        } else {\n                            literal = true;\n                        }\n                        break;\n                    default:\n                        checkLiteral();\n                }\n            }\n        }\n\n        if (iValue < value.length){\n            extra = value.substr(iValue);\n            if (!/^\\s+/.test(extra)) {\n                throw \"Extra/unparsed characters found in date: \" + extra;\n            }\n        }\n\n        if (year === -1) {\n            year = new Date().getFullYear();\n        } else if (year < 100) {\n            year += new Date().getFullYear() - new Date().getFullYear() % 100 +\n                (year <= shortYearCutoff ? 0 : -100);\n        }\n\n        if (doy > -1) {\n            month = 1;\n            day = doy;\n            do {\n                dim = this._getDaysInMonth(year, month - 1);\n                if (day <= dim) {\n                    break;\n                }\n                month++;\n                day -= dim;\n            } while (true);\n        }\n\n        date = this._daylightSavingAdjust(new Date(year, month - 1, day));\n        if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {\n            throw \"Invalid date\"; // E.g. 31/02/00\n        }\n        return date;\n    },\n\n    /* Standard date formats. */\n    ATOM: \"yy-mm-dd\", // RFC 3339 (ISO 8601)\n    COOKIE: \"D, dd M yy\",\n    ISO_8601: \"yy-mm-dd\",\n    RFC_822: \"D, d M y\",\n    RFC_850: \"DD, dd-M-y\",\n    RFC_1036: \"D, d M y\",\n    RFC_1123: \"D, d M yy\",\n    RFC_2822: \"D, d M yy\",\n    RSS: \"D, d M y\", // RFC 822\n    TICKS: \"!\",\n    TIMESTAMP: \"@\",\n    W3C: \"yy-mm-dd\", // ISO 8601\n\n    _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +\n        Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),\n\n    /* Format a date object into a string value.\n     * The format can be combinations of the following:\n     * d  - day of month (no leading zero)\n     * dd - day of month (two digit)\n     * o  - day of year (no leading zeros)\n     * oo - day of year (three digit)\n     * D  - day name short\n     * DD - day name long\n     * m  - month of year (no leading zero)\n     * mm - month of year (two digit)\n     * M  - month name short\n     * MM - month name long\n     * y  - year (two digit)\n     * yy - year (four digit)\n     * @ - Unix timestamp (ms since 01/01/1970)\n     * ! - Windows ticks (100ns since 01/01/0001)\n     * \"...\" - literal text\n     * '' - single quote\n     *\n     * @param  format string - the desired format of the date\n     * @param  date Date - the date value to format\n     * @param  settings Object - attributes include:\n     *                    dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)\n     *                    dayNames        string[7] - names of the days from Sunday (optional)\n     *                    monthNamesShort string[12] - abbreviated names of the months (optional)\n     *                    monthNames        string[12] - names of the months (optional)\n     * @return  string - the date in the above format\n     */\n    formatDate: function (format, date, settings) {\n        if (!date) {\n            return \"\";\n        }\n\n        var iFormat,\n            dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,\n            dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,\n            monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,\n            monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,\n            // Check whether a format character is doubled\n            lookAhead = function(match) {\n                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);\n                if (matches) {\n                    iFormat++;\n                }\n                return matches;\n            },\n            // Format a number, with leading zero if necessary\n            formatNumber = function(match, value, len) {\n                var num = \"\" + value;\n                if (lookAhead(match)) {\n                    while (num.length < len) {\n                        num = \"0\" + num;\n                    }\n                }\n                return num;\n            },\n            // Format a name, short or long as requested\n            formatName = function(match, value, shortNames, longNames) {\n                return (lookAhead(match) ? longNames[value] : shortNames[value]);\n            },\n            output = \"\",\n            literal = false;\n\n        if (date) {\n            for (iFormat = 0; iFormat < format.length; iFormat++) {\n                if (literal) {\n                    if (format.charAt(iFormat) === \"'\" && !lookAhead(\"'\")) {\n                        literal = false;\n                    } else {\n                        output += format.charAt(iFormat);\n                    }\n                } else {\n                    switch (format.charAt(iFormat)) {\n                        case \"d\":\n                            output += formatNumber(\"d\", date.getDate(), 2);\n                            break;\n                        case \"D\":\n                            output += formatName(\"D\", date.getDay(), dayNamesShort, dayNames);\n                            break;\n                        case \"o\":\n                            output += formatNumber(\"o\",\n                                Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);\n                            break;\n                        case \"m\":\n                            output += formatNumber(\"m\", date.getMonth() + 1, 2);\n                            break;\n                        case \"M\":\n                            output += formatName(\"M\", date.getMonth(), monthNamesShort, monthNames);\n                            break;\n                        case \"y\":\n                            output += (lookAhead(\"y\") ? date.getFullYear() :\n                                (date.getYear() % 100 < 10 ? \"0\" : \"\") + date.getYear() % 100);\n                            break;\n                        case \"@\":\n                            output += date.getTime();\n                            break;\n                        case \"!\":\n                            output += date.getTime() * 10000 + this._ticksTo1970;\n                            break;\n                        case \"'\":\n                            if (lookAhead(\"'\")) {\n                                output += \"'\";\n                            } else {\n                                literal = true;\n                            }\n                            break;\n                        default:\n                            output += format.charAt(iFormat);\n                    }\n                }\n            }\n        }\n        return output;\n    },\n\n    /* Extract all possible characters from the date format. */\n    _possibleChars: function (format) {\n        var iFormat,\n            chars = \"\",\n            literal = false,\n            // Check whether a format character is doubled\n            lookAhead = function(match) {\n                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);\n                if (matches) {\n                    iFormat++;\n                }\n                return matches;\n            };\n\n        for (iFormat = 0; iFormat < format.length; iFormat++) {\n            if (literal) {\n                if (format.charAt(iFormat) === \"'\" && !lookAhead(\"'\")) {\n                    literal = false;\n                } else {\n                    chars += format.charAt(iFormat);\n                }\n            } else {\n                switch (format.charAt(iFormat)) {\n                    case \"d\": case \"m\": case \"y\": case \"@\":\n                        chars += \"0123456789\";\n                        break;\n                    case \"D\": case \"M\":\n                        return null; // Accept anything\n                    case \"'\":\n                        if (lookAhead(\"'\")) {\n                            chars += \"'\";\n                        } else {\n                            literal = true;\n                        }\n                        break;\n                    default:\n                        chars += format.charAt(iFormat);\n                }\n            }\n        }\n        return chars;\n    },\n\n    /* Get a setting value, defaulting if necessary. */\n    _get: function(inst, name) {\n        return inst.settings[name] !== undefined ?\n            inst.settings[name] : this._defaults[name];\n    },\n\n    /* Parse existing date and initialise date picker. */\n    _setDateFromField: function(inst, noDefault) {\n        if (inst.input.val() === inst.lastVal) {\n            return;\n        }\n\n        var dateFormat = this._get(inst, \"dateFormat\"),\n            dates = inst.lastVal = inst.input ? inst.input.val() : null,\n            defaultDate = this._getDefaultDate(inst),\n            date = defaultDate,\n            settings = this._getFormatConfig(inst);\n\n        try {\n            date = this.parseDate(dateFormat, dates, settings) || defaultDate;\n        } catch (event) {\n            dates = (noDefault ? \"\" : dates);\n        }\n        inst.selectedDay = date.getDate();\n        inst.drawMonth = inst.selectedMonth = date.getMonth();\n        inst.drawYear = inst.selectedYear = date.getFullYear();\n        inst.currentDay = (dates ? date.getDate() : 0);\n        inst.currentMonth = (dates ? date.getMonth() : 0);\n        inst.currentYear = (dates ? date.getFullYear() : 0);\n        this._adjustInstDate(inst);\n    },\n\n    /* Retrieve the default date shown on opening. */\n    _getDefaultDate: function(inst) {\n        return this._restrictMinMax(inst,\n            this._determineDate(inst, this._get(inst, \"defaultDate\"), new Date()));\n    },\n\n    /* A date may be specified as an exact value or a relative one. */\n    _determineDate: function(inst, date, defaultDate) {\n        var offsetNumeric = function(offset) {\n                var date = new Date();\n                date.setDate(date.getDate() + offset);\n                return date;\n            },\n            offsetString = function(offset) {\n                try {\n                    return $.datepicker.parseDate($.datepicker._get(inst, \"dateFormat\"),\n                        offset, $.datepicker._getFormatConfig(inst));\n                }\n                catch (e) {\n                    // Ignore\n                }\n\n                var date = (offset.toLowerCase().match(/^c/) ?\n                    $.datepicker._getDate(inst) : null) || new Date(),\n                    year = date.getFullYear(),\n                    month = date.getMonth(),\n                    day = date.getDate(),\n                    pattern = /([+\\-]?[0-9]+)\\s*(d|D|w|W|m|M|y|Y)?/g,\n                    matches = pattern.exec(offset);\n\n                while (matches) {\n                    switch (matches[2] || \"d\") {\n                        case \"d\" : case \"D\" :\n                            day += parseInt(matches[1],10); break;\n                        case \"w\" : case \"W\" :\n                            day += parseInt(matches[1],10) * 7; break;\n                        case \"m\" : case \"M\" :\n                            month += parseInt(matches[1],10);\n                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));\n                            break;\n                        case \"y\": case \"Y\" :\n                            year += parseInt(matches[1],10);\n                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));\n                            break;\n                    }\n                    matches = pattern.exec(offset);\n                }\n                return new Date(year, month, day);\n            },\n            newDate = (date == null || date === \"\" ? defaultDate : (typeof date === \"string\" ? offsetString(date) :\n                (typeof date === \"number\" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));\n\n        newDate = (newDate && newDate.toString() === \"Invalid Date\" ? defaultDate : newDate);\n        if (newDate) {\n            newDate.setHours(0);\n            newDate.setMinutes(0);\n            newDate.setSeconds(0);\n            newDate.setMilliseconds(0);\n        }\n        return this._daylightSavingAdjust(newDate);\n    },\n\n    /* Handle switch to/from daylight saving.\n     * Hours may be non-zero on daylight saving cut-over:\n     * > 12 when midnight changeover, but then cannot generate\n     * midnight datetime, so jump to 1AM, otherwise reset.\n     * @param  date  (Date) the date to check\n     * @return  (Date) the corrected date\n     */\n    _daylightSavingAdjust: function(date) {\n        if (!date) {\n            return null;\n        }\n        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\n        return date;\n    },\n\n    /* Set the date(s) directly. */\n    _setDate: function(inst, date, noChange) {\n        var clear = !date,\n            origMonth = inst.selectedMonth,\n            origYear = inst.selectedYear,\n            newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));\n\n        inst.selectedDay = inst.currentDay = newDate.getDate();\n        inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();\n        inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();\n        if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {\n            this._notifyChange(inst);\n        }\n        this._adjustInstDate(inst);\n        if (inst.input) {\n            inst.input.val(clear ? \"\" : this._formatDate(inst));\n        }\n    },\n\n    /* Retrieve the date(s) directly. */\n    _getDate: function(inst) {\n        var startDate = (!inst.currentYear || (inst.input && inst.input.val() === \"\") ? null :\n            this._daylightSavingAdjust(new Date(\n            inst.currentYear, inst.currentMonth, inst.currentDay)));\n            return startDate;\n    },\n\n    /* Attach the onxxx handlers.  These are declared statically so\n     * they work with static code transformers like Caja.\n     */\n    _attachHandlers: function(inst) {\n        var stepMonths = this._get(inst, \"stepMonths\"),\n            id = \"#\" + inst.id.replace( /\\\\\\\\/g, \"\\\\\" );\n        inst.dpDiv.find(\"[data-handler]\").map(function () {\n            var handler = {\n                prev: function () {\n                    $.datepicker._adjustDate(id, -stepMonths, \"M\");\n                },\n                next: function () {\n                    $.datepicker._adjustDate(id, +stepMonths, \"M\");\n                },\n                hide: function () {\n                    $.datepicker._hideDatepicker();\n                },\n                today: function () {\n                    $.datepicker._gotoToday(id);\n                },\n                selectDay: function () {\n                    $.datepicker._selectDay(id, +this.getAttribute(\"data-month\"), +this.getAttribute(\"data-year\"), this);\n                    return false;\n                },\n                selectMonth: function () {\n                    $.datepicker._selectMonthYear(id, this, \"M\");\n                    return false;\n                },\n                selectYear: function () {\n                    $.datepicker._selectMonthYear(id, this, \"Y\");\n                    return false;\n                }\n            };\n            $(this).bind(this.getAttribute(\"data-event\"), handler[this.getAttribute(\"data-handler\")]);\n        });\n    },\n\n    /* Generate the HTML for the current state of the date picker. */\n    _generateHTML: function(inst) {\n        var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,\n            controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,\n            monthNames, monthNamesShort, beforeShowDay, showOtherMonths,\n            selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,\n            cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,\n            printDate, dRow, tbody, daySettings, otherMonth, unselectable,\n            tempDate = new Date(),\n            today = this._daylightSavingAdjust(\n                new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time\n            isRTL = this._get(inst, \"isRTL\"),\n            showButtonPanel = this._get(inst, \"showButtonPanel\"),\n            hideIfNoPrevNext = this._get(inst, \"hideIfNoPrevNext\"),\n            navigationAsDateFormat = this._get(inst, \"navigationAsDateFormat\"),\n            numMonths = this._getNumberOfMonths(inst),\n            showCurrentAtPos = this._get(inst, \"showCurrentAtPos\"),\n            stepMonths = this._get(inst, \"stepMonths\"),\n            isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),\n            currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :\n                new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),\n            minDate = this._getMinMaxDate(inst, \"min\"),\n            maxDate = this._getMinMaxDate(inst, \"max\"),\n            drawMonth = inst.drawMonth - showCurrentAtPos,\n            drawYear = inst.drawYear;\n\n        if (drawMonth < 0) {\n            drawMonth += 12;\n            drawYear--;\n        }\n        if (maxDate) {\n            maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),\n                maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));\n            maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);\n            while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {\n                drawMonth--;\n                if (drawMonth < 0) {\n                    drawMonth = 11;\n                    drawYear--;\n                }\n            }\n        }\n        inst.drawMonth = drawMonth;\n        inst.drawYear = drawYear;\n\n        prevText = this._get(inst, \"prevText\");\n        prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,\n            this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),\n            this._getFormatConfig(inst)));\n\n        prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?\n            \"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'\" +\n            \" title='\" + prevText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + ( isRTL ? \"e\" : \"w\") + \"'>\" + prevText + \"</span></a>\" :\n            (hideIfNoPrevNext ? \"\" : \"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='\"+ prevText +\"'><span class='ui-icon ui-icon-circle-triangle-\" + ( isRTL ? \"e\" : \"w\") + \"'>\" + prevText + \"</span></a>\"));\n\n        nextText = this._get(inst, \"nextText\");\n        nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,\n            this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),\n            this._getFormatConfig(inst)));\n\n        next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?\n            \"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'\" +\n            \" title='\" + nextText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + ( isRTL ? \"w\" : \"e\") + \"'>\" + nextText + \"</span></a>\" :\n            (hideIfNoPrevNext ? \"\" : \"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='\"+ nextText + \"'><span class='ui-icon ui-icon-circle-triangle-\" + ( isRTL ? \"w\" : \"e\") + \"'>\" + nextText + \"</span></a>\"));\n\n        currentText = this._get(inst, \"currentText\");\n        gotoDate = (this._get(inst, \"gotoCurrent\") && inst.currentDay ? currentDate : today);\n        currentText = (!navigationAsDateFormat ? currentText :\n            this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));\n\n        controls = (!inst.inline ? \"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>\" +\n            this._get(inst, \"closeText\") + \"</button>\" : \"\");\n\n        buttonPanel = (showButtonPanel) ? \"<div class='ui-datepicker-buttonpane ui-widget-content'>\" + (isRTL ? controls : \"\") +\n            (this._isInRange(inst, gotoDate) ? \"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'\" +\n            \">\" + currentText + \"</button>\" : \"\") + (isRTL ? \"\" : controls) + \"</div>\" : \"\";\n\n        firstDay = parseInt(this._get(inst, \"firstDay\"),10);\n        firstDay = (isNaN(firstDay) ? 0 : firstDay);\n\n        showWeek = this._get(inst, \"showWeek\");\n        dayNames = this._get(inst, \"dayNames\");\n        dayNamesMin = this._get(inst, \"dayNamesMin\");\n        monthNames = this._get(inst, \"monthNames\");\n        monthNamesShort = this._get(inst, \"monthNamesShort\");\n        beforeShowDay = this._get(inst, \"beforeShowDay\");\n        showOtherMonths = this._get(inst, \"showOtherMonths\");\n        selectOtherMonths = this._get(inst, \"selectOtherMonths\");\n        defaultDate = this._getDefaultDate(inst);\n        html = \"\";\n        dow;\n        for (row = 0; row < numMonths[0]; row++) {\n            group = \"\";\n            this.maxRows = 4;\n            for (col = 0; col < numMonths[1]; col++) {\n                selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));\n                cornerClass = \" ui-corner-all\";\n                calender = \"\";\n                if (isMultiMonth) {\n                    calender += \"<div class='ui-datepicker-group\";\n                    if (numMonths[1] > 1) {\n                        switch (col) {\n                            case 0: calender += \" ui-datepicker-group-first\";\n                                cornerClass = \" ui-corner-\" + (isRTL ? \"right\" : \"left\"); break;\n                            case numMonths[1]-1: calender += \" ui-datepicker-group-last\";\n                                cornerClass = \" ui-corner-\" + (isRTL ? \"left\" : \"right\"); break;\n                            default: calender += \" ui-datepicker-group-middle\"; cornerClass = \"\"; break;\n                        }\n                    }\n                    calender += \"'>\";\n                }\n                calender += \"<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix\" + cornerClass + \"'>\" +\n                    (/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : \"\") +\n                    (/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : \"\") +\n                    this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,\n                    row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers\n                    \"</div><table class='ui-datepicker-calendar'><thead>\" +\n                    \"<tr>\";\n                thead = (showWeek ? \"<th class='ui-datepicker-week-col'>\" + this._get(inst, \"weekHeader\") + \"</th>\" : \"\");\n                for (dow = 0; dow < 7; dow++) { // days of the week\n                    day = (dow + firstDay) % 7;\n                    thead += \"<th scope='col'\" + ((dow + firstDay + 6) % 7 >= 5 ? \" class='ui-datepicker-week-end'\" : \"\") + \">\" +\n                        \"<span title='\" + dayNames[day] + \"'>\" + dayNamesMin[day] + \"</span></th>\";\n                }\n                calender += thead + \"</tr></thead><tbody>\";\n                daysInMonth = this._getDaysInMonth(drawYear, drawMonth);\n                if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {\n                    inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);\n                }\n                leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;\n                curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate\n                numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)\n                this.maxRows = numRows;\n                printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));\n                for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows\n                    calender += \"<tr>\";\n                    tbody = (!showWeek ? \"\" : \"<td class='ui-datepicker-week-col'>\" +\n                        this._get(inst, \"calculateWeek\")(printDate) + \"</td>\");\n                    for (dow = 0; dow < 7; dow++) { // create date picker days\n                        daySettings = (beforeShowDay ?\n                            beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, \"\"]);\n                        otherMonth = (printDate.getMonth() !== drawMonth);\n                        unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||\n                            (minDate && printDate < minDate) || (maxDate && printDate > maxDate);\n                        tbody += \"<td class='\" +\n                            ((dow + firstDay + 6) % 7 >= 5 ? \" ui-datepicker-week-end\" : \"\") + // highlight weekends\n                            (otherMonth ? \" ui-datepicker-other-month\" : \"\") + // highlight days from other months\n                            ((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key\n                            (defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?\n                            // or defaultDate is current printedDate and defaultDate is selectedDate\n                            \" \" + this._dayOverClass : \"\") + // highlight selected day\n                            (unselectable ? \" \" + this._unselectableClass + \" ui-state-disabled\": \"\") +  // highlight unselectable days\n                            (otherMonth && !showOtherMonths ? \"\" : \" \" + daySettings[1] + // highlight custom dates\n                            (printDate.getTime() === currentDate.getTime() ? \" \" + this._currentClass : \"\") + // highlight selected day\n                            (printDate.getTime() === today.getTime() ? \" ui-datepicker-today\" : \"\")) + \"'\" + // highlight today (if different)\n                            ((!otherMonth || showOtherMonths) && daySettings[2] ? \" title='\" + daySettings[2].replace(/'/g, \"&#39;\") + \"'\" : \"\") + // cell title\n                            (unselectable ? \"\" : \" data-handler='selectDay' data-event='click' data-month='\" + printDate.getMonth() + \"' data-year='\" + printDate.getFullYear() + \"'\") + \">\" + // actions\n                            (otherMonth && !showOtherMonths ? \"&#xa0;\" : // display for other months\n                            (unselectable ? \"<span class='ui-state-default'>\" + printDate.getDate() + \"</span>\" : \"<a class='ui-state-default\" +\n                            (printDate.getTime() === today.getTime() ? \" ui-state-highlight\" : \"\") +\n                            (printDate.getTime() === currentDate.getTime() ? \" ui-state-active\" : \"\") + // highlight selected day\n                            (otherMonth ? \" ui-priority-secondary\" : \"\") + // distinguish dates from other months\n                            \"' href='#'>\" + printDate.getDate() + \"</a>\")) + \"</td>\"; // display selectable date\n                        printDate.setDate(printDate.getDate() + 1);\n                        printDate = this._daylightSavingAdjust(printDate);\n                    }\n                    calender += tbody + \"</tr>\";\n                }\n                drawMonth++;\n                if (drawMonth > 11) {\n                    drawMonth = 0;\n                    drawYear++;\n                }\n                calender += \"</tbody></table>\" + (isMultiMonth ? \"</div>\" +\n                            ((numMonths[0] > 0 && col === numMonths[1]-1) ? \"<div class='ui-datepicker-row-break'></div>\" : \"\") : \"\");\n                group += calender;\n            }\n            html += group;\n        }\n        html += buttonPanel;\n        inst._keyEvent = false;\n        return html;\n    },\n\n    /* Generate the month and year header. */\n    _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,\n            secondary, monthNames, monthNamesShort) {\n\n        var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,\n            changeMonth = this._get(inst, \"changeMonth\"),\n            changeYear = this._get(inst, \"changeYear\"),\n            showMonthAfterYear = this._get(inst, \"showMonthAfterYear\"),\n            html = \"<div class='ui-datepicker-title'>\",\n            monthHtml = \"\";\n\n        // month selection\n        if (secondary || !changeMonth) {\n            monthHtml += \"<span class='ui-datepicker-month'>\" + monthNames[drawMonth] + \"</span>\";\n        } else {\n            inMinYear = (minDate && minDate.getFullYear() === drawYear);\n            inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);\n            monthHtml += \"<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>\";\n            for ( month = 0; month < 12; month++) {\n                if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {\n                    monthHtml += \"<option value='\" + month + \"'\" +\n                        (month === drawMonth ? \" selected='selected'\" : \"\") +\n                        \">\" + monthNamesShort[month] + \"</option>\";\n                }\n            }\n            monthHtml += \"</select>\";\n        }\n\n        if (!showMonthAfterYear) {\n            html += monthHtml + (secondary || !(changeMonth && changeYear) ? \"&#xa0;\" : \"\");\n        }\n\n        // year selection\n        if ( !inst.yearshtml ) {\n            inst.yearshtml = \"\";\n            if (secondary || !changeYear) {\n                html += \"<span class='ui-datepicker-year'>\" + drawYear + \"</span>\";\n            } else {\n                // determine range of years to display\n                years = this._get(inst, \"yearRange\").split(\":\");\n                thisYear = new Date().getFullYear();\n                determineYear = function(value) {\n                    var year = (value.match(/c[+\\-].*/) ? drawYear + parseInt(value.substring(1), 10) :\n                        (value.match(/[+\\-].*/) ? thisYear + parseInt(value, 10) :\n                        parseInt(value, 10)));\n                    return (isNaN(year) ? thisYear : year);\n                };\n                year = determineYear(years[0]);\n                endYear = Math.max(year, determineYear(years[1] || \"\"));\n                year = (minDate ? Math.max(year, minDate.getFullYear()) : year);\n                endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);\n                inst.yearshtml += \"<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>\";\n                for (; year <= endYear; year++) {\n                    inst.yearshtml += \"<option value='\" + year + \"'\" +\n                        (year === drawYear ? \" selected='selected'\" : \"\") +\n                        \">\" + year + \"</option>\";\n                }\n                inst.yearshtml += \"</select>\";\n\n                html += inst.yearshtml;\n                inst.yearshtml = null;\n            }\n        }\n\n        html += this._get(inst, \"yearSuffix\");\n        if (showMonthAfterYear) {\n            html += (secondary || !(changeMonth && changeYear) ? \"&#xa0;\" : \"\") + monthHtml;\n        }\n        html += \"</div>\"; // Close datepicker_header\n        return html;\n    },\n\n    /* Adjust one of the date sub-fields. */\n    _adjustInstDate: function(inst, offset, period) {\n        var year = inst.drawYear + (period === \"Y\" ? offset : 0),\n            month = inst.drawMonth + (period === \"M\" ? offset : 0),\n            day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === \"D\" ? offset : 0),\n            date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));\n\n        inst.selectedDay = date.getDate();\n        inst.drawMonth = inst.selectedMonth = date.getMonth();\n        inst.drawYear = inst.selectedYear = date.getFullYear();\n        if (period === \"M\" || period === \"Y\") {\n            this._notifyChange(inst);\n        }\n    },\n\n    /* Ensure a date is within any min/max bounds. */\n    _restrictMinMax: function(inst, date) {\n        var minDate = this._getMinMaxDate(inst, \"min\"),\n            maxDate = this._getMinMaxDate(inst, \"max\"),\n            newDate = (minDate && date < minDate ? minDate : date);\n        return (maxDate && newDate > maxDate ? maxDate : newDate);\n    },\n\n    /* Notify change of month/year. */\n    _notifyChange: function(inst) {\n        var onChange = this._get(inst, \"onChangeMonthYear\");\n        if (onChange) {\n            onChange.apply((inst.input ? inst.input[0] : null),\n                [inst.selectedYear, inst.selectedMonth + 1, inst]);\n        }\n    },\n\n    /* Determine the number of months to show. */\n    _getNumberOfMonths: function(inst) {\n        var numMonths = this._get(inst, \"numberOfMonths\");\n        return (numMonths == null ? [1, 1] : (typeof numMonths === \"number\" ? [1, numMonths] : numMonths));\n    },\n\n    /* Determine the current maximum date - ensure no time components are set. */\n    _getMinMaxDate: function(inst, minMax) {\n        return this._determineDate(inst, this._get(inst, minMax + \"Date\"), null);\n    },\n\n    /* Find the number of days in a given month. */\n    _getDaysInMonth: function(year, month) {\n        return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();\n    },\n\n    /* Find the day of the week of the first of a month. */\n    _getFirstDayOfMonth: function(year, month) {\n        return new Date(year, month, 1).getDay();\n    },\n\n    /* Determines if we should allow a \"next/prev\" month display change. */\n    _canAdjustMonth: function(inst, offset, curYear, curMonth) {\n        var numMonths = this._getNumberOfMonths(inst),\n            date = this._daylightSavingAdjust(new Date(curYear,\n            curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));\n\n        if (offset < 0) {\n            date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));\n        }\n        return this._isInRange(inst, date);\n    },\n\n    /* Is the given date in the accepted range? */\n    _isInRange: function(inst, date) {\n        var yearSplit, currentYear,\n            minDate = this._getMinMaxDate(inst, \"min\"),\n            maxDate = this._getMinMaxDate(inst, \"max\"),\n            minYear = null,\n            maxYear = null,\n            years = this._get(inst, \"yearRange\");\n            if (years){\n                yearSplit = years.split(\":\");\n                currentYear = new Date().getFullYear();\n                minYear = parseInt(yearSplit[0], 10);\n                maxYear = parseInt(yearSplit[1], 10);\n                if ( yearSplit[0].match(/[+\\-].*/) ) {\n                    minYear += currentYear;\n                }\n                if ( yearSplit[1].match(/[+\\-].*/) ) {\n                    maxYear += currentYear;\n                }\n            }\n\n        return ((!minDate || date.getTime() >= minDate.getTime()) &&\n            (!maxDate || date.getTime() <= maxDate.getTime()) &&\n            (!minYear || date.getFullYear() >= minYear) &&\n            (!maxYear || date.getFullYear() <= maxYear));\n    },\n\n    /* Provide the configuration settings for formatting/parsing. */\n    _getFormatConfig: function(inst) {\n        var shortYearCutoff = this._get(inst, \"shortYearCutoff\");\n        shortYearCutoff = (typeof shortYearCutoff !== \"string\" ? shortYearCutoff :\n            new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));\n        return {shortYearCutoff: shortYearCutoff,\n            dayNamesShort: this._get(inst, \"dayNamesShort\"), dayNames: this._get(inst, \"dayNames\"),\n            monthNamesShort: this._get(inst, \"monthNamesShort\"), monthNames: this._get(inst, \"monthNames\")};\n    },\n\n    /* Format the given date for display. */\n    _formatDate: function(inst, day, month, year) {\n        if (!day) {\n            inst.currentDay = inst.selectedDay;\n            inst.currentMonth = inst.selectedMonth;\n            inst.currentYear = inst.selectedYear;\n        }\n        var date = (day ? (typeof day === \"object\" ? day :\n            this._daylightSavingAdjust(new Date(year, month, day))) :\n            this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));\n        return this.formatDate(this._get(inst, \"dateFormat\"), date, this._getFormatConfig(inst));\n    }\n});\n\n/*\n * Bind hover events for datepicker elements.\n * Done via delegate so the binding only occurs once in the lifetime of the parent div.\n * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.\n */\nfunction datepicker_bindHover(dpDiv) {\n    var selector = \"button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a\";\n    return dpDiv.delegate(selector, \"mouseout\", function() {\n            $(this).removeClass(\"ui-state-hover\");\n            if (this.className.indexOf(\"ui-datepicker-prev\") !== -1) {\n                $(this).removeClass(\"ui-datepicker-prev-hover\");\n            }\n            if (this.className.indexOf(\"ui-datepicker-next\") !== -1) {\n                $(this).removeClass(\"ui-datepicker-next-hover\");\n            }\n        })\n        .delegate( selector, \"mouseover\", datepicker_handleMouseover );\n}\n\nfunction datepicker_handleMouseover() {\n    if (!$.datepicker._isDisabledDatepicker( datepicker_instActive.inline? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {\n        $(this).parents(\".ui-datepicker-calendar\").find(\"a\").removeClass(\"ui-state-hover\");\n        $(this).addClass(\"ui-state-hover\");\n        if (this.className.indexOf(\"ui-datepicker-prev\") !== -1) {\n            $(this).addClass(\"ui-datepicker-prev-hover\");\n        }\n        if (this.className.indexOf(\"ui-datepicker-next\") !== -1) {\n            $(this).addClass(\"ui-datepicker-next-hover\");\n        }\n    }\n}\n\n/* jQuery extend now ignores nulls! */\nfunction datepicker_extendRemove(target, props) {\n    $.extend(target, props);\n    for (var name in props) {\n        if (props[name] == null) {\n            target[name] = props[name];\n        }\n    }\n    return target;\n}\n\n/* Invoke the datepicker functionality.\n   @param  options  string - a command, optionally followed by additional parameters or\n                    Object - settings for attaching new datepicker functionality\n   @return  jQuery object */\n$.fn.datepicker = function(options){\n\n    /* Verify an empty collection wasn't passed - Fixes #6976 */\n    if ( !this.length ) {\n        return this;\n    }\n\n    /* Initialise the date picker. */\n    if (!$.datepicker.initialized) {\n        $(document).mousedown($.datepicker._checkExternalClick);\n        $.datepicker.initialized = true;\n    }\n\n    /* Append datepicker main container to body if not exist. */\n    if ($(\"#\"+$.datepicker._mainDivId).length === 0) {\n        $(\"body\").append($.datepicker.dpDiv);\n    }\n\n    var otherArgs = Array.prototype.slice.call(arguments, 1);\n    if (typeof options === \"string\" && (options === \"isDisabled\" || options === \"getDate\" || options === \"widget\")) {\n        return $.datepicker[\"_\" + options + \"Datepicker\"].\n            apply($.datepicker, [this[0]].concat(otherArgs));\n    }\n    if (options === \"option\" && arguments.length === 2 && typeof arguments[1] === \"string\") {\n        return $.datepicker[\"_\" + options + \"Datepicker\"].\n            apply($.datepicker, [this[0]].concat(otherArgs));\n    }\n    return this.each(function() {\n        typeof options === \"string\" ?\n            $.datepicker[\"_\" + options + \"Datepicker\"].\n                apply($.datepicker, [this].concat(otherArgs)) :\n            $.datepicker._attachDatepicker(this, options);\n    });\n};\n\n$.datepicker = new Datepicker(); // singleton instance\n$.datepicker.initialized = false;\n$.datepicker.uuid = new Date().getTime();\n$.datepicker.version = \"1.11.2\";\n\nvar datepicker = $.datepicker;\n\n\n/*!\n * jQuery UI Draggable 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/draggable/\n */\n\n\n$.widget(\"ui.draggable\", $.ui.mouse, {\n    version: \"1.11.2\",\n    widgetEventPrefix: \"drag\",\n    options: {\n        addClasses: true,\n        appendTo: \"parent\",\n        axis: false,\n        connectToSortable: false,\n        containment: false,\n        cursor: \"auto\",\n        cursorAt: false,\n        grid: false,\n        handle: false,\n        helper: \"original\",\n        iframeFix: false,\n        opacity: false,\n        refreshPositions: false,\n        revert: false,\n        revertDuration: 500,\n        scope: \"default\",\n        scroll: true,\n        scrollSensitivity: 20,\n        scrollSpeed: 20,\n        snap: false,\n        snapMode: \"both\",\n        snapTolerance: 20,\n        stack: false,\n        zIndex: false,\n\n        // callbacks\n        drag: null,\n        start: null,\n        stop: null\n    },\n    _create: function() {\n\n        if ( this.options.helper === \"original\" ) {\n            this._setPositionRelative();\n        }\n        if (this.options.addClasses){\n            this.element.addClass(\"ui-draggable\");\n        }\n        if (this.options.disabled){\n            this.element.addClass(\"ui-draggable-disabled\");\n        }\n        this._setHandleClassName();\n\n        this._mouseInit();\n    },\n\n    _setOption: function( key, value ) {\n        this._super( key, value );\n        if ( key === \"handle\" ) {\n            this._removeHandleClassName();\n            this._setHandleClassName();\n        }\n    },\n\n    _destroy: function() {\n        if ( ( this.helper || this.element ).is( \".ui-draggable-dragging\" ) ) {\n            this.destroyOnClear = true;\n            return;\n        }\n        this.element.removeClass( \"ui-draggable ui-draggable-dragging ui-draggable-disabled\" );\n        this._removeHandleClassName();\n        this._mouseDestroy();\n    },\n\n    _mouseCapture: function(event) {\n        var o = this.options;\n\n        this._blurActiveElement( event );\n\n        // among others, prevent a drag on a resizable-handle\n        if (this.helper || o.disabled || $(event.target).closest(\".ui-resizable-handle\").length > 0) {\n            return false;\n        }\n\n        //Quit if we're not on a valid handle\n        this.handle = this._getHandle(event);\n        if (!this.handle) {\n            return false;\n        }\n\n        this._blockFrames( o.iframeFix === true ? \"iframe\" : o.iframeFix );\n\n        return true;\n\n    },\n\n    _blockFrames: function( selector ) {\n        this.iframeBlocks = this.document.find( selector ).map(function() {\n            var iframe = $( this );\n\n            return $( \"<div>\" )\n                .css( \"position\", \"absolute\" )\n                .appendTo( iframe.parent() )\n                .outerWidth( iframe.outerWidth() )\n                .outerHeight( iframe.outerHeight() )\n                .offset( iframe.offset() )[ 0 ];\n        });\n    },\n\n    _unblockFrames: function() {\n        if ( this.iframeBlocks ) {\n            this.iframeBlocks.remove();\n            delete this.iframeBlocks;\n        }\n    },\n\n    _blurActiveElement: function( event ) {\n        var document = this.document[ 0 ];\n\n        // Only need to blur if the event occurred on the draggable itself, see #10527\n        if ( !this.handleElement.is( event.target ) ) {\n            return;\n        }\n\n        // support: IE9\n        // IE9 throws an \"Unspecified error\" accessing document.activeElement from an <iframe>\n        try {\n\n            // Support: IE9, IE10\n            // If the <body> is blurred, IE will switch windows, see #9520\n            if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== \"body\" ) {\n\n                // Blur any element that currently has focus, see #4261\n                $( document.activeElement ).blur();\n            }\n        } catch ( error ) {}\n    },\n\n    _mouseStart: function(event) {\n\n        var o = this.options;\n\n        //Create and append the visible helper\n        this.helper = this._createHelper(event);\n\n        this.helper.addClass(\"ui-draggable-dragging\");\n\n        //Cache the helper size\n        this._cacheHelperProportions();\n\n        //If ddmanager is used for droppables, set the global draggable\n        if ($.ui.ddmanager) {\n            $.ui.ddmanager.current = this;\n        }\n\n        /*\n         * - Position generation -\n         * This block generates everything position related - it's the core of draggables.\n         */\n\n        //Cache the margins of the original element\n        this._cacheMargins();\n\n        //Store the helper's css position\n        this.cssPosition = this.helper.css( \"position\" );\n        this.scrollParent = this.helper.scrollParent( true );\n        this.offsetParent = this.helper.offsetParent();\n        this.hasFixedAncestor = this.helper.parents().filter(function() {\n                return $( this ).css( \"position\" ) === \"fixed\";\n            }).length > 0;\n\n        //The element's absolute position on the page minus margins\n        this.positionAbs = this.element.offset();\n        this._refreshOffsets( event );\n\n        //Generate the original position\n        this.originalPosition = this.position = this._generatePosition( event, false );\n        this.originalPageX = event.pageX;\n        this.originalPageY = event.pageY;\n\n        //Adjust the mouse offset relative to the helper if \"cursorAt\" is supplied\n        (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\n\n        //Set a containment if given in the options\n        this._setContainment();\n\n        //Trigger event + callbacks\n        if (this._trigger(\"start\", event) === false) {\n            this._clear();\n            return false;\n        }\n\n        //Recache the helper size\n        this._cacheHelperProportions();\n\n        //Prepare the droppable offsets\n        if ($.ui.ddmanager && !o.dropBehaviour) {\n            $.ui.ddmanager.prepareOffsets(this, event);\n        }\n\n        // Reset helper's right/bottom css if they're set and set explicit width/height instead\n        // as this prevents resizing of elements with right/bottom set (see #7772)\n        this._normalizeRightBottom();\n\n        this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n\n        //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)\n        if ( $.ui.ddmanager ) {\n            $.ui.ddmanager.dragStart(this, event);\n        }\n\n        return true;\n    },\n\n    _refreshOffsets: function( event ) {\n        this.offset = {\n            top: this.positionAbs.top - this.margins.top,\n            left: this.positionAbs.left - this.margins.left,\n            scroll: false,\n            parent: this._getParentOffset(),\n            relative: this._getRelativeOffset()\n        };\n\n        this.offset.click = {\n            left: event.pageX - this.offset.left,\n            top: event.pageY - this.offset.top\n        };\n    },\n\n    _mouseDrag: function(event, noPropagation) {\n        // reset any necessary cached properties (see #5009)\n        if ( this.hasFixedAncestor ) {\n            this.offset.parent = this._getParentOffset();\n        }\n\n        //Compute the helpers position\n        this.position = this._generatePosition( event, true );\n        this.positionAbs = this._convertPositionTo(\"absolute\");\n\n        //Call plugins and callbacks and use the resulting position if something is returned\n        if (!noPropagation) {\n            var ui = this._uiHash();\n            if (this._trigger(\"drag\", event, ui) === false) {\n                this._mouseUp({});\n                return false;\n            }\n            this.position = ui.position;\n        }\n\n        this.helper[ 0 ].style.left = this.position.left + \"px\";\n        this.helper[ 0 ].style.top = this.position.top + \"px\";\n\n        if ($.ui.ddmanager) {\n            $.ui.ddmanager.drag(this, event);\n        }\n\n        return false;\n    },\n\n    _mouseStop: function(event) {\n\n        //If we are using droppables, inform the manager about the drop\n        var that = this,\n            dropped = false;\n        if ($.ui.ddmanager && !this.options.dropBehaviour) {\n            dropped = $.ui.ddmanager.drop(this, event);\n        }\n\n        //if a drop comes from outside (a sortable)\n        if (this.dropped) {\n            dropped = this.dropped;\n            this.dropped = false;\n        }\n\n        if ((this.options.revert === \"invalid\" && !dropped) || (this.options.revert === \"valid\" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {\n            $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {\n                if (that._trigger(\"stop\", event) !== false) {\n                    that._clear();\n                }\n            });\n        } else {\n            if (this._trigger(\"stop\", event) !== false) {\n                this._clear();\n            }\n        }\n\n        return false;\n    },\n\n    _mouseUp: function( event ) {\n        this._unblockFrames();\n\n        //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)\n        if ( $.ui.ddmanager ) {\n            $.ui.ddmanager.dragStop(this, event);\n        }\n\n        // Only need to focus if the event occurred on the draggable itself, see #10527\n        if ( this.handleElement.is( event.target ) ) {\n            // The interaction is over; whether or not the click resulted in a drag, focus the element\n            this.element.focus();\n        }\n\n        return $.ui.mouse.prototype._mouseUp.call(this, event);\n    },\n\n    cancel: function() {\n\n        if (this.helper.is(\".ui-draggable-dragging\")) {\n            this._mouseUp({});\n        } else {\n            this._clear();\n        }\n\n        return this;\n\n    },\n\n    _getHandle: function(event) {\n        return this.options.handle ?\n            !!$( event.target ).closest( this.element.find( this.options.handle ) ).length :\n            true;\n    },\n\n    _setHandleClassName: function() {\n        this.handleElement = this.options.handle ?\n            this.element.find( this.options.handle ) : this.element;\n        this.handleElement.addClass( \"ui-draggable-handle\" );\n    },\n\n    _removeHandleClassName: function() {\n        this.handleElement.removeClass( \"ui-draggable-handle\" );\n    },\n\n    _createHelper: function(event) {\n\n        var o = this.options,\n            helperIsFunction = $.isFunction( o.helper ),\n            helper = helperIsFunction ?\n                $( o.helper.apply( this.element[ 0 ], [ event ] ) ) :\n                ( o.helper === \"clone\" ?\n                    this.element.clone().removeAttr( \"id\" ) :\n                    this.element );\n\n        if (!helper.parents(\"body\").length) {\n            helper.appendTo((o.appendTo === \"parent\" ? this.element[0].parentNode : o.appendTo));\n        }\n\n        // http://bugs.jqueryui.com/ticket/9446\n        // a helper function can return the original element\n        // which wouldn't have been set to relative in _create\n        if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {\n            this._setPositionRelative();\n        }\n\n        if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css(\"position\"))) {\n            helper.css(\"position\", \"absolute\");\n        }\n\n        return helper;\n\n    },\n\n    _setPositionRelative: function() {\n        if ( !( /^(?:r|a|f)/ ).test( this.element.css( \"position\" ) ) ) {\n            this.element[ 0 ].style.position = \"relative\";\n        }\n    },\n\n    _adjustOffsetFromHelper: function(obj) {\n        if (typeof obj === \"string\") {\n            obj = obj.split(\" \");\n        }\n        if ($.isArray(obj)) {\n            obj = { left: +obj[0], top: +obj[1] || 0 };\n        }\n        if (\"left\" in obj) {\n            this.offset.click.left = obj.left + this.margins.left;\n        }\n        if (\"right\" in obj) {\n            this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n        }\n        if (\"top\" in obj) {\n            this.offset.click.top = obj.top + this.margins.top;\n        }\n        if (\"bottom\" in obj) {\n            this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n        }\n    },\n\n    _isRootNode: function( element ) {\n        return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];\n    },\n\n    _getParentOffset: function() {\n\n        //Get the offsetParent and cache its position\n        var po = this.offsetParent.offset(),\n            document = this.document[ 0 ];\n\n        // This is a special case where we need to modify a offset calculated on start, since the following happened:\n        // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\n        // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\n        //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n        if (this.cssPosition === \"absolute\" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {\n            po.left += this.scrollParent.scrollLeft();\n            po.top += this.scrollParent.scrollTop();\n        }\n\n        if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {\n            po = { top: 0, left: 0 };\n        }\n\n        return {\n            top: po.top + (parseInt(this.offsetParent.css(\"borderTopWidth\"), 10) || 0),\n            left: po.left + (parseInt(this.offsetParent.css(\"borderLeftWidth\"), 10) || 0)\n        };\n\n    },\n\n    _getRelativeOffset: function() {\n        if ( this.cssPosition !== \"relative\" ) {\n            return { top: 0, left: 0 };\n        }\n\n        var p = this.element.position(),\n            scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );\n\n        return {\n            top: p.top - ( parseInt(this.helper.css( \"top\" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),\n            left: p.left - ( parseInt(this.helper.css( \"left\" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )\n        };\n\n    },\n\n    _cacheMargins: function() {\n        this.margins = {\n            left: (parseInt(this.element.css(\"marginLeft\"), 10) || 0),\n            top: (parseInt(this.element.css(\"marginTop\"), 10) || 0),\n            right: (parseInt(this.element.css(\"marginRight\"), 10) || 0),\n            bottom: (parseInt(this.element.css(\"marginBottom\"), 10) || 0)\n        };\n    },\n\n    _cacheHelperProportions: function() {\n        this.helperProportions = {\n            width: this.helper.outerWidth(),\n            height: this.helper.outerHeight()\n        };\n    },\n\n    _setContainment: function() {\n\n        var isUserScrollable, c, ce,\n            o = this.options,\n            document = this.document[ 0 ];\n\n        this.relativeContainer = null;\n\n        if ( !o.containment ) {\n            this.containment = null;\n            return;\n        }\n\n        if ( o.containment === \"window\" ) {\n            this.containment = [\n                $( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,\n                $( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,\n                $( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,\n                $( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top\n            ];\n            return;\n        }\n\n        if ( o.containment === \"document\") {\n            this.containment = [\n                0,\n                0,\n                $( document ).width() - this.helperProportions.width - this.margins.left,\n                ( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top\n            ];\n            return;\n        }\n\n        if ( o.containment.constructor === Array ) {\n            this.containment = o.containment;\n            return;\n        }\n\n        if ( o.containment === \"parent\" ) {\n            o.containment = this.helper[ 0 ].parentNode;\n        }\n\n        c = $( o.containment );\n        ce = c[ 0 ];\n\n        if ( !ce ) {\n            return;\n        }\n\n        isUserScrollable = /(scroll|auto)/.test( c.css( \"overflow\" ) );\n\n        this.containment = [\n            ( parseInt( c.css( \"borderLeftWidth\" ), 10 ) || 0 ) + ( parseInt( c.css( \"paddingLeft\" ), 10 ) || 0 ),\n            ( parseInt( c.css( \"borderTopWidth\" ), 10 ) || 0 ) + ( parseInt( c.css( \"paddingTop\" ), 10 ) || 0 ),\n            ( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -\n                ( parseInt( c.css( \"borderRightWidth\" ), 10 ) || 0 ) -\n                ( parseInt( c.css( \"paddingRight\" ), 10 ) || 0 ) -\n                this.helperProportions.width -\n                this.margins.left -\n                this.margins.right,\n            ( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -\n                ( parseInt( c.css( \"borderBottomWidth\" ), 10 ) || 0 ) -\n                ( parseInt( c.css( \"paddingBottom\" ), 10 ) || 0 ) -\n                this.helperProportions.height -\n                this.margins.top -\n                this.margins.bottom\n        ];\n        this.relativeContainer = c;\n    },\n\n    _convertPositionTo: function(d, pos) {\n\n        if (!pos) {\n            pos = this.position;\n        }\n\n        var mod = d === \"absolute\" ? 1 : -1,\n            scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );\n\n        return {\n            top: (\n                pos.top    +                                                                // The absolute mouse position\n                this.offset.relative.top * mod +                                        // Only for relative positioned nodes: Relative offset from element to offset parent\n                this.offset.parent.top * mod -                                        // The offsetParent's offset without borders (offset + border)\n                ( ( this.cssPosition === \"fixed\" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)\n            ),\n            left: (\n                pos.left +                                                                // The absolute mouse position\n                this.offset.relative.left * mod +                                        // Only for relative positioned nodes: Relative offset from element to offset parent\n                this.offset.parent.left * mod    -                                        // The offsetParent's offset without borders (offset + border)\n                ( ( this.cssPosition === \"fixed\" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)\n            )\n        };\n\n    },\n\n    _generatePosition: function( event, constrainPosition ) {\n\n        var containment, co, top, left,\n            o = this.options,\n            scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),\n            pageX = event.pageX,\n            pageY = event.pageY;\n\n        // Cache the scroll\n        if ( !scrollIsRootNode || !this.offset.scroll ) {\n            this.offset.scroll = {\n                top: this.scrollParent.scrollTop(),\n                left: this.scrollParent.scrollLeft()\n            };\n        }\n\n        /*\n         * - Position constraining -\n         * Constrain the position to a mix of grid, containment.\n         */\n\n        // If we are not dragging yet, we won't check for options\n        if ( constrainPosition ) {\n            if ( this.containment ) {\n                if ( this.relativeContainer ){\n                    co = this.relativeContainer.offset();\n                    containment = [\n                        this.containment[ 0 ] + co.left,\n                        this.containment[ 1 ] + co.top,\n                        this.containment[ 2 ] + co.left,\n                        this.containment[ 3 ] + co.top\n                    ];\n                } else {\n                    containment = this.containment;\n                }\n\n                if (event.pageX - this.offset.click.left < containment[0]) {\n                    pageX = containment[0] + this.offset.click.left;\n                }\n                if (event.pageY - this.offset.click.top < containment[1]) {\n                    pageY = containment[1] + this.offset.click.top;\n                }\n                if (event.pageX - this.offset.click.left > containment[2]) {\n                    pageX = containment[2] + this.offset.click.left;\n                }\n                if (event.pageY - this.offset.click.top > containment[3]) {\n                    pageY = containment[3] + this.offset.click.top;\n                }\n            }\n\n            if (o.grid) {\n                //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)\n                top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;\n                pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\n\n                left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;\n                pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\n            }\n\n            if ( o.axis === \"y\" ) {\n                pageX = this.originalPageX;\n            }\n\n            if ( o.axis === \"x\" ) {\n                pageY = this.originalPageY;\n            }\n        }\n\n        return {\n            top: (\n                pageY -                                                                    // The absolute mouse position\n                this.offset.click.top    -                                                // Click offset (relative to the element)\n                this.offset.relative.top -                                                // Only for relative positioned nodes: Relative offset from element to offset parent\n                this.offset.parent.top +                                                // The offsetParent's offset without borders (offset + border)\n                ( this.cssPosition === \"fixed\" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )\n            ),\n            left: (\n                pageX -                                                                    // The absolute mouse position\n                this.offset.click.left -                                                // Click offset (relative to the element)\n                this.offset.relative.left -                                                // Only for relative positioned nodes: Relative offset from element to offset parent\n                this.offset.parent.left +                                                // The offsetParent's offset without borders (offset + border)\n                ( this.cssPosition === \"fixed\" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )\n            )\n        };\n\n    },\n\n    _clear: function() {\n        this.helper.removeClass(\"ui-draggable-dragging\");\n        if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {\n            this.helper.remove();\n        }\n        this.helper = null;\n        this.cancelHelperRemoval = false;\n        if ( this.destroyOnClear ) {\n            this.destroy();\n        }\n    },\n\n    _normalizeRightBottom: function() {\n        if ( this.options.axis !== \"y\" && this.helper.css( \"right\" ) !== \"auto\" ) {\n            this.helper.width( this.helper.width() );\n            this.helper.css( \"right\", \"auto\" );\n        }\n        if ( this.options.axis !== \"x\" && this.helper.css( \"bottom\" ) !== \"auto\" ) {\n            this.helper.height( this.helper.height() );\n            this.helper.css( \"bottom\", \"auto\" );\n        }\n    },\n\n    // From now on bulk stuff - mainly helpers\n\n    _trigger: function( type, event, ui ) {\n        ui = ui || this._uiHash();\n        $.ui.plugin.call( this, type, [ event, ui, this ], true );\n\n        // Absolute position and offset (see #6884 ) have to be recalculated after plugins\n        if ( /^(drag|start|stop)/.test( type ) ) {\n            this.positionAbs = this._convertPositionTo( \"absolute\" );\n            ui.offset = this.positionAbs;\n        }\n        return $.Widget.prototype._trigger.call( this, type, event, ui );\n    },\n\n    plugins: {},\n\n    _uiHash: function() {\n        return {\n            helper: this.helper,\n            position: this.position,\n            originalPosition: this.originalPosition,\n            offset: this.positionAbs\n        };\n    }\n\n});\n\n$.ui.plugin.add( \"draggable\", \"connectToSortable\", {\n    start: function( event, ui, draggable ) {\n        var uiSortable = $.extend( {}, ui, {\n            item: draggable.element\n        });\n\n        draggable.sortables = [];\n        $( draggable.options.connectToSortable ).each(function() {\n            var sortable = $( this ).sortable( \"instance\" );\n\n            if ( sortable && !sortable.options.disabled ) {\n                draggable.sortables.push( sortable );\n\n                // refreshPositions is called at drag start to refresh the containerCache\n                // which is used in drag. This ensures it's initialized and synchronized\n                // with any changes that might have happened on the page since initialization.\n                sortable.refreshPositions();\n                sortable._trigger(\"activate\", event, uiSortable);\n            }\n        });\n    },\n    stop: function( event, ui, draggable ) {\n        var uiSortable = $.extend( {}, ui, {\n            item: draggable.element\n        });\n\n        draggable.cancelHelperRemoval = false;\n\n        $.each( draggable.sortables, function() {\n            var sortable = this;\n\n            if ( sortable.isOver ) {\n                sortable.isOver = 0;\n\n                // Allow this sortable to handle removing the helper\n                draggable.cancelHelperRemoval = true;\n                sortable.cancelHelperRemoval = false;\n\n                // Use _storedCSS To restore properties in the sortable,\n                // as this also handles revert (#9675) since the draggable\n                // may have modified them in unexpected ways (#8809)\n                sortable._storedCSS = {\n                    position: sortable.placeholder.css( \"position\" ),\n                    top: sortable.placeholder.css( \"top\" ),\n                    left: sortable.placeholder.css( \"left\" )\n                };\n\n                sortable._mouseStop(event);\n\n                // Once drag has ended, the sortable should return to using\n                // its original helper, not the shared helper from draggable\n                sortable.options.helper = sortable.options._helper;\n            } else {\n                // Prevent this Sortable from removing the helper.\n                // However, don't set the draggable to remove the helper\n                // either as another connected Sortable may yet handle the removal.\n                sortable.cancelHelperRemoval = true;\n\n                sortable._trigger( \"deactivate\", event, uiSortable );\n            }\n        });\n    },\n    drag: function( event, ui, draggable ) {\n        $.each( draggable.sortables, function() {\n            var innermostIntersecting = false,\n                sortable = this;\n\n            // Copy over variables that sortable's _intersectsWith uses\n            sortable.positionAbs = draggable.positionAbs;\n            sortable.helperProportions = draggable.helperProportions;\n            sortable.offset.click = draggable.offset.click;\n\n            if ( sortable._intersectsWith( sortable.containerCache ) ) {\n                innermostIntersecting = true;\n\n                $.each( draggable.sortables, function() {\n                    // Copy over variables that sortable's _intersectsWith uses\n                    this.positionAbs = draggable.positionAbs;\n                    this.helperProportions = draggable.helperProportions;\n                    this.offset.click = draggable.offset.click;\n\n                    if ( this !== sortable &&\n                            this._intersectsWith( this.containerCache ) &&\n                            $.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {\n                        innermostIntersecting = false;\n                    }\n\n                    return innermostIntersecting;\n                });\n            }\n\n            if ( innermostIntersecting ) {\n                // If it intersects, we use a little isOver variable and set it once,\n                // so that the move-in stuff gets fired only once.\n                if ( !sortable.isOver ) {\n                    sortable.isOver = 1;\n\n                    sortable.currentItem = ui.helper\n                        .appendTo( sortable.element )\n                        .data( \"ui-sortable-item\", true );\n\n                    // Store helper option to later restore it\n                    sortable.options._helper = sortable.options.helper;\n\n                    sortable.options.helper = function() {\n                        return ui.helper[ 0 ];\n                    };\n\n                    // Fire the start events of the sortable with our passed browser event,\n                    // and our own helper (so it doesn't create a new one)\n                    event.target = sortable.currentItem[ 0 ];\n                    sortable._mouseCapture( event, true );\n                    sortable._mouseStart( event, true, true );\n\n                    // Because the browser event is way off the new appended portlet,\n                    // modify necessary variables to reflect the changes\n                    sortable.offset.click.top = draggable.offset.click.top;\n                    sortable.offset.click.left = draggable.offset.click.left;\n                    sortable.offset.parent.left -= draggable.offset.parent.left -\n                        sortable.offset.parent.left;\n                    sortable.offset.parent.top -= draggable.offset.parent.top -\n                        sortable.offset.parent.top;\n\n                    draggable._trigger( \"toSortable\", event );\n\n                    // Inform draggable that the helper is in a valid drop zone,\n                    // used solely in the revert option to handle \"valid/invalid\".\n                    draggable.dropped = sortable.element;\n\n                    // Need to refreshPositions of all sortables in the case that\n                    // adding to one sortable changes the location of the other sortables (#9675)\n                    $.each( draggable.sortables, function() {\n                        this.refreshPositions();\n                    });\n\n                    // hack so receive/update callbacks work (mostly)\n                    draggable.currentItem = draggable.element;\n                    sortable.fromOutside = draggable;\n                }\n\n                if ( sortable.currentItem ) {\n                    sortable._mouseDrag( event );\n                    // Copy the sortable's position because the draggable's can potentially reflect\n                    // a relative position, while sortable is always absolute, which the dragged\n                    // element has now become. (#8809)\n                    ui.position = sortable.position;\n                }\n            } else {\n                // If it doesn't intersect with the sortable, and it intersected before,\n                // we fake the drag stop of the sortable, but make sure it doesn't remove\n                // the helper by using cancelHelperRemoval.\n                if ( sortable.isOver ) {\n\n                    sortable.isOver = 0;\n                    sortable.cancelHelperRemoval = true;\n\n                    // Calling sortable's mouseStop would trigger a revert,\n                    // so revert must be temporarily false until after mouseStop is called.\n                    sortable.options._revert = sortable.options.revert;\n                    sortable.options.revert = false;\n\n                    sortable._trigger( \"out\", event, sortable._uiHash( sortable ) );\n                    sortable._mouseStop( event, true );\n\n                    // restore sortable behaviors that were modfied\n                    // when the draggable entered the sortable area (#9481)\n                    sortable.options.revert = sortable.options._revert;\n                    sortable.options.helper = sortable.options._helper;\n\n                    if ( sortable.placeholder ) {\n                        sortable.placeholder.remove();\n                    }\n\n                    // Recalculate the draggable's offset considering the sortable\n                    // may have modified them in unexpected ways (#8809)\n                    draggable._refreshOffsets( event );\n                    ui.position = draggable._generatePosition( event, true );\n\n                    draggable._trigger( \"fromSortable\", event );\n\n                    // Inform draggable that the helper is no longer in a valid drop zone\n                    draggable.dropped = false;\n\n                    // Need to refreshPositions of all sortables just in case removing\n                    // from one sortable changes the location of other sortables (#9675)\n                    $.each( draggable.sortables, function() {\n                        this.refreshPositions();\n                    });\n                }\n            }\n        });\n    }\n});\n\n$.ui.plugin.add(\"draggable\", \"cursor\", {\n    start: function( event, ui, instance ) {\n        var t = $( \"body\" ),\n            o = instance.options;\n\n        if (t.css(\"cursor\")) {\n            o._cursor = t.css(\"cursor\");\n        }\n        t.css(\"cursor\", o.cursor);\n    },\n    stop: function( event, ui, instance ) {\n        var o = instance.options;\n        if (o._cursor) {\n            $(\"body\").css(\"cursor\", o._cursor);\n        }\n    }\n});\n\n$.ui.plugin.add(\"draggable\", \"opacity\", {\n    start: function( event, ui, instance ) {\n        var t = $( ui.helper ),\n            o = instance.options;\n        if (t.css(\"opacity\")) {\n            o._opacity = t.css(\"opacity\");\n        }\n        t.css(\"opacity\", o.opacity);\n    },\n    stop: function( event, ui, instance ) {\n        var o = instance.options;\n        if (o._opacity) {\n            $(ui.helper).css(\"opacity\", o._opacity);\n        }\n    }\n});\n\n$.ui.plugin.add(\"draggable\", \"scroll\", {\n    start: function( event, ui, i ) {\n        if ( !i.scrollParentNotHidden ) {\n            i.scrollParentNotHidden = i.helper.scrollParent( false );\n        }\n\n        if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== \"HTML\" ) {\n            i.overflowOffset = i.scrollParentNotHidden.offset();\n        }\n    },\n    drag: function( event, ui, i  ) {\n\n        var o = i.options,\n            scrolled = false,\n            scrollParent = i.scrollParentNotHidden[ 0 ],\n            document = i.document[ 0 ];\n\n        if ( scrollParent !== document && scrollParent.tagName !== \"HTML\" ) {\n            if ( !o.axis || o.axis !== \"x\" ) {\n                if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {\n                    scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;\n                } else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {\n                    scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;\n                }\n            }\n\n            if ( !o.axis || o.axis !== \"y\" ) {\n                if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {\n                    scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;\n                } else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {\n                    scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;\n                }\n            }\n\n        } else {\n\n            if (!o.axis || o.axis !== \"x\") {\n                if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {\n                    scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\n                } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {\n                    scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\n                }\n            }\n\n            if (!o.axis || o.axis !== \"y\") {\n                if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {\n                    scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\n                } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {\n                    scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\n                }\n            }\n\n        }\n\n        if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\n            $.ui.ddmanager.prepareOffsets(i, event);\n        }\n\n    }\n});\n\n$.ui.plugin.add(\"draggable\", \"snap\", {\n    start: function( event, ui, i ) {\n\n        var o = i.options;\n\n        i.snapElements = [];\n\n        $(o.snap.constructor !== String ? ( o.snap.items || \":data(ui-draggable)\" ) : o.snap).each(function() {\n            var $t = $(this),\n                $o = $t.offset();\n            if (this !== i.element[0]) {\n                i.snapElements.push({\n                    item: this,\n                    width: $t.outerWidth(), height: $t.outerHeight(),\n                    top: $o.top, left: $o.left\n                });\n            }\n        });\n\n    },\n    drag: function( event, ui, inst ) {\n\n        var ts, bs, ls, rs, l, r, t, b, i, first,\n            o = inst.options,\n            d = o.snapTolerance,\n            x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,\n            y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;\n\n        for (i = inst.snapElements.length - 1; i >= 0; i--){\n\n            l = inst.snapElements[i].left - inst.margins.left;\n            r = l + inst.snapElements[i].width;\n            t = inst.snapElements[i].top - inst.margins.top;\n            b = t + inst.snapElements[i].height;\n\n            if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {\n                if (inst.snapElements[i].snapping) {\n                    (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\n                }\n                inst.snapElements[i].snapping = false;\n                continue;\n            }\n\n            if (o.snapMode !== \"inner\") {\n                ts = Math.abs(t - y2) <= d;\n                bs = Math.abs(b - y1) <= d;\n                ls = Math.abs(l - x2) <= d;\n                rs = Math.abs(r - x1) <= d;\n                if (ts) {\n                    ui.position.top = inst._convertPositionTo(\"relative\", { top: t - inst.helperProportions.height, left: 0 }).top;\n                }\n                if (bs) {\n                    ui.position.top = inst._convertPositionTo(\"relative\", { top: b, left: 0 }).top;\n                }\n                if (ls) {\n                    ui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: l - inst.helperProportions.width }).left;\n                }\n                if (rs) {\n                    ui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: r }).left;\n                }\n            }\n\n            first = (ts || bs || ls || rs);\n\n            if (o.snapMode !== \"outer\") {\n                ts = Math.abs(t - y1) <= d;\n                bs = Math.abs(b - y2) <= d;\n                ls = Math.abs(l - x1) <= d;\n                rs = Math.abs(r - x2) <= d;\n                if (ts) {\n                    ui.position.top = inst._convertPositionTo(\"relative\", { top: t, left: 0 }).top;\n                }\n                if (bs) {\n                    ui.position.top = inst._convertPositionTo(\"relative\", { top: b - inst.helperProportions.height, left: 0 }).top;\n                }\n                if (ls) {\n                    ui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: l }).left;\n                }\n                if (rs) {\n                    ui.position.left = inst._convertPositionTo(\"relative\", { top: 0, left: r - inst.helperProportions.width }).left;\n                }\n            }\n\n            if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {\n                (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\n            }\n            inst.snapElements[i].snapping = (ts || bs || ls || rs || first);\n\n        }\n\n    }\n});\n\n$.ui.plugin.add(\"draggable\", \"stack\", {\n    start: function( event, ui, instance ) {\n        var min,\n            o = instance.options,\n            group = $.makeArray($(o.stack)).sort(function(a, b) {\n                return (parseInt($(a).css(\"zIndex\"), 10) || 0) - (parseInt($(b).css(\"zIndex\"), 10) || 0);\n            });\n\n        if (!group.length) { return; }\n\n        min = parseInt($(group[0]).css(\"zIndex\"), 10) || 0;\n        $(group).each(function(i) {\n            $(this).css(\"zIndex\", min + i);\n        });\n        this.css(\"zIndex\", (min + group.length));\n    }\n});\n\n$.ui.plugin.add(\"draggable\", \"zIndex\", {\n    start: function( event, ui, instance ) {\n        var t = $( ui.helper ),\n            o = instance.options;\n\n        if (t.css(\"zIndex\")) {\n            o._zIndex = t.css(\"zIndex\");\n        }\n        t.css(\"zIndex\", o.zIndex);\n    },\n    stop: function( event, ui, instance ) {\n        var o = instance.options;\n\n        if (o._zIndex) {\n            $(ui.helper).css(\"zIndex\", o._zIndex);\n        }\n    }\n});\n\nvar draggable = $.ui.draggable;\n\n\n/*!\n * jQuery UI Resizable 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/resizable/\n */\n\n\n$.widget(\"ui.resizable\", $.ui.mouse, {\n    version: \"1.11.2\",\n    widgetEventPrefix: \"resize\",\n    options: {\n        alsoResize: false,\n        animate: false,\n        animateDuration: \"slow\",\n        animateEasing: \"swing\",\n        aspectRatio: false,\n        autoHide: false,\n        containment: false,\n        ghost: false,\n        grid: false,\n        handles: \"e,s,se\",\n        helper: false,\n        maxHeight: null,\n        maxWidth: null,\n        minHeight: 10,\n        minWidth: 10,\n        // See #7960\n        zIndex: 90,\n\n        // callbacks\n        resize: null,\n        start: null,\n        stop: null\n    },\n\n    _num: function( value ) {\n        return parseInt( value, 10 ) || 0;\n    },\n\n    _isNumber: function( value ) {\n        return !isNaN( parseInt( value, 10 ) );\n    },\n\n    _hasScroll: function( el, a ) {\n\n        if ( $( el ).css( \"overflow\" ) === \"hidden\") {\n            return false;\n        }\n\n        var scroll = ( a && a === \"left\" ) ? \"scrollLeft\" : \"scrollTop\",\n            has = false;\n\n        if ( el[ scroll ] > 0 ) {\n            return true;\n        }\n\n        // TODO: determine which cases actually cause this to happen\n        // if the element doesn't have the scroll set, see if it's possible to\n        // set the scroll\n        el[ scroll ] = 1;\n        has = ( el[ scroll ] > 0 );\n        el[ scroll ] = 0;\n        return has;\n    },\n\n    _create: function() {\n\n        var n, i, handle, axis, hname,\n            that = this,\n            o = this.options;\n        this.element.addClass(\"ui-resizable\");\n\n        $.extend(this, {\n            _aspectRatio: !!(o.aspectRatio),\n            aspectRatio: o.aspectRatio,\n            originalElement: this.element,\n            _proportionallyResizeElements: [],\n            _helper: o.helper || o.ghost || o.animate ? o.helper || \"ui-resizable-helper\" : null\n        });\n\n        // Wrap the element if it cannot hold child nodes\n        if (this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {\n\n            this.element.wrap(\n                $(\"<div class='ui-wrapper' style='overflow: hidden;'></div>\").css({\n                    position: this.element.css(\"position\"),\n                    width: this.element.outerWidth(),\n                    height: this.element.outerHeight(),\n                    top: this.element.css(\"top\"),\n                    left: this.element.css(\"left\")\n                })\n            );\n\n            this.element = this.element.parent().data(\n                \"ui-resizable\", this.element.resizable( \"instance\" )\n            );\n\n            this.elementIsWrapper = true;\n\n            this.element.css({\n                marginLeft: this.originalElement.css(\"marginLeft\"),\n                marginTop: this.originalElement.css(\"marginTop\"),\n                marginRight: this.originalElement.css(\"marginRight\"),\n                marginBottom: this.originalElement.css(\"marginBottom\")\n            });\n            this.originalElement.css({\n                marginLeft: 0,\n                marginTop: 0,\n                marginRight: 0,\n                marginBottom: 0\n            });\n            // support: Safari\n            // Prevent Safari textarea resize\n            this.originalResizeStyle = this.originalElement.css(\"resize\");\n            this.originalElement.css(\"resize\", \"none\");\n\n            this._proportionallyResizeElements.push( this.originalElement.css({\n                position: \"static\",\n                zoom: 1,\n                display: \"block\"\n            }) );\n\n            // support: IE9\n            // avoid IE jump (hard set the margin)\n            this.originalElement.css({ margin: this.originalElement.css(\"margin\") });\n\n            this._proportionallyResize();\n        }\n\n        this.handles = o.handles ||\n            ( !$(\".ui-resizable-handle\", this.element).length ?\n                \"e,s,se\" : {\n                    n: \".ui-resizable-n\",\n                    e: \".ui-resizable-e\",\n                    s: \".ui-resizable-s\",\n                    w: \".ui-resizable-w\",\n                    se: \".ui-resizable-se\",\n                    sw: \".ui-resizable-sw\",\n                    ne: \".ui-resizable-ne\",\n                    nw: \".ui-resizable-nw\"\n                } );\n\n        if (this.handles.constructor === String) {\n\n            if ( this.handles === \"all\") {\n                this.handles = \"n,e,s,w,se,sw,ne,nw\";\n            }\n\n            n = this.handles.split(\",\");\n            this.handles = {};\n\n            for (i = 0; i < n.length; i++) {\n\n                handle = $.trim(n[i]);\n                hname = \"ui-resizable-\" + handle;\n                axis = $(\"<div class='ui-resizable-handle \" + hname + \"'></div>\");\n\n                axis.css({ zIndex: o.zIndex });\n\n                // TODO : What's going on here?\n                if (\"se\" === handle) {\n                    axis.addClass(\"ui-icon ui-icon-gripsmall-diagonal-se\");\n                }\n\n                this.handles[handle] = \".ui-resizable-\" + handle;\n                this.element.append(axis);\n            }\n\n        }\n\n        this._renderAxis = function(target) {\n\n            var i, axis, padPos, padWrapper;\n\n            target = target || this.element;\n\n            for (i in this.handles) {\n\n                if (this.handles[i].constructor === String) {\n                    this.handles[i] = this.element.children( this.handles[ i ] ).first().show();\n                }\n\n                if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {\n\n                    axis = $(this.handles[i], this.element);\n\n                    padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();\n\n                    padPos = [ \"padding\",\n                        /ne|nw|n/.test(i) ? \"Top\" :\n                        /se|sw|s/.test(i) ? \"Bottom\" :\n                        /^e$/.test(i) ? \"Right\" : \"Left\" ].join(\"\");\n\n                    target.css(padPos, padWrapper);\n\n                    this._proportionallyResize();\n\n                }\n\n                // TODO: What's that good for? There's not anything to be executed left\n                if (!$(this.handles[i]).length) {\n                    continue;\n                }\n            }\n        };\n\n        // TODO: make renderAxis a prototype function\n        this._renderAxis(this.element);\n\n        this._handles = $(\".ui-resizable-handle\", this.element)\n            .disableSelection();\n\n        this._handles.mouseover(function() {\n            if (!that.resizing) {\n                if (this.className) {\n                    axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);\n                }\n                that.axis = axis && axis[1] ? axis[1] : \"se\";\n            }\n        });\n\n        if (o.autoHide) {\n            this._handles.hide();\n            $(this.element)\n                .addClass(\"ui-resizable-autohide\")\n                .mouseenter(function() {\n                    if (o.disabled) {\n                        return;\n                    }\n                    $(this).removeClass(\"ui-resizable-autohide\");\n                    that._handles.show();\n                })\n                .mouseleave(function() {\n                    if (o.disabled) {\n                        return;\n                    }\n                    if (!that.resizing) {\n                        $(this).addClass(\"ui-resizable-autohide\");\n                        that._handles.hide();\n                    }\n                });\n        }\n\n        this._mouseInit();\n\n    },\n\n    _destroy: function() {\n\n        this._mouseDestroy();\n\n        var wrapper,\n            _destroy = function(exp) {\n                $(exp)\n                    .removeClass(\"ui-resizable ui-resizable-disabled ui-resizable-resizing\")\n                    .removeData(\"resizable\")\n                    .removeData(\"ui-resizable\")\n                    .unbind(\".resizable\")\n                    .find(\".ui-resizable-handle\")\n                        .remove();\n            };\n\n        // TODO: Unwrap at same DOM position\n        if (this.elementIsWrapper) {\n            _destroy(this.element);\n            wrapper = this.element;\n            this.originalElement.css({\n                position: wrapper.css(\"position\"),\n                width: wrapper.outerWidth(),\n                height: wrapper.outerHeight(),\n                top: wrapper.css(\"top\"),\n                left: wrapper.css(\"left\")\n            }).insertAfter( wrapper );\n            wrapper.remove();\n        }\n\n        this.originalElement.css(\"resize\", this.originalResizeStyle);\n        _destroy(this.originalElement);\n\n        return this;\n    },\n\n    _mouseCapture: function(event) {\n        var i, handle,\n            capture = false;\n\n        for (i in this.handles) {\n            handle = $(this.handles[i])[0];\n            if (handle === event.target || $.contains(handle, event.target)) {\n                capture = true;\n            }\n        }\n\n        return !this.options.disabled && capture;\n    },\n\n    _mouseStart: function(event) {\n\n        var curleft, curtop, cursor,\n            o = this.options,\n            el = this.element;\n\n        this.resizing = true;\n\n        this._renderProxy();\n\n        curleft = this._num(this.helper.css(\"left\"));\n        curtop = this._num(this.helper.css(\"top\"));\n\n        if (o.containment) {\n            curleft += $(o.containment).scrollLeft() || 0;\n            curtop += $(o.containment).scrollTop() || 0;\n        }\n\n        this.offset = this.helper.offset();\n        this.position = { left: curleft, top: curtop };\n\n        this.size = this._helper ? {\n                width: this.helper.width(),\n                height: this.helper.height()\n            } : {\n                width: el.width(),\n                height: el.height()\n            };\n\n        this.originalSize = this._helper ? {\n                width: el.outerWidth(),\n                height: el.outerHeight()\n            } : {\n                width: el.width(),\n                height: el.height()\n            };\n\n        this.sizeDiff = {\n            width: el.outerWidth() - el.width(),\n            height: el.outerHeight() - el.height()\n        };\n\n        this.originalPosition = { left: curleft, top: curtop };\n        this.originalMousePosition = { left: event.pageX, top: event.pageY };\n\n        this.aspectRatio = (typeof o.aspectRatio === \"number\") ?\n            o.aspectRatio :\n            ((this.originalSize.width / this.originalSize.height) || 1);\n\n        cursor = $(\".ui-resizable-\" + this.axis).css(\"cursor\");\n        $(\"body\").css(\"cursor\", cursor === \"auto\" ? this.axis + \"-resize\" : cursor);\n\n        el.addClass(\"ui-resizable-resizing\");\n        this._propagate(\"start\", event);\n        return true;\n    },\n\n    _mouseDrag: function(event) {\n\n        var data, props,\n            smp = this.originalMousePosition,\n            a = this.axis,\n            dx = (event.pageX - smp.left) || 0,\n            dy = (event.pageY - smp.top) || 0,\n            trigger = this._change[a];\n\n        this._updatePrevProperties();\n\n        if (!trigger) {\n            return false;\n        }\n\n        data = trigger.apply(this, [ event, dx, dy ]);\n\n        this._updateVirtualBoundaries(event.shiftKey);\n        if (this._aspectRatio || event.shiftKey) {\n            data = this._updateRatio(data, event);\n        }\n\n        data = this._respectSize(data, event);\n\n        this._updateCache(data);\n\n        this._propagate(\"resize\", event);\n\n        props = this._applyChanges();\n\n        if ( !this._helper && this._proportionallyResizeElements.length ) {\n            this._proportionallyResize();\n        }\n\n        if ( !$.isEmptyObject( props ) ) {\n            this._updatePrevProperties();\n            this._trigger( \"resize\", event, this.ui() );\n            this._applyChanges();\n        }\n\n        return false;\n    },\n\n    _mouseStop: function(event) {\n\n        this.resizing = false;\n        var pr, ista, soffseth, soffsetw, s, left, top,\n            o = this.options, that = this;\n\n        if (this._helper) {\n\n            pr = this._proportionallyResizeElements;\n            ista = pr.length && (/textarea/i).test(pr[0].nodeName);\n            soffseth = ista && this._hasScroll(pr[0], \"left\") ? 0 : that.sizeDiff.height;\n            soffsetw = ista ? 0 : that.sizeDiff.width;\n\n            s = {\n                width: (that.helper.width()  - soffsetw),\n                height: (that.helper.height() - soffseth)\n            };\n            left = (parseInt(that.element.css(\"left\"), 10) +\n                (that.position.left - that.originalPosition.left)) || null;\n            top = (parseInt(that.element.css(\"top\"), 10) +\n                (that.position.top - that.originalPosition.top)) || null;\n\n            if (!o.animate) {\n                this.element.css($.extend(s, { top: top, left: left }));\n            }\n\n            that.helper.height(that.size.height);\n            that.helper.width(that.size.width);\n\n            if (this._helper && !o.animate) {\n                this._proportionallyResize();\n            }\n        }\n\n        $(\"body\").css(\"cursor\", \"auto\");\n\n        this.element.removeClass(\"ui-resizable-resizing\");\n\n        this._propagate(\"stop\", event);\n\n        if (this._helper) {\n            this.helper.remove();\n        }\n\n        return false;\n\n    },\n\n    _updatePrevProperties: function() {\n        this.prevPosition = {\n            top: this.position.top,\n            left: this.position.left\n        };\n        this.prevSize = {\n            width: this.size.width,\n            height: this.size.height\n        };\n    },\n\n    _applyChanges: function() {\n        var props = {};\n\n        if ( this.position.top !== this.prevPosition.top ) {\n            props.top = this.position.top + \"px\";\n        }\n        if ( this.position.left !== this.prevPosition.left ) {\n            props.left = this.position.left + \"px\";\n        }\n        if ( this.size.width !== this.prevSize.width ) {\n            props.width = this.size.width + \"px\";\n        }\n        if ( this.size.height !== this.prevSize.height ) {\n            props.height = this.size.height + \"px\";\n        }\n\n        this.helper.css( props );\n\n        return props;\n    },\n\n    _updateVirtualBoundaries: function(forceAspectRatio) {\n        var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,\n            o = this.options;\n\n        b = {\n            minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,\n            maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,\n            minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,\n            maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity\n        };\n\n        if (this._aspectRatio || forceAspectRatio) {\n            pMinWidth = b.minHeight * this.aspectRatio;\n            pMinHeight = b.minWidth / this.aspectRatio;\n            pMaxWidth = b.maxHeight * this.aspectRatio;\n            pMaxHeight = b.maxWidth / this.aspectRatio;\n\n            if (pMinWidth > b.minWidth) {\n                b.minWidth = pMinWidth;\n            }\n            if (pMinHeight > b.minHeight) {\n                b.minHeight = pMinHeight;\n            }\n            if (pMaxWidth < b.maxWidth) {\n                b.maxWidth = pMaxWidth;\n            }\n            if (pMaxHeight < b.maxHeight) {\n                b.maxHeight = pMaxHeight;\n            }\n        }\n        this._vBoundaries = b;\n    },\n\n    _updateCache: function(data) {\n        this.offset = this.helper.offset();\n        if (this._isNumber(data.left)) {\n            this.position.left = data.left;\n        }\n        if (this._isNumber(data.top)) {\n            this.position.top = data.top;\n        }\n        if (this._isNumber(data.height)) {\n            this.size.height = data.height;\n        }\n        if (this._isNumber(data.width)) {\n            this.size.width = data.width;\n        }\n    },\n\n    _updateRatio: function( data ) {\n\n        var cpos = this.position,\n            csize = this.size,\n            a = this.axis;\n\n        if (this._isNumber(data.height)) {\n            data.width = (data.height * this.aspectRatio);\n        } else if (this._isNumber(data.width)) {\n            data.height = (data.width / this.aspectRatio);\n        }\n\n        if (a === \"sw\") {\n            data.left = cpos.left + (csize.width - data.width);\n            data.top = null;\n        }\n        if (a === \"nw\") {\n            data.top = cpos.top + (csize.height - data.height);\n            data.left = cpos.left + (csize.width - data.width);\n        }\n\n        return data;\n    },\n\n    _respectSize: function( data ) {\n\n        var o = this._vBoundaries,\n            a = this.axis,\n            ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),\n            ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),\n            isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),\n            isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),\n            dw = this.originalPosition.left + this.originalSize.width,\n            dh = this.position.top + this.size.height,\n            cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);\n        if (isminw) {\n            data.width = o.minWidth;\n        }\n        if (isminh) {\n            data.height = o.minHeight;\n        }\n        if (ismaxw) {\n            data.width = o.maxWidth;\n        }\n        if (ismaxh) {\n            data.height = o.maxHeight;\n        }\n\n        if (isminw && cw) {\n            data.left = dw - o.minWidth;\n        }\n        if (ismaxw && cw) {\n            data.left = dw - o.maxWidth;\n        }\n        if (isminh && ch) {\n            data.top = dh - o.minHeight;\n        }\n        if (ismaxh && ch) {\n            data.top = dh - o.maxHeight;\n        }\n\n        // Fixing jump error on top/left - bug #2330\n        if (!data.width && !data.height && !data.left && data.top) {\n            data.top = null;\n        } else if (!data.width && !data.height && !data.top && data.left) {\n            data.left = null;\n        }\n\n        return data;\n    },\n\n    _getPaddingPlusBorderDimensions: function( element ) {\n        var i = 0,\n            widths = [],\n            borders = [\n                element.css( \"borderTopWidth\" ),\n                element.css( \"borderRightWidth\" ),\n                element.css( \"borderBottomWidth\" ),\n                element.css( \"borderLeftWidth\" )\n            ],\n            paddings = [\n                element.css( \"paddingTop\" ),\n                element.css( \"paddingRight\" ),\n                element.css( \"paddingBottom\" ),\n                element.css( \"paddingLeft\" )\n            ];\n\n        for ( ; i < 4; i++ ) {\n            widths[ i ] = ( parseInt( borders[ i ], 10 ) || 0 );\n            widths[ i ] += ( parseInt( paddings[ i ], 10 ) || 0 );\n        }\n\n        return {\n            height: widths[ 0 ] + widths[ 2 ],\n            width: widths[ 1 ] + widths[ 3 ]\n        };\n    },\n\n    _proportionallyResize: function() {\n\n        if (!this._proportionallyResizeElements.length) {\n            return;\n        }\n\n        var prel,\n            i = 0,\n            element = this.helper || this.element;\n\n        for ( ; i < this._proportionallyResizeElements.length; i++) {\n\n            prel = this._proportionallyResizeElements[i];\n\n            // TODO: Seems like a bug to cache this.outerDimensions\n            // considering that we are in a loop.\n            if (!this.outerDimensions) {\n                this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );\n            }\n\n            prel.css({\n                height: (element.height() - this.outerDimensions.height) || 0,\n                width: (element.width() - this.outerDimensions.width) || 0\n            });\n\n        }\n\n    },\n\n    _renderProxy: function() {\n\n        var el = this.element, o = this.options;\n        this.elementOffset = el.offset();\n\n        if (this._helper) {\n\n            this.helper = this.helper || $(\"<div style='overflow:hidden;'></div>\");\n\n            this.helper.addClass(this._helper).css({\n                width: this.element.outerWidth() - 1,\n                height: this.element.outerHeight() - 1,\n                position: \"absolute\",\n                left: this.elementOffset.left + \"px\",\n                top: this.elementOffset.top + \"px\",\n                zIndex: ++o.zIndex //TODO: Don't modify option\n            });\n\n            this.helper\n                .appendTo(\"body\")\n                .disableSelection();\n\n        } else {\n            this.helper = this.element;\n        }\n\n    },\n\n    _change: {\n        e: function(event, dx) {\n            return { width: this.originalSize.width + dx };\n        },\n        w: function(event, dx) {\n            var cs = this.originalSize, sp = this.originalPosition;\n            return { left: sp.left + dx, width: cs.width - dx };\n        },\n        n: function(event, dx, dy) {\n            var cs = this.originalSize, sp = this.originalPosition;\n            return { top: sp.top + dy, height: cs.height - dy };\n        },\n        s: function(event, dx, dy) {\n            return { height: this.originalSize.height + dy };\n        },\n        se: function(event, dx, dy) {\n            return $.extend(this._change.s.apply(this, arguments),\n                this._change.e.apply(this, [ event, dx, dy ]));\n        },\n        sw: function(event, dx, dy) {\n            return $.extend(this._change.s.apply(this, arguments),\n                this._change.w.apply(this, [ event, dx, dy ]));\n        },\n        ne: function(event, dx, dy) {\n            return $.extend(this._change.n.apply(this, arguments),\n                this._change.e.apply(this, [ event, dx, dy ]));\n        },\n        nw: function(event, dx, dy) {\n            return $.extend(this._change.n.apply(this, arguments),\n                this._change.w.apply(this, [ event, dx, dy ]));\n        }\n    },\n\n    _propagate: function(n, event) {\n        $.ui.plugin.call(this, n, [ event, this.ui() ]);\n        (n !== \"resize\" && this._trigger(n, event, this.ui()));\n    },\n\n    plugins: {},\n\n    ui: function() {\n        return {\n            originalElement: this.originalElement,\n            element: this.element,\n            helper: this.helper,\n            position: this.position,\n            size: this.size,\n            originalSize: this.originalSize,\n            originalPosition: this.originalPosition\n        };\n    }\n\n});\n\n/*\n * Resizable Extensions\n */\n\n$.ui.plugin.add(\"resizable\", \"animate\", {\n\n    stop: function( event ) {\n        var that = $(this).resizable( \"instance\" ),\n            o = that.options,\n            pr = that._proportionallyResizeElements,\n            ista = pr.length && (/textarea/i).test(pr[0].nodeName),\n            soffseth = ista && that._hasScroll(pr[0], \"left\") ? 0 : that.sizeDiff.height,\n            soffsetw = ista ? 0 : that.sizeDiff.width,\n            style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },\n            left = (parseInt(that.element.css(\"left\"), 10) +\n                (that.position.left - that.originalPosition.left)) || null,\n            top = (parseInt(that.element.css(\"top\"), 10) +\n                (that.position.top - that.originalPosition.top)) || null;\n\n        that.element.animate(\n            $.extend(style, top && left ? { top: top, left: left } : {}), {\n                duration: o.animateDuration,\n                easing: o.animateEasing,\n                step: function() {\n\n                    var data = {\n                        width: parseInt(that.element.css(\"width\"), 10),\n                        height: parseInt(that.element.css(\"height\"), 10),\n                        top: parseInt(that.element.css(\"top\"), 10),\n                        left: parseInt(that.element.css(\"left\"), 10)\n                    };\n\n                    if (pr && pr.length) {\n                        $(pr[0]).css({ width: data.width, height: data.height });\n                    }\n\n                    // propagating resize, and updating values for each animation step\n                    that._updateCache(data);\n                    that._propagate(\"resize\", event);\n\n                }\n            }\n        );\n    }\n\n});\n\n$.ui.plugin.add( \"resizable\", \"containment\", {\n\n    start: function() {\n        var element, p, co, ch, cw, width, height,\n            that = $( this ).resizable( \"instance\" ),\n            o = that.options,\n            el = that.element,\n            oc = o.containment,\n            ce = ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;\n\n        if ( !ce ) {\n            return;\n        }\n\n        that.containerElement = $( ce );\n\n        if ( /document/.test( oc ) || oc === document ) {\n            that.containerOffset = {\n                left: 0,\n                top: 0\n            };\n            that.containerPosition = {\n                left: 0,\n                top: 0\n            };\n\n            that.parentData = {\n                element: $( document ),\n                left: 0,\n                top: 0,\n                width: $( document ).width(),\n                height: $( document ).height() || document.body.parentNode.scrollHeight\n            };\n        } else {\n            element = $( ce );\n            p = [];\n            $([ \"Top\", \"Right\", \"Left\", \"Bottom\" ]).each(function( i, name ) {\n                p[ i ] = that._num( element.css( \"padding\" + name ) );\n            });\n\n            that.containerOffset = element.offset();\n            that.containerPosition = element.position();\n            that.containerSize = {\n                height: ( element.innerHeight() - p[ 3 ] ),\n                width: ( element.innerWidth() - p[ 1 ] )\n            };\n\n            co = that.containerOffset;\n            ch = that.containerSize.height;\n            cw = that.containerSize.width;\n            width = ( that._hasScroll ( ce, \"left\" ) ? ce.scrollWidth : cw );\n            height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;\n\n            that.parentData = {\n                element: ce,\n                left: co.left,\n                top: co.top,\n                width: width,\n                height: height\n            };\n        }\n    },\n\n    resize: function( event ) {\n        var woset, hoset, isParent, isOffsetRelative,\n            that = $( this ).resizable( \"instance\" ),\n            o = that.options,\n            co = that.containerOffset,\n            cp = that.position,\n            pRatio = that._aspectRatio || event.shiftKey,\n            cop = {\n                top: 0,\n                left: 0\n            },\n            ce = that.containerElement,\n            continueResize = true;\n\n        if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( \"position\" ) ) ) {\n            cop = co;\n        }\n\n        if ( cp.left < ( that._helper ? co.left : 0 ) ) {\n            that.size.width = that.size.width +\n                ( that._helper ?\n                    ( that.position.left - co.left ) :\n                    ( that.position.left - cop.left ) );\n\n            if ( pRatio ) {\n                that.size.height = that.size.width / that.aspectRatio;\n                continueResize = false;\n            }\n            that.position.left = o.helper ? co.left : 0;\n        }\n\n        if ( cp.top < ( that._helper ? co.top : 0 ) ) {\n            that.size.height = that.size.height +\n                ( that._helper ?\n                    ( that.position.top - co.top ) :\n                    that.position.top );\n\n            if ( pRatio ) {\n                that.size.width = that.size.height * that.aspectRatio;\n                continueResize = false;\n            }\n            that.position.top = that._helper ? co.top : 0;\n        }\n\n        isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );\n        isOffsetRelative = /relative|absolute/.test( that.containerElement.css( \"position\" ) );\n\n        if ( isParent && isOffsetRelative ) {\n            that.offset.left = that.parentData.left + that.position.left;\n            that.offset.top = that.parentData.top + that.position.top;\n        } else {\n            that.offset.left = that.element.offset().left;\n            that.offset.top = that.element.offset().top;\n        }\n\n        woset = Math.abs( that.sizeDiff.width +\n            (that._helper ?\n                that.offset.left - cop.left :\n                (that.offset.left - co.left)) );\n\n        hoset = Math.abs( that.sizeDiff.height +\n            (that._helper ?\n                that.offset.top - cop.top :\n                (that.offset.top - co.top)) );\n\n        if ( woset + that.size.width >= that.parentData.width ) {\n            that.size.width = that.parentData.width - woset;\n            if ( pRatio ) {\n                that.size.height = that.size.width / that.aspectRatio;\n                continueResize = false;\n            }\n        }\n\n        if ( hoset + that.size.height >= that.parentData.height ) {\n            that.size.height = that.parentData.height - hoset;\n            if ( pRatio ) {\n                that.size.width = that.size.height * that.aspectRatio;\n                continueResize = false;\n            }\n        }\n\n        if ( !continueResize ){\n            that.position.left = that.prevPosition.left;\n            that.position.top = that.prevPosition.top;\n            that.size.width = that.prevSize.width;\n            that.size.height = that.prevSize.height;\n        }\n    },\n\n    stop: function() {\n        var that = $( this ).resizable( \"instance\" ),\n            o = that.options,\n            co = that.containerOffset,\n            cop = that.containerPosition,\n            ce = that.containerElement,\n            helper = $( that.helper ),\n            ho = helper.offset(),\n            w = helper.outerWidth() - that.sizeDiff.width,\n            h = helper.outerHeight() - that.sizeDiff.height;\n\n        if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( \"position\" ) ) ) {\n            $( this ).css({\n                left: ho.left - cop.left - co.left,\n                width: w,\n                height: h\n            });\n        }\n\n        if ( that._helper && !o.animate && ( /static/ ).test( ce.css( \"position\" ) ) ) {\n            $( this ).css({\n                left: ho.left - cop.left - co.left,\n                width: w,\n                height: h\n            });\n        }\n    }\n});\n\n$.ui.plugin.add(\"resizable\", \"alsoResize\", {\n\n    start: function() {\n        var that = $(this).resizable( \"instance\" ),\n            o = that.options,\n            _store = function(exp) {\n                $(exp).each(function() {\n                    var el = $(this);\n                    el.data(\"ui-resizable-alsoresize\", {\n                        width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),\n                        left: parseInt(el.css(\"left\"), 10), top: parseInt(el.css(\"top\"), 10)\n                    });\n                });\n            };\n\n        if (typeof(o.alsoResize) === \"object\" && !o.alsoResize.parentNode) {\n            if (o.alsoResize.length) {\n                o.alsoResize = o.alsoResize[0];\n                _store(o.alsoResize);\n            } else {\n                $.each(o.alsoResize, function(exp) {\n                    _store(exp);\n                });\n            }\n        } else {\n            _store(o.alsoResize);\n        }\n    },\n\n    resize: function(event, ui) {\n        var that = $(this).resizable( \"instance\" ),\n            o = that.options,\n            os = that.originalSize,\n            op = that.originalPosition,\n            delta = {\n                height: (that.size.height - os.height) || 0,\n                width: (that.size.width - os.width) || 0,\n                top: (that.position.top - op.top) || 0,\n                left: (that.position.left - op.left) || 0\n            },\n\n            _alsoResize = function(exp, c) {\n                $(exp).each(function() {\n                    var el = $(this), start = $(this).data(\"ui-resizable-alsoresize\"), style = {},\n                        css = c && c.length ?\n                            c :\n                            el.parents(ui.originalElement[0]).length ?\n                                [ \"width\", \"height\" ] :\n                                [ \"width\", \"height\", \"top\", \"left\" ];\n\n                    $.each(css, function(i, prop) {\n                        var sum = (start[prop] || 0) + (delta[prop] || 0);\n                        if (sum && sum >= 0) {\n                            style[prop] = sum || null;\n                        }\n                    });\n\n                    el.css(style);\n                });\n            };\n\n        if (typeof(o.alsoResize) === \"object\" && !o.alsoResize.nodeType) {\n            $.each(o.alsoResize, function(exp, c) {\n                _alsoResize(exp, c);\n            });\n        } else {\n            _alsoResize(o.alsoResize);\n        }\n    },\n\n    stop: function() {\n        $(this).removeData(\"resizable-alsoresize\");\n    }\n});\n\n$.ui.plugin.add(\"resizable\", \"ghost\", {\n\n    start: function() {\n\n        var that = $(this).resizable( \"instance\" ), o = that.options, cs = that.size;\n\n        that.ghost = that.originalElement.clone();\n        that.ghost\n            .css({\n                opacity: 0.25,\n                display: \"block\",\n                position: \"relative\",\n                height: cs.height,\n                width: cs.width,\n                margin: 0,\n                left: 0,\n                top: 0\n            })\n            .addClass(\"ui-resizable-ghost\")\n            .addClass(typeof o.ghost === \"string\" ? o.ghost : \"\");\n\n        that.ghost.appendTo(that.helper);\n\n    },\n\n    resize: function() {\n        var that = $(this).resizable( \"instance\" );\n        if (that.ghost) {\n            that.ghost.css({\n                position: \"relative\",\n                height: that.size.height,\n                width: that.size.width\n            });\n        }\n    },\n\n    stop: function() {\n        var that = $(this).resizable( \"instance\" );\n        if (that.ghost && that.helper) {\n            that.helper.get(0).removeChild(that.ghost.get(0));\n        }\n    }\n\n});\n\n$.ui.plugin.add(\"resizable\", \"grid\", {\n\n    resize: function() {\n        var outerDimensions,\n            that = $(this).resizable( \"instance\" ),\n            o = that.options,\n            cs = that.size,\n            os = that.originalSize,\n            op = that.originalPosition,\n            a = that.axis,\n            grid = typeof o.grid === \"number\" ? [ o.grid, o.grid ] : o.grid,\n            gridX = (grid[0] || 1),\n            gridY = (grid[1] || 1),\n            ox = Math.round((cs.width - os.width) / gridX) * gridX,\n            oy = Math.round((cs.height - os.height) / gridY) * gridY,\n            newWidth = os.width + ox,\n            newHeight = os.height + oy,\n            isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),\n            isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),\n            isMinWidth = o.minWidth && (o.minWidth > newWidth),\n            isMinHeight = o.minHeight && (o.minHeight > newHeight);\n\n        o.grid = grid;\n\n        if (isMinWidth) {\n            newWidth += gridX;\n        }\n        if (isMinHeight) {\n            newHeight += gridY;\n        }\n        if (isMaxWidth) {\n            newWidth -= gridX;\n        }\n        if (isMaxHeight) {\n            newHeight -= gridY;\n        }\n\n        if (/^(se|s|e)$/.test(a)) {\n            that.size.width = newWidth;\n            that.size.height = newHeight;\n        } else if (/^(ne)$/.test(a)) {\n            that.size.width = newWidth;\n            that.size.height = newHeight;\n            that.position.top = op.top - oy;\n        } else if (/^(sw)$/.test(a)) {\n            that.size.width = newWidth;\n            that.size.height = newHeight;\n            that.position.left = op.left - ox;\n        } else {\n            if ( newHeight - gridY <= 0 || newWidth - gridX <= 0) {\n                outerDimensions = that._getPaddingPlusBorderDimensions( this );\n            }\n\n            if ( newHeight - gridY > 0 ) {\n                that.size.height = newHeight;\n                that.position.top = op.top - oy;\n            } else {\n                newHeight = gridY - outerDimensions.height;\n                that.size.height = newHeight;\n                that.position.top = op.top + os.height - newHeight;\n            }\n            if ( newWidth - gridX > 0 ) {\n                that.size.width = newWidth;\n                that.position.left = op.left - ox;\n            } else {\n                newWidth = gridY - outerDimensions.height;\n                that.size.width = newWidth;\n                that.position.left = op.left + os.width - newWidth;\n            }\n        }\n    }\n\n});\n\nvar resizable = $.ui.resizable;\n\n\n/*!\n * jQuery UI Dialog 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/dialog/\n */\n\n\nvar dialog = $.widget( \"ui.dialog\", {\n    version: \"1.11.2\",\n    options: {\n        appendTo: \"body\",\n        autoOpen: true,\n        buttons: [],\n        closeOnEscape: true,\n        closeText: \"Close\",\n        dialogClass: \"\",\n        draggable: true,\n        hide: null,\n        height: \"auto\",\n        maxHeight: null,\n        maxWidth: null,\n        minHeight: 150,\n        minWidth: 150,\n        modal: false,\n        position: {\n            my: \"center\",\n            at: \"center\",\n            of: window,\n            collision: \"fit\",\n            // Ensure the titlebar is always visible\n            using: function( pos ) {\n                var topOffset = $( this ).css( pos ).offset().top;\n                if ( topOffset < 0 ) {\n                    $( this ).css( \"top\", pos.top - topOffset );\n                }\n            }\n        },\n        resizable: true,\n        show: null,\n        title: null,\n        width: 300,\n\n        // callbacks\n        beforeClose: null,\n        close: null,\n        drag: null,\n        dragStart: null,\n        dragStop: null,\n        focus: null,\n        open: null,\n        resize: null,\n        resizeStart: null,\n        resizeStop: null\n    },\n\n    sizeRelatedOptions: {\n        buttons: true,\n        height: true,\n        maxHeight: true,\n        maxWidth: true,\n        minHeight: true,\n        minWidth: true,\n        width: true\n    },\n\n    resizableRelatedOptions: {\n        maxHeight: true,\n        maxWidth: true,\n        minHeight: true,\n        minWidth: true\n    },\n\n    _create: function() {\n        this.originalCss = {\n            display: this.element[ 0 ].style.display,\n            width: this.element[ 0 ].style.width,\n            minHeight: this.element[ 0 ].style.minHeight,\n            maxHeight: this.element[ 0 ].style.maxHeight,\n            height: this.element[ 0 ].style.height\n        };\n        this.originalPosition = {\n            parent: this.element.parent(),\n            index: this.element.parent().children().index( this.element )\n        };\n        this.originalTitle = this.element.attr( \"title\" );\n        this.options.title = this.options.title || this.originalTitle;\n\n        this._createWrapper();\n\n        this.element\n            .show()\n            .removeAttr( \"title\" )\n            .addClass( \"ui-dialog-content ui-widget-content\" )\n            .appendTo( this.uiDialog );\n\n        this._createTitlebar();\n        this._createButtonPane();\n\n        if ( this.options.draggable && $.fn.draggable ) {\n            this._makeDraggable();\n        }\n        if ( this.options.resizable && $.fn.resizable ) {\n            this._makeResizable();\n        }\n\n        this._isOpen = false;\n\n        this._trackFocus();\n    },\n\n    _init: function() {\n        if ( this.options.autoOpen ) {\n            this.open();\n        }\n    },\n\n    _appendTo: function() {\n        var element = this.options.appendTo;\n        if ( element && (element.jquery || element.nodeType) ) {\n            return $( element );\n        }\n        return this.document.find( element || \"body\" ).eq( 0 );\n    },\n\n    _destroy: function() {\n        var next,\n            originalPosition = this.originalPosition;\n\n        this._destroyOverlay();\n\n        this.element\n            .removeUniqueId()\n            .removeClass( \"ui-dialog-content ui-widget-content\" )\n            .css( this.originalCss )\n            // Without detaching first, the following becomes really slow\n            .detach();\n\n        this.uiDialog.stop( true, true ).remove();\n\n        if ( this.originalTitle ) {\n            this.element.attr( \"title\", this.originalTitle );\n        }\n\n        next = originalPosition.parent.children().eq( originalPosition.index );\n        // Don't try to place the dialog next to itself (#8613)\n        if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {\n            next.before( this.element );\n        } else {\n            originalPosition.parent.append( this.element );\n        }\n    },\n\n    widget: function() {\n        return this.uiDialog;\n    },\n\n    disable: $.noop,\n    enable: $.noop,\n\n    close: function( event ) {\n        var activeElement,\n            that = this;\n\n        if ( !this._isOpen || this._trigger( \"beforeClose\", event ) === false ) {\n            return;\n        }\n\n        this._isOpen = false;\n        this._focusedElement = null;\n        this._destroyOverlay();\n        this._untrackInstance();\n\n        if ( !this.opener.filter( \":focusable\" ).focus().length ) {\n\n            // support: IE9\n            // IE9 throws an \"Unspecified error\" accessing document.activeElement from an <iframe>\n            try {\n                activeElement = this.document[ 0 ].activeElement;\n\n                // Support: IE9, IE10\n                // If the <body> is blurred, IE will switch windows, see #4520\n                if ( activeElement && activeElement.nodeName.toLowerCase() !== \"body\" ) {\n\n                    // Hiding a focused element doesn't trigger blur in WebKit\n                    // so in case we have nothing to focus on, explicitly blur the active element\n                    // https://bugs.webkit.org/show_bug.cgi?id=47182\n                    $( activeElement ).blur();\n                }\n            } catch ( error ) {}\n        }\n\n        this._hide( this.uiDialog, this.options.hide, function() {\n            that._trigger( \"close\", event );\n        });\n    },\n\n    isOpen: function() {\n        return this._isOpen;\n    },\n\n    moveToTop: function() {\n        this._moveToTop();\n    },\n\n    _moveToTop: function( event, silent ) {\n        var moved = false,\n            zIndicies = this.uiDialog.siblings( \".ui-front:visible\" ).map(function() {\n                return +$( this ).css( \"z-index\" );\n            }).get(),\n            zIndexMax = Math.max.apply( null, zIndicies );\n\n        if ( zIndexMax >= +this.uiDialog.css( \"z-index\" ) ) {\n            this.uiDialog.css( \"z-index\", zIndexMax + 1 );\n            moved = true;\n        }\n\n        if ( moved && !silent ) {\n            this._trigger( \"focus\", event );\n        }\n        return moved;\n    },\n\n    open: function() {\n        var that = this;\n        if ( this._isOpen ) {\n            if ( this._moveToTop() ) {\n                this._focusTabbable();\n            }\n            return;\n        }\n\n        this._isOpen = true;\n        this.opener = $( this.document[ 0 ].activeElement );\n\n        this._size();\n        this._position();\n        this._createOverlay();\n        this._moveToTop( null, true );\n\n        // Ensure the overlay is moved to the top with the dialog, but only when\n        // opening. The overlay shouldn't move after the dialog is open so that\n        // modeless dialogs opened after the modal dialog stack properly.\n        if ( this.overlay ) {\n            this.overlay.css( \"z-index\", this.uiDialog.css( \"z-index\" ) - 1 );\n        }\n\n        this._show( this.uiDialog, this.options.show, function() {\n            that._focusTabbable();\n            that._trigger( \"focus\" );\n        });\n\n        // Track the dialog immediately upon openening in case a focus event\n        // somehow occurs outside of the dialog before an element inside the\n        // dialog is focused (#10152)\n        this._makeFocusTarget();\n\n        this._trigger( \"open\" );\n    },\n\n    _focusTabbable: function() {\n        // Set focus to the first match:\n        // 1. An element that was focused previously\n        // 2. First element inside the dialog matching [autofocus]\n        // 3. Tabbable element inside the content element\n        // 4. Tabbable element inside the buttonpane\n        // 5. The close button\n        // 6. The dialog itself\n        var hasFocus = this._focusedElement;\n        if ( !hasFocus ) {\n            hasFocus = this.element.find( \"[autofocus]\" );\n        }\n        if ( !hasFocus.length ) {\n            hasFocus = this.element.find( \":tabbable\" );\n        }\n        if ( !hasFocus.length ) {\n            hasFocus = this.uiDialogButtonPane.find( \":tabbable\" );\n        }\n        if ( !hasFocus.length ) {\n            hasFocus = this.uiDialogTitlebarClose.filter( \":tabbable\" );\n        }\n        if ( !hasFocus.length ) {\n            hasFocus = this.uiDialog;\n        }\n        hasFocus.eq( 0 ).focus();\n    },\n\n    _keepFocus: function( event ) {\n        function checkFocus() {\n            var activeElement = this.document[0].activeElement,\n                isActive = this.uiDialog[0] === activeElement ||\n                    $.contains( this.uiDialog[0], activeElement );\n            if ( !isActive ) {\n                this._focusTabbable();\n            }\n        }\n        event.preventDefault();\n        checkFocus.call( this );\n        // support: IE\n        // IE <= 8 doesn't prevent moving focus even with event.preventDefault()\n        // so we check again later\n        this._delay( checkFocus );\n    },\n\n    _createWrapper: function() {\n        this.uiDialog = $(\"<div>\")\n            .addClass( \"ui-dialog ui-widget ui-widget-content ui-corner-all ui-front \" +\n                this.options.dialogClass )\n            .hide()\n            .attr({\n                // Setting tabIndex makes the div focusable\n                tabIndex: -1,\n                role: \"dialog\"\n            })\n            .appendTo( this._appendTo() );\n\n        this._on( this.uiDialog, {\n            keydown: function( event ) {\n                if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&\n                        event.keyCode === $.ui.keyCode.ESCAPE ) {\n                    event.preventDefault();\n                    this.close( event );\n                    return;\n                }\n\n                // prevent tabbing out of dialogs\n                if ( event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented() ) {\n                    return;\n                }\n                var tabbables = this.uiDialog.find( \":tabbable\" ),\n                    first = tabbables.filter( \":first\" ),\n                    last = tabbables.filter( \":last\" );\n\n                if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {\n                    this._delay(function() {\n                        first.focus();\n                    });\n                    event.preventDefault();\n                } else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {\n                    this._delay(function() {\n                        last.focus();\n                    });\n                    event.preventDefault();\n                }\n            },\n            mousedown: function( event ) {\n                if ( this._moveToTop( event ) ) {\n                    this._focusTabbable();\n                }\n            }\n        });\n\n        // We assume that any existing aria-describedby attribute means\n        // that the dialog content is marked up properly\n        // otherwise we brute force the content as the description\n        if ( !this.element.find( \"[aria-describedby]\" ).length ) {\n            this.uiDialog.attr({\n                \"aria-describedby\": this.element.uniqueId().attr( \"id\" )\n            });\n        }\n    },\n\n    _createTitlebar: function() {\n        var uiDialogTitle;\n\n        this.uiDialogTitlebar = $( \"<div>\" )\n            .addClass( \"ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix\" )\n            .prependTo( this.uiDialog );\n        this._on( this.uiDialogTitlebar, {\n            mousedown: function( event ) {\n                // Don't prevent click on close button (#8838)\n                // Focusing a dialog that is partially scrolled out of view\n                // causes the browser to scroll it into view, preventing the click event\n                if ( !$( event.target ).closest( \".ui-dialog-titlebar-close\" ) ) {\n                    // Dialog isn't getting focus when dragging (#8063)\n                    this.uiDialog.focus();\n                }\n            }\n        });\n\n        // support: IE\n        // Use type=\"button\" to prevent enter keypresses in textboxes from closing the\n        // dialog in IE (#9312)\n        this.uiDialogTitlebarClose = $( \"<button type='button'></button>\" )\n            .button({\n                label: this.options.closeText,\n                icons: {\n                    primary: \"ui-icon-closethick\"\n                },\n                text: false\n            })\n            .addClass( \"ui-dialog-titlebar-close\" )\n            .appendTo( this.uiDialogTitlebar );\n        this._on( this.uiDialogTitlebarClose, {\n            click: function( event ) {\n                event.preventDefault();\n                this.close( event );\n            }\n        });\n\n        uiDialogTitle = $( \"<span>\" )\n            .uniqueId()\n            .addClass( \"ui-dialog-title\" )\n            .prependTo( this.uiDialogTitlebar );\n        this._title( uiDialogTitle );\n\n        this.uiDialog.attr({\n            \"aria-labelledby\": uiDialogTitle.attr( \"id\" )\n        });\n    },\n\n    _title: function( title ) {\n        if ( !this.options.title ) {\n            title.html( \"&#160;\" );\n        }\n        title.text( this.options.title );\n    },\n\n    _createButtonPane: function() {\n        this.uiDialogButtonPane = $( \"<div>\" )\n            .addClass( \"ui-dialog-buttonpane ui-widget-content ui-helper-clearfix\" );\n\n        this.uiButtonSet = $( \"<div>\" )\n            .addClass( \"ui-dialog-buttonset\" )\n            .appendTo( this.uiDialogButtonPane );\n\n        this._createButtons();\n    },\n\n    _createButtons: function() {\n        var that = this,\n            buttons = this.options.buttons;\n\n        // if we already have a button pane, remove it\n        this.uiDialogButtonPane.remove();\n        this.uiButtonSet.empty();\n\n        if ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && !buttons.length) ) {\n            this.uiDialog.removeClass( \"ui-dialog-buttons\" );\n            return;\n        }\n\n        $.each( buttons, function( name, props ) {\n            var click, buttonOptions;\n            props = $.isFunction( props ) ?\n                { click: props, text: name } :\n                props;\n            // Default to a non-submitting button\n            props = $.extend( { type: \"button\" }, props );\n            // Change the context for the click callback to be the main element\n            click = props.click;\n            props.click = function() {\n                click.apply( that.element[ 0 ], arguments );\n            };\n            buttonOptions = {\n                icons: props.icons,\n                text: props.showText\n            };\n            delete props.icons;\n            delete props.showText;\n            $( \"<button></button>\", props )\n                .button( buttonOptions )\n                .appendTo( that.uiButtonSet );\n        });\n        this.uiDialog.addClass( \"ui-dialog-buttons\" );\n        this.uiDialogButtonPane.appendTo( this.uiDialog );\n    },\n\n    _makeDraggable: function() {\n        var that = this,\n            options = this.options;\n\n        function filteredUi( ui ) {\n            return {\n                position: ui.position,\n                offset: ui.offset\n            };\n        }\n\n        this.uiDialog.draggable({\n            cancel: \".ui-dialog-content, .ui-dialog-titlebar-close\",\n            handle: \".ui-dialog-titlebar\",\n            containment: \"document\",\n            start: function( event, ui ) {\n                $( this ).addClass( \"ui-dialog-dragging\" );\n                that._blockFrames();\n                that._trigger( \"dragStart\", event, filteredUi( ui ) );\n            },\n            drag: function( event, ui ) {\n                that._trigger( \"drag\", event, filteredUi( ui ) );\n            },\n            stop: function( event, ui ) {\n                var left = ui.offset.left - that.document.scrollLeft(),\n                    top = ui.offset.top - that.document.scrollTop();\n\n                options.position = {\n                    my: \"left top\",\n                    at: \"left\" + (left >= 0 ? \"+\" : \"\") + left + \" \" +\n                        \"top\" + (top >= 0 ? \"+\" : \"\") + top,\n                    of: that.window\n                };\n                $( this ).removeClass( \"ui-dialog-dragging\" );\n                that._unblockFrames();\n                that._trigger( \"dragStop\", event, filteredUi( ui ) );\n            }\n        });\n    },\n\n    _makeResizable: function() {\n        var that = this,\n            options = this.options,\n            handles = options.resizable,\n            // .ui-resizable has position: relative defined in the stylesheet\n            // but dialogs have to use absolute or fixed positioning\n            position = this.uiDialog.css(\"position\"),\n            resizeHandles = typeof handles === \"string\" ?\n                handles    :\n                \"n,e,s,w,se,sw,ne,nw\";\n\n        function filteredUi( ui ) {\n            return {\n                originalPosition: ui.originalPosition,\n                originalSize: ui.originalSize,\n                position: ui.position,\n                size: ui.size\n            };\n        }\n\n        this.uiDialog.resizable({\n            cancel: \".ui-dialog-content\",\n            containment: \"document\",\n            alsoResize: this.element,\n            maxWidth: options.maxWidth,\n            maxHeight: options.maxHeight,\n            minWidth: options.minWidth,\n            minHeight: this._minHeight(),\n            handles: resizeHandles,\n            start: function( event, ui ) {\n                $( this ).addClass( \"ui-dialog-resizing\" );\n                that._blockFrames();\n                that._trigger( \"resizeStart\", event, filteredUi( ui ) );\n            },\n            resize: function( event, ui ) {\n                that._trigger( \"resize\", event, filteredUi( ui ) );\n            },\n            stop: function( event, ui ) {\n                var offset = that.uiDialog.offset(),\n                    left = offset.left - that.document.scrollLeft(),\n                    top = offset.top - that.document.scrollTop();\n\n                options.height = that.uiDialog.height();\n                options.width = that.uiDialog.width();\n                options.position = {\n                    my: \"left top\",\n                    at: \"left\" + (left >= 0 ? \"+\" : \"\") + left + \" \" +\n                        \"top\" + (top >= 0 ? \"+\" : \"\") + top,\n                    of: that.window\n                };\n                $( this ).removeClass( \"ui-dialog-resizing\" );\n                that._unblockFrames();\n                that._trigger( \"resizeStop\", event, filteredUi( ui ) );\n            }\n        })\n        .css( \"position\", position );\n    },\n\n    _trackFocus: function() {\n        this._on( this.widget(), {\n            focusin: function( event ) {\n                this._makeFocusTarget();\n                this._focusedElement = $( event.target );\n            }\n        });\n    },\n\n    _makeFocusTarget: function() {\n        this._untrackInstance();\n        this._trackingInstances().unshift( this );\n    },\n\n    _untrackInstance: function() {\n        var instances = this._trackingInstances(),\n            exists = $.inArray( this, instances );\n        if ( exists !== -1 ) {\n            instances.splice( exists, 1 );\n        }\n    },\n\n    _trackingInstances: function() {\n        var instances = this.document.data( \"ui-dialog-instances\" );\n        if ( !instances ) {\n            instances = [];\n            this.document.data( \"ui-dialog-instances\", instances );\n        }\n        return instances;\n    },\n\n    _minHeight: function() {\n        var options = this.options;\n\n        return options.height === \"auto\" ?\n            options.minHeight :\n            Math.min( options.minHeight, options.height );\n    },\n\n    _position: function() {\n        // Need to show the dialog to get the actual offset in the position plugin\n        var isVisible = this.uiDialog.is( \":visible\" );\n        if ( !isVisible ) {\n            this.uiDialog.show();\n        }\n        this.uiDialog.position( this.options.position );\n        if ( !isVisible ) {\n            this.uiDialog.hide();\n        }\n    },\n\n    _setOptions: function( options ) {\n        var that = this,\n            resize = false,\n            resizableOptions = {};\n\n        $.each( options, function( key, value ) {\n            that._setOption( key, value );\n\n            if ( key in that.sizeRelatedOptions ) {\n                resize = true;\n            }\n            if ( key in that.resizableRelatedOptions ) {\n                resizableOptions[ key ] = value;\n            }\n        });\n\n        if ( resize ) {\n            this._size();\n            this._position();\n        }\n        if ( this.uiDialog.is( \":data(ui-resizable)\" ) ) {\n            this.uiDialog.resizable( \"option\", resizableOptions );\n        }\n    },\n\n    _setOption: function( key, value ) {\n        var isDraggable, isResizable,\n            uiDialog = this.uiDialog;\n\n        if ( key === \"dialogClass\" ) {\n            uiDialog\n                .removeClass( this.options.dialogClass )\n                .addClass( value );\n        }\n\n        if ( key === \"disabled\" ) {\n            return;\n        }\n\n        this._super( key, value );\n\n        if ( key === \"appendTo\" ) {\n            this.uiDialog.appendTo( this._appendTo() );\n        }\n\n        if ( key === \"buttons\" ) {\n            this._createButtons();\n        }\n\n        if ( key === \"closeText\" ) {\n            this.uiDialogTitlebarClose.button({\n                // Ensure that we always pass a string\n                label: \"\" + value\n            });\n        }\n\n        if ( key === \"draggable\" ) {\n            isDraggable = uiDialog.is( \":data(ui-draggable)\" );\n            if ( isDraggable && !value ) {\n                uiDialog.draggable( \"destroy\" );\n            }\n\n            if ( !isDraggable && value ) {\n                this._makeDraggable();\n            }\n        }\n\n        if ( key === \"position\" ) {\n            this._position();\n        }\n\n        if ( key === \"resizable\" ) {\n            // currently resizable, becoming non-resizable\n            isResizable = uiDialog.is( \":data(ui-resizable)\" );\n            if ( isResizable && !value ) {\n                uiDialog.resizable( \"destroy\" );\n            }\n\n            // currently resizable, changing handles\n            if ( isResizable && typeof value === \"string\" ) {\n                uiDialog.resizable( \"option\", \"handles\", value );\n            }\n\n            // currently non-resizable, becoming resizable\n            if ( !isResizable && value !== false ) {\n                this._makeResizable();\n            }\n        }\n\n        if ( key === \"title\" ) {\n            this._title( this.uiDialogTitlebar.find( \".ui-dialog-title\" ) );\n        }\n    },\n\n    _size: function() {\n        // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content\n        // divs will both have width and height set, so we need to reset them\n        var nonContentHeight, minContentHeight, maxContentHeight,\n            options = this.options;\n\n        // Reset content sizing\n        this.element.show().css({\n            width: \"auto\",\n            minHeight: 0,\n            maxHeight: \"none\",\n            height: 0\n        });\n\n        if ( options.minWidth > options.width ) {\n            options.width = options.minWidth;\n        }\n\n        // reset wrapper sizing\n        // determine the height of all the non-content elements\n        nonContentHeight = this.uiDialog.css({\n                height: \"auto\",\n                width: options.width\n            })\n            .outerHeight();\n        minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );\n        maxContentHeight = typeof options.maxHeight === \"number\" ?\n            Math.max( 0, options.maxHeight - nonContentHeight ) :\n            \"none\";\n\n        if ( options.height === \"auto\" ) {\n            this.element.css({\n                minHeight: minContentHeight,\n                maxHeight: maxContentHeight,\n                height: \"auto\"\n            });\n        } else {\n            this.element.height( Math.max( 0, options.height - nonContentHeight ) );\n        }\n\n        if ( this.uiDialog.is( \":data(ui-resizable)\" ) ) {\n            this.uiDialog.resizable( \"option\", \"minHeight\", this._minHeight() );\n        }\n    },\n\n    _blockFrames: function() {\n        this.iframeBlocks = this.document.find( \"iframe\" ).map(function() {\n            var iframe = $( this );\n\n            return $( \"<div>\" )\n                .css({\n                    position: \"absolute\",\n                    width: iframe.outerWidth(),\n                    height: iframe.outerHeight()\n                })\n                .appendTo( iframe.parent() )\n                .offset( iframe.offset() )[0];\n        });\n    },\n\n    _unblockFrames: function() {\n        if ( this.iframeBlocks ) {\n            this.iframeBlocks.remove();\n            delete this.iframeBlocks;\n        }\n    },\n\n    _allowInteraction: function( event ) {\n        if ( $( event.target ).closest( \".ui-dialog\" ).length ) {\n            return true;\n        }\n\n        // TODO: Remove hack when datepicker implements\n        // the .ui-front logic (#8989)\n        return !!$( event.target ).closest( \".ui-datepicker\" ).length;\n    },\n\n    _createOverlay: function() {\n        if ( !this.options.modal ) {\n            return;\n        }\n\n        // We use a delay in case the overlay is created from an\n        // event that we're going to be cancelling (#2804)\n        var isOpening = true;\n        this._delay(function() {\n            isOpening = false;\n        });\n\n        if ( !this.document.data( \"ui-dialog-overlays\" ) ) {\n\n            // Prevent use of anchors and inputs\n            // Using _on() for an event handler shared across many instances is\n            // safe because the dialogs stack and must be closed in reverse order\n            this._on( this.document, {\n                focusin: function( event ) {\n                    if ( isOpening ) {\n                        return;\n                    }\n\n                    if ( !this._allowInteraction( event ) ) {\n                        event.preventDefault();\n                        this._trackingInstances()[ 0 ]._focusTabbable();\n                    }\n                }\n            });\n        }\n\n        this.overlay = $( \"<div>\" )\n            .addClass( \"ui-widget-overlay ui-front\" )\n            .appendTo( this._appendTo() );\n        this._on( this.overlay, {\n            mousedown: \"_keepFocus\"\n        });\n        this.document.data( \"ui-dialog-overlays\",\n            (this.document.data( \"ui-dialog-overlays\" ) || 0) + 1 );\n    },\n\n    _destroyOverlay: function() {\n        if ( !this.options.modal ) {\n            return;\n        }\n\n        if ( this.overlay ) {\n            var overlays = this.document.data( \"ui-dialog-overlays\" ) - 1;\n\n            if ( !overlays ) {\n                this.document\n                    .unbind( \"focusin\" )\n                    .removeData( \"ui-dialog-overlays\" );\n            } else {\n                this.document.data( \"ui-dialog-overlays\", overlays );\n            }\n\n            this.overlay.remove();\n            this.overlay = null;\n        }\n    }\n});\n\n\n/*!\n * jQuery UI Droppable 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/droppable/\n */\n\n\n$.widget( \"ui.droppable\", {\n    version: \"1.11.2\",\n    widgetEventPrefix: \"drop\",\n    options: {\n        accept: \"*\",\n        activeClass: false,\n        addClasses: true,\n        greedy: false,\n        hoverClass: false,\n        scope: \"default\",\n        tolerance: \"intersect\",\n\n        // callbacks\n        activate: null,\n        deactivate: null,\n        drop: null,\n        out: null,\n        over: null\n    },\n    _create: function() {\n\n        var proportions,\n            o = this.options,\n            accept = o.accept;\n\n        this.isover = false;\n        this.isout = true;\n\n        this.accept = $.isFunction( accept ) ? accept : function( d ) {\n            return d.is( accept );\n        };\n\n        this.proportions = function( /* valueToWrite */ ) {\n            if ( arguments.length ) {\n                // Store the droppable's proportions\n                proportions = arguments[ 0 ];\n            } else {\n                // Retrieve or derive the droppable's proportions\n                return proportions ?\n                    proportions :\n                    proportions = {\n                        width: this.element[ 0 ].offsetWidth,\n                        height: this.element[ 0 ].offsetHeight\n                    };\n            }\n        };\n\n        this._addToManager( o.scope );\n\n        o.addClasses && this.element.addClass( \"ui-droppable\" );\n\n    },\n\n    _addToManager: function( scope ) {\n        // Add the reference and positions to the manager\n        $.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];\n        $.ui.ddmanager.droppables[ scope ].push( this );\n    },\n\n    _splice: function( drop ) {\n        var i = 0;\n        for ( ; i < drop.length; i++ ) {\n            if ( drop[ i ] === this ) {\n                drop.splice( i, 1 );\n            }\n        }\n    },\n\n    _destroy: function() {\n        var drop = $.ui.ddmanager.droppables[ this.options.scope ];\n\n        this._splice( drop );\n\n        this.element.removeClass( \"ui-droppable ui-droppable-disabled\" );\n    },\n\n    _setOption: function( key, value ) {\n\n        if ( key === \"accept\" ) {\n            this.accept = $.isFunction( value ) ? value : function( d ) {\n                return d.is( value );\n            };\n        } else if ( key === \"scope\" ) {\n            var drop = $.ui.ddmanager.droppables[ this.options.scope ];\n\n            this._splice( drop );\n            this._addToManager( value );\n        }\n\n        this._super( key, value );\n    },\n\n    _activate: function( event ) {\n        var draggable = $.ui.ddmanager.current;\n        if ( this.options.activeClass ) {\n            this.element.addClass( this.options.activeClass );\n        }\n        if ( draggable ){\n            this._trigger( \"activate\", event, this.ui( draggable ) );\n        }\n    },\n\n    _deactivate: function( event ) {\n        var draggable = $.ui.ddmanager.current;\n        if ( this.options.activeClass ) {\n            this.element.removeClass( this.options.activeClass );\n        }\n        if ( draggable ){\n            this._trigger( \"deactivate\", event, this.ui( draggable ) );\n        }\n    },\n\n    _over: function( event ) {\n\n        var draggable = $.ui.ddmanager.current;\n\n        // Bail if draggable and droppable are same element\n        if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {\n            return;\n        }\n\n        if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {\n            if ( this.options.hoverClass ) {\n                this.element.addClass( this.options.hoverClass );\n            }\n            this._trigger( \"over\", event, this.ui( draggable ) );\n        }\n\n    },\n\n    _out: function( event ) {\n\n        var draggable = $.ui.ddmanager.current;\n\n        // Bail if draggable and droppable are same element\n        if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {\n            return;\n        }\n\n        if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {\n            if ( this.options.hoverClass ) {\n                this.element.removeClass( this.options.hoverClass );\n            }\n            this._trigger( \"out\", event, this.ui( draggable ) );\n        }\n\n    },\n\n    _drop: function( event, custom ) {\n\n        var draggable = custom || $.ui.ddmanager.current,\n            childrenIntersection = false;\n\n        // Bail if draggable and droppable are same element\n        if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {\n            return false;\n        }\n\n        this.element.find( \":data(ui-droppable)\" ).not( \".ui-draggable-dragging\" ).each(function() {\n            var inst = $( this ).droppable( \"instance\" );\n            if (\n                inst.options.greedy &&\n                !inst.options.disabled &&\n                inst.options.scope === draggable.options.scope &&\n                inst.accept.call( inst.element[ 0 ], ( draggable.currentItem || draggable.element ) ) &&\n                $.ui.intersect( draggable, $.extend( inst, { offset: inst.element.offset() } ), inst.options.tolerance, event )\n            ) { childrenIntersection = true; return false; }\n        });\n        if ( childrenIntersection ) {\n            return false;\n        }\n\n        if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {\n            if ( this.options.activeClass ) {\n                this.element.removeClass( this.options.activeClass );\n            }\n            if ( this.options.hoverClass ) {\n                this.element.removeClass( this.options.hoverClass );\n            }\n            this._trigger( \"drop\", event, this.ui( draggable ) );\n            return this.element;\n        }\n\n        return false;\n\n    },\n\n    ui: function( c ) {\n        return {\n            draggable: ( c.currentItem || c.element ),\n            helper: c.helper,\n            position: c.position,\n            offset: c.positionAbs\n        };\n    }\n\n});\n\n$.ui.intersect = (function() {\n    function isOverAxis( x, reference, size ) {\n        return ( x >= reference ) && ( x < ( reference + size ) );\n    }\n\n    return function( draggable, droppable, toleranceMode, event ) {\n\n        if ( !droppable.offset ) {\n            return false;\n        }\n\n        var x1 = ( draggable.positionAbs || draggable.position.absolute ).left + draggable.margins.left,\n            y1 = ( draggable.positionAbs || draggable.position.absolute ).top + draggable.margins.top,\n            x2 = x1 + draggable.helperProportions.width,\n            y2 = y1 + draggable.helperProportions.height,\n            l = droppable.offset.left,\n            t = droppable.offset.top,\n            r = l + droppable.proportions().width,\n            b = t + droppable.proportions().height;\n\n        switch ( toleranceMode ) {\n        case \"fit\":\n            return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );\n        case \"intersect\":\n            return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half\n                x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half\n                t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half\n                y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half\n        case \"pointer\":\n            return isOverAxis( event.pageY, t, droppable.proportions().height ) && isOverAxis( event.pageX, l, droppable.proportions().width );\n        case \"touch\":\n            return (\n                ( y1 >= t && y1 <= b ) || // Top edge touching\n                ( y2 >= t && y2 <= b ) || // Bottom edge touching\n                ( y1 < t && y2 > b ) // Surrounded vertically\n            ) && (\n                ( x1 >= l && x1 <= r ) || // Left edge touching\n                ( x2 >= l && x2 <= r ) || // Right edge touching\n                ( x1 < l && x2 > r ) // Surrounded horizontally\n            );\n        default:\n            return false;\n        }\n    };\n})();\n\n/*\n    This manager tracks offsets of draggables and droppables\n*/\n$.ui.ddmanager = {\n    current: null,\n    droppables: { \"default\": [] },\n    prepareOffsets: function( t, event ) {\n\n        var i, j,\n            m = $.ui.ddmanager.droppables[ t.options.scope ] || [],\n            type = event ? event.type : null, // workaround for #2317\n            list = ( t.currentItem || t.element ).find( \":data(ui-droppable)\" ).addBack();\n\n        droppablesLoop: for ( i = 0; i < m.length; i++ ) {\n\n            // No disabled and non-accepted\n            if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ], ( t.currentItem || t.element ) ) ) ) {\n                continue;\n            }\n\n            // Filter out elements in the current dragged item\n            for ( j = 0; j < list.length; j++ ) {\n                if ( list[ j ] === m[ i ].element[ 0 ] ) {\n                    m[ i ].proportions().height = 0;\n                    continue droppablesLoop;\n                }\n            }\n\n            m[ i ].visible = m[ i ].element.css( \"display\" ) !== \"none\";\n            if ( !m[ i ].visible ) {\n                continue;\n            }\n\n            // Activate the droppable if used directly from draggables\n            if ( type === \"mousedown\" ) {\n                m[ i ]._activate.call( m[ i ], event );\n            }\n\n            m[ i ].offset = m[ i ].element.offset();\n            m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });\n\n        }\n\n    },\n    drop: function( draggable, event ) {\n\n        var dropped = false;\n        // Create a copy of the droppables in case the list changes during the drop (#9116)\n        $.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {\n\n            if ( !this.options ) {\n                return;\n            }\n            if ( !this.options.disabled && this.visible && $.ui.intersect( draggable, this, this.options.tolerance, event ) ) {\n                dropped = this._drop.call( this, event ) || dropped;\n            }\n\n            if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {\n                this.isout = true;\n                this.isover = false;\n                this._deactivate.call( this, event );\n            }\n\n        });\n        return dropped;\n\n    },\n    dragStart: function( draggable, event ) {\n        // Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)\n        draggable.element.parentsUntil( \"body\" ).bind( \"scroll.droppable\", function() {\n            if ( !draggable.options.refreshPositions ) {\n                $.ui.ddmanager.prepareOffsets( draggable, event );\n            }\n        });\n    },\n    drag: function( draggable, event ) {\n\n        // If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.\n        if ( draggable.options.refreshPositions ) {\n            $.ui.ddmanager.prepareOffsets( draggable, event );\n        }\n\n        // Run through all droppables and check their positions based on specific tolerance options\n        $.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {\n\n            if ( this.options.disabled || this.greedyChild || !this.visible ) {\n                return;\n            }\n\n            var parentInstance, scope, parent,\n                intersects = $.ui.intersect( draggable, this, this.options.tolerance, event ),\n                c = !intersects && this.isover ? \"isout\" : ( intersects && !this.isover ? \"isover\" : null );\n            if ( !c ) {\n                return;\n            }\n\n            if ( this.options.greedy ) {\n                // find droppable parents with same scope\n                scope = this.options.scope;\n                parent = this.element.parents( \":data(ui-droppable)\" ).filter(function() {\n                    return $( this ).droppable( \"instance\" ).options.scope === scope;\n                });\n\n                if ( parent.length ) {\n                    parentInstance = $( parent[ 0 ] ).droppable( \"instance\" );\n                    parentInstance.greedyChild = ( c === \"isover\" );\n                }\n            }\n\n            // we just moved into a greedy child\n            if ( parentInstance && c === \"isover\" ) {\n                parentInstance.isover = false;\n                parentInstance.isout = true;\n                parentInstance._out.call( parentInstance, event );\n            }\n\n            this[ c ] = true;\n            this[c === \"isout\" ? \"isover\" : \"isout\"] = false;\n            this[c === \"isover\" ? \"_over\" : \"_out\"].call( this, event );\n\n            // we just moved out of a greedy child\n            if ( parentInstance && c === \"isout\" ) {\n                parentInstance.isout = false;\n                parentInstance.isover = true;\n                parentInstance._over.call( parentInstance, event );\n            }\n        });\n\n    },\n    dragStop: function( draggable, event ) {\n        draggable.element.parentsUntil( \"body\" ).unbind( \"scroll.droppable\" );\n        // Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)\n        if ( !draggable.options.refreshPositions ) {\n            $.ui.ddmanager.prepareOffsets( draggable, event );\n        }\n    }\n};\n\nvar droppable = $.ui.droppable;\n\n\n/*!\n * jQuery UI Effects 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/effects-core/\n */\n\n\nvar dataSpace = \"ui-effects-\",\n\n    // Create a local jQuery because jQuery Color relies on it and the\n    // global may not exist with AMD and a custom build (#10199)\n    jQuery = $;\n\n$.effects = {\n    effect: {}\n};\n\n/*!\n * jQuery Color Animations v2.1.2\n * https://github.com/jquery/jquery-color\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * Date: Wed Jan 16 08:47:09 2013 -0600\n */\n(function( jQuery, undefined ) {\n\n    var stepHooks = \"backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor\",\n\n    // plusequals test for += 100 -= 100\n    rplusequals = /^([\\-+])=\\s*(\\d+\\.?\\d*)/,\n    // a set of RE's that can match strings and generate color tuples.\n    stringParsers = [ {\n            re: /rgba?\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n            parse: function( execResult ) {\n                return [\n                    execResult[ 1 ],\n                    execResult[ 2 ],\n                    execResult[ 3 ],\n                    execResult[ 4 ]\n                ];\n            }\n        }, {\n            re: /rgba?\\(\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n            parse: function( execResult ) {\n                return [\n                    execResult[ 1 ] * 2.55,\n                    execResult[ 2 ] * 2.55,\n                    execResult[ 3 ] * 2.55,\n                    execResult[ 4 ]\n                ];\n            }\n        }, {\n            // this regex ignores A-F because it's compared against an already lowercased string\n            re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,\n            parse: function( execResult ) {\n                return [\n                    parseInt( execResult[ 1 ], 16 ),\n                    parseInt( execResult[ 2 ], 16 ),\n                    parseInt( execResult[ 3 ], 16 )\n                ];\n            }\n        }, {\n            // this regex ignores A-F because it's compared against an already lowercased string\n            re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,\n            parse: function( execResult ) {\n                return [\n                    parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),\n                    parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),\n                    parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )\n                ];\n            }\n        }, {\n            re: /hsla?\\(\\s*(\\d+(?:\\.\\d+)?)\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*,\\s*(\\d+(?:\\.\\d+)?)\\%\\s*(?:,\\s*(\\d?(?:\\.\\d+)?)\\s*)?\\)/,\n            space: \"hsla\",\n            parse: function( execResult ) {\n                return [\n                    execResult[ 1 ],\n                    execResult[ 2 ] / 100,\n                    execResult[ 3 ] / 100,\n                    execResult[ 4 ]\n                ];\n            }\n        } ],\n\n    // jQuery.Color( )\n    color = jQuery.Color = function( color, green, blue, alpha ) {\n        return new jQuery.Color.fn.parse( color, green, blue, alpha );\n    },\n    spaces = {\n        rgba: {\n            props: {\n                red: {\n                    idx: 0,\n                    type: \"byte\"\n                },\n                green: {\n                    idx: 1,\n                    type: \"byte\"\n                },\n                blue: {\n                    idx: 2,\n                    type: \"byte\"\n                }\n            }\n        },\n\n        hsla: {\n            props: {\n                hue: {\n                    idx: 0,\n                    type: \"degrees\"\n                },\n                saturation: {\n                    idx: 1,\n                    type: \"percent\"\n                },\n                lightness: {\n                    idx: 2,\n                    type: \"percent\"\n                }\n            }\n        }\n    },\n    propTypes = {\n        \"byte\": {\n            floor: true,\n            max: 255\n        },\n        \"percent\": {\n            max: 1\n        },\n        \"degrees\": {\n            mod: 360,\n            floor: true\n        }\n    },\n    support = color.support = {},\n\n    // element for support tests\n    supportElem = jQuery( \"<p>\" )[ 0 ],\n\n    // colors = jQuery.Color.names\n    colors,\n\n    // local aliases of functions called often\n    each = jQuery.each;\n\n// determine rgba support immediately\nsupportElem.style.cssText = \"background-color:rgba(1,1,1,.5)\";\nsupport.rgba = supportElem.style.backgroundColor.indexOf( \"rgba\" ) > -1;\n\n// define cache name and alpha properties\n// for rgba and hsla spaces\neach( spaces, function( spaceName, space ) {\n    space.cache = \"_\" + spaceName;\n    space.props.alpha = {\n        idx: 3,\n        type: \"percent\",\n        def: 1\n    };\n});\n\nfunction clamp( value, prop, allowEmpty ) {\n    var type = propTypes[ prop.type ] || {};\n\n    if ( value == null ) {\n        return (allowEmpty || !prop.def) ? null : prop.def;\n    }\n\n    // ~~ is an short way of doing floor for positive numbers\n    value = type.floor ? ~~value : parseFloat( value );\n\n    // IE will pass in empty strings as value for alpha,\n    // which will hit this case\n    if ( isNaN( value ) ) {\n        return prop.def;\n    }\n\n    if ( type.mod ) {\n        // we add mod before modding to make sure that negatives values\n        // get converted properly: -10 -> 350\n        return (value + type.mod) % type.mod;\n    }\n\n    // for now all property types without mod have min and max\n    return 0 > value ? 0 : type.max < value ? type.max : value;\n}\n\nfunction stringParse( string ) {\n    var inst = color(),\n        rgba = inst._rgba = [];\n\n    string = string.toLowerCase();\n\n    each( stringParsers, function( i, parser ) {\n        var parsed,\n            match = parser.re.exec( string ),\n            values = match && parser.parse( match ),\n            spaceName = parser.space || \"rgba\";\n\n        if ( values ) {\n            parsed = inst[ spaceName ]( values );\n\n            // if this was an rgba parse the assignment might happen twice\n            // oh well....\n            inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];\n            rgba = inst._rgba = parsed._rgba;\n\n            // exit each( stringParsers ) here because we matched\n            return false;\n        }\n    });\n\n    // Found a stringParser that handled it\n    if ( rgba.length ) {\n\n        // if this came from a parsed string, force \"transparent\" when alpha is 0\n        // chrome, (and maybe others) return \"transparent\" as rgba(0,0,0,0)\n        if ( rgba.join() === \"0,0,0,0\" ) {\n            jQuery.extend( rgba, colors.transparent );\n        }\n        return inst;\n    }\n\n    // named colors\n    return colors[ string ];\n}\n\ncolor.fn = jQuery.extend( color.prototype, {\n    parse: function( red, green, blue, alpha ) {\n        if ( red === undefined ) {\n            this._rgba = [ null, null, null, null ];\n            return this;\n        }\n        if ( red.jquery || red.nodeType ) {\n            red = jQuery( red ).css( green );\n            green = undefined;\n        }\n\n        var inst = this,\n            type = jQuery.type( red ),\n            rgba = this._rgba = [];\n\n        // more than 1 argument specified - assume ( red, green, blue, alpha )\n        if ( green !== undefined ) {\n            red = [ red, green, blue, alpha ];\n            type = \"array\";\n        }\n\n        if ( type === \"string\" ) {\n            return this.parse( stringParse( red ) || colors._default );\n        }\n\n        if ( type === \"array\" ) {\n            each( spaces.rgba.props, function( key, prop ) {\n                rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );\n            });\n            return this;\n        }\n\n        if ( type === \"object\" ) {\n            if ( red instanceof color ) {\n                each( spaces, function( spaceName, space ) {\n                    if ( red[ space.cache ] ) {\n                        inst[ space.cache ] = red[ space.cache ].slice();\n                    }\n                });\n            } else {\n                each( spaces, function( spaceName, space ) {\n                    var cache = space.cache;\n                    each( space.props, function( key, prop ) {\n\n                        // if the cache doesn't exist, and we know how to convert\n                        if ( !inst[ cache ] && space.to ) {\n\n                            // if the value was null, we don't need to copy it\n                            // if the key was alpha, we don't need to copy it either\n                            if ( key === \"alpha\" || red[ key ] == null ) {\n                                return;\n                            }\n                            inst[ cache ] = space.to( inst._rgba );\n                        }\n\n                        // this is the only case where we allow nulls for ALL properties.\n                        // call clamp with alwaysAllowEmpty\n                        inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );\n                    });\n\n                    // everything defined but alpha?\n                    if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {\n                        // use the default of 1\n                        inst[ cache ][ 3 ] = 1;\n                        if ( space.from ) {\n                            inst._rgba = space.from( inst[ cache ] );\n                        }\n                    }\n                });\n            }\n            return this;\n        }\n    },\n    is: function( compare ) {\n        var is = color( compare ),\n            same = true,\n            inst = this;\n\n        each( spaces, function( _, space ) {\n            var localCache,\n                isCache = is[ space.cache ];\n            if (isCache) {\n                localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];\n                each( space.props, function( _, prop ) {\n                    if ( isCache[ prop.idx ] != null ) {\n                        same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );\n                        return same;\n                    }\n                });\n            }\n            return same;\n        });\n        return same;\n    },\n    _space: function() {\n        var used = [],\n            inst = this;\n        each( spaces, function( spaceName, space ) {\n            if ( inst[ space.cache ] ) {\n                used.push( spaceName );\n            }\n        });\n        return used.pop();\n    },\n    transition: function( other, distance ) {\n        var end = color( other ),\n            spaceName = end._space(),\n            space = spaces[ spaceName ],\n            startColor = this.alpha() === 0 ? color( \"transparent\" ) : this,\n            start = startColor[ space.cache ] || space.to( startColor._rgba ),\n            result = start.slice();\n\n        end = end[ space.cache ];\n        each( space.props, function( key, prop ) {\n            var index = prop.idx,\n                startValue = start[ index ],\n                endValue = end[ index ],\n                type = propTypes[ prop.type ] || {};\n\n            // if null, don't override start value\n            if ( endValue === null ) {\n                return;\n            }\n            // if null - use end\n            if ( startValue === null ) {\n                result[ index ] = endValue;\n            } else {\n                if ( type.mod ) {\n                    if ( endValue - startValue > type.mod / 2 ) {\n                        startValue += type.mod;\n                    } else if ( startValue - endValue > type.mod / 2 ) {\n                        startValue -= type.mod;\n                    }\n                }\n                result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );\n            }\n        });\n        return this[ spaceName ]( result );\n    },\n    blend: function( opaque ) {\n        // if we are already opaque - return ourself\n        if ( this._rgba[ 3 ] === 1 ) {\n            return this;\n        }\n\n        var rgb = this._rgba.slice(),\n            a = rgb.pop(),\n            blend = color( opaque )._rgba;\n\n        return color( jQuery.map( rgb, function( v, i ) {\n            return ( 1 - a ) * blend[ i ] + a * v;\n        }));\n    },\n    toRgbaString: function() {\n        var prefix = \"rgba(\",\n            rgba = jQuery.map( this._rgba, function( v, i ) {\n                return v == null ? ( i > 2 ? 1 : 0 ) : v;\n            });\n\n        if ( rgba[ 3 ] === 1 ) {\n            rgba.pop();\n            prefix = \"rgb(\";\n        }\n\n        return prefix + rgba.join() + \")\";\n    },\n    toHslaString: function() {\n        var prefix = \"hsla(\",\n            hsla = jQuery.map( this.hsla(), function( v, i ) {\n                if ( v == null ) {\n                    v = i > 2 ? 1 : 0;\n                }\n\n                // catch 1 and 2\n                if ( i && i < 3 ) {\n                    v = Math.round( v * 100 ) + \"%\";\n                }\n                return v;\n            });\n\n        if ( hsla[ 3 ] === 1 ) {\n            hsla.pop();\n            prefix = \"hsl(\";\n        }\n        return prefix + hsla.join() + \")\";\n    },\n    toHexString: function( includeAlpha ) {\n        var rgba = this._rgba.slice(),\n            alpha = rgba.pop();\n\n        if ( includeAlpha ) {\n            rgba.push( ~~( alpha * 255 ) );\n        }\n\n        return \"#\" + jQuery.map( rgba, function( v ) {\n\n            // default to 0 when nulls exist\n            v = ( v || 0 ).toString( 16 );\n            return v.length === 1 ? \"0\" + v : v;\n        }).join(\"\");\n    },\n    toString: function() {\n        return this._rgba[ 3 ] === 0 ? \"transparent\" : this.toRgbaString();\n    }\n});\ncolor.fn.parse.prototype = color.fn;\n\n// hsla conversions adapted from:\n// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021\n\nfunction hue2rgb( p, q, h ) {\n    h = ( h + 1 ) % 1;\n    if ( h * 6 < 1 ) {\n        return p + ( q - p ) * h * 6;\n    }\n    if ( h * 2 < 1) {\n        return q;\n    }\n    if ( h * 3 < 2 ) {\n        return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;\n    }\n    return p;\n}\n\nspaces.hsla.to = function( rgba ) {\n    if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {\n        return [ null, null, null, rgba[ 3 ] ];\n    }\n    var r = rgba[ 0 ] / 255,\n        g = rgba[ 1 ] / 255,\n        b = rgba[ 2 ] / 255,\n        a = rgba[ 3 ],\n        max = Math.max( r, g, b ),\n        min = Math.min( r, g, b ),\n        diff = max - min,\n        add = max + min,\n        l = add * 0.5,\n        h, s;\n\n    if ( min === max ) {\n        h = 0;\n    } else if ( r === max ) {\n        h = ( 60 * ( g - b ) / diff ) + 360;\n    } else if ( g === max ) {\n        h = ( 60 * ( b - r ) / diff ) + 120;\n    } else {\n        h = ( 60 * ( r - g ) / diff ) + 240;\n    }\n\n    // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%\n    // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)\n    if ( diff === 0 ) {\n        s = 0;\n    } else if ( l <= 0.5 ) {\n        s = diff / add;\n    } else {\n        s = diff / ( 2 - add );\n    }\n    return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];\n};\n\nspaces.hsla.from = function( hsla ) {\n    if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {\n        return [ null, null, null, hsla[ 3 ] ];\n    }\n    var h = hsla[ 0 ] / 360,\n        s = hsla[ 1 ],\n        l = hsla[ 2 ],\n        a = hsla[ 3 ],\n        q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,\n        p = 2 * l - q;\n\n    return [\n        Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),\n        Math.round( hue2rgb( p, q, h ) * 255 ),\n        Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),\n        a\n    ];\n};\n\neach( spaces, function( spaceName, space ) {\n    var props = space.props,\n        cache = space.cache,\n        to = space.to,\n        from = space.from;\n\n    // makes rgba() and hsla()\n    color.fn[ spaceName ] = function( value ) {\n\n        // generate a cache for this space if it doesn't exist\n        if ( to && !this[ cache ] ) {\n            this[ cache ] = to( this._rgba );\n        }\n        if ( value === undefined ) {\n            return this[ cache ].slice();\n        }\n\n        var ret,\n            type = jQuery.type( value ),\n            arr = ( type === \"array\" || type === \"object\" ) ? value : arguments,\n            local = this[ cache ].slice();\n\n        each( props, function( key, prop ) {\n            var val = arr[ type === \"object\" ? key : prop.idx ];\n            if ( val == null ) {\n                val = local[ prop.idx ];\n            }\n            local[ prop.idx ] = clamp( val, prop );\n        });\n\n        if ( from ) {\n            ret = color( from( local ) );\n            ret[ cache ] = local;\n            return ret;\n        } else {\n            return color( local );\n        }\n    };\n\n    // makes red() green() blue() alpha() hue() saturation() lightness()\n    each( props, function( key, prop ) {\n        // alpha is included in more than one space\n        if ( color.fn[ key ] ) {\n            return;\n        }\n        color.fn[ key ] = function( value ) {\n            var vtype = jQuery.type( value ),\n                fn = ( key === \"alpha\" ? ( this._hsla ? \"hsla\" : \"rgba\" ) : spaceName ),\n                local = this[ fn ](),\n                cur = local[ prop.idx ],\n                match;\n\n            if ( vtype === \"undefined\" ) {\n                return cur;\n            }\n\n            if ( vtype === \"function\" ) {\n                value = value.call( this, cur );\n                vtype = jQuery.type( value );\n            }\n            if ( value == null && prop.empty ) {\n                return this;\n            }\n            if ( vtype === \"string\" ) {\n                match = rplusequals.exec( value );\n                if ( match ) {\n                    value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === \"+\" ? 1 : -1 );\n                }\n            }\n            local[ prop.idx ] = value;\n            return this[ fn ]( local );\n        };\n    });\n});\n\n// add cssHook and .fx.step function for each named hook.\n// accept a space separated string of properties\ncolor.hook = function( hook ) {\n    var hooks = hook.split( \" \" );\n    each( hooks, function( i, hook ) {\n        jQuery.cssHooks[ hook ] = {\n            set: function( elem, value ) {\n                var parsed, curElem,\n                    backgroundColor = \"\";\n\n                if ( value !== \"transparent\" && ( jQuery.type( value ) !== \"string\" || ( parsed = stringParse( value ) ) ) ) {\n                    value = color( parsed || value );\n                    if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {\n                        curElem = hook === \"backgroundColor\" ? elem.parentNode : elem;\n                        while (\n                            (backgroundColor === \"\" || backgroundColor === \"transparent\") &&\n                            curElem && curElem.style\n                        ) {\n                            try {\n                                backgroundColor = jQuery.css( curElem, \"backgroundColor\" );\n                                curElem = curElem.parentNode;\n                            } catch ( e ) {\n                            }\n                        }\n\n                        value = value.blend( backgroundColor && backgroundColor !== \"transparent\" ?\n                            backgroundColor :\n                            \"_default\" );\n                    }\n\n                    value = value.toRgbaString();\n                }\n                try {\n                    elem.style[ hook ] = value;\n                } catch ( e ) {\n                    // wrapped to prevent IE from throwing errors on \"invalid\" values like 'auto' or 'inherit'\n                }\n            }\n        };\n        jQuery.fx.step[ hook ] = function( fx ) {\n            if ( !fx.colorInit ) {\n                fx.start = color( fx.elem, hook );\n                fx.end = color( fx.end );\n                fx.colorInit = true;\n            }\n            jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );\n        };\n    });\n\n};\n\ncolor.hook( stepHooks );\n\njQuery.cssHooks.borderColor = {\n    expand: function( value ) {\n        var expanded = {};\n\n        each( [ \"Top\", \"Right\", \"Bottom\", \"Left\" ], function( i, part ) {\n            expanded[ \"border\" + part + \"Color\" ] = value;\n        });\n        return expanded;\n    }\n};\n\n// Basic color names only.\n// Usage of any of the other color names requires adding yourself or including\n// jquery.color.svg-names.js.\ncolors = jQuery.Color.names = {\n    // 4.1. Basic color keywords\n    aqua: \"#00ffff\",\n    black: \"#000000\",\n    blue: \"#0000ff\",\n    fuchsia: \"#ff00ff\",\n    gray: \"#808080\",\n    green: \"#008000\",\n    lime: \"#00ff00\",\n    maroon: \"#800000\",\n    navy: \"#000080\",\n    olive: \"#808000\",\n    purple: \"#800080\",\n    red: \"#ff0000\",\n    silver: \"#c0c0c0\",\n    teal: \"#008080\",\n    white: \"#ffffff\",\n    yellow: \"#ffff00\",\n\n    // 4.2.3. \"transparent\" color keyword\n    transparent: [ null, null, null, 0 ],\n\n    _default: \"#ffffff\"\n};\n\n})( jQuery );\n\n/******************************************************************************/\n/****************************** CLASS ANIMATIONS ******************************/\n/******************************************************************************/\n(function() {\n\nvar classAnimationActions = [ \"add\", \"remove\", \"toggle\" ],\n    shorthandStyles = {\n        border: 1,\n        borderBottom: 1,\n        borderColor: 1,\n        borderLeft: 1,\n        borderRight: 1,\n        borderTop: 1,\n        borderWidth: 1,\n        margin: 1,\n        padding: 1\n    };\n\n$.each([ \"borderLeftStyle\", \"borderRightStyle\", \"borderBottomStyle\", \"borderTopStyle\" ], function( _, prop ) {\n    $.fx.step[ prop ] = function( fx ) {\n        if ( fx.end !== \"none\" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {\n            jQuery.style( fx.elem, prop, fx.end );\n            fx.setAttr = true;\n        }\n    };\n});\n\nfunction getElementStyles( elem ) {\n    var key, len,\n        style = elem.ownerDocument.defaultView ?\n            elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :\n            elem.currentStyle,\n        styles = {};\n\n    if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {\n        len = style.length;\n        while ( len-- ) {\n            key = style[ len ];\n            if ( typeof style[ key ] === \"string\" ) {\n                styles[ $.camelCase( key ) ] = style[ key ];\n            }\n        }\n    // support: Opera, IE <9\n    } else {\n        for ( key in style ) {\n            if ( typeof style[ key ] === \"string\" ) {\n                styles[ key ] = style[ key ];\n            }\n        }\n    }\n\n    return styles;\n}\n\nfunction styleDifference( oldStyle, newStyle ) {\n    var diff = {},\n        name, value;\n\n    for ( name in newStyle ) {\n        value = newStyle[ name ];\n        if ( oldStyle[ name ] !== value ) {\n            if ( !shorthandStyles[ name ] ) {\n                if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {\n                    diff[ name ] = value;\n                }\n            }\n        }\n    }\n\n    return diff;\n}\n\n// support: jQuery <1.8\nif ( !$.fn.addBack ) {\n    $.fn.addBack = function( selector ) {\n        return this.add( selector == null ?\n            this.prevObject : this.prevObject.filter( selector )\n        );\n    };\n}\n\n$.effects.animateClass = function( value, duration, easing, callback ) {\n    var o = $.speed( duration, easing, callback );\n\n    return this.queue( function() {\n        var animated = $( this ),\n            baseClass = animated.attr( \"class\" ) || \"\",\n            applyClassChange,\n            allAnimations = o.children ? animated.find( \"*\" ).addBack() : animated;\n\n        // map the animated objects to store the original styles.\n        allAnimations = allAnimations.map(function() {\n            var el = $( this );\n            return {\n                el: el,\n                start: getElementStyles( this )\n            };\n        });\n\n        // apply class change\n        applyClassChange = function() {\n            $.each( classAnimationActions, function(i, action) {\n                if ( value[ action ] ) {\n                    animated[ action + \"Class\" ]( value[ action ] );\n                }\n            });\n        };\n        applyClassChange();\n\n        // map all animated objects again - calculate new styles and diff\n        allAnimations = allAnimations.map(function() {\n            this.end = getElementStyles( this.el[ 0 ] );\n            this.diff = styleDifference( this.start, this.end );\n            return this;\n        });\n\n        // apply original class\n        animated.attr( \"class\", baseClass );\n\n        // map all animated objects again - this time collecting a promise\n        allAnimations = allAnimations.map(function() {\n            var styleInfo = this,\n                dfd = $.Deferred(),\n                opts = $.extend({}, o, {\n                    queue: false,\n                    complete: function() {\n                        dfd.resolve( styleInfo );\n                    }\n                });\n\n            this.el.animate( this.diff, opts );\n            return dfd.promise();\n        });\n\n        // once all animations have completed:\n        $.when.apply( $, allAnimations.get() ).done(function() {\n\n            // set the final class\n            applyClassChange();\n\n            // for each animated element,\n            // clear all css properties that were animated\n            $.each( arguments, function() {\n                var el = this.el;\n                $.each( this.diff, function(key) {\n                    el.css( key, \"\" );\n                });\n            });\n\n            // this is guarnteed to be there if you use jQuery.speed()\n            // it also handles dequeuing the next anim...\n            o.complete.call( animated[ 0 ] );\n        });\n    });\n};\n\n$.fn.extend({\n    addClass: (function( orig ) {\n        return function( classNames, speed, easing, callback ) {\n            return speed ?\n                $.effects.animateClass.call( this,\n                    { add: classNames }, speed, easing, callback ) :\n                orig.apply( this, arguments );\n        };\n    })( $.fn.addClass ),\n\n    removeClass: (function( orig ) {\n        return function( classNames, speed, easing, callback ) {\n            return arguments.length > 1 ?\n                $.effects.animateClass.call( this,\n                    { remove: classNames }, speed, easing, callback ) :\n                orig.apply( this, arguments );\n        };\n    })( $.fn.removeClass ),\n\n    toggleClass: (function( orig ) {\n        return function( classNames, force, speed, easing, callback ) {\n            if ( typeof force === \"boolean\" || force === undefined ) {\n                if ( !speed ) {\n                    // without speed parameter\n                    return orig.apply( this, arguments );\n                } else {\n                    return $.effects.animateClass.call( this,\n                        (force ? { add: classNames } : { remove: classNames }),\n                        speed, easing, callback );\n                }\n            } else {\n                // without force parameter\n                return $.effects.animateClass.call( this,\n                    { toggle: classNames }, force, speed, easing );\n            }\n        };\n    })( $.fn.toggleClass ),\n\n    switchClass: function( remove, add, speed, easing, callback) {\n        return $.effects.animateClass.call( this, {\n            add: add,\n            remove: remove\n        }, speed, easing, callback );\n    }\n});\n\n})();\n\n/******************************************************************************/\n/*********************************** EFFECTS **********************************/\n/******************************************************************************/\n\n(function() {\n\n$.extend( $.effects, {\n    version: \"1.11.2\",\n\n    // Saves a set of properties in a data storage\n    save: function( element, set ) {\n        for ( var i = 0; i < set.length; i++ ) {\n            if ( set[ i ] !== null ) {\n                element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );\n            }\n        }\n    },\n\n    // Restores a set of previously saved properties from a data storage\n    restore: function( element, set ) {\n        var val, i;\n        for ( i = 0; i < set.length; i++ ) {\n            if ( set[ i ] !== null ) {\n                val = element.data( dataSpace + set[ i ] );\n                // support: jQuery 1.6.2\n                // http://bugs.jquery.com/ticket/9917\n                // jQuery 1.6.2 incorrectly returns undefined for any falsy value.\n                // We can't differentiate between \"\" and 0 here, so we just assume\n                // empty string since it's likely to be a more common value...\n                if ( val === undefined ) {\n                    val = \"\";\n                }\n                element.css( set[ i ], val );\n            }\n        }\n    },\n\n    setMode: function( el, mode ) {\n        if (mode === \"toggle\") {\n            mode = el.is( \":hidden\" ) ? \"show\" : \"hide\";\n        }\n        return mode;\n    },\n\n    // Translates a [top,left] array into a baseline value\n    // this should be a little more flexible in the future to handle a string & hash\n    getBaseline: function( origin, original ) {\n        var y, x;\n        switch ( origin[ 0 ] ) {\n            case \"top\": y = 0; break;\n            case \"middle\": y = 0.5; break;\n            case \"bottom\": y = 1; break;\n            default: y = origin[ 0 ] / original.height;\n        }\n        switch ( origin[ 1 ] ) {\n            case \"left\": x = 0; break;\n            case \"center\": x = 0.5; break;\n            case \"right\": x = 1; break;\n            default: x = origin[ 1 ] / original.width;\n        }\n        return {\n            x: x,\n            y: y\n        };\n    },\n\n    // Wraps the element around a wrapper that copies position properties\n    createWrapper: function( element ) {\n\n        // if the element is already wrapped, return it\n        if ( element.parent().is( \".ui-effects-wrapper\" )) {\n            return element.parent();\n        }\n\n        // wrap the element\n        var props = {\n                width: element.outerWidth(true),\n                height: element.outerHeight(true),\n                \"float\": element.css( \"float\" )\n            },\n            wrapper = $( \"<div></div>\" )\n                .addClass( \"ui-effects-wrapper\" )\n                .css({\n                    fontSize: \"100%\",\n                    background: \"transparent\",\n                    border: \"none\",\n                    margin: 0,\n                    padding: 0\n                }),\n            // Store the size in case width/height are defined in % - Fixes #5245\n            size = {\n                width: element.width(),\n                height: element.height()\n            },\n            active = document.activeElement;\n\n        // support: Firefox\n        // Firefox incorrectly exposes anonymous content\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=561664\n        try {\n            active.id;\n        } catch ( e ) {\n            active = document.body;\n        }\n\n        element.wrap( wrapper );\n\n        // Fixes #7595 - Elements lose focus when wrapped.\n        if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {\n            $( active ).focus();\n        }\n\n        wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element\n\n        // transfer positioning properties to the wrapper\n        if ( element.css( \"position\" ) === \"static\" ) {\n            wrapper.css({ position: \"relative\" });\n            element.css({ position: \"relative\" });\n        } else {\n            $.extend( props, {\n                position: element.css( \"position\" ),\n                zIndex: element.css( \"z-index\" )\n            });\n            $.each([ \"top\", \"left\", \"bottom\", \"right\" ], function(i, pos) {\n                props[ pos ] = element.css( pos );\n                if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {\n                    props[ pos ] = \"auto\";\n                }\n            });\n            element.css({\n                position: \"relative\",\n                top: 0,\n                left: 0,\n                right: \"auto\",\n                bottom: \"auto\"\n            });\n        }\n        element.css(size);\n\n        return wrapper.css( props ).show();\n    },\n\n    removeWrapper: function( element ) {\n        var active = document.activeElement;\n\n        if ( element.parent().is( \".ui-effects-wrapper\" ) ) {\n            element.parent().replaceWith( element );\n\n            // Fixes #7595 - Elements lose focus when wrapped.\n            if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {\n                $( active ).focus();\n            }\n        }\n\n        return element;\n    },\n\n    setTransition: function( element, list, factor, value ) {\n        value = value || {};\n        $.each( list, function( i, x ) {\n            var unit = element.cssUnit( x );\n            if ( unit[ 0 ] > 0 ) {\n                value[ x ] = unit[ 0 ] * factor + unit[ 1 ];\n            }\n        });\n        return value;\n    }\n});\n\n// return an effect options object for the given parameters:\nfunction _normalizeArguments( effect, options, speed, callback ) {\n\n    // allow passing all options as the first parameter\n    if ( $.isPlainObject( effect ) ) {\n        options = effect;\n        effect = effect.effect;\n    }\n\n    // convert to an object\n    effect = { effect: effect };\n\n    // catch (effect, null, ...)\n    if ( options == null ) {\n        options = {};\n    }\n\n    // catch (effect, callback)\n    if ( $.isFunction( options ) ) {\n        callback = options;\n        speed = null;\n        options = {};\n    }\n\n    // catch (effect, speed, ?)\n    if ( typeof options === \"number\" || $.fx.speeds[ options ] ) {\n        callback = speed;\n        speed = options;\n        options = {};\n    }\n\n    // catch (effect, options, callback)\n    if ( $.isFunction( speed ) ) {\n        callback = speed;\n        speed = null;\n    }\n\n    // add options to effect\n    if ( options ) {\n        $.extend( effect, options );\n    }\n\n    speed = speed || options.duration;\n    effect.duration = $.fx.off ? 0 :\n        typeof speed === \"number\" ? speed :\n        speed in $.fx.speeds ? $.fx.speeds[ speed ] :\n        $.fx.speeds._default;\n\n    effect.complete = callback || options.complete;\n\n    return effect;\n}\n\nfunction standardAnimationOption( option ) {\n    // Valid standard speeds (nothing, number, named speed)\n    if ( !option || typeof option === \"number\" || $.fx.speeds[ option ] ) {\n        return true;\n    }\n\n    // Invalid strings - treat as \"normal\" speed\n    if ( typeof option === \"string\" && !$.effects.effect[ option ] ) {\n        return true;\n    }\n\n    // Complete callback\n    if ( $.isFunction( option ) ) {\n        return true;\n    }\n\n    // Options hash (but not naming an effect)\n    if ( typeof option === \"object\" && !option.effect ) {\n        return true;\n    }\n\n    // Didn't match any standard API\n    return false;\n}\n\n$.fn.extend({\n    effect: function( /* effect, options, speed, callback */ ) {\n        var args = _normalizeArguments.apply( this, arguments ),\n            mode = args.mode,\n            queue = args.queue,\n            effectMethod = $.effects.effect[ args.effect ];\n\n        if ( $.fx.off || !effectMethod ) {\n            // delegate to the original method (e.g., .show()) if possible\n            if ( mode ) {\n                return this[ mode ]( args.duration, args.complete );\n            } else {\n                return this.each( function() {\n                    if ( args.complete ) {\n                        args.complete.call( this );\n                    }\n                });\n            }\n        }\n\n        function run( next ) {\n            var elem = $( this ),\n                complete = args.complete,\n                mode = args.mode;\n\n            function done() {\n                if ( $.isFunction( complete ) ) {\n                    complete.call( elem[0] );\n                }\n                if ( $.isFunction( next ) ) {\n                    next();\n                }\n            }\n\n            // If the element already has the correct final state, delegate to\n            // the core methods so the internal tracking of \"olddisplay\" works.\n            if ( elem.is( \":hidden\" ) ? mode === \"hide\" : mode === \"show\" ) {\n                elem[ mode ]();\n                done();\n            } else {\n                effectMethod.call( elem[0], args, done );\n            }\n        }\n\n        return queue === false ? this.each( run ) : this.queue( queue || \"fx\", run );\n    },\n\n    show: (function( orig ) {\n        return function( option ) {\n            if ( standardAnimationOption( option ) ) {\n                return orig.apply( this, arguments );\n            } else {\n                var args = _normalizeArguments.apply( this, arguments );\n                args.mode = \"show\";\n                return this.effect.call( this, args );\n            }\n        };\n    })( $.fn.show ),\n\n    hide: (function( orig ) {\n        return function( option ) {\n            if ( standardAnimationOption( option ) ) {\n                return orig.apply( this, arguments );\n            } else {\n                var args = _normalizeArguments.apply( this, arguments );\n                args.mode = \"hide\";\n                return this.effect.call( this, args );\n            }\n        };\n    })( $.fn.hide ),\n\n    toggle: (function( orig ) {\n        return function( option ) {\n            if ( standardAnimationOption( option ) || typeof option === \"boolean\" ) {\n                return orig.apply( this, arguments );\n            } else {\n                var args = _normalizeArguments.apply( this, arguments );\n                args.mode = \"toggle\";\n                return this.effect.call( this, args );\n            }\n        };\n    })( $.fn.toggle ),\n\n    // helper functions\n    cssUnit: function(key) {\n        var style = this.css( key ),\n            val = [];\n\n        $.each( [ \"em\", \"px\", \"%\", \"pt\" ], function( i, unit ) {\n            if ( style.indexOf( unit ) > 0 ) {\n                val = [ parseFloat( style ), unit ];\n            }\n        });\n        return val;\n    }\n});\n\n})();\n\n/******************************************************************************/\n/*********************************** EASING ***********************************/\n/******************************************************************************/\n\n(function() {\n\n// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)\n\nvar baseEasings = {};\n\n$.each( [ \"Quad\", \"Cubic\", \"Quart\", \"Quint\", \"Expo\" ], function( i, name ) {\n    baseEasings[ name ] = function( p ) {\n        return Math.pow( p, i + 2 );\n    };\n});\n\n$.extend( baseEasings, {\n    Sine: function( p ) {\n        return 1 - Math.cos( p * Math.PI / 2 );\n    },\n    Circ: function( p ) {\n        return 1 - Math.sqrt( 1 - p * p );\n    },\n    Elastic: function( p ) {\n        return p === 0 || p === 1 ? p :\n            -Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );\n    },\n    Back: function( p ) {\n        return p * p * ( 3 * p - 2 );\n    },\n    Bounce: function( p ) {\n        var pow2,\n            bounce = 4;\n\n        while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}\n        return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );\n    }\n});\n\n$.each( baseEasings, function( name, easeIn ) {\n    $.easing[ \"easeIn\" + name ] = easeIn;\n    $.easing[ \"easeOut\" + name ] = function( p ) {\n        return 1 - easeIn( 1 - p );\n    };\n    $.easing[ \"easeInOut\" + name ] = function( p ) {\n        return p < 0.5 ?\n            easeIn( p * 2 ) / 2 :\n            1 - easeIn( p * -2 + 2 ) / 2;\n    };\n});\n\n})();\n\nvar effect = $.effects;\n\n\n/*!\n * jQuery UI Effects Blind 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/blind-effect/\n */\n\n\nvar effectBlind = $.effects.effect.blind = function( o, done ) {\n    // Create element\n    var el = $( this ),\n        rvertical = /up|down|vertical/,\n        rpositivemotion = /up|left|vertical|horizontal/,\n        props = [ \"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\" ],\n        mode = $.effects.setMode( el, o.mode || \"hide\" ),\n        direction = o.direction || \"up\",\n        vertical = rvertical.test( direction ),\n        ref = vertical ? \"height\" : \"width\",\n        ref2 = vertical ? \"top\" : \"left\",\n        motion = rpositivemotion.test( direction ),\n        animation = {},\n        show = mode === \"show\",\n        wrapper, distance, margin;\n\n    // if already wrapped, the wrapper's properties are my property. #6245\n    if ( el.parent().is( \".ui-effects-wrapper\" ) ) {\n        $.effects.save( el.parent(), props );\n    } else {\n        $.effects.save( el, props );\n    }\n    el.show();\n    wrapper = $.effects.createWrapper( el ).css({\n        overflow: \"hidden\"\n    });\n\n    distance = wrapper[ ref ]();\n    margin = parseFloat( wrapper.css( ref2 ) ) || 0;\n\n    animation[ ref ] = show ? distance : 0;\n    if ( !motion ) {\n        el\n            .css( vertical ? \"bottom\" : \"right\", 0 )\n            .css( vertical ? \"top\" : \"left\", \"auto\" )\n            .css({ position: \"absolute\" });\n\n        animation[ ref2 ] = show ? margin : distance + margin;\n    }\n\n    // start at 0 if we are showing\n    if ( show ) {\n        wrapper.css( ref, 0 );\n        if ( !motion ) {\n            wrapper.css( ref2, margin + distance );\n        }\n    }\n\n    // Animate\n    wrapper.animate( animation, {\n        duration: o.duration,\n        easing: o.easing,\n        queue: false,\n        complete: function() {\n            if ( mode === \"hide\" ) {\n                el.hide();\n            }\n            $.effects.restore( el, props );\n            $.effects.removeWrapper( el );\n            done();\n        }\n    });\n};\n\n\n/*!\n * jQuery UI Effects Bounce 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/bounce-effect/\n */\n\n\nvar effectBounce = $.effects.effect.bounce = function( o, done ) {\n    var el = $( this ),\n        props = [ \"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\" ],\n\n        // defaults:\n        mode = $.effects.setMode( el, o.mode || \"effect\" ),\n        hide = mode === \"hide\",\n        show = mode === \"show\",\n        direction = o.direction || \"up\",\n        distance = o.distance,\n        times = o.times || 5,\n\n        // number of internal animations\n        anims = times * 2 + ( show || hide ? 1 : 0 ),\n        speed = o.duration / anims,\n        easing = o.easing,\n\n        // utility:\n        ref = ( direction === \"up\" || direction === \"down\" ) ? \"top\" : \"left\",\n        motion = ( direction === \"up\" || direction === \"left\" ),\n        i,\n        upAnim,\n        downAnim,\n\n        // we will need to re-assemble the queue to stack our animations in place\n        queue = el.queue(),\n        queuelen = queue.length;\n\n    // Avoid touching opacity to prevent clearType and PNG issues in IE\n    if ( show || hide ) {\n        props.push( \"opacity\" );\n    }\n\n    $.effects.save( el, props );\n    el.show();\n    $.effects.createWrapper( el ); // Create Wrapper\n\n    // default distance for the BIGGEST bounce is the outer Distance / 3\n    if ( !distance ) {\n        distance = el[ ref === \"top\" ? \"outerHeight\" : \"outerWidth\" ]() / 3;\n    }\n\n    if ( show ) {\n        downAnim = { opacity: 1 };\n        downAnim[ ref ] = 0;\n\n        // if we are showing, force opacity 0 and set the initial position\n        // then do the \"first\" animation\n        el.css( \"opacity\", 0 )\n            .css( ref, motion ? -distance * 2 : distance * 2 )\n            .animate( downAnim, speed, easing );\n    }\n\n    // start at the smallest distance if we are hiding\n    if ( hide ) {\n        distance = distance / Math.pow( 2, times - 1 );\n    }\n\n    downAnim = {};\n    downAnim[ ref ] = 0;\n    // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here\n    for ( i = 0; i < times; i++ ) {\n        upAnim = {};\n        upAnim[ ref ] = ( motion ? \"-=\" : \"+=\" ) + distance;\n\n        el.animate( upAnim, speed, easing )\n            .animate( downAnim, speed, easing );\n\n        distance = hide ? distance * 2 : distance / 2;\n    }\n\n    // Last Bounce when Hiding\n    if ( hide ) {\n        upAnim = { opacity: 0 };\n        upAnim[ ref ] = ( motion ? \"-=\" : \"+=\" ) + distance;\n\n        el.animate( upAnim, speed, easing );\n    }\n\n    el.queue(function() {\n        if ( hide ) {\n            el.hide();\n        }\n        $.effects.restore( el, props );\n        $.effects.removeWrapper( el );\n        done();\n    });\n\n    // inject all the animations we just queued to be first in line (after \"inprogress\")\n    if ( queuelen > 1) {\n        queue.splice.apply( queue,\n            [ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );\n    }\n    el.dequeue();\n\n};\n\n\n/*!\n * jQuery UI Effects Clip 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/clip-effect/\n */\n\n\nvar effectClip = $.effects.effect.clip = function( o, done ) {\n    // Create element\n    var el = $( this ),\n        props = [ \"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\" ],\n        mode = $.effects.setMode( el, o.mode || \"hide\" ),\n        show = mode === \"show\",\n        direction = o.direction || \"vertical\",\n        vert = direction === \"vertical\",\n        size = vert ? \"height\" : \"width\",\n        position = vert ? \"top\" : \"left\",\n        animation = {},\n        wrapper, animate, distance;\n\n    // Save & Show\n    $.effects.save( el, props );\n    el.show();\n\n    // Create Wrapper\n    wrapper = $.effects.createWrapper( el ).css({\n        overflow: \"hidden\"\n    });\n    animate = ( el[0].tagName === \"IMG\" ) ? wrapper : el;\n    distance = animate[ size ]();\n\n    // Shift\n    if ( show ) {\n        animate.css( size, 0 );\n        animate.css( position, distance / 2 );\n    }\n\n    // Create Animation Object:\n    animation[ size ] = show ? distance : 0;\n    animation[ position ] = show ? 0 : distance / 2;\n\n    // Animate\n    animate.animate( animation, {\n        queue: false,\n        duration: o.duration,\n        easing: o.easing,\n        complete: function() {\n            if ( !show ) {\n                el.hide();\n            }\n            $.effects.restore( el, props );\n            $.effects.removeWrapper( el );\n            done();\n        }\n    });\n\n};\n\n\n/*!\n * jQuery UI Effects Drop 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/drop-effect/\n */\n\n\nvar effectDrop = $.effects.effect.drop = function( o, done ) {\n\n    var el = $( this ),\n        props = [ \"position\", \"top\", \"bottom\", \"left\", \"right\", \"opacity\", \"height\", \"width\" ],\n        mode = $.effects.setMode( el, o.mode || \"hide\" ),\n        show = mode === \"show\",\n        direction = o.direction || \"left\",\n        ref = ( direction === \"up\" || direction === \"down\" ) ? \"top\" : \"left\",\n        motion = ( direction === \"up\" || direction === \"left\" ) ? \"pos\" : \"neg\",\n        animation = {\n            opacity: show ? 1 : 0\n        },\n        distance;\n\n    // Adjust\n    $.effects.save( el, props );\n    el.show();\n    $.effects.createWrapper( el );\n\n    distance = o.distance || el[ ref === \"top\" ? \"outerHeight\" : \"outerWidth\" ]( true ) / 2;\n\n    if ( show ) {\n        el\n            .css( \"opacity\", 0 )\n            .css( ref, motion === \"pos\" ? -distance : distance );\n    }\n\n    // Animation\n    animation[ ref ] = ( show ?\n        ( motion === \"pos\" ? \"+=\" : \"-=\" ) :\n        ( motion === \"pos\" ? \"-=\" : \"+=\" ) ) +\n        distance;\n\n    // Animate\n    el.animate( animation, {\n        queue: false,\n        duration: o.duration,\n        easing: o.easing,\n        complete: function() {\n            if ( mode === \"hide\" ) {\n                el.hide();\n            }\n            $.effects.restore( el, props );\n            $.effects.removeWrapper( el );\n            done();\n        }\n    });\n};\n\n\n/*!\n * jQuery UI Effects Explode 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/explode-effect/\n */\n\n\nvar effectExplode = $.effects.effect.explode = function( o, done ) {\n\n    var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,\n        cells = rows,\n        el = $( this ),\n        mode = $.effects.setMode( el, o.mode || \"hide\" ),\n        show = mode === \"show\",\n\n        // show and then visibility:hidden the element before calculating offset\n        offset = el.show().css( \"visibility\", \"hidden\" ).offset(),\n\n        // width and height of a piece\n        width = Math.ceil( el.outerWidth() / cells ),\n        height = Math.ceil( el.outerHeight() / rows ),\n        pieces = [],\n\n        // loop\n        i, j, left, top, mx, my;\n\n    // children animate complete:\n    function childComplete() {\n        pieces.push( this );\n        if ( pieces.length === rows * cells ) {\n            animComplete();\n        }\n    }\n\n    // clone the element for each row and cell.\n    for ( i = 0; i < rows ; i++ ) { // ===>\n        top = offset.top + i * height;\n        my = i - ( rows - 1 ) / 2 ;\n\n        for ( j = 0; j < cells ; j++ ) { // |||\n            left = offset.left + j * width;\n            mx = j - ( cells - 1 ) / 2 ;\n\n            // Create a clone of the now hidden main element that will be absolute positioned\n            // within a wrapper div off the -left and -top equal to size of our pieces\n            el\n                .clone()\n                .appendTo( \"body\" )\n                .wrap( \"<div></div>\" )\n                .css({\n                    position: \"absolute\",\n                    visibility: \"visible\",\n                    left: -j * width,\n                    top: -i * height\n                })\n\n            // select the wrapper - make it overflow: hidden and absolute positioned based on\n            // where the original was located +left and +top equal to the size of pieces\n                .parent()\n                .addClass( \"ui-effects-explode\" )\n                .css({\n                    position: \"absolute\",\n                    overflow: \"hidden\",\n                    width: width,\n                    height: height,\n                    left: left + ( show ? mx * width : 0 ),\n                    top: top + ( show ? my * height : 0 ),\n                    opacity: show ? 0 : 1\n                }).animate({\n                    left: left + ( show ? 0 : mx * width ),\n                    top: top + ( show ? 0 : my * height ),\n                    opacity: show ? 1 : 0\n                }, o.duration || 500, o.easing, childComplete );\n        }\n    }\n\n    function animComplete() {\n        el.css({\n            visibility: \"visible\"\n        });\n        $( pieces ).remove();\n        if ( !show ) {\n            el.hide();\n        }\n        done();\n    }\n};\n\n\n/*!\n * jQuery UI Effects Fade 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/fade-effect/\n */\n\n\nvar effectFade = $.effects.effect.fade = function( o, done ) {\n    var el = $( this ),\n        mode = $.effects.setMode( el, o.mode || \"toggle\" );\n\n    el.animate({\n        opacity: mode\n    }, {\n        queue: false,\n        duration: o.duration,\n        easing: o.easing,\n        complete: done\n    });\n};\n\n\n/*!\n * jQuery UI Effects Fold 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/fold-effect/\n */\n\n\nvar effectFold = $.effects.effect.fold = function( o, done ) {\n\n    // Create element\n    var el = $( this ),\n        props = [ \"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\" ],\n        mode = $.effects.setMode( el, o.mode || \"hide\" ),\n        show = mode === \"show\",\n        hide = mode === \"hide\",\n        size = o.size || 15,\n        percent = /([0-9]+)%/.exec( size ),\n        horizFirst = !!o.horizFirst,\n        widthFirst = show !== horizFirst,\n        ref = widthFirst ? [ \"width\", \"height\" ] : [ \"height\", \"width\" ],\n        duration = o.duration / 2,\n        wrapper, distance,\n        animation1 = {},\n        animation2 = {};\n\n    $.effects.save( el, props );\n    el.show();\n\n    // Create Wrapper\n    wrapper = $.effects.createWrapper( el ).css({\n        overflow: \"hidden\"\n    });\n    distance = widthFirst ?\n        [ wrapper.width(), wrapper.height() ] :\n        [ wrapper.height(), wrapper.width() ];\n\n    if ( percent ) {\n        size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];\n    }\n    if ( show ) {\n        wrapper.css( horizFirst ? {\n            height: 0,\n            width: size\n        } : {\n            height: size,\n            width: 0\n        });\n    }\n\n    // Animation\n    animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;\n    animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;\n\n    // Animate\n    wrapper\n        .animate( animation1, duration, o.easing )\n        .animate( animation2, duration, o.easing, function() {\n            if ( hide ) {\n                el.hide();\n            }\n            $.effects.restore( el, props );\n            $.effects.removeWrapper( el );\n            done();\n        });\n\n};\n\n\n/*!\n * jQuery UI Effects Highlight 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/highlight-effect/\n */\n\n\nvar effectHighlight = $.effects.effect.highlight = function( o, done ) {\n    var elem = $( this ),\n        props = [ \"backgroundImage\", \"backgroundColor\", \"opacity\" ],\n        mode = $.effects.setMode( elem, o.mode || \"show\" ),\n        animation = {\n            backgroundColor: elem.css( \"backgroundColor\" )\n        };\n\n    if (mode === \"hide\") {\n        animation.opacity = 0;\n    }\n\n    $.effects.save( elem, props );\n\n    elem\n        .show()\n        .css({\n            backgroundImage: \"none\",\n            backgroundColor: o.color || \"#ffff99\"\n        })\n        .animate( animation, {\n            queue: false,\n            duration: o.duration,\n            easing: o.easing,\n            complete: function() {\n                if ( mode === \"hide\" ) {\n                    elem.hide();\n                }\n                $.effects.restore( elem, props );\n                done();\n            }\n        });\n};\n\n\n/*!\n * jQuery UI Effects Size 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/size-effect/\n */\n\n\nvar effectSize = $.effects.effect.size = function( o, done ) {\n\n    // Create element\n    var original, baseline, factor,\n        el = $( this ),\n        props0 = [ \"position\", \"top\", \"bottom\", \"left\", \"right\", \"width\", \"height\", \"overflow\", \"opacity\" ],\n\n        // Always restore\n        props1 = [ \"position\", \"top\", \"bottom\", \"left\", \"right\", \"overflow\", \"opacity\" ],\n\n        // Copy for children\n        props2 = [ \"width\", \"height\", \"overflow\" ],\n        cProps = [ \"fontSize\" ],\n        vProps = [ \"borderTopWidth\", \"borderBottomWidth\", \"paddingTop\", \"paddingBottom\" ],\n        hProps = [ \"borderLeftWidth\", \"borderRightWidth\", \"paddingLeft\", \"paddingRight\" ],\n\n        // Set options\n        mode = $.effects.setMode( el, o.mode || \"effect\" ),\n        restore = o.restore || mode !== \"effect\",\n        scale = o.scale || \"both\",\n        origin = o.origin || [ \"middle\", \"center\" ],\n        position = el.css( \"position\" ),\n        props = restore ? props0 : props1,\n        zero = {\n            height: 0,\n            width: 0,\n            outerHeight: 0,\n            outerWidth: 0\n        };\n\n    if ( mode === \"show\" ) {\n        el.show();\n    }\n    original = {\n        height: el.height(),\n        width: el.width(),\n        outerHeight: el.outerHeight(),\n        outerWidth: el.outerWidth()\n    };\n\n    if ( o.mode === \"toggle\" && mode === \"show\" ) {\n        el.from = o.to || zero;\n        el.to = o.from || original;\n    } else {\n        el.from = o.from || ( mode === \"show\" ? zero : original );\n        el.to = o.to || ( mode === \"hide\" ? zero : original );\n    }\n\n    // Set scaling factor\n    factor = {\n        from: {\n            y: el.from.height / original.height,\n            x: el.from.width / original.width\n        },\n        to: {\n            y: el.to.height / original.height,\n            x: el.to.width / original.width\n        }\n    };\n\n    // Scale the css box\n    if ( scale === \"box\" || scale === \"both\" ) {\n\n        // Vertical props scaling\n        if ( factor.from.y !== factor.to.y ) {\n            props = props.concat( vProps );\n            el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );\n            el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );\n        }\n\n        // Horizontal props scaling\n        if ( factor.from.x !== factor.to.x ) {\n            props = props.concat( hProps );\n            el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );\n            el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );\n        }\n    }\n\n    // Scale the content\n    if ( scale === \"content\" || scale === \"both\" ) {\n\n        // Vertical props scaling\n        if ( factor.from.y !== factor.to.y ) {\n            props = props.concat( cProps ).concat( props2 );\n            el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );\n            el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );\n        }\n    }\n\n    $.effects.save( el, props );\n    el.show();\n    $.effects.createWrapper( el );\n    el.css( \"overflow\", \"hidden\" ).css( el.from );\n\n    // Adjust\n    if (origin) { // Calculate baseline shifts\n        baseline = $.effects.getBaseline( origin, original );\n        el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;\n        el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;\n        el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;\n        el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;\n    }\n    el.css( el.from ); // set top & left\n\n    // Animate\n    if ( scale === \"content\" || scale === \"both\" ) { // Scale the children\n\n        // Add margins/font-size\n        vProps = vProps.concat([ \"marginTop\", \"marginBottom\" ]).concat(cProps);\n        hProps = hProps.concat([ \"marginLeft\", \"marginRight\" ]);\n        props2 = props0.concat(vProps).concat(hProps);\n\n        el.find( \"*[width]\" ).each( function() {\n            var child = $( this ),\n                c_original = {\n                    height: child.height(),\n                    width: child.width(),\n                    outerHeight: child.outerHeight(),\n                    outerWidth: child.outerWidth()\n                };\n            if (restore) {\n                $.effects.save(child, props2);\n            }\n\n            child.from = {\n                height: c_original.height * factor.from.y,\n                width: c_original.width * factor.from.x,\n                outerHeight: c_original.outerHeight * factor.from.y,\n                outerWidth: c_original.outerWidth * factor.from.x\n            };\n            child.to = {\n                height: c_original.height * factor.to.y,\n                width: c_original.width * factor.to.x,\n                outerHeight: c_original.height * factor.to.y,\n                outerWidth: c_original.width * factor.to.x\n            };\n\n            // Vertical props scaling\n            if ( factor.from.y !== factor.to.y ) {\n                child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );\n                child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );\n            }\n\n            // Horizontal props scaling\n            if ( factor.from.x !== factor.to.x ) {\n                child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );\n                child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );\n            }\n\n            // Animate children\n            child.css( child.from );\n            child.animate( child.to, o.duration, o.easing, function() {\n\n                // Restore children\n                if ( restore ) {\n                    $.effects.restore( child, props2 );\n                }\n            });\n        });\n    }\n\n    // Animate\n    el.animate( el.to, {\n        queue: false,\n        duration: o.duration,\n        easing: o.easing,\n        complete: function() {\n            if ( el.to.opacity === 0 ) {\n                el.css( \"opacity\", el.from.opacity );\n            }\n            if ( mode === \"hide\" ) {\n                el.hide();\n            }\n            $.effects.restore( el, props );\n            if ( !restore ) {\n\n                // we need to calculate our new positioning based on the scaling\n                if ( position === \"static\" ) {\n                    el.css({\n                        position: \"relative\",\n                        top: el.to.top,\n                        left: el.to.left\n                    });\n                } else {\n                    $.each([ \"top\", \"left\" ], function( idx, pos ) {\n                        el.css( pos, function( _, str ) {\n                            var val = parseInt( str, 10 ),\n                                toRef = idx ? el.to.left : el.to.top;\n\n                            // if original was \"auto\", recalculate the new value from wrapper\n                            if ( str === \"auto\" ) {\n                                return toRef + \"px\";\n                            }\n\n                            return val + toRef + \"px\";\n                        });\n                    });\n                }\n            }\n\n            $.effects.removeWrapper( el );\n            done();\n        }\n    });\n\n};\n\n\n/*!\n * jQuery UI Effects Scale 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/scale-effect/\n */\n\n\nvar effectScale = $.effects.effect.scale = function( o, done ) {\n\n    // Create element\n    var el = $( this ),\n        options = $.extend( true, {}, o ),\n        mode = $.effects.setMode( el, o.mode || \"effect\" ),\n        percent = parseInt( o.percent, 10 ) ||\n            ( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === \"hide\" ? 0 : 100 ) ),\n        direction = o.direction || \"both\",\n        origin = o.origin,\n        original = {\n            height: el.height(),\n            width: el.width(),\n            outerHeight: el.outerHeight(),\n            outerWidth: el.outerWidth()\n        },\n        factor = {\n            y: direction !== \"horizontal\" ? (percent / 100) : 1,\n            x: direction !== \"vertical\" ? (percent / 100) : 1\n        };\n\n    // We are going to pass this effect to the size effect:\n    options.effect = \"size\";\n    options.queue = false;\n    options.complete = done;\n\n    // Set default origin and restore for show/hide\n    if ( mode !== \"effect\" ) {\n        options.origin = origin || [ \"middle\", \"center\" ];\n        options.restore = true;\n    }\n\n    options.from = o.from || ( mode === \"show\" ? {\n        height: 0,\n        width: 0,\n        outerHeight: 0,\n        outerWidth: 0\n    } : original );\n    options.to = {\n        height: original.height * factor.y,\n        width: original.width * factor.x,\n        outerHeight: original.outerHeight * factor.y,\n        outerWidth: original.outerWidth * factor.x\n    };\n\n    // Fade option to support puff\n    if ( options.fade ) {\n        if ( mode === \"show\" ) {\n            options.from.opacity = 0;\n            options.to.opacity = 1;\n        }\n        if ( mode === \"hide\" ) {\n            options.from.opacity = 1;\n            options.to.opacity = 0;\n        }\n    }\n\n    // Animate\n    el.effect( options );\n\n};\n\n\n/*!\n * jQuery UI Effects Puff 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/puff-effect/\n */\n\n\nvar effectPuff = $.effects.effect.puff = function( o, done ) {\n    var elem = $( this ),\n        mode = $.effects.setMode( elem, o.mode || \"hide\" ),\n        hide = mode === \"hide\",\n        percent = parseInt( o.percent, 10 ) || 150,\n        factor = percent / 100,\n        original = {\n            height: elem.height(),\n            width: elem.width(),\n            outerHeight: elem.outerHeight(),\n            outerWidth: elem.outerWidth()\n        };\n\n    $.extend( o, {\n        effect: \"scale\",\n        queue: false,\n        fade: true,\n        mode: mode,\n        complete: done,\n        percent: hide ? percent : 100,\n        from: hide ?\n            original :\n            {\n                height: original.height * factor,\n                width: original.width * factor,\n                outerHeight: original.outerHeight * factor,\n                outerWidth: original.outerWidth * factor\n            }\n    });\n\n    elem.effect( o );\n};\n\n\n/*!\n * jQuery UI Effects Pulsate 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/pulsate-effect/\n */\n\n\nvar effectPulsate = $.effects.effect.pulsate = function( o, done ) {\n    var elem = $( this ),\n        mode = $.effects.setMode( elem, o.mode || \"show\" ),\n        show = mode === \"show\",\n        hide = mode === \"hide\",\n        showhide = ( show || mode === \"hide\" ),\n\n        // showing or hiding leaves of the \"last\" animation\n        anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),\n        duration = o.duration / anims,\n        animateTo = 0,\n        queue = elem.queue(),\n        queuelen = queue.length,\n        i;\n\n    if ( show || !elem.is(\":visible\")) {\n        elem.css( \"opacity\", 0 ).show();\n        animateTo = 1;\n    }\n\n    // anims - 1 opacity \"toggles\"\n    for ( i = 1; i < anims; i++ ) {\n        elem.animate({\n            opacity: animateTo\n        }, duration, o.easing );\n        animateTo = 1 - animateTo;\n    }\n\n    elem.animate({\n        opacity: animateTo\n    }, duration, o.easing);\n\n    elem.queue(function() {\n        if ( hide ) {\n            elem.hide();\n        }\n        done();\n    });\n\n    // We just queued up \"anims\" animations, we need to put them next in the queue\n    if ( queuelen > 1 ) {\n        queue.splice.apply( queue,\n            [ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );\n    }\n    elem.dequeue();\n};\n\n\n/*!\n * jQuery UI Effects Shake 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/shake-effect/\n */\n\n\nvar effectShake = $.effects.effect.shake = function( o, done ) {\n\n    var el = $( this ),\n        props = [ \"position\", \"top\", \"bottom\", \"left\", \"right\", \"height\", \"width\" ],\n        mode = $.effects.setMode( el, o.mode || \"effect\" ),\n        direction = o.direction || \"left\",\n        distance = o.distance || 20,\n        times = o.times || 3,\n        anims = times * 2 + 1,\n        speed = Math.round( o.duration / anims ),\n        ref = (direction === \"up\" || direction === \"down\") ? \"top\" : \"left\",\n        positiveMotion = (direction === \"up\" || direction === \"left\"),\n        animation = {},\n        animation1 = {},\n        animation2 = {},\n        i,\n\n        // we will need to re-assemble the queue to stack our animations in place\n        queue = el.queue(),\n        queuelen = queue.length;\n\n    $.effects.save( el, props );\n    el.show();\n    $.effects.createWrapper( el );\n\n    // Animation\n    animation[ ref ] = ( positiveMotion ? \"-=\" : \"+=\" ) + distance;\n    animation1[ ref ] = ( positiveMotion ? \"+=\" : \"-=\" ) + distance * 2;\n    animation2[ ref ] = ( positiveMotion ? \"-=\" : \"+=\" ) + distance * 2;\n\n    // Animate\n    el.animate( animation, speed, o.easing );\n\n    // Shakes\n    for ( i = 1; i < times; i++ ) {\n        el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );\n    }\n    el\n        .animate( animation1, speed, o.easing )\n        .animate( animation, speed / 2, o.easing )\n        .queue(function() {\n            if ( mode === \"hide\" ) {\n                el.hide();\n            }\n            $.effects.restore( el, props );\n            $.effects.removeWrapper( el );\n            done();\n        });\n\n    // inject all the animations we just queued to be first in line (after \"inprogress\")\n    if ( queuelen > 1) {\n        queue.splice.apply( queue,\n            [ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );\n    }\n    el.dequeue();\n\n};\n\n\n/*!\n * jQuery UI Effects Slide 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/slide-effect/\n */\n\n\nvar effectSlide = $.effects.effect.slide = function( o, done ) {\n\n    // Create element\n    var el = $( this ),\n        props = [ \"position\", \"top\", \"bottom\", \"left\", \"right\", \"width\", \"height\" ],\n        mode = $.effects.setMode( el, o.mode || \"show\" ),\n        show = mode === \"show\",\n        direction = o.direction || \"left\",\n        ref = (direction === \"up\" || direction === \"down\") ? \"top\" : \"left\",\n        positiveMotion = (direction === \"up\" || direction === \"left\"),\n        distance,\n        animation = {};\n\n    // Adjust\n    $.effects.save( el, props );\n    el.show();\n    distance = o.distance || el[ ref === \"top\" ? \"outerHeight\" : \"outerWidth\" ]( true );\n\n    $.effects.createWrapper( el ).css({\n        overflow: \"hidden\"\n    });\n\n    if ( show ) {\n        el.css( ref, positiveMotion ? (isNaN(distance) ? \"-\" + distance : -distance) : distance );\n    }\n\n    // Animation\n    animation[ ref ] = ( show ?\n        ( positiveMotion ? \"+=\" : \"-=\") :\n        ( positiveMotion ? \"-=\" : \"+=\")) +\n        distance;\n\n    // Animate\n    el.animate( animation, {\n        queue: false,\n        duration: o.duration,\n        easing: o.easing,\n        complete: function() {\n            if ( mode === \"hide\" ) {\n                el.hide();\n            }\n            $.effects.restore( el, props );\n            $.effects.removeWrapper( el );\n            done();\n        }\n    });\n};\n\n\n/*!\n * jQuery UI Effects Transfer 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/transfer-effect/\n */\n\n\nvar effectTransfer = $.effects.effect.transfer = function( o, done ) {\n    var elem = $( this ),\n        target = $( o.to ),\n        targetFixed = target.css( \"position\" ) === \"fixed\",\n        body = $(\"body\"),\n        fixTop = targetFixed ? body.scrollTop() : 0,\n        fixLeft = targetFixed ? body.scrollLeft() : 0,\n        endPosition = target.offset(),\n        animation = {\n            top: endPosition.top - fixTop,\n            left: endPosition.left - fixLeft,\n            height: target.innerHeight(),\n            width: target.innerWidth()\n        },\n        startPosition = elem.offset(),\n        transfer = $( \"<div class='ui-effects-transfer'></div>\" )\n            .appendTo( document.body )\n            .addClass( o.className )\n            .css({\n                top: startPosition.top - fixTop,\n                left: startPosition.left - fixLeft,\n                height: elem.innerHeight(),\n                width: elem.innerWidth(),\n                position: targetFixed ? \"fixed\" : \"absolute\"\n            })\n            .animate( animation, o.duration, o.easing, function() {\n                transfer.remove();\n                done();\n            });\n};\n\n\n/*!\n * jQuery UI Progressbar 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/progressbar/\n */\n\n\nvar progressbar = $.widget( \"ui.progressbar\", {\n    version: \"1.11.2\",\n    options: {\n        max: 100,\n        value: 0,\n\n        change: null,\n        complete: null\n    },\n\n    min: 0,\n\n    _create: function() {\n        // Constrain initial value\n        this.oldValue = this.options.value = this._constrainedValue();\n\n        this.element\n            .addClass( \"ui-progressbar ui-widget ui-widget-content ui-corner-all\" )\n            .attr({\n                // Only set static values, aria-valuenow and aria-valuemax are\n                // set inside _refreshValue()\n                role: \"progressbar\",\n                \"aria-valuemin\": this.min\n            });\n\n        this.valueDiv = $( \"<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>\" )\n            .appendTo( this.element );\n\n        this._refreshValue();\n    },\n\n    _destroy: function() {\n        this.element\n            .removeClass( \"ui-progressbar ui-widget ui-widget-content ui-corner-all\" )\n            .removeAttr( \"role\" )\n            .removeAttr( \"aria-valuemin\" )\n            .removeAttr( \"aria-valuemax\" )\n            .removeAttr( \"aria-valuenow\" );\n\n        this.valueDiv.remove();\n    },\n\n    value: function( newValue ) {\n        if ( newValue === undefined ) {\n            return this.options.value;\n        }\n\n        this.options.value = this._constrainedValue( newValue );\n        this._refreshValue();\n    },\n\n    _constrainedValue: function( newValue ) {\n        if ( newValue === undefined ) {\n            newValue = this.options.value;\n        }\n\n        this.indeterminate = newValue === false;\n\n        // sanitize value\n        if ( typeof newValue !== \"number\" ) {\n            newValue = 0;\n        }\n\n        return this.indeterminate ? false :\n            Math.min( this.options.max, Math.max( this.min, newValue ) );\n    },\n\n    _setOptions: function( options ) {\n        // Ensure \"value\" option is set after other values (like max)\n        var value = options.value;\n        delete options.value;\n\n        this._super( options );\n\n        this.options.value = this._constrainedValue( value );\n        this._refreshValue();\n    },\n\n    _setOption: function( key, value ) {\n        if ( key === \"max\" ) {\n            // Don't allow a max less than min\n            value = Math.max( this.min, value );\n        }\n        if ( key === \"disabled\" ) {\n            this.element\n                .toggleClass( \"ui-state-disabled\", !!value )\n                .attr( \"aria-disabled\", value );\n        }\n        this._super( key, value );\n    },\n\n    _percentage: function() {\n        return this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );\n    },\n\n    _refreshValue: function() {\n        var value = this.options.value,\n            percentage = this._percentage();\n\n        this.valueDiv\n            .toggle( this.indeterminate || value > this.min )\n            .toggleClass( \"ui-corner-right\", value === this.options.max )\n            .width( percentage.toFixed(0) + \"%\" );\n\n        this.element.toggleClass( \"ui-progressbar-indeterminate\", this.indeterminate );\n\n        if ( this.indeterminate ) {\n            this.element.removeAttr( \"aria-valuenow\" );\n            if ( !this.overlayDiv ) {\n                this.overlayDiv = $( \"<div class='ui-progressbar-overlay'></div>\" ).appendTo( this.valueDiv );\n            }\n        } else {\n            this.element.attr({\n                \"aria-valuemax\": this.options.max,\n                \"aria-valuenow\": value\n            });\n            if ( this.overlayDiv ) {\n                this.overlayDiv.remove();\n                this.overlayDiv = null;\n            }\n        }\n\n        if ( this.oldValue !== value ) {\n            this.oldValue = value;\n            this._trigger( \"change\" );\n        }\n        if ( value === this.options.max ) {\n            this._trigger( \"complete\" );\n        }\n    }\n});\n\n\n/*!\n * jQuery UI Selectable 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/selectable/\n */\n\n\nvar selectable = $.widget(\"ui.selectable\", $.ui.mouse, {\n    version: \"1.11.2\",\n    options: {\n        appendTo: \"body\",\n        autoRefresh: true,\n        distance: 0,\n        filter: \"*\",\n        tolerance: \"touch\",\n\n        // callbacks\n        selected: null,\n        selecting: null,\n        start: null,\n        stop: null,\n        unselected: null,\n        unselecting: null\n    },\n    _create: function() {\n        var selectees,\n            that = this;\n\n        this.element.addClass(\"ui-selectable\");\n\n        this.dragged = false;\n\n        // cache selectee children based on filter\n        this.refresh = function() {\n            selectees = $(that.options.filter, that.element[0]);\n            selectees.addClass(\"ui-selectee\");\n            selectees.each(function() {\n                var $this = $(this),\n                    pos = $this.offset();\n                $.data(this, \"selectable-item\", {\n                    element: this,\n                    $element: $this,\n                    left: pos.left,\n                    top: pos.top,\n                    right: pos.left + $this.outerWidth(),\n                    bottom: pos.top + $this.outerHeight(),\n                    startselected: false,\n                    selected: $this.hasClass(\"ui-selected\"),\n                    selecting: $this.hasClass(\"ui-selecting\"),\n                    unselecting: $this.hasClass(\"ui-unselecting\")\n                });\n            });\n        };\n        this.refresh();\n\n        this.selectees = selectees.addClass(\"ui-selectee\");\n\n        this._mouseInit();\n\n        this.helper = $(\"<div class='ui-selectable-helper'></div>\");\n    },\n\n    _destroy: function() {\n        this.selectees\n            .removeClass(\"ui-selectee\")\n            .removeData(\"selectable-item\");\n        this.element\n            .removeClass(\"ui-selectable ui-selectable-disabled\");\n        this._mouseDestroy();\n    },\n\n    _mouseStart: function(event) {\n        var that = this,\n            options = this.options;\n\n        this.opos = [ event.pageX, event.pageY ];\n\n        if (this.options.disabled) {\n            return;\n        }\n\n        this.selectees = $(options.filter, this.element[0]);\n\n        this._trigger(\"start\", event);\n\n        $(options.appendTo).append(this.helper);\n        // position helper (lasso)\n        this.helper.css({\n            \"left\": event.pageX,\n            \"top\": event.pageY,\n            \"width\": 0,\n            \"height\": 0\n        });\n\n        if (options.autoRefresh) {\n            this.refresh();\n        }\n\n        this.selectees.filter(\".ui-selected\").each(function() {\n            var selectee = $.data(this, \"selectable-item\");\n            selectee.startselected = true;\n            if (!event.metaKey && !event.ctrlKey) {\n                selectee.$element.removeClass(\"ui-selected\");\n                selectee.selected = false;\n                selectee.$element.addClass(\"ui-unselecting\");\n                selectee.unselecting = true;\n                // selectable UNSELECTING callback\n                that._trigger(\"unselecting\", event, {\n                    unselecting: selectee.element\n                });\n            }\n        });\n\n        $(event.target).parents().addBack().each(function() {\n            var doSelect,\n                selectee = $.data(this, \"selectable-item\");\n            if (selectee) {\n                doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass(\"ui-selected\");\n                selectee.$element\n                    .removeClass(doSelect ? \"ui-unselecting\" : \"ui-selected\")\n                    .addClass(doSelect ? \"ui-selecting\" : \"ui-unselecting\");\n                selectee.unselecting = !doSelect;\n                selectee.selecting = doSelect;\n                selectee.selected = doSelect;\n                // selectable (UN)SELECTING callback\n                if (doSelect) {\n                    that._trigger(\"selecting\", event, {\n                        selecting: selectee.element\n                    });\n                } else {\n                    that._trigger(\"unselecting\", event, {\n                        unselecting: selectee.element\n                    });\n                }\n                return false;\n            }\n        });\n\n    },\n\n    _mouseDrag: function(event) {\n\n        this.dragged = true;\n\n        if (this.options.disabled) {\n            return;\n        }\n\n        var tmp,\n            that = this,\n            options = this.options,\n            x1 = this.opos[0],\n            y1 = this.opos[1],\n            x2 = event.pageX,\n            y2 = event.pageY;\n\n        if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }\n        if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }\n        this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });\n\n        this.selectees.each(function() {\n            var selectee = $.data(this, \"selectable-item\"),\n                hit = false;\n\n            //prevent helper from being selected if appendTo: selectable\n            if (!selectee || selectee.element === that.element[0]) {\n                return;\n            }\n\n            if (options.tolerance === \"touch\") {\n                hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );\n            } else if (options.tolerance === \"fit\") {\n                hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);\n            }\n\n            if (hit) {\n                // SELECT\n                if (selectee.selected) {\n                    selectee.$element.removeClass(\"ui-selected\");\n                    selectee.selected = false;\n                }\n                if (selectee.unselecting) {\n                    selectee.$element.removeClass(\"ui-unselecting\");\n                    selectee.unselecting = false;\n                }\n                if (!selectee.selecting) {\n                    selectee.$element.addClass(\"ui-selecting\");\n                    selectee.selecting = true;\n                    // selectable SELECTING callback\n                    that._trigger(\"selecting\", event, {\n                        selecting: selectee.element\n                    });\n                }\n            } else {\n                // UNSELECT\n                if (selectee.selecting) {\n                    if ((event.metaKey || event.ctrlKey) && selectee.startselected) {\n                        selectee.$element.removeClass(\"ui-selecting\");\n                        selectee.selecting = false;\n                        selectee.$element.addClass(\"ui-selected\");\n                        selectee.selected = true;\n                    } else {\n                        selectee.$element.removeClass(\"ui-selecting\");\n                        selectee.selecting = false;\n                        if (selectee.startselected) {\n                            selectee.$element.addClass(\"ui-unselecting\");\n                            selectee.unselecting = true;\n                        }\n                        // selectable UNSELECTING callback\n                        that._trigger(\"unselecting\", event, {\n                            unselecting: selectee.element\n                        });\n                    }\n                }\n                if (selectee.selected) {\n                    if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {\n                        selectee.$element.removeClass(\"ui-selected\");\n                        selectee.selected = false;\n\n                        selectee.$element.addClass(\"ui-unselecting\");\n                        selectee.unselecting = true;\n                        // selectable UNSELECTING callback\n                        that._trigger(\"unselecting\", event, {\n                            unselecting: selectee.element\n                        });\n                    }\n                }\n            }\n        });\n\n        return false;\n    },\n\n    _mouseStop: function(event) {\n        var that = this;\n\n        this.dragged = false;\n\n        $(\".ui-unselecting\", this.element[0]).each(function() {\n            var selectee = $.data(this, \"selectable-item\");\n            selectee.$element.removeClass(\"ui-unselecting\");\n            selectee.unselecting = false;\n            selectee.startselected = false;\n            that._trigger(\"unselected\", event, {\n                unselected: selectee.element\n            });\n        });\n        $(\".ui-selecting\", this.element[0]).each(function() {\n            var selectee = $.data(this, \"selectable-item\");\n            selectee.$element.removeClass(\"ui-selecting\").addClass(\"ui-selected\");\n            selectee.selecting = false;\n            selectee.selected = true;\n            selectee.startselected = true;\n            that._trigger(\"selected\", event, {\n                selected: selectee.element\n            });\n        });\n        this._trigger(\"stop\", event);\n\n        this.helper.remove();\n\n        return false;\n    }\n\n});\n\n\n/*!\n * jQuery UI Selectmenu 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/selectmenu\n */\n\n\nvar selectmenu = $.widget( \"ui.selectmenu\", {\n    version: \"1.11.2\",\n    defaultElement: \"<select>\",\n    options: {\n        appendTo: null,\n        disabled: null,\n        icons: {\n            button: \"ui-icon-triangle-1-s\"\n        },\n        position: {\n            my: \"left top\",\n            at: \"left bottom\",\n            collision: \"none\"\n        },\n        width: null,\n\n        // callbacks\n        change: null,\n        close: null,\n        focus: null,\n        open: null,\n        select: null\n    },\n\n    _create: function() {\n        var selectmenuId = this.element.uniqueId().attr( \"id\" );\n        this.ids = {\n            element: selectmenuId,\n            button: selectmenuId + \"-button\",\n            menu: selectmenuId + \"-menu\"\n        };\n\n        this._drawButton();\n        this._drawMenu();\n\n        if ( this.options.disabled ) {\n            this.disable();\n        }\n    },\n\n    _drawButton: function() {\n        var that = this,\n            tabindex = this.element.attr( \"tabindex\" );\n\n        // Associate existing label with the new button\n        this.label = $( \"label[for='\" + this.ids.element + \"']\" ).attr( \"for\", this.ids.button );\n        this._on( this.label, {\n            click: function( event ) {\n                this.button.focus();\n                event.preventDefault();\n            }\n        });\n\n        // Hide original select element\n        this.element.hide();\n\n        // Create button\n        this.button = $( \"<span>\", {\n            \"class\": \"ui-selectmenu-button ui-widget ui-state-default ui-corner-all\",\n            tabindex: tabindex || this.options.disabled ? -1 : 0,\n            id: this.ids.button,\n            role: \"combobox\",\n            \"aria-expanded\": \"false\",\n            \"aria-autocomplete\": \"list\",\n            \"aria-owns\": this.ids.menu,\n            \"aria-haspopup\": \"true\"\n        })\n            .insertAfter( this.element );\n\n        $( \"<span>\", {\n            \"class\": \"ui-icon \" + this.options.icons.button\n        })\n            .prependTo( this.button );\n\n        this.buttonText = $( \"<span>\", {\n            \"class\": \"ui-selectmenu-text\"\n        })\n            .appendTo( this.button );\n\n        this._setText( this.buttonText, this.element.find( \"option:selected\" ).text() );\n        this._resizeButton();\n\n        this._on( this.button, this._buttonEvents );\n        this.button.one( \"focusin\", function() {\n\n            // Delay rendering the menu items until the button receives focus.\n            // The menu may have already been rendered via a programmatic open.\n            if ( !that.menuItems ) {\n                that._refreshMenu();\n            }\n        });\n        this._hoverable( this.button );\n        this._focusable( this.button );\n    },\n\n    _drawMenu: function() {\n        var that = this;\n\n        // Create menu\n        this.menu = $( \"<ul>\", {\n            \"aria-hidden\": \"true\",\n            \"aria-labelledby\": this.ids.button,\n            id: this.ids.menu\n        });\n\n        // Wrap menu\n        this.menuWrap = $( \"<div>\", {\n            \"class\": \"ui-selectmenu-menu ui-front\"\n        })\n            .append( this.menu )\n            .appendTo( this._appendTo() );\n\n        // Initialize menu widget\n        this.menuInstance = this.menu\n            .menu({\n                role: \"listbox\",\n                select: function( event, ui ) {\n                    event.preventDefault();\n\n                    // support: IE8\n                    // If the item was selected via a click, the text selection\n                    // will be destroyed in IE\n                    that._setSelection();\n\n                    that._select( ui.item.data( \"ui-selectmenu-item\" ), event );\n                },\n                focus: function( event, ui ) {\n                    var item = ui.item.data( \"ui-selectmenu-item\" );\n\n                    // Prevent inital focus from firing and check if its a newly focused item\n                    if ( that.focusIndex != null && item.index !== that.focusIndex ) {\n                        that._trigger( \"focus\", event, { item: item } );\n                        if ( !that.isOpen ) {\n                            that._select( item, event );\n                        }\n                    }\n                    that.focusIndex = item.index;\n\n                    that.button.attr( \"aria-activedescendant\",\n                        that.menuItems.eq( item.index ).attr( \"id\" ) );\n                }\n            })\n            .menu( \"instance\" );\n\n        // Adjust menu styles to dropdown\n        this.menu\n            .addClass( \"ui-corner-bottom\" )\n            .removeClass( \"ui-corner-all\" );\n\n        // Don't close the menu on mouseleave\n        this.menuInstance._off( this.menu, \"mouseleave\" );\n\n        // Cancel the menu's collapseAll on document click\n        this.menuInstance._closeOnDocumentClick = function() {\n            return false;\n        };\n\n        // Selects often contain empty items, but never contain dividers\n        this.menuInstance._isDivider = function() {\n            return false;\n        };\n    },\n\n    refresh: function() {\n        this._refreshMenu();\n        this._setText( this.buttonText, this._getSelectedItem().text() );\n        if ( !this.options.width ) {\n            this._resizeButton();\n        }\n    },\n\n    _refreshMenu: function() {\n        this.menu.empty();\n\n        var item,\n            options = this.element.find( \"option\" );\n\n        if ( !options.length ) {\n            return;\n        }\n\n        this._parseOptions( options );\n        this._renderMenu( this.menu, this.items );\n\n        this.menuInstance.refresh();\n        this.menuItems = this.menu.find( \"li\" ).not( \".ui-selectmenu-optgroup\" );\n\n        item = this._getSelectedItem();\n\n        // Update the menu to have the correct item focused\n        this.menuInstance.focus( null, item );\n        this._setAria( item.data( \"ui-selectmenu-item\" ) );\n\n        // Set disabled state\n        this._setOption( \"disabled\", this.element.prop( \"disabled\" ) );\n    },\n\n    open: function( event ) {\n        if ( this.options.disabled ) {\n            return;\n        }\n\n        // If this is the first time the menu is being opened, render the items\n        if ( !this.menuItems ) {\n            this._refreshMenu();\n        } else {\n\n            // Menu clears focus on close, reset focus to selected item\n            this.menu.find( \".ui-state-focus\" ).removeClass( \"ui-state-focus\" );\n            this.menuInstance.focus( null, this._getSelectedItem() );\n        }\n\n        this.isOpen = true;\n        this._toggleAttr();\n        this._resizeMenu();\n        this._position();\n\n        this._on( this.document, this._documentClick );\n\n        this._trigger( \"open\", event );\n    },\n\n    _position: function() {\n        this.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );\n    },\n\n    close: function( event ) {\n        if ( !this.isOpen ) {\n            return;\n        }\n\n        this.isOpen = false;\n        this._toggleAttr();\n\n        this.range = null;\n        this._off( this.document );\n\n        this._trigger( \"close\", event );\n    },\n\n    widget: function() {\n        return this.button;\n    },\n\n    menuWidget: function() {\n        return this.menu;\n    },\n\n    _renderMenu: function( ul, items ) {\n        var that = this,\n            currentOptgroup = \"\";\n\n        $.each( items, function( index, item ) {\n            if ( item.optgroup !== currentOptgroup ) {\n                $( \"<li>\", {\n                    \"class\": \"ui-selectmenu-optgroup ui-menu-divider\" +\n                        ( item.element.parent( \"optgroup\" ).prop( \"disabled\" ) ?\n                            \" ui-state-disabled\" :\n                            \"\" ),\n                    text: item.optgroup\n                })\n                    .appendTo( ul );\n\n                currentOptgroup = item.optgroup;\n            }\n\n            that._renderItemData( ul, item );\n        });\n    },\n\n    _renderItemData: function( ul, item ) {\n        return this._renderItem( ul, item ).data( \"ui-selectmenu-item\", item );\n    },\n\n    _renderItem: function( ul, item ) {\n        var li = $( \"<li>\" );\n\n        if ( item.disabled ) {\n            li.addClass( \"ui-state-disabled\" );\n        }\n        this._setText( li, item.label );\n\n        return li.appendTo( ul );\n    },\n\n    _setText: function( element, value ) {\n        if ( value ) {\n            element.text( value );\n        } else {\n            element.html( \"&#160;\" );\n        }\n    },\n\n    _move: function( direction, event ) {\n        var item, next,\n            filter = \".ui-menu-item\";\n\n        if ( this.isOpen ) {\n            item = this.menuItems.eq( this.focusIndex );\n        } else {\n            item = this.menuItems.eq( this.element[ 0 ].selectedIndex );\n            filter += \":not(.ui-state-disabled)\";\n        }\n\n        if ( direction === \"first\" || direction === \"last\" ) {\n            next = item[ direction === \"first\" ? \"prevAll\" : \"nextAll\" ]( filter ).eq( -1 );\n        } else {\n            next = item[ direction + \"All\" ]( filter ).eq( 0 );\n        }\n\n        if ( next.length ) {\n            this.menuInstance.focus( event, next );\n        }\n    },\n\n    _getSelectedItem: function() {\n        return this.menuItems.eq( this.element[ 0 ].selectedIndex );\n    },\n\n    _toggle: function( event ) {\n        this[ this.isOpen ? \"close\" : \"open\" ]( event );\n    },\n\n    _setSelection: function() {\n        var selection;\n\n        if ( !this.range ) {\n            return;\n        }\n\n        if ( window.getSelection ) {\n            selection = window.getSelection();\n            selection.removeAllRanges();\n            selection.addRange( this.range );\n\n        // support: IE8\n        } else {\n            this.range.select();\n        }\n\n        // support: IE\n        // Setting the text selection kills the button focus in IE, but\n        // restoring the focus doesn't kill the selection.\n        this.button.focus();\n    },\n\n    _documentClick: {\n        mousedown: function( event ) {\n            if ( !this.isOpen ) {\n                return;\n            }\n\n            if ( !$( event.target ).closest( \".ui-selectmenu-menu, #\" + this.ids.button ).length ) {\n                this.close( event );\n            }\n        }\n    },\n\n    _buttonEvents: {\n\n        // Prevent text selection from being reset when interacting with the selectmenu (#10144)\n        mousedown: function() {\n            var selection;\n\n            if ( window.getSelection ) {\n                selection = window.getSelection();\n                if ( selection.rangeCount ) {\n                    this.range = selection.getRangeAt( 0 );\n                }\n\n            // support: IE8\n            } else {\n                this.range = document.selection.createRange();\n            }\n        },\n\n        click: function( event ) {\n            this._setSelection();\n            this._toggle( event );\n        },\n\n        keydown: function( event ) {\n            var preventDefault = true;\n            switch ( event.keyCode ) {\n                case $.ui.keyCode.TAB:\n                case $.ui.keyCode.ESCAPE:\n                    this.close( event );\n                    preventDefault = false;\n                    break;\n                case $.ui.keyCode.ENTER:\n                    if ( this.isOpen ) {\n                        this._selectFocusedItem( event );\n                    }\n                    break;\n                case $.ui.keyCode.UP:\n                    if ( event.altKey ) {\n                        this._toggle( event );\n                    } else {\n                        this._move( \"prev\", event );\n                    }\n                    break;\n                case $.ui.keyCode.DOWN:\n                    if ( event.altKey ) {\n                        this._toggle( event );\n                    } else {\n                        this._move( \"next\", event );\n                    }\n                    break;\n                case $.ui.keyCode.SPACE:\n                    if ( this.isOpen ) {\n                        this._selectFocusedItem( event );\n                    } else {\n                        this._toggle( event );\n                    }\n                    break;\n                case $.ui.keyCode.LEFT:\n                    this._move( \"prev\", event );\n                    break;\n                case $.ui.keyCode.RIGHT:\n                    this._move( \"next\", event );\n                    break;\n                case $.ui.keyCode.HOME:\n                case $.ui.keyCode.PAGE_UP:\n                    this._move( \"first\", event );\n                    break;\n                case $.ui.keyCode.END:\n                case $.ui.keyCode.PAGE_DOWN:\n                    this._move( \"last\", event );\n                    break;\n                default:\n                    this.menu.trigger( event );\n                    preventDefault = false;\n            }\n\n            if ( preventDefault ) {\n                event.preventDefault();\n            }\n        }\n    },\n\n    _selectFocusedItem: function( event ) {\n        var item = this.menuItems.eq( this.focusIndex );\n        if ( !item.hasClass( \"ui-state-disabled\" ) ) {\n            this._select( item.data( \"ui-selectmenu-item\" ), event );\n        }\n    },\n\n    _select: function( item, event ) {\n        var oldIndex = this.element[ 0 ].selectedIndex;\n\n        // Change native select element\n        this.element[ 0 ].selectedIndex = item.index;\n        this._setText( this.buttonText, item.label );\n        this._setAria( item );\n        this._trigger( \"select\", event, { item: item } );\n\n        if ( item.index !== oldIndex ) {\n            this._trigger( \"change\", event, { item: item } );\n        }\n\n        this.close( event );\n    },\n\n    _setAria: function( item ) {\n        var id = this.menuItems.eq( item.index ).attr( \"id\" );\n\n        this.button.attr({\n            \"aria-labelledby\": id,\n            \"aria-activedescendant\": id\n        });\n        this.menu.attr( \"aria-activedescendant\", id );\n    },\n\n    _setOption: function( key, value ) {\n        if ( key === \"icons\" ) {\n            this.button.find( \"span.ui-icon\" )\n                .removeClass( this.options.icons.button )\n                .addClass( value.button );\n        }\n\n        this._super( key, value );\n\n        if ( key === \"appendTo\" ) {\n            this.menuWrap.appendTo( this._appendTo() );\n        }\n\n        if ( key === \"disabled\" ) {\n            this.menuInstance.option( \"disabled\", value );\n            this.button\n                .toggleClass( \"ui-state-disabled\", value )\n                .attr( \"aria-disabled\", value );\n\n            this.element.prop( \"disabled\", value );\n            if ( value ) {\n                this.button.attr( \"tabindex\", -1 );\n                this.close();\n            } else {\n                this.button.attr( \"tabindex\", 0 );\n            }\n        }\n\n        if ( key === \"width\" ) {\n            this._resizeButton();\n        }\n    },\n\n    _appendTo: function() {\n        var element = this.options.appendTo;\n\n        if ( element ) {\n            element = element.jquery || element.nodeType ?\n                $( element ) :\n                this.document.find( element ).eq( 0 );\n        }\n\n        if ( !element || !element[ 0 ] ) {\n            element = this.element.closest( \".ui-front\" );\n        }\n\n        if ( !element.length ) {\n            element = this.document[ 0 ].body;\n        }\n\n        return element;\n    },\n\n    _toggleAttr: function() {\n        this.button\n            .toggleClass( \"ui-corner-top\", this.isOpen )\n            .toggleClass( \"ui-corner-all\", !this.isOpen )\n            .attr( \"aria-expanded\", this.isOpen );\n        this.menuWrap.toggleClass( \"ui-selectmenu-open\", this.isOpen );\n        this.menu.attr( \"aria-hidden\", !this.isOpen );\n    },\n\n    _resizeButton: function() {\n        var width = this.options.width;\n\n        if ( !width ) {\n            width = this.element.show().outerWidth();\n            this.element.hide();\n        }\n\n        this.button.outerWidth( width );\n    },\n\n    _resizeMenu: function() {\n        this.menu.outerWidth( Math.max(\n            this.button.outerWidth(),\n\n            // support: IE10\n            // IE10 wraps long text (possibly a rounding bug)\n            // so we add 1px to avoid the wrapping\n            this.menu.width( \"\" ).outerWidth() + 1\n        ) );\n    },\n\n    _getCreateOptions: function() {\n        return { disabled: this.element.prop( \"disabled\" ) };\n    },\n\n    _parseOptions: function( options ) {\n        var data = [];\n        options.each(function( index, item ) {\n            var option = $( item ),\n                optgroup = option.parent( \"optgroup\" );\n            data.push({\n                element: option,\n                index: index,\n                value: option.attr( \"value\" ),\n                label: option.text(),\n                optgroup: optgroup.attr( \"label\" ) || \"\",\n                disabled: optgroup.prop( \"disabled\" ) || option.prop( \"disabled\" )\n            });\n        });\n        this.items = data;\n    },\n\n    _destroy: function() {\n        this.menuWrap.remove();\n        this.button.remove();\n        this.element.show();\n        this.element.removeUniqueId();\n        this.label.attr( \"for\", this.ids.element );\n    }\n});\n\n\n/*!\n * jQuery UI Slider 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/slider/\n */\n\n\nvar slider = $.widget( \"ui.slider\", $.ui.mouse, {\n    version: \"1.11.2\",\n    widgetEventPrefix: \"slide\",\n\n    options: {\n        animate: false,\n        distance: 0,\n        max: 100,\n        min: 0,\n        orientation: \"horizontal\",\n        range: false,\n        step: 1,\n        value: 0,\n        values: null,\n\n        // callbacks\n        change: null,\n        slide: null,\n        start: null,\n        stop: null\n    },\n\n    // number of pages in a slider\n    // (how many times can you page up/down to go through the whole range)\n    numPages: 5,\n\n    _create: function() {\n        this._keySliding = false;\n        this._mouseSliding = false;\n        this._animateOff = true;\n        this._handleIndex = null;\n        this._detectOrientation();\n        this._mouseInit();\n        this._calculateNewMax();\n\n        this.element\n            .addClass( \"ui-slider\" +\n                \" ui-slider-\" + this.orientation +\n                \" ui-widget\" +\n                \" ui-widget-content\" +\n                \" ui-corner-all\");\n\n        this._refresh();\n        this._setOption( \"disabled\", this.options.disabled );\n\n        this._animateOff = false;\n    },\n\n    _refresh: function() {\n        this._createRange();\n        this._createHandles();\n        this._setupEvents();\n        this._refreshValue();\n    },\n\n    _createHandles: function() {\n        var i, handleCount,\n            options = this.options,\n            existingHandles = this.element.find( \".ui-slider-handle\" ).addClass( \"ui-state-default ui-corner-all\" ),\n            handle = \"<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>\",\n            handles = [];\n\n        handleCount = ( options.values && options.values.length ) || 1;\n\n        if ( existingHandles.length > handleCount ) {\n            existingHandles.slice( handleCount ).remove();\n            existingHandles = existingHandles.slice( 0, handleCount );\n        }\n\n        for ( i = existingHandles.length; i < handleCount; i++ ) {\n            handles.push( handle );\n        }\n\n        this.handles = existingHandles.add( $( handles.join( \"\" ) ).appendTo( this.element ) );\n\n        this.handle = this.handles.eq( 0 );\n\n        this.handles.each(function( i ) {\n            $( this ).data( \"ui-slider-handle-index\", i );\n        });\n    },\n\n    _createRange: function() {\n        var options = this.options,\n            classes = \"\";\n\n        if ( options.range ) {\n            if ( options.range === true ) {\n                if ( !options.values ) {\n                    options.values = [ this._valueMin(), this._valueMin() ];\n                } else if ( options.values.length && options.values.length !== 2 ) {\n                    options.values = [ options.values[0], options.values[0] ];\n                } else if ( $.isArray( options.values ) ) {\n                    options.values = options.values.slice(0);\n                }\n            }\n\n            if ( !this.range || !this.range.length ) {\n                this.range = $( \"<div></div>\" )\n                    .appendTo( this.element );\n\n                classes = \"ui-slider-range\" +\n                // note: this isn't the most fittingly semantic framework class for this element,\n                // but worked best visually with a variety of themes\n                \" ui-widget-header ui-corner-all\";\n            } else {\n                this.range.removeClass( \"ui-slider-range-min ui-slider-range-max\" )\n                    // Handle range switching from true to min/max\n                    .css({\n                        \"left\": \"\",\n                        \"bottom\": \"\"\n                    });\n            }\n\n            this.range.addClass( classes +\n                ( ( options.range === \"min\" || options.range === \"max\" ) ? \" ui-slider-range-\" + options.range : \"\" ) );\n        } else {\n            if ( this.range ) {\n                this.range.remove();\n            }\n            this.range = null;\n        }\n    },\n\n    _setupEvents: function() {\n        this._off( this.handles );\n        this._on( this.handles, this._handleEvents );\n        this._hoverable( this.handles );\n        this._focusable( this.handles );\n    },\n\n    _destroy: function() {\n        this.handles.remove();\n        if ( this.range ) {\n            this.range.remove();\n        }\n\n        this.element\n            .removeClass( \"ui-slider\" +\n                \" ui-slider-horizontal\" +\n                \" ui-slider-vertical\" +\n                \" ui-widget\" +\n                \" ui-widget-content\" +\n                \" ui-corner-all\" );\n\n        this._mouseDestroy();\n    },\n\n    _mouseCapture: function( event ) {\n        var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,\n            that = this,\n            o = this.options;\n\n        if ( o.disabled ) {\n            return false;\n        }\n\n        this.elementSize = {\n            width: this.element.outerWidth(),\n            height: this.element.outerHeight()\n        };\n        this.elementOffset = this.element.offset();\n\n        position = { x: event.pageX, y: event.pageY };\n        normValue = this._normValueFromMouse( position );\n        distance = this._valueMax() - this._valueMin() + 1;\n        this.handles.each(function( i ) {\n            var thisDistance = Math.abs( normValue - that.values(i) );\n            if (( distance > thisDistance ) ||\n                ( distance === thisDistance &&\n                    (i === that._lastChangedValue || that.values(i) === o.min ))) {\n                distance = thisDistance;\n                closestHandle = $( this );\n                index = i;\n            }\n        });\n\n        allowed = this._start( event, index );\n        if ( allowed === false ) {\n            return false;\n        }\n        this._mouseSliding = true;\n\n        this._handleIndex = index;\n\n        closestHandle\n            .addClass( \"ui-state-active\" )\n            .focus();\n\n        offset = closestHandle.offset();\n        mouseOverHandle = !$( event.target ).parents().addBack().is( \".ui-slider-handle\" );\n        this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {\n            left: event.pageX - offset.left - ( closestHandle.width() / 2 ),\n            top: event.pageY - offset.top -\n                ( closestHandle.height() / 2 ) -\n                ( parseInt( closestHandle.css(\"borderTopWidth\"), 10 ) || 0 ) -\n                ( parseInt( closestHandle.css(\"borderBottomWidth\"), 10 ) || 0) +\n                ( parseInt( closestHandle.css(\"marginTop\"), 10 ) || 0)\n        };\n\n        if ( !this.handles.hasClass( \"ui-state-hover\" ) ) {\n            this._slide( event, index, normValue );\n        }\n        this._animateOff = true;\n        return true;\n    },\n\n    _mouseStart: function() {\n        return true;\n    },\n\n    _mouseDrag: function( event ) {\n        var position = { x: event.pageX, y: event.pageY },\n            normValue = this._normValueFromMouse( position );\n\n        this._slide( event, this._handleIndex, normValue );\n\n        return false;\n    },\n\n    _mouseStop: function( event ) {\n        this.handles.removeClass( \"ui-state-active\" );\n        this._mouseSliding = false;\n\n        this._stop( event, this._handleIndex );\n        this._change( event, this._handleIndex );\n\n        this._handleIndex = null;\n        this._clickOffset = null;\n        this._animateOff = false;\n\n        return false;\n    },\n\n    _detectOrientation: function() {\n        this.orientation = ( this.options.orientation === \"vertical\" ) ? \"vertical\" : \"horizontal\";\n    },\n\n    _normValueFromMouse: function( position ) {\n        var pixelTotal,\n            pixelMouse,\n            percentMouse,\n            valueTotal,\n            valueMouse;\n\n        if ( this.orientation === \"horizontal\" ) {\n            pixelTotal = this.elementSize.width;\n            pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );\n        } else {\n            pixelTotal = this.elementSize.height;\n            pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );\n        }\n\n        percentMouse = ( pixelMouse / pixelTotal );\n        if ( percentMouse > 1 ) {\n            percentMouse = 1;\n        }\n        if ( percentMouse < 0 ) {\n            percentMouse = 0;\n        }\n        if ( this.orientation === \"vertical\" ) {\n            percentMouse = 1 - percentMouse;\n        }\n\n        valueTotal = this._valueMax() - this._valueMin();\n        valueMouse = this._valueMin() + percentMouse * valueTotal;\n\n        return this._trimAlignValue( valueMouse );\n    },\n\n    _start: function( event, index ) {\n        var uiHash = {\n            handle: this.handles[ index ],\n            value: this.value()\n        };\n        if ( this.options.values && this.options.values.length ) {\n            uiHash.value = this.values( index );\n            uiHash.values = this.values();\n        }\n        return this._trigger( \"start\", event, uiHash );\n    },\n\n    _slide: function( event, index, newVal ) {\n        var otherVal,\n            newValues,\n            allowed;\n\n        if ( this.options.values && this.options.values.length ) {\n            otherVal = this.values( index ? 0 : 1 );\n\n            if ( ( this.options.values.length === 2 && this.options.range === true ) &&\n                    ( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )\n                ) {\n                newVal = otherVal;\n            }\n\n            if ( newVal !== this.values( index ) ) {\n                newValues = this.values();\n                newValues[ index ] = newVal;\n                // A slide can be canceled by returning false from the slide callback\n                allowed = this._trigger( \"slide\", event, {\n                    handle: this.handles[ index ],\n                    value: newVal,\n                    values: newValues\n                } );\n                otherVal = this.values( index ? 0 : 1 );\n                if ( allowed !== false ) {\n                    this.values( index, newVal );\n                }\n            }\n        } else {\n            if ( newVal !== this.value() ) {\n                // A slide can be canceled by returning false from the slide callback\n                allowed = this._trigger( \"slide\", event, {\n                    handle: this.handles[ index ],\n                    value: newVal\n                } );\n                if ( allowed !== false ) {\n                    this.value( newVal );\n                }\n            }\n        }\n    },\n\n    _stop: function( event, index ) {\n        var uiHash = {\n            handle: this.handles[ index ],\n            value: this.value()\n        };\n        if ( this.options.values && this.options.values.length ) {\n            uiHash.value = this.values( index );\n            uiHash.values = this.values();\n        }\n\n        this._trigger( \"stop\", event, uiHash );\n    },\n\n    _change: function( event, index ) {\n        if ( !this._keySliding && !this._mouseSliding ) {\n            var uiHash = {\n                handle: this.handles[ index ],\n                value: this.value()\n            };\n            if ( this.options.values && this.options.values.length ) {\n                uiHash.value = this.values( index );\n                uiHash.values = this.values();\n            }\n\n            //store the last changed value index for reference when handles overlap\n            this._lastChangedValue = index;\n\n            this._trigger( \"change\", event, uiHash );\n        }\n    },\n\n    value: function( newValue ) {\n        if ( arguments.length ) {\n            this.options.value = this._trimAlignValue( newValue );\n            this._refreshValue();\n            this._change( null, 0 );\n            return;\n        }\n\n        return this._value();\n    },\n\n    values: function( index, newValue ) {\n        var vals,\n            newValues,\n            i;\n\n        if ( arguments.length > 1 ) {\n            this.options.values[ index ] = this._trimAlignValue( newValue );\n            this._refreshValue();\n            this._change( null, index );\n            return;\n        }\n\n        if ( arguments.length ) {\n            if ( $.isArray( arguments[ 0 ] ) ) {\n                vals = this.options.values;\n                newValues = arguments[ 0 ];\n                for ( i = 0; i < vals.length; i += 1 ) {\n                    vals[ i ] = this._trimAlignValue( newValues[ i ] );\n                    this._change( null, i );\n                }\n                this._refreshValue();\n            } else {\n                if ( this.options.values && this.options.values.length ) {\n                    return this._values( index );\n                } else {\n                    return this.value();\n                }\n            }\n        } else {\n            return this._values();\n        }\n    },\n\n    _setOption: function( key, value ) {\n        var i,\n            valsLength = 0;\n\n        if ( key === \"range\" && this.options.range === true ) {\n            if ( value === \"min\" ) {\n                this.options.value = this._values( 0 );\n                this.options.values = null;\n            } else if ( value === \"max\" ) {\n                this.options.value = this._values( this.options.values.length - 1 );\n                this.options.values = null;\n            }\n        }\n\n        if ( $.isArray( this.options.values ) ) {\n            valsLength = this.options.values.length;\n        }\n\n        if ( key === \"disabled\" ) {\n            this.element.toggleClass( \"ui-state-disabled\", !!value );\n        }\n\n        this._super( key, value );\n\n        switch ( key ) {\n            case \"orientation\":\n                this._detectOrientation();\n                this.element\n                    .removeClass( \"ui-slider-horizontal ui-slider-vertical\" )\n                    .addClass( \"ui-slider-\" + this.orientation );\n                this._refreshValue();\n\n                // Reset positioning from previous orientation\n                this.handles.css( value === \"horizontal\" ? \"bottom\" : \"left\", \"\" );\n                break;\n            case \"value\":\n                this._animateOff = true;\n                this._refreshValue();\n                this._change( null, 0 );\n                this._animateOff = false;\n                break;\n            case \"values\":\n                this._animateOff = true;\n                this._refreshValue();\n                for ( i = 0; i < valsLength; i += 1 ) {\n                    this._change( null, i );\n                }\n                this._animateOff = false;\n                break;\n            case \"step\":\n            case \"min\":\n            case \"max\":\n                this._animateOff = true;\n                this._calculateNewMax();\n                this._refreshValue();\n                this._animateOff = false;\n                break;\n            case \"range\":\n                this._animateOff = true;\n                this._refresh();\n                this._animateOff = false;\n                break;\n        }\n    },\n\n    //internal value getter\n    // _value() returns value trimmed by min and max, aligned by step\n    _value: function() {\n        var val = this.options.value;\n        val = this._trimAlignValue( val );\n\n        return val;\n    },\n\n    //internal values getter\n    // _values() returns array of values trimmed by min and max, aligned by step\n    // _values( index ) returns single value trimmed by min and max, aligned by step\n    _values: function( index ) {\n        var val,\n            vals,\n            i;\n\n        if ( arguments.length ) {\n            val = this.options.values[ index ];\n            val = this._trimAlignValue( val );\n\n            return val;\n        } else if ( this.options.values && this.options.values.length ) {\n            // .slice() creates a copy of the array\n            // this copy gets trimmed by min and max and then returned\n            vals = this.options.values.slice();\n            for ( i = 0; i < vals.length; i += 1) {\n                vals[ i ] = this._trimAlignValue( vals[ i ] );\n            }\n\n            return vals;\n        } else {\n            return [];\n        }\n    },\n\n    // returns the step-aligned value that val is closest to, between (inclusive) min and max\n    _trimAlignValue: function( val ) {\n        if ( val <= this._valueMin() ) {\n            return this._valueMin();\n        }\n        if ( val >= this._valueMax() ) {\n            return this._valueMax();\n        }\n        var step = ( this.options.step > 0 ) ? this.options.step : 1,\n            valModStep = (val - this._valueMin()) % step,\n            alignValue = val - valModStep;\n\n        if ( Math.abs(valModStep) * 2 >= step ) {\n            alignValue += ( valModStep > 0 ) ? step : ( -step );\n        }\n\n        // Since JavaScript has problems with large floats, round\n        // the final value to 5 digits after the decimal point (see #4124)\n        return parseFloat( alignValue.toFixed(5) );\n    },\n\n    _calculateNewMax: function() {\n        var remainder = ( this.options.max - this._valueMin() ) % this.options.step;\n        this.max = this.options.max - remainder;\n    },\n\n    _valueMin: function() {\n        return this.options.min;\n    },\n\n    _valueMax: function() {\n        return this.max;\n    },\n\n    _refreshValue: function() {\n        var lastValPercent, valPercent, value, valueMin, valueMax,\n            oRange = this.options.range,\n            o = this.options,\n            that = this,\n            animate = ( !this._animateOff ) ? o.animate : false,\n            _set = {};\n\n        if ( this.options.values && this.options.values.length ) {\n            this.handles.each(function( i ) {\n                valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;\n                _set[ that.orientation === \"horizontal\" ? \"left\" : \"bottom\" ] = valPercent + \"%\";\n                $( this ).stop( 1, 1 )[ animate ? \"animate\" : \"css\" ]( _set, o.animate );\n                if ( that.options.range === true ) {\n                    if ( that.orientation === \"horizontal\" ) {\n                        if ( i === 0 ) {\n                            that.range.stop( 1, 1 )[ animate ? \"animate\" : \"css\" ]( { left: valPercent + \"%\" }, o.animate );\n                        }\n                        if ( i === 1 ) {\n                            that.range[ animate ? \"animate\" : \"css\" ]( { width: ( valPercent - lastValPercent ) + \"%\" }, { queue: false, duration: o.animate } );\n                        }\n                    } else {\n                        if ( i === 0 ) {\n                            that.range.stop( 1, 1 )[ animate ? \"animate\" : \"css\" ]( { bottom: ( valPercent ) + \"%\" }, o.animate );\n                        }\n                        if ( i === 1 ) {\n                            that.range[ animate ? \"animate\" : \"css\" ]( { height: ( valPercent - lastValPercent ) + \"%\" }, { queue: false, duration: o.animate } );\n                        }\n                    }\n                }\n                lastValPercent = valPercent;\n            });\n        } else {\n            value = this.value();\n            valueMin = this._valueMin();\n            valueMax = this._valueMax();\n            valPercent = ( valueMax !== valueMin ) ?\n                    ( value - valueMin ) / ( valueMax - valueMin ) * 100 :\n                    0;\n            _set[ this.orientation === \"horizontal\" ? \"left\" : \"bottom\" ] = valPercent + \"%\";\n            this.handle.stop( 1, 1 )[ animate ? \"animate\" : \"css\" ]( _set, o.animate );\n\n            if ( oRange === \"min\" && this.orientation === \"horizontal\" ) {\n                this.range.stop( 1, 1 )[ animate ? \"animate\" : \"css\" ]( { width: valPercent + \"%\" }, o.animate );\n            }\n            if ( oRange === \"max\" && this.orientation === \"horizontal\" ) {\n                this.range[ animate ? \"animate\" : \"css\" ]( { width: ( 100 - valPercent ) + \"%\" }, { queue: false, duration: o.animate } );\n            }\n            if ( oRange === \"min\" && this.orientation === \"vertical\" ) {\n                this.range.stop( 1, 1 )[ animate ? \"animate\" : \"css\" ]( { height: valPercent + \"%\" }, o.animate );\n            }\n            if ( oRange === \"max\" && this.orientation === \"vertical\" ) {\n                this.range[ animate ? \"animate\" : \"css\" ]( { height: ( 100 - valPercent ) + \"%\" }, { queue: false, duration: o.animate } );\n            }\n        }\n    },\n\n    _handleEvents: {\n        keydown: function( event ) {\n            var allowed, curVal, newVal, step,\n                index = $( event.target ).data( \"ui-slider-handle-index\" );\n\n            switch ( event.keyCode ) {\n                case $.ui.keyCode.HOME:\n                case $.ui.keyCode.END:\n                case $.ui.keyCode.PAGE_UP:\n                case $.ui.keyCode.PAGE_DOWN:\n                case $.ui.keyCode.UP:\n                case $.ui.keyCode.RIGHT:\n                case $.ui.keyCode.DOWN:\n                case $.ui.keyCode.LEFT:\n                    event.preventDefault();\n                    if ( !this._keySliding ) {\n                        this._keySliding = true;\n                        $( event.target ).addClass( \"ui-state-active\" );\n                        allowed = this._start( event, index );\n                        if ( allowed === false ) {\n                            return;\n                        }\n                    }\n                    break;\n            }\n\n            step = this.options.step;\n            if ( this.options.values && this.options.values.length ) {\n                curVal = newVal = this.values( index );\n            } else {\n                curVal = newVal = this.value();\n            }\n\n            switch ( event.keyCode ) {\n                case $.ui.keyCode.HOME:\n                    newVal = this._valueMin();\n                    break;\n                case $.ui.keyCode.END:\n                    newVal = this._valueMax();\n                    break;\n                case $.ui.keyCode.PAGE_UP:\n                    newVal = this._trimAlignValue(\n                        curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )\n                    );\n                    break;\n                case $.ui.keyCode.PAGE_DOWN:\n                    newVal = this._trimAlignValue(\n                        curVal - ( (this._valueMax() - this._valueMin()) / this.numPages ) );\n                    break;\n                case $.ui.keyCode.UP:\n                case $.ui.keyCode.RIGHT:\n                    if ( curVal === this._valueMax() ) {\n                        return;\n                    }\n                    newVal = this._trimAlignValue( curVal + step );\n                    break;\n                case $.ui.keyCode.DOWN:\n                case $.ui.keyCode.LEFT:\n                    if ( curVal === this._valueMin() ) {\n                        return;\n                    }\n                    newVal = this._trimAlignValue( curVal - step );\n                    break;\n            }\n\n            this._slide( event, index, newVal );\n        },\n        keyup: function( event ) {\n            var index = $( event.target ).data( \"ui-slider-handle-index\" );\n\n            if ( this._keySliding ) {\n                this._keySliding = false;\n                this._stop( event, index );\n                this._change( event, index );\n                $( event.target ).removeClass( \"ui-state-active\" );\n            }\n        }\n    }\n});\n\n\n/*!\n * jQuery UI Sortable 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/sortable/\n */\n\n\nvar sortable = $.widget(\"ui.sortable\", $.ui.mouse, {\n    version: \"1.11.2\",\n    widgetEventPrefix: \"sort\",\n    ready: false,\n    options: {\n        appendTo: \"parent\",\n        axis: false,\n        connectWith: false,\n        containment: false,\n        cursor: \"auto\",\n        cursorAt: false,\n        dropOnEmpty: true,\n        forcePlaceholderSize: false,\n        forceHelperSize: false,\n        grid: false,\n        handle: false,\n        helper: \"original\",\n        items: \"> *\",\n        opacity: false,\n        placeholder: false,\n        revert: false,\n        scroll: true,\n        scrollSensitivity: 20,\n        scrollSpeed: 20,\n        scope: \"default\",\n        tolerance: \"intersect\",\n        zIndex: 1000,\n\n        // callbacks\n        activate: null,\n        beforeStop: null,\n        change: null,\n        deactivate: null,\n        out: null,\n        over: null,\n        receive: null,\n        remove: null,\n        sort: null,\n        start: null,\n        stop: null,\n        update: null\n    },\n\n    _isOverAxis: function( x, reference, size ) {\n        return ( x >= reference ) && ( x < ( reference + size ) );\n    },\n\n    _isFloating: function( item ) {\n        return (/left|right/).test(item.css(\"float\")) || (/inline|table-cell/).test(item.css(\"display\"));\n    },\n\n    _create: function() {\n\n        var o = this.options;\n        this.containerCache = {};\n        this.element.addClass(\"ui-sortable\");\n\n        //Get the items\n        this.refresh();\n\n        //Let's determine if the items are being displayed horizontally\n        this.floating = this.items.length ? o.axis === \"x\" || this._isFloating(this.items[0].item) : false;\n\n        //Let's determine the parent's offset\n        this.offset = this.element.offset();\n\n        //Initialize mouse events for interaction\n        this._mouseInit();\n\n        this._setHandleClassName();\n\n        //We're ready to go\n        this.ready = true;\n\n    },\n\n    _setOption: function( key, value ) {\n        this._super( key, value );\n\n        if ( key === \"handle\" ) {\n            this._setHandleClassName();\n        }\n    },\n\n    _setHandleClassName: function() {\n        this.element.find( \".ui-sortable-handle\" ).removeClass( \"ui-sortable-handle\" );\n        $.each( this.items, function() {\n            ( this.instance.options.handle ?\n                this.item.find( this.instance.options.handle ) : this.item )\n                .addClass( \"ui-sortable-handle\" );\n        });\n    },\n\n    _destroy: function() {\n        this.element\n            .removeClass( \"ui-sortable ui-sortable-disabled\" )\n            .find( \".ui-sortable-handle\" )\n                .removeClass( \"ui-sortable-handle\" );\n        this._mouseDestroy();\n\n        for ( var i = this.items.length - 1; i >= 0; i-- ) {\n            this.items[i].item.removeData(this.widgetName + \"-item\");\n        }\n\n        return this;\n    },\n\n    _mouseCapture: function(event, overrideHandle) {\n        var currentItem = null,\n            validHandle = false,\n            that = this;\n\n        if (this.reverting) {\n            return false;\n        }\n\n        if(this.options.disabled || this.options.type === \"static\") {\n            return false;\n        }\n\n        //We have to refresh the items data once first\n        this._refreshItems(event);\n\n        //Find out if the clicked node (or one of its parents) is a actual item in this.items\n        $(event.target).parents().each(function() {\n            if($.data(this, that.widgetName + \"-item\") === that) {\n                currentItem = $(this);\n                return false;\n            }\n        });\n        if($.data(event.target, that.widgetName + \"-item\") === that) {\n            currentItem = $(event.target);\n        }\n\n        if(!currentItem) {\n            return false;\n        }\n        if(this.options.handle && !overrideHandle) {\n            $(this.options.handle, currentItem).find(\"*\").addBack().each(function() {\n                if(this === event.target) {\n                    validHandle = true;\n                }\n            });\n            if(!validHandle) {\n                return false;\n            }\n        }\n\n        this.currentItem = currentItem;\n        this._removeCurrentsFromItems();\n        return true;\n\n    },\n\n    _mouseStart: function(event, overrideHandle, noActivation) {\n\n        var i, body,\n            o = this.options;\n\n        this.currentContainer = this;\n\n        //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture\n        this.refreshPositions();\n\n        //Create and append the visible helper\n        this.helper = this._createHelper(event);\n\n        //Cache the helper size\n        this._cacheHelperProportions();\n\n        /*\n         * - Position generation -\n         * This block generates everything position related - it's the core of draggables.\n         */\n\n        //Cache the margins of the original element\n        this._cacheMargins();\n\n        //Get the next scrolling parent\n        this.scrollParent = this.helper.scrollParent();\n\n        //The element's absolute position on the page minus margins\n        this.offset = this.currentItem.offset();\n        this.offset = {\n            top: this.offset.top - this.margins.top,\n            left: this.offset.left - this.margins.left\n        };\n\n        $.extend(this.offset, {\n            click: { //Where the click happened, relative to the element\n                left: event.pageX - this.offset.left,\n                top: event.pageY - this.offset.top\n            },\n            parent: this._getParentOffset(),\n            relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper\n        });\n\n        // Only after we got the offset, we can change the helper's position to absolute\n        // TODO: Still need to figure out a way to make relative sorting possible\n        this.helper.css(\"position\", \"absolute\");\n        this.cssPosition = this.helper.css(\"position\");\n\n        //Generate the original position\n        this.originalPosition = this._generatePosition(event);\n        this.originalPageX = event.pageX;\n        this.originalPageY = event.pageY;\n\n        //Adjust the mouse offset relative to the helper if \"cursorAt\" is supplied\n        (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\n\n        //Cache the former DOM position\n        this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };\n\n        //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way\n        if(this.helper[0] !== this.currentItem[0]) {\n            this.currentItem.hide();\n        }\n\n        //Create the placeholder\n        this._createPlaceholder();\n\n        //Set a containment if given in the options\n        if(o.containment) {\n            this._setContainment();\n        }\n\n        if( o.cursor && o.cursor !== \"auto\" ) { // cursor option\n            body = this.document.find( \"body\" );\n\n            // support: IE\n            this.storedCursor = body.css( \"cursor\" );\n            body.css( \"cursor\", o.cursor );\n\n            this.storedStylesheet = $( \"<style>*{ cursor: \"+o.cursor+\" !important; }</style>\" ).appendTo( body );\n        }\n\n        if(o.opacity) { // opacity option\n            if (this.helper.css(\"opacity\")) {\n                this._storedOpacity = this.helper.css(\"opacity\");\n            }\n            this.helper.css(\"opacity\", o.opacity);\n        }\n\n        if(o.zIndex) { // zIndex option\n            if (this.helper.css(\"zIndex\")) {\n                this._storedZIndex = this.helper.css(\"zIndex\");\n            }\n            this.helper.css(\"zIndex\", o.zIndex);\n        }\n\n        //Prepare scrolling\n        if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== \"HTML\") {\n            this.overflowOffset = this.scrollParent.offset();\n        }\n\n        //Call callbacks\n        this._trigger(\"start\", event, this._uiHash());\n\n        //Recache the helper size\n        if(!this._preserveHelperProportions) {\n            this._cacheHelperProportions();\n        }\n\n\n        //Post \"activate\" events to possible containers\n        if( !noActivation ) {\n            for ( i = this.containers.length - 1; i >= 0; i-- ) {\n                this.containers[ i ]._trigger( \"activate\", event, this._uiHash( this ) );\n            }\n        }\n\n        //Prepare possible droppables\n        if($.ui.ddmanager) {\n            $.ui.ddmanager.current = this;\n        }\n\n        if ($.ui.ddmanager && !o.dropBehaviour) {\n            $.ui.ddmanager.prepareOffsets(this, event);\n        }\n\n        this.dragging = true;\n\n        this.helper.addClass(\"ui-sortable-helper\");\n        this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position\n        return true;\n\n    },\n\n    _mouseDrag: function(event) {\n        var i, item, itemElement, intersection,\n            o = this.options,\n            scrolled = false;\n\n        //Compute the helpers position\n        this.position = this._generatePosition(event);\n        this.positionAbs = this._convertPositionTo(\"absolute\");\n\n        if (!this.lastPositionAbs) {\n            this.lastPositionAbs = this.positionAbs;\n        }\n\n        //Do scrolling\n        if(this.options.scroll) {\n            if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== \"HTML\") {\n\n                if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {\n                    this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;\n                } else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {\n                    this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;\n                }\n\n                if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {\n                    this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;\n                } else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {\n                    this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;\n                }\n\n            } else {\n\n                if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {\n                    scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\n                } else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {\n                    scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\n                }\n\n                if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {\n                    scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\n                } else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {\n                    scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\n                }\n\n            }\n\n            if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\n                $.ui.ddmanager.prepareOffsets(this, event);\n            }\n        }\n\n        //Regenerate the absolute position used for position checks\n        this.positionAbs = this._convertPositionTo(\"absolute\");\n\n        //Set the helper position\n        if(!this.options.axis || this.options.axis !== \"y\") {\n            this.helper[0].style.left = this.position.left+\"px\";\n        }\n        if(!this.options.axis || this.options.axis !== \"x\") {\n            this.helper[0].style.top = this.position.top+\"px\";\n        }\n\n        //Rearrange\n        for (i = this.items.length - 1; i >= 0; i--) {\n\n            //Cache variables and intersection, continue if no intersection\n            item = this.items[i];\n            itemElement = item.item[0];\n            intersection = this._intersectsWithPointer(item);\n            if (!intersection) {\n                continue;\n            }\n\n            // Only put the placeholder inside the current Container, skip all\n            // items from other containers. This works because when moving\n            // an item from one container to another the\n            // currentContainer is switched before the placeholder is moved.\n            //\n            // Without this, moving items in \"sub-sortables\" can cause\n            // the placeholder to jitter between the outer and inner container.\n            if (item.instance !== this.currentContainer) {\n                continue;\n            }\n\n            // cannot intersect with itself\n            // no useless actions that have been done before\n            // no action if the item moved is the parent of the item checked\n            if (itemElement !== this.currentItem[0] &&\n                this.placeholder[intersection === 1 ? \"next\" : \"prev\"]()[0] !== itemElement &&\n                !$.contains(this.placeholder[0], itemElement) &&\n                (this.options.type === \"semi-dynamic\" ? !$.contains(this.element[0], itemElement) : true)\n            ) {\n\n                this.direction = intersection === 1 ? \"down\" : \"up\";\n\n                if (this.options.tolerance === \"pointer\" || this._intersectsWithSides(item)) {\n                    this._rearrange(event, item);\n                } else {\n                    break;\n                }\n\n                this._trigger(\"change\", event, this._uiHash());\n                break;\n            }\n        }\n\n        //Post events to containers\n        this._contactContainers(event);\n\n        //Interconnect with droppables\n        if($.ui.ddmanager) {\n            $.ui.ddmanager.drag(this, event);\n        }\n\n        //Call callbacks\n        this._trigger(\"sort\", event, this._uiHash());\n\n        this.lastPositionAbs = this.positionAbs;\n        return false;\n\n    },\n\n    _mouseStop: function(event, noPropagation) {\n\n        if(!event) {\n            return;\n        }\n\n        //If we are using droppables, inform the manager about the drop\n        if ($.ui.ddmanager && !this.options.dropBehaviour) {\n            $.ui.ddmanager.drop(this, event);\n        }\n\n        if(this.options.revert) {\n            var that = this,\n                cur = this.placeholder.offset(),\n                axis = this.options.axis,\n                animation = {};\n\n            if ( !axis || axis === \"x\" ) {\n                animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);\n            }\n            if ( !axis || axis === \"y\" ) {\n                animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);\n            }\n            this.reverting = true;\n            $(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {\n                that._clear(event);\n            });\n        } else {\n            this._clear(event, noPropagation);\n        }\n\n        return false;\n\n    },\n\n    cancel: function() {\n\n        if(this.dragging) {\n\n            this._mouseUp({ target: null });\n\n            if(this.options.helper === \"original\") {\n                this.currentItem.css(this._storedCSS).removeClass(\"ui-sortable-helper\");\n            } else {\n                this.currentItem.show();\n            }\n\n            //Post deactivating events to containers\n            for (var i = this.containers.length - 1; i >= 0; i--){\n                this.containers[i]._trigger(\"deactivate\", null, this._uiHash(this));\n                if(this.containers[i].containerCache.over) {\n                    this.containers[i]._trigger(\"out\", null, this._uiHash(this));\n                    this.containers[i].containerCache.over = 0;\n                }\n            }\n\n        }\n\n        if (this.placeholder) {\n            //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n            if(this.placeholder[0].parentNode) {\n                this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n            }\n            if(this.options.helper !== \"original\" && this.helper && this.helper[0].parentNode) {\n                this.helper.remove();\n            }\n\n            $.extend(this, {\n                helper: null,\n                dragging: false,\n                reverting: false,\n                _noFinalSort: null\n            });\n\n            if(this.domPosition.prev) {\n                $(this.domPosition.prev).after(this.currentItem);\n            } else {\n                $(this.domPosition.parent).prepend(this.currentItem);\n            }\n        }\n\n        return this;\n\n    },\n\n    serialize: function(o) {\n\n        var items = this._getItemsAsjQuery(o && o.connected),\n            str = [];\n        o = o || {};\n\n        $(items).each(function() {\n            var res = ($(o.item || this).attr(o.attribute || \"id\") || \"\").match(o.expression || (/(.+)[\\-=_](.+)/));\n            if (res) {\n                str.push((o.key || res[1]+\"[]\")+\"=\"+(o.key && o.expression ? res[1] : res[2]));\n            }\n        });\n\n        if(!str.length && o.key) {\n            str.push(o.key + \"=\");\n        }\n\n        return str.join(\"&\");\n\n    },\n\n    toArray: function(o) {\n\n        var items = this._getItemsAsjQuery(o && o.connected),\n            ret = [];\n\n        o = o || {};\n\n        items.each(function() { ret.push($(o.item || this).attr(o.attribute || \"id\") || \"\"); });\n        return ret;\n\n    },\n\n    /* Be careful with the following core functions */\n    _intersectsWith: function(item) {\n\n        var x1 = this.positionAbs.left,\n            x2 = x1 + this.helperProportions.width,\n            y1 = this.positionAbs.top,\n            y2 = y1 + this.helperProportions.height,\n            l = item.left,\n            r = l + item.width,\n            t = item.top,\n            b = t + item.height,\n            dyClick = this.offset.click.top,\n            dxClick = this.offset.click.left,\n            isOverElementHeight = ( this.options.axis === \"x\" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),\n            isOverElementWidth = ( this.options.axis === \"y\" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),\n            isOverElement = isOverElementHeight && isOverElementWidth;\n\n        if ( this.options.tolerance === \"pointer\" ||\n            this.options.forcePointerForContainers ||\n            (this.options.tolerance !== \"pointer\" && this.helperProportions[this.floating ? \"width\" : \"height\"] > item[this.floating ? \"width\" : \"height\"])\n        ) {\n            return isOverElement;\n        } else {\n\n            return (l < x1 + (this.helperProportions.width / 2) && // Right Half\n                x2 - (this.helperProportions.width / 2) < r && // Left Half\n                t < y1 + (this.helperProportions.height / 2) && // Bottom Half\n                y2 - (this.helperProportions.height / 2) < b ); // Top Half\n\n        }\n    },\n\n    _intersectsWithPointer: function(item) {\n\n        var isOverElementHeight = (this.options.axis === \"x\") || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),\n            isOverElementWidth = (this.options.axis === \"y\") || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),\n            isOverElement = isOverElementHeight && isOverElementWidth,\n            verticalDirection = this._getDragVerticalDirection(),\n            horizontalDirection = this._getDragHorizontalDirection();\n\n        if (!isOverElement) {\n            return false;\n        }\n\n        return this.floating ?\n            ( ((horizontalDirection && horizontalDirection === \"right\") || verticalDirection === \"down\") ? 2 : 1 )\n            : ( verticalDirection && (verticalDirection === \"down\" ? 2 : 1) );\n\n    },\n\n    _intersectsWithSides: function(item) {\n\n        var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),\n            isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),\n            verticalDirection = this._getDragVerticalDirection(),\n            horizontalDirection = this._getDragHorizontalDirection();\n\n        if (this.floating && horizontalDirection) {\n            return ((horizontalDirection === \"right\" && isOverRightHalf) || (horizontalDirection === \"left\" && !isOverRightHalf));\n        } else {\n            return verticalDirection && ((verticalDirection === \"down\" && isOverBottomHalf) || (verticalDirection === \"up\" && !isOverBottomHalf));\n        }\n\n    },\n\n    _getDragVerticalDirection: function() {\n        var delta = this.positionAbs.top - this.lastPositionAbs.top;\n        return delta !== 0 && (delta > 0 ? \"down\" : \"up\");\n    },\n\n    _getDragHorizontalDirection: function() {\n        var delta = this.positionAbs.left - this.lastPositionAbs.left;\n        return delta !== 0 && (delta > 0 ? \"right\" : \"left\");\n    },\n\n    refresh: function(event) {\n        this._refreshItems(event);\n        this._setHandleClassName();\n        this.refreshPositions();\n        return this;\n    },\n\n    _connectWith: function() {\n        var options = this.options;\n        return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;\n    },\n\n    _getItemsAsjQuery: function(connected) {\n\n        var i, j, cur, inst,\n            items = [],\n            queries = [],\n            connectWith = this._connectWith();\n\n        if(connectWith && connected) {\n            for (i = connectWith.length - 1; i >= 0; i--){\n                cur = $(connectWith[i]);\n                for ( j = cur.length - 1; j >= 0; j--){\n                    inst = $.data(cur[j], this.widgetFullName);\n                    if(inst && inst !== this && !inst.options.disabled) {\n                        queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(\".ui-sortable-helper\").not(\".ui-sortable-placeholder\"), inst]);\n                    }\n                }\n            }\n        }\n\n        queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(\".ui-sortable-helper\").not(\".ui-sortable-placeholder\"), this]);\n\n        function addItems() {\n            items.push( this );\n        }\n        for (i = queries.length - 1; i >= 0; i--){\n            queries[i][0].each( addItems );\n        }\n\n        return $(items);\n\n    },\n\n    _removeCurrentsFromItems: function() {\n\n        var list = this.currentItem.find(\":data(\" + this.widgetName + \"-item)\");\n\n        this.items = $.grep(this.items, function (item) {\n            for (var j=0; j < list.length; j++) {\n                if(list[j] === item.item[0]) {\n                    return false;\n                }\n            }\n            return true;\n        });\n\n    },\n\n    _refreshItems: function(event) {\n\n        this.items = [];\n        this.containers = [this];\n\n        var i, j, cur, inst, targetData, _queries, item, queriesLength,\n            items = this.items,\n            queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],\n            connectWith = this._connectWith();\n\n        if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down\n            for (i = connectWith.length - 1; i >= 0; i--){\n                cur = $(connectWith[i]);\n                for (j = cur.length - 1; j >= 0; j--){\n                    inst = $.data(cur[j], this.widgetFullName);\n                    if(inst && inst !== this && !inst.options.disabled) {\n                        queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);\n                        this.containers.push(inst);\n                    }\n                }\n            }\n        }\n\n        for (i = queries.length - 1; i >= 0; i--) {\n            targetData = queries[i][1];\n            _queries = queries[i][0];\n\n            for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {\n                item = $(_queries[j]);\n\n                item.data(this.widgetName + \"-item\", targetData); // Data for target checking (mouse manager)\n\n                items.push({\n                    item: item,\n                    instance: targetData,\n                    width: 0, height: 0,\n                    left: 0, top: 0\n                });\n            }\n        }\n\n    },\n\n    refreshPositions: function(fast) {\n\n        //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change\n        if(this.offsetParent && this.helper) {\n            this.offset.parent = this._getParentOffset();\n        }\n\n        var i, item, t, p;\n\n        for (i = this.items.length - 1; i >= 0; i--){\n            item = this.items[i];\n\n            //We ignore calculating positions of all connected containers when we're not over them\n            if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {\n                continue;\n            }\n\n            t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;\n\n            if (!fast) {\n                item.width = t.outerWidth();\n                item.height = t.outerHeight();\n            }\n\n            p = t.offset();\n            item.left = p.left;\n            item.top = p.top;\n        }\n\n        if(this.options.custom && this.options.custom.refreshContainers) {\n            this.options.custom.refreshContainers.call(this);\n        } else {\n            for (i = this.containers.length - 1; i >= 0; i--){\n                p = this.containers[i].element.offset();\n                this.containers[i].containerCache.left = p.left;\n                this.containers[i].containerCache.top = p.top;\n                this.containers[i].containerCache.width = this.containers[i].element.outerWidth();\n                this.containers[i].containerCache.height = this.containers[i].element.outerHeight();\n            }\n        }\n\n        return this;\n    },\n\n    _createPlaceholder: function(that) {\n        that = that || this;\n        var className,\n            o = that.options;\n\n        if(!o.placeholder || o.placeholder.constructor === String) {\n            className = o.placeholder;\n            o.placeholder = {\n                element: function() {\n\n                    var nodeName = that.currentItem[0].nodeName.toLowerCase(),\n                        element = $( \"<\" + nodeName + \">\", that.document[0] )\n                            .addClass(className || that.currentItem[0].className+\" ui-sortable-placeholder\")\n                            .removeClass(\"ui-sortable-helper\");\n\n                    if ( nodeName === \"tr\" ) {\n                        that.currentItem.children().each(function() {\n                            $( \"<td>&#160;</td>\", that.document[0] )\n                                .attr( \"colspan\", $( this ).attr( \"colspan\" ) || 1 )\n                                .appendTo( element );\n                        });\n                    } else if ( nodeName === \"img\" ) {\n                        element.attr( \"src\", that.currentItem.attr( \"src\" ) );\n                    }\n\n                    if ( !className ) {\n                        element.css( \"visibility\", \"hidden\" );\n                    }\n\n                    return element;\n                },\n                update: function(container, p) {\n\n                    // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that\n                    // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified\n                    if(className && !o.forcePlaceholderSize) {\n                        return;\n                    }\n\n                    //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item\n                    if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css(\"paddingTop\")||0, 10) - parseInt(that.currentItem.css(\"paddingBottom\")||0, 10)); }\n                    if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css(\"paddingLeft\")||0, 10) - parseInt(that.currentItem.css(\"paddingRight\")||0, 10)); }\n                }\n            };\n        }\n\n        //Create the placeholder\n        that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));\n\n        //Append it after the actual current item\n        that.currentItem.after(that.placeholder);\n\n        //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)\n        o.placeholder.update(that, that.placeholder);\n\n    },\n\n    _contactContainers: function(event) {\n        var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis,\n            innermostContainer = null,\n            innermostIndex = null;\n\n        // get innermost container that intersects with item\n        for (i = this.containers.length - 1; i >= 0; i--) {\n\n            // never consider a container that's located within the item itself\n            if($.contains(this.currentItem[0], this.containers[i].element[0])) {\n                continue;\n            }\n\n            if(this._intersectsWith(this.containers[i].containerCache)) {\n\n                // if we've already found a container and it's more \"inner\" than this, then continue\n                if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {\n                    continue;\n                }\n\n                innermostContainer = this.containers[i];\n                innermostIndex = i;\n\n            } else {\n                // container doesn't intersect. trigger \"out\" event if necessary\n                if(this.containers[i].containerCache.over) {\n                    this.containers[i]._trigger(\"out\", event, this._uiHash(this));\n                    this.containers[i].containerCache.over = 0;\n                }\n            }\n\n        }\n\n        // if no intersecting containers found, return\n        if(!innermostContainer) {\n            return;\n        }\n\n        // move the item into the container if it's not there already\n        if(this.containers.length === 1) {\n            if (!this.containers[innermostIndex].containerCache.over) {\n                this.containers[innermostIndex]._trigger(\"over\", event, this._uiHash(this));\n                this.containers[innermostIndex].containerCache.over = 1;\n            }\n        } else {\n\n            //When entering a new container, we will find the item with the least distance and append our item near it\n            dist = 10000;\n            itemWithLeastDistance = null;\n            floating = innermostContainer.floating || this._isFloating(this.currentItem);\n            posProperty = floating ? \"left\" : \"top\";\n            sizeProperty = floating ? \"width\" : \"height\";\n            axis = floating ? \"clientX\" : \"clientY\";\n\n            for (j = this.items.length - 1; j >= 0; j--) {\n                if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {\n                    continue;\n                }\n                if(this.items[j].item[0] === this.currentItem[0]) {\n                    continue;\n                }\n\n                cur = this.items[j].item.offset()[posProperty];\n                nearBottom = false;\n                if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {\n                    nearBottom = true;\n                }\n\n                if ( Math.abs( event[ axis ] - cur ) < dist ) {\n                    dist = Math.abs( event[ axis ] - cur );\n                    itemWithLeastDistance = this.items[ j ];\n                    this.direction = nearBottom ? \"up\": \"down\";\n                }\n            }\n\n            //Check if dropOnEmpty is enabled\n            if(!itemWithLeastDistance && !this.options.dropOnEmpty) {\n                return;\n            }\n\n            if(this.currentContainer === this.containers[innermostIndex]) {\n                if ( !this.currentContainer.containerCache.over ) {\n                    this.containers[ innermostIndex ]._trigger( \"over\", event, this._uiHash() );\n                    this.currentContainer.containerCache.over = 1;\n                }\n                return;\n            }\n\n            itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);\n            this._trigger(\"change\", event, this._uiHash());\n            this.containers[innermostIndex]._trigger(\"change\", event, this._uiHash(this));\n            this.currentContainer = this.containers[innermostIndex];\n\n            //Update the placeholder\n            this.options.placeholder.update(this.currentContainer, this.placeholder);\n\n            this.containers[innermostIndex]._trigger(\"over\", event, this._uiHash(this));\n            this.containers[innermostIndex].containerCache.over = 1;\n        }\n\n\n    },\n\n    _createHelper: function(event) {\n\n        var o = this.options,\n            helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === \"clone\" ? this.currentItem.clone() : this.currentItem);\n\n        //Add the helper to the DOM if that didn't happen already\n        if(!helper.parents(\"body\").length) {\n            $(o.appendTo !== \"parent\" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);\n        }\n\n        if(helper[0] === this.currentItem[0]) {\n            this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css(\"position\"), top: this.currentItem.css(\"top\"), left: this.currentItem.css(\"left\") };\n        }\n\n        if(!helper[0].style.width || o.forceHelperSize) {\n            helper.width(this.currentItem.width());\n        }\n        if(!helper[0].style.height || o.forceHelperSize) {\n            helper.height(this.currentItem.height());\n        }\n\n        return helper;\n\n    },\n\n    _adjustOffsetFromHelper: function(obj) {\n        if (typeof obj === \"string\") {\n            obj = obj.split(\" \");\n        }\n        if ($.isArray(obj)) {\n            obj = {left: +obj[0], top: +obj[1] || 0};\n        }\n        if (\"left\" in obj) {\n            this.offset.click.left = obj.left + this.margins.left;\n        }\n        if (\"right\" in obj) {\n            this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\n        }\n        if (\"top\" in obj) {\n            this.offset.click.top = obj.top + this.margins.top;\n        }\n        if (\"bottom\" in obj) {\n            this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\n        }\n    },\n\n    _getParentOffset: function() {\n\n\n        //Get the offsetParent and cache its position\n        this.offsetParent = this.helper.offsetParent();\n        var po = this.offsetParent.offset();\n\n        // This is a special case where we need to modify a offset calculated on start, since the following happened:\n        // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\n        // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\n        //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\n        if(this.cssPosition === \"absolute\" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {\n            po.left += this.scrollParent.scrollLeft();\n            po.top += this.scrollParent.scrollTop();\n        }\n\n        // This needs to be actually done for all browsers, since pageX/pageY includes this information\n        // with an ugly IE fix\n        if( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === \"html\" && $.ui.ie)) {\n            po = { top: 0, left: 0 };\n        }\n\n        return {\n            top: po.top + (parseInt(this.offsetParent.css(\"borderTopWidth\"),10) || 0),\n            left: po.left + (parseInt(this.offsetParent.css(\"borderLeftWidth\"),10) || 0)\n        };\n\n    },\n\n    _getRelativeOffset: function() {\n\n        if(this.cssPosition === \"relative\") {\n            var p = this.currentItem.position();\n            return {\n                top: p.top - (parseInt(this.helper.css(\"top\"),10) || 0) + this.scrollParent.scrollTop(),\n                left: p.left - (parseInt(this.helper.css(\"left\"),10) || 0) + this.scrollParent.scrollLeft()\n            };\n        } else {\n            return { top: 0, left: 0 };\n        }\n\n    },\n\n    _cacheMargins: function() {\n        this.margins = {\n            left: (parseInt(this.currentItem.css(\"marginLeft\"),10) || 0),\n            top: (parseInt(this.currentItem.css(\"marginTop\"),10) || 0)\n        };\n    },\n\n    _cacheHelperProportions: function() {\n        this.helperProportions = {\n            width: this.helper.outerWidth(),\n            height: this.helper.outerHeight()\n        };\n    },\n\n    _setContainment: function() {\n\n        var ce, co, over,\n            o = this.options;\n        if(o.containment === \"parent\") {\n            o.containment = this.helper[0].parentNode;\n        }\n        if(o.containment === \"document\" || o.containment === \"window\") {\n            this.containment = [\n                0 - this.offset.relative.left - this.offset.parent.left,\n                0 - this.offset.relative.top - this.offset.parent.top,\n                $(o.containment === \"document\" ? document : window).width() - this.helperProportions.width - this.margins.left,\n                ($(o.containment === \"document\" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top\n            ];\n        }\n\n        if(!(/^(document|window|parent)$/).test(o.containment)) {\n            ce = $(o.containment)[0];\n            co = $(o.containment).offset();\n            over = ($(ce).css(\"overflow\") !== \"hidden\");\n\n            this.containment = [\n                co.left + (parseInt($(ce).css(\"borderLeftWidth\"),10) || 0) + (parseInt($(ce).css(\"paddingLeft\"),10) || 0) - this.margins.left,\n                co.top + (parseInt($(ce).css(\"borderTopWidth\"),10) || 0) + (parseInt($(ce).css(\"paddingTop\"),10) || 0) - this.margins.top,\n                co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(\"borderLeftWidth\"),10) || 0) - (parseInt($(ce).css(\"paddingRight\"),10) || 0) - this.helperProportions.width - this.margins.left,\n                co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(\"borderTopWidth\"),10) || 0) - (parseInt($(ce).css(\"paddingBottom\"),10) || 0) - this.helperProportions.height - this.margins.top\n            ];\n        }\n\n    },\n\n    _convertPositionTo: function(d, pos) {\n\n        if(!pos) {\n            pos = this.position;\n        }\n        var mod = d === \"absolute\" ? 1 : -1,\n            scroll = this.cssPosition === \"absolute\" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,\n            scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\n\n        return {\n            top: (\n                pos.top    +                                                                // The absolute mouse position\n                this.offset.relative.top * mod +                                        // Only for relative positioned nodes: Relative offset from element to offset parent\n                this.offset.parent.top * mod -                                            // The offsetParent's offset without borders (offset + border)\n                ( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)\n            ),\n            left: (\n                pos.left +                                                                // The absolute mouse position\n                this.offset.relative.left * mod +                                        // Only for relative positioned nodes: Relative offset from element to offset parent\n                this.offset.parent.left * mod    -                                        // The offsetParent's offset without borders (offset + border)\n                ( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)\n            )\n        };\n\n    },\n\n    _generatePosition: function(event) {\n\n        var top, left,\n            o = this.options,\n            pageX = event.pageX,\n            pageY = event.pageY,\n            scroll = this.cssPosition === \"absolute\" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\n\n        // This is another very weird special case that only happens for relative elements:\n        // 1. If the css position is relative\n        // 2. and the scroll parent is the document or similar to the offset parent\n        // we have to refresh the relative offset during the scroll so there are no jumps\n        if(this.cssPosition === \"relative\" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {\n            this.offset.relative = this._getRelativeOffset();\n        }\n\n        /*\n         * - Position constraining -\n         * Constrain the position to a mix of grid, containment.\n         */\n\n        if(this.originalPosition) { //If we are not dragging yet, we won't check for options\n\n            if(this.containment) {\n                if(event.pageX - this.offset.click.left < this.containment[0]) {\n                    pageX = this.containment[0] + this.offset.click.left;\n                }\n                if(event.pageY - this.offset.click.top < this.containment[1]) {\n                    pageY = this.containment[1] + this.offset.click.top;\n                }\n                if(event.pageX - this.offset.click.left > this.containment[2]) {\n                    pageX = this.containment[2] + this.offset.click.left;\n                }\n                if(event.pageY - this.offset.click.top > this.containment[3]) {\n                    pageY = this.containment[3] + this.offset.click.top;\n                }\n            }\n\n            if(o.grid) {\n                top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];\n                pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\n\n                left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];\n                pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\n            }\n\n        }\n\n        return {\n            top: (\n                pageY -                                                                // The absolute mouse position\n                this.offset.click.top -                                                    // Click offset (relative to the element)\n                this.offset.relative.top    -                                            // Only for relative positioned nodes: Relative offset from element to offset parent\n                this.offset.parent.top +                                                // The offsetParent's offset without borders (offset + border)\n                ( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))\n            ),\n            left: (\n                pageX -                                                                // The absolute mouse position\n                this.offset.click.left -                                                // Click offset (relative to the element)\n                this.offset.relative.left    -                                            // Only for relative positioned nodes: Relative offset from element to offset parent\n                this.offset.parent.left +                                                // The offsetParent's offset without borders (offset + border)\n                ( ( this.cssPosition === \"fixed\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))\n            )\n        };\n\n    },\n\n    _rearrange: function(event, i, a, hardRefresh) {\n\n        a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === \"down\" ? i.item[0] : i.item[0].nextSibling));\n\n        //Various things done here to improve the performance:\n        // 1. we create a setTimeout, that calls refreshPositions\n        // 2. on the instance, we have a counter variable, that get's higher after every append\n        // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same\n        // 4. this lets only the last addition to the timeout stack through\n        this.counter = this.counter ? ++this.counter : 1;\n        var counter = this.counter;\n\n        this._delay(function() {\n            if(counter === this.counter) {\n                this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove\n            }\n        });\n\n    },\n\n    _clear: function(event, noPropagation) {\n\n        this.reverting = false;\n        // We delay all events that have to be triggered to after the point where the placeholder has been removed and\n        // everything else normalized again\n        var i,\n            delayedTriggers = [];\n\n        // We first have to update the dom position of the actual currentItem\n        // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)\n        if(!this._noFinalSort && this.currentItem.parent().length) {\n            this.placeholder.before(this.currentItem);\n        }\n        this._noFinalSort = null;\n\n        if(this.helper[0] === this.currentItem[0]) {\n            for(i in this._storedCSS) {\n                if(this._storedCSS[i] === \"auto\" || this._storedCSS[i] === \"static\") {\n                    this._storedCSS[i] = \"\";\n                }\n            }\n            this.currentItem.css(this._storedCSS).removeClass(\"ui-sortable-helper\");\n        } else {\n            this.currentItem.show();\n        }\n\n        if(this.fromOutside && !noPropagation) {\n            delayedTriggers.push(function(event) { this._trigger(\"receive\", event, this._uiHash(this.fromOutside)); });\n        }\n        if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(\".ui-sortable-helper\")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {\n            delayedTriggers.push(function(event) { this._trigger(\"update\", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed\n        }\n\n        // Check if the items Container has Changed and trigger appropriate\n        // events.\n        if (this !== this.currentContainer) {\n            if(!noPropagation) {\n                delayedTriggers.push(function(event) { this._trigger(\"remove\", event, this._uiHash()); });\n                delayedTriggers.push((function(c) { return function(event) { c._trigger(\"receive\", event, this._uiHash(this)); };  }).call(this, this.currentContainer));\n                delayedTriggers.push((function(c) { return function(event) { c._trigger(\"update\", event, this._uiHash(this));  }; }).call(this, this.currentContainer));\n            }\n        }\n\n\n        //Post events to containers\n        function delayEvent( type, instance, container ) {\n            return function( event ) {\n                container._trigger( type, event, instance._uiHash( instance ) );\n            };\n        }\n        for (i = this.containers.length - 1; i >= 0; i--){\n            if (!noPropagation) {\n                delayedTriggers.push( delayEvent( \"deactivate\", this, this.containers[ i ] ) );\n            }\n            if(this.containers[i].containerCache.over) {\n                delayedTriggers.push( delayEvent( \"out\", this, this.containers[ i ] ) );\n                this.containers[i].containerCache.over = 0;\n            }\n        }\n\n        //Do what was originally in plugins\n        if ( this.storedCursor ) {\n            this.document.find( \"body\" ).css( \"cursor\", this.storedCursor );\n            this.storedStylesheet.remove();\n        }\n        if(this._storedOpacity) {\n            this.helper.css(\"opacity\", this._storedOpacity);\n        }\n        if(this._storedZIndex) {\n            this.helper.css(\"zIndex\", this._storedZIndex === \"auto\" ? \"\" : this._storedZIndex);\n        }\n\n        this.dragging = false;\n\n        if(!noPropagation) {\n            this._trigger(\"beforeStop\", event, this._uiHash());\n        }\n\n        //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\n        this.placeholder[0].parentNode.removeChild(this.placeholder[0]);\n\n        if ( !this.cancelHelperRemoval ) {\n            if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {\n                this.helper.remove();\n            }\n            this.helper = null;\n        }\n\n        if(!noPropagation) {\n            for (i=0; i < delayedTriggers.length; i++) {\n                delayedTriggers[i].call(this, event);\n            } //Trigger all delayed events\n            this._trigger(\"stop\", event, this._uiHash());\n        }\n\n        this.fromOutside = false;\n        return !this.cancelHelperRemoval;\n\n    },\n\n    _trigger: function() {\n        if ($.Widget.prototype._trigger.apply(this, arguments) === false) {\n            this.cancel();\n        }\n    },\n\n    _uiHash: function(_inst) {\n        var inst = _inst || this;\n        return {\n            helper: inst.helper,\n            placeholder: inst.placeholder || $([]),\n            position: inst.position,\n            originalPosition: inst.originalPosition,\n            offset: inst.positionAbs,\n            item: inst.currentItem,\n            sender: _inst ? _inst.element : null\n        };\n    }\n\n});\n\n\n/*!\n * jQuery UI Spinner 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/spinner/\n */\n\n\nfunction spinner_modifier( fn ) {\n    return function() {\n        var previous = this.element.val();\n        fn.apply( this, arguments );\n        this._refresh();\n        if ( previous !== this.element.val() ) {\n            this._trigger( \"change\" );\n        }\n    };\n}\n\nvar spinner = $.widget( \"ui.spinner\", {\n    version: \"1.11.2\",\n    defaultElement: \"<input>\",\n    widgetEventPrefix: \"spin\",\n    options: {\n        culture: null,\n        icons: {\n            down: \"ui-icon-triangle-1-s\",\n            up: \"ui-icon-triangle-1-n\"\n        },\n        incremental: true,\n        max: null,\n        min: null,\n        numberFormat: null,\n        page: 10,\n        step: 1,\n\n        change: null,\n        spin: null,\n        start: null,\n        stop: null\n    },\n\n    _create: function() {\n        // handle string values that need to be parsed\n        this._setOption( \"max\", this.options.max );\n        this._setOption( \"min\", this.options.min );\n        this._setOption( \"step\", this.options.step );\n\n        // Only format if there is a value, prevents the field from being marked\n        // as invalid in Firefox, see #9573.\n        if ( this.value() !== \"\" ) {\n            // Format the value, but don't constrain.\n            this._value( this.element.val(), true );\n        }\n\n        this._draw();\n        this._on( this._events );\n        this._refresh();\n\n        // turning off autocomplete prevents the browser from remembering the\n        // value when navigating through history, so we re-enable autocomplete\n        // if the page is unloaded before the widget is destroyed. #7790\n        this._on( this.window, {\n            beforeunload: function() {\n                this.element.removeAttr( \"autocomplete\" );\n            }\n        });\n    },\n\n    _getCreateOptions: function() {\n        var options = {},\n            element = this.element;\n\n        $.each( [ \"min\", \"max\", \"step\" ], function( i, option ) {\n            var value = element.attr( option );\n            if ( value !== undefined && value.length ) {\n                options[ option ] = value;\n            }\n        });\n\n        return options;\n    },\n\n    _events: {\n        keydown: function( event ) {\n            if ( this._start( event ) && this._keydown( event ) ) {\n                event.preventDefault();\n            }\n        },\n        keyup: \"_stop\",\n        focus: function() {\n            this.previous = this.element.val();\n        },\n        blur: function( event ) {\n            if ( this.cancelBlur ) {\n                delete this.cancelBlur;\n                return;\n            }\n\n            this._stop();\n            this._refresh();\n            if ( this.previous !== this.element.val() ) {\n                this._trigger( \"change\", event );\n            }\n        },\n        mousewheel: function( event, delta ) {\n            if ( !delta ) {\n                return;\n            }\n            if ( !this.spinning && !this._start( event ) ) {\n                return false;\n            }\n\n            this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );\n            clearTimeout( this.mousewheelTimer );\n            this.mousewheelTimer = this._delay(function() {\n                if ( this.spinning ) {\n                    this._stop( event );\n                }\n            }, 100 );\n            event.preventDefault();\n        },\n        \"mousedown .ui-spinner-button\": function( event ) {\n            var previous;\n\n            // We never want the buttons to have focus; whenever the user is\n            // interacting with the spinner, the focus should be on the input.\n            // If the input is focused then this.previous is properly set from\n            // when the input first received focus. If the input is not focused\n            // then we need to set this.previous based on the value before spinning.\n            previous = this.element[0] === this.document[0].activeElement ?\n                this.previous : this.element.val();\n            function checkFocus() {\n                var isActive = this.element[0] === this.document[0].activeElement;\n                if ( !isActive ) {\n                    this.element.focus();\n                    this.previous = previous;\n                    // support: IE\n                    // IE sets focus asynchronously, so we need to check if focus\n                    // moved off of the input because the user clicked on the button.\n                    this._delay(function() {\n                        this.previous = previous;\n                    });\n                }\n            }\n\n            // ensure focus is on (or stays on) the text field\n            event.preventDefault();\n            checkFocus.call( this );\n\n            // support: IE\n            // IE doesn't prevent moving focus even with event.preventDefault()\n            // so we set a flag to know when we should ignore the blur event\n            // and check (again) if focus moved off of the input.\n            this.cancelBlur = true;\n            this._delay(function() {\n                delete this.cancelBlur;\n                checkFocus.call( this );\n            });\n\n            if ( this._start( event ) === false ) {\n                return;\n            }\n\n            this._repeat( null, $( event.currentTarget ).hasClass( \"ui-spinner-up\" ) ? 1 : -1, event );\n        },\n        \"mouseup .ui-spinner-button\": \"_stop\",\n        \"mouseenter .ui-spinner-button\": function( event ) {\n            // button will add ui-state-active if mouse was down while mouseleave and kept down\n            if ( !$( event.currentTarget ).hasClass( \"ui-state-active\" ) ) {\n                return;\n            }\n\n            if ( this._start( event ) === false ) {\n                return false;\n            }\n            this._repeat( null, $( event.currentTarget ).hasClass( \"ui-spinner-up\" ) ? 1 : -1, event );\n        },\n        // TODO: do we really want to consider this a stop?\n        // shouldn't we just stop the repeater and wait until mouseup before\n        // we trigger the stop event?\n        \"mouseleave .ui-spinner-button\": \"_stop\"\n    },\n\n    _draw: function() {\n        var uiSpinner = this.uiSpinner = this.element\n            .addClass( \"ui-spinner-input\" )\n            .attr( \"autocomplete\", \"off\" )\n            .wrap( this._uiSpinnerHtml() )\n            .parent()\n                // add buttons\n                .append( this._buttonHtml() );\n\n        this.element.attr( \"role\", \"spinbutton\" );\n\n        // button bindings\n        this.buttons = uiSpinner.find( \".ui-spinner-button\" )\n            .attr( \"tabIndex\", -1 )\n            .button()\n            .removeClass( \"ui-corner-all\" );\n\n        // IE 6 doesn't understand height: 50% for the buttons\n        // unless the wrapper has an explicit height\n        if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&\n                uiSpinner.height() > 0 ) {\n            uiSpinner.height( uiSpinner.height() );\n        }\n\n        // disable spinner if element was already disabled\n        if ( this.options.disabled ) {\n            this.disable();\n        }\n    },\n\n    _keydown: function( event ) {\n        var options = this.options,\n            keyCode = $.ui.keyCode;\n\n        switch ( event.keyCode ) {\n        case keyCode.UP:\n            this._repeat( null, 1, event );\n            return true;\n        case keyCode.DOWN:\n            this._repeat( null, -1, event );\n            return true;\n        case keyCode.PAGE_UP:\n            this._repeat( null, options.page, event );\n            return true;\n        case keyCode.PAGE_DOWN:\n            this._repeat( null, -options.page, event );\n            return true;\n        }\n\n        return false;\n    },\n\n    _uiSpinnerHtml: function() {\n        return \"<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>\";\n    },\n\n    _buttonHtml: function() {\n        return \"\" +\n            \"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>\" +\n                \"<span class='ui-icon \" + this.options.icons.up + \"'>&#9650;</span>\" +\n            \"</a>\" +\n            \"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>\" +\n                \"<span class='ui-icon \" + this.options.icons.down + \"'>&#9660;</span>\" +\n            \"</a>\";\n    },\n\n    _start: function( event ) {\n        if ( !this.spinning && this._trigger( \"start\", event ) === false ) {\n            return false;\n        }\n\n        if ( !this.counter ) {\n            this.counter = 1;\n        }\n        this.spinning = true;\n        return true;\n    },\n\n    _repeat: function( i, steps, event ) {\n        i = i || 500;\n\n        clearTimeout( this.timer );\n        this.timer = this._delay(function() {\n            this._repeat( 40, steps, event );\n        }, i );\n\n        this._spin( steps * this.options.step, event );\n    },\n\n    _spin: function( step, event ) {\n        var value = this.value() || 0;\n\n        if ( !this.counter ) {\n            this.counter = 1;\n        }\n\n        value = this._adjustValue( value + step * this._increment( this.counter ) );\n\n        if ( !this.spinning || this._trigger( \"spin\", event, { value: value } ) !== false) {\n            this._value( value );\n            this.counter++;\n        }\n    },\n\n    _increment: function( i ) {\n        var incremental = this.options.incremental;\n\n        if ( incremental ) {\n            return $.isFunction( incremental ) ?\n                incremental( i ) :\n                Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );\n        }\n\n        return 1;\n    },\n\n    _precision: function() {\n        var precision = this._precisionOf( this.options.step );\n        if ( this.options.min !== null ) {\n            precision = Math.max( precision, this._precisionOf( this.options.min ) );\n        }\n        return precision;\n    },\n\n    _precisionOf: function( num ) {\n        var str = num.toString(),\n            decimal = str.indexOf( \".\" );\n        return decimal === -1 ? 0 : str.length - decimal - 1;\n    },\n\n    _adjustValue: function( value ) {\n        var base, aboveMin,\n            options = this.options;\n\n        // make sure we're at a valid step\n        // - find out where we are relative to the base (min or 0)\n        base = options.min !== null ? options.min : 0;\n        aboveMin = value - base;\n        // - round to the nearest step\n        aboveMin = Math.round(aboveMin / options.step) * options.step;\n        // - rounding is based on 0, so adjust back to our base\n        value = base + aboveMin;\n\n        // fix precision from bad JS floating point math\n        value = parseFloat( value.toFixed( this._precision() ) );\n\n        // clamp the value\n        if ( options.max !== null && value > options.max) {\n            return options.max;\n        }\n        if ( options.min !== null && value < options.min ) {\n            return options.min;\n        }\n\n        return value;\n    },\n\n    _stop: function( event ) {\n        if ( !this.spinning ) {\n            return;\n        }\n\n        clearTimeout( this.timer );\n        clearTimeout( this.mousewheelTimer );\n        this.counter = 0;\n        this.spinning = false;\n        this._trigger( \"stop\", event );\n    },\n\n    _setOption: function( key, value ) {\n        if ( key === \"culture\" || key === \"numberFormat\" ) {\n            var prevValue = this._parse( this.element.val() );\n            this.options[ key ] = value;\n            this.element.val( this._format( prevValue ) );\n            return;\n        }\n\n        if ( key === \"max\" || key === \"min\" || key === \"step\" ) {\n            if ( typeof value === \"string\" ) {\n                value = this._parse( value );\n            }\n        }\n        if ( key === \"icons\" ) {\n            this.buttons.first().find( \".ui-icon\" )\n                .removeClass( this.options.icons.up )\n                .addClass( value.up );\n            this.buttons.last().find( \".ui-icon\" )\n                .removeClass( this.options.icons.down )\n                .addClass( value.down );\n        }\n\n        this._super( key, value );\n\n        if ( key === \"disabled\" ) {\n            this.widget().toggleClass( \"ui-state-disabled\", !!value );\n            this.element.prop( \"disabled\", !!value );\n            this.buttons.button( value ? \"disable\" : \"enable\" );\n        }\n    },\n\n    _setOptions: spinner_modifier(function( options ) {\n        this._super( options );\n    }),\n\n    _parse: function( val ) {\n        if ( typeof val === \"string\" && val !== \"\" ) {\n            val = window.Globalize && this.options.numberFormat ?\n                Globalize.parseFloat( val, 10, this.options.culture ) : +val;\n        }\n        return val === \"\" || isNaN( val ) ? null : val;\n    },\n\n    _format: function( value ) {\n        if ( value === \"\" ) {\n            return \"\";\n        }\n        return window.Globalize && this.options.numberFormat ?\n            Globalize.format( value, this.options.numberFormat, this.options.culture ) :\n            value;\n    },\n\n    _refresh: function() {\n        this.element.attr({\n            \"aria-valuemin\": this.options.min,\n            \"aria-valuemax\": this.options.max,\n            // TODO: what should we do with values that can't be parsed?\n            \"aria-valuenow\": this._parse( this.element.val() )\n        });\n    },\n\n    isValid: function() {\n        var value = this.value();\n\n        // null is invalid\n        if ( value === null ) {\n            return false;\n        }\n\n        // if value gets adjusted, it's invalid\n        return value === this._adjustValue( value );\n    },\n\n    // update the value without triggering change\n    _value: function( value, allowAny ) {\n        var parsed;\n        if ( value !== \"\" ) {\n            parsed = this._parse( value );\n            if ( parsed !== null ) {\n                if ( !allowAny ) {\n                    parsed = this._adjustValue( parsed );\n                }\n                value = this._format( parsed );\n            }\n        }\n        this.element.val( value );\n        this._refresh();\n    },\n\n    _destroy: function() {\n        this.element\n            .removeClass( \"ui-spinner-input\" )\n            .prop( \"disabled\", false )\n            .removeAttr( \"autocomplete\" )\n            .removeAttr( \"role\" )\n            .removeAttr( \"aria-valuemin\" )\n            .removeAttr( \"aria-valuemax\" )\n            .removeAttr( \"aria-valuenow\" );\n        this.uiSpinner.replaceWith( this.element );\n    },\n\n    stepUp: spinner_modifier(function( steps ) {\n        this._stepUp( steps );\n    }),\n    _stepUp: function( steps ) {\n        if ( this._start() ) {\n            this._spin( (steps || 1) * this.options.step );\n            this._stop();\n        }\n    },\n\n    stepDown: spinner_modifier(function( steps ) {\n        this._stepDown( steps );\n    }),\n    _stepDown: function( steps ) {\n        if ( this._start() ) {\n            this._spin( (steps || 1) * -this.options.step );\n            this._stop();\n        }\n    },\n\n    pageUp: spinner_modifier(function( pages ) {\n        this._stepUp( (pages || 1) * this.options.page );\n    }),\n\n    pageDown: spinner_modifier(function( pages ) {\n        this._stepDown( (pages || 1) * this.options.page );\n    }),\n\n    value: function( newVal ) {\n        if ( !arguments.length ) {\n            return this._parse( this.element.val() );\n        }\n        spinner_modifier( this._value ).call( this, newVal );\n    },\n\n    widget: function() {\n        return this.uiSpinner;\n    }\n});\n\n\n/*!\n * jQuery UI Tabs 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/tabs/\n */\n\n\nvar tabs = $.widget( \"ui.tabs\", {\n    version: \"1.11.2\",\n    delay: 300,\n    options: {\n        active: null,\n        collapsible: false,\n        event: \"click\",\n        heightStyle: \"content\",\n        hide: null,\n        show: null,\n\n        // callbacks\n        activate: null,\n        beforeActivate: null,\n        beforeLoad: null,\n        load: null\n    },\n\n    _isLocal: (function() {\n        var rhash = /#.*$/;\n\n        return function( anchor ) {\n            var anchorUrl, locationUrl;\n\n            // support: IE7\n            // IE7 doesn't normalize the href property when set via script (#9317)\n            anchor = anchor.cloneNode( false );\n\n            anchorUrl = anchor.href.replace( rhash, \"\" );\n            locationUrl = location.href.replace( rhash, \"\" );\n\n            // decoding may throw an error if the URL isn't UTF-8 (#9518)\n            try {\n                anchorUrl = decodeURIComponent( anchorUrl );\n            } catch ( error ) {}\n            try {\n                locationUrl = decodeURIComponent( locationUrl );\n            } catch ( error ) {}\n\n            return anchor.hash.length > 1 && anchorUrl === locationUrl;\n        };\n    })(),\n\n    _create: function() {\n        var that = this,\n            options = this.options;\n\n        this.running = false;\n\n        this.element\n            .addClass( \"ui-tabs ui-widget ui-widget-content ui-corner-all\" )\n            .toggleClass( \"ui-tabs-collapsible\", options.collapsible );\n\n        this._processTabs();\n        options.active = this._initialActive();\n\n        // Take disabling tabs via class attribute from HTML\n        // into account and update option properly.\n        if ( $.isArray( options.disabled ) ) {\n            options.disabled = $.unique( options.disabled.concat(\n                $.map( this.tabs.filter( \".ui-state-disabled\" ), function( li ) {\n                    return that.tabs.index( li );\n                })\n            ) ).sort();\n        }\n\n        // check for length avoids error when initializing empty list\n        if ( this.options.active !== false && this.anchors.length ) {\n            this.active = this._findActive( options.active );\n        } else {\n            this.active = $();\n        }\n\n        this._refresh();\n\n        if ( this.active.length ) {\n            this.load( options.active );\n        }\n    },\n\n    _initialActive: function() {\n        var active = this.options.active,\n            collapsible = this.options.collapsible,\n            locationHash = location.hash.substring( 1 );\n\n        if ( active === null ) {\n            // check the fragment identifier in the URL\n            if ( locationHash ) {\n                this.tabs.each(function( i, tab ) {\n                    if ( $( tab ).attr( \"aria-controls\" ) === locationHash ) {\n                        active = i;\n                        return false;\n                    }\n                });\n            }\n\n            // check for a tab marked active via a class\n            if ( active === null ) {\n                active = this.tabs.index( this.tabs.filter( \".ui-tabs-active\" ) );\n            }\n\n            // no active tab, set to false\n            if ( active === null || active === -1 ) {\n                active = this.tabs.length ? 0 : false;\n            }\n        }\n\n        // handle numbers: negative, out of range\n        if ( active !== false ) {\n            active = this.tabs.index( this.tabs.eq( active ) );\n            if ( active === -1 ) {\n                active = collapsible ? false : 0;\n            }\n        }\n\n        // don't allow collapsible: false and active: false\n        if ( !collapsible && active === false && this.anchors.length ) {\n            active = 0;\n        }\n\n        return active;\n    },\n\n    _getCreateEventData: function() {\n        return {\n            tab: this.active,\n            panel: !this.active.length ? $() : this._getPanelForTab( this.active )\n        };\n    },\n\n    _tabKeydown: function( event ) {\n        var focusedTab = $( this.document[0].activeElement ).closest( \"li\" ),\n            selectedIndex = this.tabs.index( focusedTab ),\n            goingForward = true;\n\n        if ( this._handlePageNav( event ) ) {\n            return;\n        }\n\n        switch ( event.keyCode ) {\n            case $.ui.keyCode.RIGHT:\n            case $.ui.keyCode.DOWN:\n                selectedIndex++;\n                break;\n            case $.ui.keyCode.UP:\n            case $.ui.keyCode.LEFT:\n                goingForward = false;\n                selectedIndex--;\n                break;\n            case $.ui.keyCode.END:\n                selectedIndex = this.anchors.length - 1;\n                break;\n            case $.ui.keyCode.HOME:\n                selectedIndex = 0;\n                break;\n            case $.ui.keyCode.SPACE:\n                // Activate only, no collapsing\n                event.preventDefault();\n                clearTimeout( this.activating );\n                this._activate( selectedIndex );\n                return;\n            case $.ui.keyCode.ENTER:\n                // Toggle (cancel delayed activation, allow collapsing)\n                event.preventDefault();\n                clearTimeout( this.activating );\n                // Determine if we should collapse or activate\n                this._activate( selectedIndex === this.options.active ? false : selectedIndex );\n                return;\n            default:\n                return;\n        }\n\n        // Focus the appropriate tab, based on which key was pressed\n        event.preventDefault();\n        clearTimeout( this.activating );\n        selectedIndex = this._focusNextTab( selectedIndex, goingForward );\n\n        // Navigating with control key will prevent automatic activation\n        if ( !event.ctrlKey ) {\n            // Update aria-selected immediately so that AT think the tab is already selected.\n            // Otherwise AT may confuse the user by stating that they need to activate the tab,\n            // but the tab will already be activated by the time the announcement finishes.\n            focusedTab.attr( \"aria-selected\", \"false\" );\n            this.tabs.eq( selectedIndex ).attr( \"aria-selected\", \"true\" );\n\n            this.activating = this._delay(function() {\n                this.option( \"active\", selectedIndex );\n            }, this.delay );\n        }\n    },\n\n    _panelKeydown: function( event ) {\n        if ( this._handlePageNav( event ) ) {\n            return;\n        }\n\n        // Ctrl+up moves focus to the current tab\n        if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {\n            event.preventDefault();\n            this.active.focus();\n        }\n    },\n\n    // Alt+page up/down moves focus to the previous/next tab (and activates)\n    _handlePageNav: function( event ) {\n        if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {\n            this._activate( this._focusNextTab( this.options.active - 1, false ) );\n            return true;\n        }\n        if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {\n            this._activate( this._focusNextTab( this.options.active + 1, true ) );\n            return true;\n        }\n    },\n\n    _findNextTab: function( index, goingForward ) {\n        var lastTabIndex = this.tabs.length - 1;\n\n        function constrain() {\n            if ( index > lastTabIndex ) {\n                index = 0;\n            }\n            if ( index < 0 ) {\n                index = lastTabIndex;\n            }\n            return index;\n        }\n\n        while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {\n            index = goingForward ? index + 1 : index - 1;\n        }\n\n        return index;\n    },\n\n    _focusNextTab: function( index, goingForward ) {\n        index = this._findNextTab( index, goingForward );\n        this.tabs.eq( index ).focus();\n        return index;\n    },\n\n    _setOption: function( key, value ) {\n        if ( key === \"active\" ) {\n            // _activate() will handle invalid values and update this.options\n            this._activate( value );\n            return;\n        }\n\n        if ( key === \"disabled\" ) {\n            // don't use the widget factory's disabled handling\n            this._setupDisabled( value );\n            return;\n        }\n\n        this._super( key, value);\n\n        if ( key === \"collapsible\" ) {\n            this.element.toggleClass( \"ui-tabs-collapsible\", value );\n            // Setting collapsible: false while collapsed; open first panel\n            if ( !value && this.options.active === false ) {\n                this._activate( 0 );\n            }\n        }\n\n        if ( key === \"event\" ) {\n            this._setupEvents( value );\n        }\n\n        if ( key === \"heightStyle\" ) {\n            this._setupHeightStyle( value );\n        }\n    },\n\n    _sanitizeSelector: function( hash ) {\n        return hash ? hash.replace( /[!\"$%&'()*+,.\\/:;<=>?@\\[\\]\\^`{|}~]/g, \"\\\\$&\" ) : \"\";\n    },\n\n    refresh: function() {\n        var options = this.options,\n            lis = this.tablist.children( \":has(a[href])\" );\n\n        // get disabled tabs from class attribute from HTML\n        // this will get converted to a boolean if needed in _refresh()\n        options.disabled = $.map( lis.filter( \".ui-state-disabled\" ), function( tab ) {\n            return lis.index( tab );\n        });\n\n        this._processTabs();\n\n        // was collapsed or no tabs\n        if ( options.active === false || !this.anchors.length ) {\n            options.active = false;\n            this.active = $();\n        // was active, but active tab is gone\n        } else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {\n            // all remaining tabs are disabled\n            if ( this.tabs.length === options.disabled.length ) {\n                options.active = false;\n                this.active = $();\n            // activate previous tab\n            } else {\n                this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );\n            }\n        // was active, active tab still exists\n        } else {\n            // make sure active index is correct\n            options.active = this.tabs.index( this.active );\n        }\n\n        this._refresh();\n    },\n\n    _refresh: function() {\n        this._setupDisabled( this.options.disabled );\n        this._setupEvents( this.options.event );\n        this._setupHeightStyle( this.options.heightStyle );\n\n        this.tabs.not( this.active ).attr({\n            \"aria-selected\": \"false\",\n            \"aria-expanded\": \"false\",\n            tabIndex: -1\n        });\n        this.panels.not( this._getPanelForTab( this.active ) )\n            .hide()\n            .attr({\n                \"aria-hidden\": \"true\"\n            });\n\n        // Make sure one tab is in the tab order\n        if ( !this.active.length ) {\n            this.tabs.eq( 0 ).attr( \"tabIndex\", 0 );\n        } else {\n            this.active\n                .addClass( \"ui-tabs-active ui-state-active\" )\n                .attr({\n                    \"aria-selected\": \"true\",\n                    \"aria-expanded\": \"true\",\n                    tabIndex: 0\n                });\n            this._getPanelForTab( this.active )\n                .show()\n                .attr({\n                    \"aria-hidden\": \"false\"\n                });\n        }\n    },\n\n    _processTabs: function() {\n        var that = this,\n            prevTabs = this.tabs,\n            prevAnchors = this.anchors,\n            prevPanels = this.panels;\n\n        this.tablist = this._getList()\n            .addClass( \"ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all\" )\n            .attr( \"role\", \"tablist\" )\n\n            // Prevent users from focusing disabled tabs via click\n            .delegate( \"> li\", \"mousedown\" + this.eventNamespace, function( event ) {\n                if ( $( this ).is( \".ui-state-disabled\" ) ) {\n                    event.preventDefault();\n                }\n            })\n\n            // support: IE <9\n            // Preventing the default action in mousedown doesn't prevent IE\n            // from focusing the element, so if the anchor gets focused, blur.\n            // We don't have to worry about focusing the previously focused\n            // element since clicking on a non-focusable element should focus\n            // the body anyway.\n            .delegate( \".ui-tabs-anchor\", \"focus\" + this.eventNamespace, function() {\n                if ( $( this ).closest( \"li\" ).is( \".ui-state-disabled\" ) ) {\n                    this.blur();\n                }\n            });\n\n        this.tabs = this.tablist.find( \"> li:has(a[href])\" )\n            .addClass( \"ui-state-default ui-corner-top\" )\n            .attr({\n                role: \"tab\",\n                tabIndex: -1\n            });\n\n        this.anchors = this.tabs.map(function() {\n                return $( \"a\", this )[ 0 ];\n            })\n            .addClass( \"ui-tabs-anchor\" )\n            .attr({\n                role: \"presentation\",\n                tabIndex: -1\n            });\n\n        this.panels = $();\n\n        this.anchors.each(function( i, anchor ) {\n            var selector, panel, panelId,\n                anchorId = $( anchor ).uniqueId().attr( \"id\" ),\n                tab = $( anchor ).closest( \"li\" ),\n                originalAriaControls = tab.attr( \"aria-controls\" );\n\n            // inline tab\n            if ( that._isLocal( anchor ) ) {\n                selector = anchor.hash;\n                panelId = selector.substring( 1 );\n                panel = that.element.find( that._sanitizeSelector( selector ) );\n            // remote tab\n            } else {\n                // If the tab doesn't already have aria-controls,\n                // generate an id by using a throw-away element\n                panelId = tab.attr( \"aria-controls\" ) || $( {} ).uniqueId()[ 0 ].id;\n                selector = \"#\" + panelId;\n                panel = that.element.find( selector );\n                if ( !panel.length ) {\n                    panel = that._createPanel( panelId );\n                    panel.insertAfter( that.panels[ i - 1 ] || that.tablist );\n                }\n                panel.attr( \"aria-live\", \"polite\" );\n            }\n\n            if ( panel.length) {\n                that.panels = that.panels.add( panel );\n            }\n            if ( originalAriaControls ) {\n                tab.data( \"ui-tabs-aria-controls\", originalAriaControls );\n            }\n            tab.attr({\n                \"aria-controls\": panelId,\n                \"aria-labelledby\": anchorId\n            });\n            panel.attr( \"aria-labelledby\", anchorId );\n        });\n\n        this.panels\n            .addClass( \"ui-tabs-panel ui-widget-content ui-corner-bottom\" )\n            .attr( \"role\", \"tabpanel\" );\n\n        // Avoid memory leaks (#10056)\n        if ( prevTabs ) {\n            this._off( prevTabs.not( this.tabs ) );\n            this._off( prevAnchors.not( this.anchors ) );\n            this._off( prevPanels.not( this.panels ) );\n        }\n    },\n\n    // allow overriding how to find the list for rare usage scenarios (#7715)\n    _getList: function() {\n        return this.tablist || this.element.find( \"ol,ul\" ).eq( 0 );\n    },\n\n    _createPanel: function( id ) {\n        return $( \"<div>\" )\n            .attr( \"id\", id )\n            .addClass( \"ui-tabs-panel ui-widget-content ui-corner-bottom\" )\n            .data( \"ui-tabs-destroy\", true );\n    },\n\n    _setupDisabled: function( disabled ) {\n        if ( $.isArray( disabled ) ) {\n            if ( !disabled.length ) {\n                disabled = false;\n            } else if ( disabled.length === this.anchors.length ) {\n                disabled = true;\n            }\n        }\n\n        // disable tabs\n        for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {\n            if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {\n                $( li )\n                    .addClass( \"ui-state-disabled\" )\n                    .attr( \"aria-disabled\", \"true\" );\n            } else {\n                $( li )\n                    .removeClass( \"ui-state-disabled\" )\n                    .removeAttr( \"aria-disabled\" );\n            }\n        }\n\n        this.options.disabled = disabled;\n    },\n\n    _setupEvents: function( event ) {\n        var events = {};\n        if ( event ) {\n            $.each( event.split(\" \"), function( index, eventName ) {\n                events[ eventName ] = \"_eventHandler\";\n            });\n        }\n\n        this._off( this.anchors.add( this.tabs ).add( this.panels ) );\n        // Always prevent the default action, even when disabled\n        this._on( true, this.anchors, {\n            click: function( event ) {\n                event.preventDefault();\n            }\n        });\n        this._on( this.anchors, events );\n        this._on( this.tabs, { keydown: \"_tabKeydown\" } );\n        this._on( this.panels, { keydown: \"_panelKeydown\" } );\n\n        this._focusable( this.tabs );\n        this._hoverable( this.tabs );\n    },\n\n    _setupHeightStyle: function( heightStyle ) {\n        var maxHeight,\n            parent = this.element.parent();\n\n        if ( heightStyle === \"fill\" ) {\n            maxHeight = parent.height();\n            maxHeight -= this.element.outerHeight() - this.element.height();\n\n            this.element.siblings( \":visible\" ).each(function() {\n                var elem = $( this ),\n                    position = elem.css( \"position\" );\n\n                if ( position === \"absolute\" || position === \"fixed\" ) {\n                    return;\n                }\n                maxHeight -= elem.outerHeight( true );\n            });\n\n            this.element.children().not( this.panels ).each(function() {\n                maxHeight -= $( this ).outerHeight( true );\n            });\n\n            this.panels.each(function() {\n                $( this ).height( Math.max( 0, maxHeight -\n                    $( this ).innerHeight() + $( this ).height() ) );\n            })\n            .css( \"overflow\", \"auto\" );\n        } else if ( heightStyle === \"auto\" ) {\n            maxHeight = 0;\n            this.panels.each(function() {\n                maxHeight = Math.max( maxHeight, $( this ).height( \"\" ).height() );\n            }).height( maxHeight );\n        }\n    },\n\n    _eventHandler: function( event ) {\n        var options = this.options,\n            active = this.active,\n            anchor = $( event.currentTarget ),\n            tab = anchor.closest( \"li\" ),\n            clickedIsActive = tab[ 0 ] === active[ 0 ],\n            collapsing = clickedIsActive && options.collapsible,\n            toShow = collapsing ? $() : this._getPanelForTab( tab ),\n            toHide = !active.length ? $() : this._getPanelForTab( active ),\n            eventData = {\n                oldTab: active,\n                oldPanel: toHide,\n                newTab: collapsing ? $() : tab,\n                newPanel: toShow\n            };\n\n        event.preventDefault();\n\n        if ( tab.hasClass( \"ui-state-disabled\" ) ||\n                // tab is already loading\n                tab.hasClass( \"ui-tabs-loading\" ) ||\n                // can't switch durning an animation\n                this.running ||\n                // click on active header, but not collapsible\n                ( clickedIsActive && !options.collapsible ) ||\n                // allow canceling activation\n                ( this._trigger( \"beforeActivate\", event, eventData ) === false ) ) {\n            return;\n        }\n\n        options.active = collapsing ? false : this.tabs.index( tab );\n\n        this.active = clickedIsActive ? $() : tab;\n        if ( this.xhr ) {\n            this.xhr.abort();\n        }\n\n        if ( !toHide.length && !toShow.length ) {\n            $.error( \"jQuery UI Tabs: Mismatching fragment identifier.\" );\n        }\n\n        if ( toShow.length ) {\n            this.load( this.tabs.index( tab ), event );\n        }\n        this._toggle( event, eventData );\n    },\n\n    // handles show/hide for selecting tabs\n    _toggle: function( event, eventData ) {\n        var that = this,\n            toShow = eventData.newPanel,\n            toHide = eventData.oldPanel;\n\n        this.running = true;\n\n        function complete() {\n            that.running = false;\n            that._trigger( \"activate\", event, eventData );\n        }\n\n        function show() {\n            eventData.newTab.closest( \"li\" ).addClass( \"ui-tabs-active ui-state-active\" );\n\n            if ( toShow.length && that.options.show ) {\n                that._show( toShow, that.options.show, complete );\n            } else {\n                toShow.show();\n                complete();\n            }\n        }\n\n        // start out by hiding, then showing, then completing\n        if ( toHide.length && this.options.hide ) {\n            this._hide( toHide, this.options.hide, function() {\n                eventData.oldTab.closest( \"li\" ).removeClass( \"ui-tabs-active ui-state-active\" );\n                show();\n            });\n        } else {\n            eventData.oldTab.closest( \"li\" ).removeClass( \"ui-tabs-active ui-state-active\" );\n            toHide.hide();\n            show();\n        }\n\n        toHide.attr( \"aria-hidden\", \"true\" );\n        eventData.oldTab.attr({\n            \"aria-selected\": \"false\",\n            \"aria-expanded\": \"false\"\n        });\n        // If we're switching tabs, remove the old tab from the tab order.\n        // If we're opening from collapsed state, remove the previous tab from the tab order.\n        // If we're collapsing, then keep the collapsing tab in the tab order.\n        if ( toShow.length && toHide.length ) {\n            eventData.oldTab.attr( \"tabIndex\", -1 );\n        } else if ( toShow.length ) {\n            this.tabs.filter(function() {\n                return $( this ).attr( \"tabIndex\" ) === 0;\n            })\n            .attr( \"tabIndex\", -1 );\n        }\n\n        toShow.attr( \"aria-hidden\", \"false\" );\n        eventData.newTab.attr({\n            \"aria-selected\": \"true\",\n            \"aria-expanded\": \"true\",\n            tabIndex: 0\n        });\n    },\n\n    _activate: function( index ) {\n        var anchor,\n            active = this._findActive( index );\n\n        // trying to activate the already active panel\n        if ( active[ 0 ] === this.active[ 0 ] ) {\n            return;\n        }\n\n        // trying to collapse, simulate a click on the current active header\n        if ( !active.length ) {\n            active = this.active;\n        }\n\n        anchor = active.find( \".ui-tabs-anchor\" )[ 0 ];\n        this._eventHandler({\n            target: anchor,\n            currentTarget: anchor,\n            preventDefault: $.noop\n        });\n    },\n\n    _findActive: function( index ) {\n        return index === false ? $() : this.tabs.eq( index );\n    },\n\n    _getIndex: function( index ) {\n        // meta-function to give users option to provide a href string instead of a numerical index.\n        if ( typeof index === \"string\" ) {\n            index = this.anchors.index( this.anchors.filter( \"[href$='\" + index + \"']\" ) );\n        }\n\n        return index;\n    },\n\n    _destroy: function() {\n        if ( this.xhr ) {\n            this.xhr.abort();\n        }\n\n        this.element.removeClass( \"ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible\" );\n\n        this.tablist\n            .removeClass( \"ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all\" )\n            .removeAttr( \"role\" );\n\n        this.anchors\n            .removeClass( \"ui-tabs-anchor\" )\n            .removeAttr( \"role\" )\n            .removeAttr( \"tabIndex\" )\n            .removeUniqueId();\n\n        this.tablist.unbind( this.eventNamespace );\n\n        this.tabs.add( this.panels ).each(function() {\n            if ( $.data( this, \"ui-tabs-destroy\" ) ) {\n                $( this ).remove();\n            } else {\n                $( this )\n                    .removeClass( \"ui-state-default ui-state-active ui-state-disabled \" +\n                        \"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel\" )\n                    .removeAttr( \"tabIndex\" )\n                    .removeAttr( \"aria-live\" )\n                    .removeAttr( \"aria-busy\" )\n                    .removeAttr( \"aria-selected\" )\n                    .removeAttr( \"aria-labelledby\" )\n                    .removeAttr( \"aria-hidden\" )\n                    .removeAttr( \"aria-expanded\" )\n                    .removeAttr( \"role\" );\n            }\n        });\n\n        this.tabs.each(function() {\n            var li = $( this ),\n                prev = li.data( \"ui-tabs-aria-controls\" );\n            if ( prev ) {\n                li\n                    .attr( \"aria-controls\", prev )\n                    .removeData( \"ui-tabs-aria-controls\" );\n            } else {\n                li.removeAttr( \"aria-controls\" );\n            }\n        });\n\n        this.panels.show();\n\n        if ( this.options.heightStyle !== \"content\" ) {\n            this.panels.css( \"height\", \"\" );\n        }\n    },\n\n    enable: function( index ) {\n        var disabled = this.options.disabled;\n        if ( disabled === false ) {\n            return;\n        }\n\n        if ( index === undefined ) {\n            disabled = false;\n        } else {\n            index = this._getIndex( index );\n            if ( $.isArray( disabled ) ) {\n                disabled = $.map( disabled, function( num ) {\n                    return num !== index ? num : null;\n                });\n            } else {\n                disabled = $.map( this.tabs, function( li, num ) {\n                    return num !== index ? num : null;\n                });\n            }\n        }\n        this._setupDisabled( disabled );\n    },\n\n    disable: function( index ) {\n        var disabled = this.options.disabled;\n        if ( disabled === true ) {\n            return;\n        }\n\n        if ( index === undefined ) {\n            disabled = true;\n        } else {\n            index = this._getIndex( index );\n            if ( $.inArray( index, disabled ) !== -1 ) {\n                return;\n            }\n            if ( $.isArray( disabled ) ) {\n                disabled = $.merge( [ index ], disabled ).sort();\n            } else {\n                disabled = [ index ];\n            }\n        }\n        this._setupDisabled( disabled );\n    },\n\n    load: function( index, event ) {\n        index = this._getIndex( index );\n        var that = this,\n            tab = this.tabs.eq( index ),\n            anchor = tab.find( \".ui-tabs-anchor\" ),\n            panel = this._getPanelForTab( tab ),\n            eventData = {\n                tab: tab,\n                panel: panel\n            };\n\n        // not remote\n        if ( this._isLocal( anchor[ 0 ] ) ) {\n            return;\n        }\n\n        this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );\n\n        // support: jQuery <1.8\n        // jQuery <1.8 returns false if the request is canceled in beforeSend,\n        // but as of 1.8, $.ajax() always returns a jqXHR object.\n        if ( this.xhr && this.xhr.statusText !== \"canceled\" ) {\n            tab.addClass( \"ui-tabs-loading\" );\n            panel.attr( \"aria-busy\", \"true\" );\n\n            this.xhr\n                .success(function( response ) {\n                    // support: jQuery <1.8\n                    // http://bugs.jquery.com/ticket/11778\n                    setTimeout(function() {\n                        panel.html( response );\n                        that._trigger( \"load\", event, eventData );\n                    }, 1 );\n                })\n                .complete(function( jqXHR, status ) {\n                    // support: jQuery <1.8\n                    // http://bugs.jquery.com/ticket/11778\n                    setTimeout(function() {\n                        if ( status === \"abort\" ) {\n                            that.panels.stop( false, true );\n                        }\n\n                        tab.removeClass( \"ui-tabs-loading\" );\n                        panel.removeAttr( \"aria-busy\" );\n\n                        if ( jqXHR === that.xhr ) {\n                            delete that.xhr;\n                        }\n                    }, 1 );\n                });\n        }\n    },\n\n    _ajaxSettings: function( anchor, event, eventData ) {\n        var that = this;\n        return {\n            url: anchor.attr( \"href\" ),\n            beforeSend: function( jqXHR, settings ) {\n                return that._trigger( \"beforeLoad\", event,\n                    $.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );\n            }\n        };\n    },\n\n    _getPanelForTab: function( tab ) {\n        var id = $( tab ).attr( \"aria-controls\" );\n        return this.element.find( this._sanitizeSelector( \"#\" + id ) );\n    }\n});\n\n\n/*!\n * jQuery UI Tooltip 1.11.2\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/tooltip/\n */\n\n\nvar tooltip = $.widget( \"ui.tooltip\", {\n    version: \"1.11.2\",\n    options: {\n        content: function() {\n            // support: IE<9, Opera in jQuery <1.7\n            // .text() can't accept undefined, so coerce to a string\n            var title = $( this ).attr( \"title\" ) || \"\";\n            // Escape title, since we're going from an attribute to raw HTML\n            return $( \"<a>\" ).text( title ).html();\n        },\n        hide: true,\n        // Disabled elements have inconsistent behavior across browsers (#8661)\n        items: \"[title]:not([disabled])\",\n        position: {\n            my: \"left top+15\",\n            at: \"left bottom\",\n            collision: \"flipfit flip\"\n        },\n        show: true,\n        tooltipClass: null,\n        track: false,\n\n        // callbacks\n        close: null,\n        open: null\n    },\n\n    _addDescribedBy: function( elem, id ) {\n        var describedby = (elem.attr( \"aria-describedby\" ) || \"\").split( /\\s+/ );\n        describedby.push( id );\n        elem\n            .data( \"ui-tooltip-id\", id )\n            .attr( \"aria-describedby\", $.trim( describedby.join( \" \" ) ) );\n    },\n\n    _removeDescribedBy: function( elem ) {\n        var id = elem.data( \"ui-tooltip-id\" ),\n            describedby = (elem.attr( \"aria-describedby\" ) || \"\").split( /\\s+/ ),\n            index = $.inArray( id, describedby );\n\n        if ( index !== -1 ) {\n            describedby.splice( index, 1 );\n        }\n\n        elem.removeData( \"ui-tooltip-id\" );\n        describedby = $.trim( describedby.join( \" \" ) );\n        if ( describedby ) {\n            elem.attr( \"aria-describedby\", describedby );\n        } else {\n            elem.removeAttr( \"aria-describedby\" );\n        }\n    },\n\n    _create: function() {\n        this._on({\n            mouseover: \"open\",\n            focusin: \"open\"\n        });\n\n        // IDs of generated tooltips, needed for destroy\n        this.tooltips = {};\n\n        // IDs of parent tooltips where we removed the title attribute\n        this.parents = {};\n\n        if ( this.options.disabled ) {\n            this._disable();\n        }\n\n        // Append the aria-live region so tooltips announce correctly\n        this.liveRegion = $( \"<div>\" )\n            .attr({\n                role: \"log\",\n                \"aria-live\": \"assertive\",\n                \"aria-relevant\": \"additions\"\n            })\n            .addClass( \"ui-helper-hidden-accessible\" )\n            .appendTo( this.document[ 0 ].body );\n    },\n\n    _setOption: function( key, value ) {\n        var that = this;\n\n        if ( key === \"disabled\" ) {\n            this[ value ? \"_disable\" : \"_enable\" ]();\n            this.options[ key ] = value;\n            // disable element style changes\n            return;\n        }\n\n        this._super( key, value );\n\n        if ( key === \"content\" ) {\n            $.each( this.tooltips, function( id, tooltipData ) {\n                that._updateContent( tooltipData.element );\n            });\n        }\n    },\n\n    _disable: function() {\n        var that = this;\n\n        // close open tooltips\n        $.each( this.tooltips, function( id, tooltipData ) {\n            var event = $.Event( \"blur\" );\n            event.target = event.currentTarget = tooltipData.element[ 0 ];\n            that.close( event, true );\n        });\n\n        // remove title attributes to prevent native tooltips\n        this.element.find( this.options.items ).addBack().each(function() {\n            var element = $( this );\n            if ( element.is( \"[title]\" ) ) {\n                element\n                    .data( \"ui-tooltip-title\", element.attr( \"title\" ) )\n                    .removeAttr( \"title\" );\n            }\n        });\n    },\n\n    _enable: function() {\n        // restore title attributes\n        this.element.find( this.options.items ).addBack().each(function() {\n            var element = $( this );\n            if ( element.data( \"ui-tooltip-title\" ) ) {\n                element.attr( \"title\", element.data( \"ui-tooltip-title\" ) );\n            }\n        });\n    },\n\n    open: function( event ) {\n        var that = this,\n            target = $( event ? event.target : this.element )\n                // we need closest here due to mouseover bubbling,\n                // but always pointing at the same event target\n                .closest( this.options.items );\n\n        // No element to show a tooltip for or the tooltip is already open\n        if ( !target.length || target.data( \"ui-tooltip-id\" ) ) {\n            return;\n        }\n\n        if ( target.attr( \"title\" ) ) {\n            target.data( \"ui-tooltip-title\", target.attr( \"title\" ) );\n        }\n\n        target.data( \"ui-tooltip-open\", true );\n\n        // kill parent tooltips, custom or native, for hover\n        if ( event && event.type === \"mouseover\" ) {\n            target.parents().each(function() {\n                var parent = $( this ),\n                    blurEvent;\n                if ( parent.data( \"ui-tooltip-open\" ) ) {\n                    blurEvent = $.Event( \"blur\" );\n                    blurEvent.target = blurEvent.currentTarget = this;\n                    that.close( blurEvent, true );\n                }\n                if ( parent.attr( \"title\" ) ) {\n                    parent.uniqueId();\n                    that.parents[ this.id ] = {\n                        element: this,\n                        title: parent.attr( \"title\" )\n                    };\n                    parent.attr( \"title\", \"\" );\n                }\n            });\n        }\n\n        this._updateContent( target, event );\n    },\n\n    _updateContent: function( target, event ) {\n        var content,\n            contentOption = this.options.content,\n            that = this,\n            eventType = event ? event.type : null;\n\n        if ( typeof contentOption === \"string\" ) {\n            return this._open( event, target, contentOption );\n        }\n\n        content = contentOption.call( target[0], function( response ) {\n            // ignore async response if tooltip was closed already\n            if ( !target.data( \"ui-tooltip-open\" ) ) {\n                return;\n            }\n            // IE may instantly serve a cached response for ajax requests\n            // delay this call to _open so the other call to _open runs first\n            that._delay(function() {\n                // jQuery creates a special event for focusin when it doesn't\n                // exist natively. To improve performance, the native event\n                // object is reused and the type is changed. Therefore, we can't\n                // rely on the type being correct after the event finished\n                // bubbling, so we set it back to the previous value. (#8740)\n                if ( event ) {\n                    event.type = eventType;\n                }\n                this._open( event, target, response );\n            });\n        });\n        if ( content ) {\n            this._open( event, target, content );\n        }\n    },\n\n    _open: function( event, target, content ) {\n        var tooltipData, tooltip, events, delayedShow, a11yContent,\n            positionOption = $.extend( {}, this.options.position );\n\n        if ( !content ) {\n            return;\n        }\n\n        // Content can be updated multiple times. If the tooltip already\n        // exists, then just update the content and bail.\n        tooltipData = this._find( target );\n        if ( tooltipData ) {\n            tooltipData.tooltip.find( \".ui-tooltip-content\" ).html( content );\n            return;\n        }\n\n        // if we have a title, clear it to prevent the native tooltip\n        // we have to check first to avoid defining a title if none exists\n        // (we don't want to cause an element to start matching [title])\n        //\n        // We use removeAttr only for key events, to allow IE to export the correct\n        // accessible attributes. For mouse events, set to empty string to avoid\n        // native tooltip showing up (happens only when removing inside mouseover).\n        if ( target.is( \"[title]\" ) ) {\n            if ( event && event.type === \"mouseover\" ) {\n                target.attr( \"title\", \"\" );\n            } else {\n                target.removeAttr( \"title\" );\n            }\n        }\n\n        tooltipData = this._tooltip( target );\n        tooltip = tooltipData.tooltip;\n        this._addDescribedBy( target, tooltip.attr( \"id\" ) );\n        tooltip.find( \".ui-tooltip-content\" ).html( content );\n\n        // Support: Voiceover on OS X, JAWS on IE <= 9\n        // JAWS announces deletions even when aria-relevant=\"additions\"\n        // Voiceover will sometimes re-read the entire log region's contents from the beginning\n        this.liveRegion.children().hide();\n        if ( content.clone ) {\n            a11yContent = content.clone();\n            a11yContent.removeAttr( \"id\" ).find( \"[id]\" ).removeAttr( \"id\" );\n        } else {\n            a11yContent = content;\n        }\n        $( \"<div>\" ).html( a11yContent ).appendTo( this.liveRegion );\n\n        function position( event ) {\n            positionOption.of = event;\n            if ( tooltip.is( \":hidden\" ) ) {\n                return;\n            }\n            tooltip.position( positionOption );\n        }\n        if ( this.options.track && event && /^mouse/.test( event.type ) ) {\n            this._on( this.document, {\n                mousemove: position\n            });\n            // trigger once to override element-relative positioning\n            position( event );\n        } else {\n            tooltip.position( $.extend({\n                of: target\n            }, this.options.position ) );\n        }\n\n        tooltip.hide();\n\n        this._show( tooltip, this.options.show );\n        // Handle tracking tooltips that are shown with a delay (#8644). As soon\n        // as the tooltip is visible, position the tooltip using the most recent\n        // event.\n        if ( this.options.show && this.options.show.delay ) {\n            delayedShow = this.delayedShow = setInterval(function() {\n                if ( tooltip.is( \":visible\" ) ) {\n                    position( positionOption.of );\n                    clearInterval( delayedShow );\n                }\n            }, $.fx.interval );\n        }\n\n        this._trigger( \"open\", event, { tooltip: tooltip } );\n\n        events = {\n            keyup: function( event ) {\n                if ( event.keyCode === $.ui.keyCode.ESCAPE ) {\n                    var fakeEvent = $.Event(event);\n                    fakeEvent.currentTarget = target[0];\n                    this.close( fakeEvent, true );\n                }\n            }\n        };\n\n        // Only bind remove handler for delegated targets. Non-delegated\n        // tooltips will handle this in destroy.\n        if ( target[ 0 ] !== this.element[ 0 ] ) {\n            events.remove = function() {\n                this._removeTooltip( tooltip );\n            };\n        }\n\n        if ( !event || event.type === \"mouseover\" ) {\n            events.mouseleave = \"close\";\n        }\n        if ( !event || event.type === \"focusin\" ) {\n            events.focusout = \"close\";\n        }\n        this._on( true, target, events );\n    },\n\n    close: function( event ) {\n        var tooltip,\n            that = this,\n            target = $( event ? event.currentTarget : this.element ),\n            tooltipData = this._find( target );\n\n        // The tooltip may already be closed\n        if ( !tooltipData ) {\n            return;\n        }\n\n        tooltip = tooltipData.tooltip;\n\n        // disabling closes the tooltip, so we need to track when we're closing\n        // to avoid an infinite loop in case the tooltip becomes disabled on close\n        if ( tooltipData.closing ) {\n            return;\n        }\n\n        // Clear the interval for delayed tracking tooltips\n        clearInterval( this.delayedShow );\n\n        // only set title if we had one before (see comment in _open())\n        // If the title attribute has changed since open(), don't restore\n        if ( target.data( \"ui-tooltip-title\" ) && !target.attr( \"title\" ) ) {\n            target.attr( \"title\", target.data( \"ui-tooltip-title\" ) );\n        }\n\n        this._removeDescribedBy( target );\n\n        tooltipData.hiding = true;\n        tooltip.stop( true );\n        this._hide( tooltip, this.options.hide, function() {\n            that._removeTooltip( $( this ) );\n        });\n\n        target.removeData( \"ui-tooltip-open\" );\n        this._off( target, \"mouseleave focusout keyup\" );\n\n        // Remove 'remove' binding only on delegated targets\n        if ( target[ 0 ] !== this.element[ 0 ] ) {\n            this._off( target, \"remove\" );\n        }\n        this._off( this.document, \"mousemove\" );\n\n        if ( event && event.type === \"mouseleave\" ) {\n            $.each( this.parents, function( id, parent ) {\n                $( parent.element ).attr( \"title\", parent.title );\n                delete that.parents[ id ];\n            });\n        }\n\n        tooltipData.closing = true;\n        this._trigger( \"close\", event, { tooltip: tooltip } );\n        if ( !tooltipData.hiding ) {\n            tooltipData.closing = false;\n        }\n    },\n\n    _tooltip: function( element ) {\n        var tooltip = $( \"<div>\" )\n                .attr( \"role\", \"tooltip\" )\n                .addClass( \"ui-tooltip ui-widget ui-corner-all ui-widget-content \" +\n                    ( this.options.tooltipClass || \"\" ) ),\n            id = tooltip.uniqueId().attr( \"id\" );\n\n        $( \"<div>\" )\n            .addClass( \"ui-tooltip-content\" )\n            .appendTo( tooltip );\n\n        tooltip.appendTo( this.document[0].body );\n\n        return this.tooltips[ id ] = {\n            element: element,\n            tooltip: tooltip\n        };\n    },\n\n    _find: function( target ) {\n        var id = target.data( \"ui-tooltip-id\" );\n        return id ? this.tooltips[ id ] : null;\n    },\n\n    _removeTooltip: function( tooltip ) {\n        tooltip.remove();\n        delete this.tooltips[ tooltip.attr( \"id\" ) ];\n    },\n\n    _destroy: function() {\n        var that = this;\n\n        // close open tooltips\n        $.each( this.tooltips, function( id, tooltipData ) {\n            // Delegate to close method to handle common cleanup\n            var event = $.Event( \"blur\" ),\n                element = tooltipData.element;\n            event.target = event.currentTarget = element[ 0 ];\n            that.close( event, true );\n\n            // Remove immediately; destroying an open tooltip doesn't use the\n            // hide animation\n            $( \"#\" + id ).remove();\n\n            // Restore the title\n            if ( element.data( \"ui-tooltip-title\" ) ) {\n                // If the title attribute has changed since open(), don't restore\n                if ( !element.attr( \"title\" ) ) {\n                    element.attr( \"title\", element.data( \"ui-tooltip-title\" ) );\n                }\n                element.removeData( \"ui-tooltip-title\" );\n            }\n        });\n        this.liveRegion.remove();\n    }\n});\n\n\n\n}));"], "locale": [".py", "def getdefaultlocale():\n return __BRYTHON__.language,None\n \ndef localeconv():\n \"\"\n \n return {'grouping': [127],\n 'currency_symbol': '',\n 'n_sign_posn': 127,\n 'p_cs_precedes': 127,\n 'n_cs_precedes': 127,\n 'mon_grouping': [],\n 'n_sep_by_space': 127,\n 'decimal_point': '.',\n 'negative_sign': '',\n 'positive_sign': '',\n 'p_sep_by_space': 127,\n 'decimal_point': '.',\n 'negative_sign': '',\n 'positive_sign': '',\n 'p_sep_by_space': 127,\n 'int_curr_symbol': '',\n 'p_sign_posn': 127,\n 'thousands_sep': '',\n 'mon_thousands_sep': '',\n 'frac_digits': 127,\n 'mon_decimal_point': '',\n 'int_frac_digits': 127}\n \ndef setlocale(category, value=None):\n \"\"\n if value not in (None, '', 'C'):\n  raise Error('_locale emulation only supports \"C\" locale')\n return 'C'\n \nCHAR_MAX = 127\nLC_ALL = 6\nLC_COLLATE = 3\nLC_CTYPE = 0\nLC_MESSAGES = 5\nLC_MONETARY = 4\nLC_NUMERIC = 1\nLC_TIME = 2\nError = ValueError\n\n\ndef getlocale(category=LC_CTYPE):\n\n \"\"\n return None, None\n"], "site-packages.pygame.mixer": [".py", "\n\ndef get_init():\n pass\n"], "multiprocessing.process": [".py", "\n\n\n\n\n\n\n\n\n__all__ = ['Process', 'current_process', 'active_children']\n\n\n\n\n\nimport os\nimport sys\nimport signal\nimport itertools\nfrom _weakrefset import WeakSet\n\n\nfrom _multiprocessing import Process\n\n\n\n\ntry:\n ORIGINAL_DIR = os.path.abspath(os.getcwd())\nexcept OSError:\n ORIGINAL_DIR = None\n \n \n \n \n \ndef current_process():\n \"\"\n return _current_process\n \ndef active_children():\n \"\"\n _cleanup()\n return list(_current_process._children)\n \n \n \n \n \ndef _cleanup():\n\n for p in list(_current_process._children):\n  if p._popen.poll() is not None:\n   _current_process._children.discard(p)\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \nclass AuthenticationString(bytes):\n def __reduce__(self):\n  from .forking import Popen\n  if not Popen.thread_is_spawning():\n   raise TypeError(\n   'Pickling an AuthenticationString object is '\n   'disallowed for security reasons'\n   )\n  return AuthenticationString, (bytes(self),)\n  \n  \n  \n  \n  \nclass _MainProcess(Process):\n\n def __init__(self):\n  self._identity = ()\n  self._daemonic = False\n  self._name = 'MainProcess'\n  self._parent_pid = None\n  self._popen = None\n  self._counter = itertools.count(1)\n  self._children = set()\n  self._authkey = AuthenticationString(os.urandom(32))\n  self._tempdir = None\n  \n_current_process = _MainProcess()\ndel _MainProcess\n\n\n\n\n\n_exitcode_to_name = {}\n\nfor name, signum in list(signal.__dict__.items()):\n if name[:3]=='SIG' and '_' not in name:\n  _exitcode_to_name[-signum] = name\n  \n  \n_dangling = WeakSet()\n"], "atexit": [".py", "\"\"\n\n\nclass __loader__(object):\n pass\n \ndef _clear(*args,**kw):\n \"\"\n pass\n \ndef _run_exitfuncs(*args,**kw):\n \"\"\n pass\n \ndef register(*args,**kw):\n \"\"\n pass\n \ndef unregister(*args,**kw):\n \"\"\n pass\n"], "pydoc_data": [".py", "", 1], "encodings": [".py", "\"\"\n\nimport codecs\nfrom . import aliases\n\n_cache = {}\n_unknown = '--unknown--'\n_import_tail = ['*']\n_aliases = aliases.aliases\n\nclass CodecRegistryError(LookupError, SystemError):\n pass\n \ndef normalize_encoding(encoding):\n\n \"\"\n if isinstance(encoding, bytes):\n  encoding = str(encoding, \"ascii\")\n chars = []\n punct = False\n for c in encoding:\n  if c.isalnum() or c == '.':\n   if punct and chars:\n    chars.append('_')\n   chars.append(c)\n   punct = False\n  else:\n   punct = True\n return ''.join(chars)\n \ndef search_function(encoding):\n\n\n entry = _cache.get(encoding, _unknown)\n if entry is not _unknown:\n  return entry\n  \n  \n  \n  \n  \n  \n  \n  \n norm_encoding = normalize_encoding(encoding)\n aliased_encoding = _aliases.get(norm_encoding) or _aliases.get(norm_encoding.replace('.', '_'))\n if aliased_encoding is not None:\n  modnames = [aliased_encoding,\n  norm_encoding]\n else:\n  modnames = [norm_encoding]\n for modname in modnames:\n  if not modname or '.' in modname:\n   continue\n  try:\n  \n  \n   mod = __import__('encodings.' + modname, fromlist=_import_tail,\n   level=0)\n  except ImportError:\n   pass\n  else:\n   break\n else:\n  mod = None\n  \n try:\n  getregentry = mod.getregentry\n except AttributeError:\n \n  mod = None\n  \n if mod is None:\n \n  _cache[encoding] = None\n  return None\n  \n  \n entry = getregentry()\n if not isinstance(entry, codecs.CodecInfo):\n  if not 4 <= len(entry) <= 7:\n   raise CodecRegistryError('module \"%s\" (%s) failed to register'\n   % (mod.__name__, mod.__file__))\n  if not callable(entry[0]) or not callable(entry[1]) or (entry[2] is not None and not callable(entry[2])) or (entry[3] is not None and not callable(entry[3])) or (len(entry) > 4 and entry[4] is not None and not callable(entry[4])) or (len(entry) > 5 and entry[5] is not None and not callable(entry[5])):\n   raise CodecRegistryError('incompatible codecs in module \"%s\" (%s)'\n   % (mod.__name__, mod.__file__))\n  if len(entry)<7 or entry[6] is None:\n   entry += (None,)*(6-len(entry)) + (mod.__name__.split(\".\", 1)[1],)\n  entry = codecs.CodecInfo(*entry)\n  \n  \n _cache[encoding] = entry\n \n \n \n try:\n  codecaliases = mod.getaliases()\n except AttributeError:\n  pass\n else:\n  for alias in codecaliases:\n   if alias not in _aliases:\n    _aliases[alias] = modname\n    \n    \n return entry\n \n \ncodecs.register(search_function)\n", 1], "xml.etree.ElementTree": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__ = [\n\n\"Comment\",\n\"dump\",\n\"Element\", \"ElementTree\",\n\"fromstring\", \"fromstringlist\",\n\"iselement\", \"iterparse\",\n\"parse\", \"ParseError\",\n\"PI\", \"ProcessingInstruction\",\n\"QName\",\n\"SubElement\",\n\"tostring\", \"tostringlist\",\n\"TreeBuilder\",\n\"VERSION\",\n\"XML\", \"XMLID\",\n\"XMLParser\", \"XMLTreeBuilder\",\n\"register_namespace\",\n]\n\nVERSION = \"1.3.0\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport sys\nimport re\nimport warnings\nimport io\nimport contextlib\n\nfrom . import ElementPath\n\n\n\n\n\n\n\n\n\nclass ParseError(SyntaxError):\n pass\n \n \n \n \n \n \n \n \n \n \ndef iselement(element):\n\n\n return hasattr(element, 'tag')\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nclass Element:\n\n\n\n\n\n tag = None\n \n \n \n \n \n \n \n \n \n attrib = None\n \n \n \n \n \n \n \n text = None\n \n \n \n \n \n \n \n tail = None \n \n \n \n def __init__(self, tag, attrib={}, **extra):\n  if not isinstance(attrib, dict):\n   raise TypeError(\"attrib must be dict, not %s\" % (\n   attrib.__class__.__name__,))\n  attrib = attrib.copy()\n  attrib.update(extra)\n  self.tag = tag\n  self.attrib = attrib\n  self._children = []\n  \n def __repr__(self):\n  return \"<Element %s at 0x%x>\" % (repr(self.tag), id(self))\n  \n  \n  \n  \n  \n  \n  \n  \n def makeelement(self, tag, attrib):\n  return self.__class__(tag, attrib)\n  \n  \n  \n  \n  \n  \n  \n def copy(self):\n  elem = self.makeelement(self.tag, self.attrib)\n  elem.text = self.text\n  elem.tail = self.tail\n  elem[:] = self\n  return elem\n  \n  \n  \n  \n  \n  \n  \n  \n def __len__(self):\n  return len(self._children)\n  \n def __bool__(self):\n  warnings.warn(\n  \"The behavior of this method will change in future versions.  \"\n  \"Use specific 'len(elem)' or 'elem is not None' test instead.\",\n  FutureWarning, stacklevel=2\n  )\n  return len(self._children) != 0 \n  \n  \n  \n  \n  \n  \n  \n  \n def __getitem__(self, index):\n  return self._children[index]\n  \n  \n  \n  \n  \n  \n  \n  \n def __setitem__(self, index, element):\n \n \n \n \n \n  self._children[index] = element\n  \n  \n  \n  \n  \n  \n  \n def __delitem__(self, index):\n  del self._children[index]\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def append(self, element):\n  self._assert_is_element(element)\n  self._children.append(element)\n  \n  \n  \n  \n  \n  \n  \n def extend(self, elements):\n  for element in elements:\n   self._assert_is_element(element)\n  self._children.extend(elements)\n  \n  \n  \n  \n  \n  \n def insert(self, index, element):\n  self._assert_is_element(element)\n  self._children.insert(index, element)\n  \n def _assert_is_element(self, e):\n \n \n  if not isinstance(e, _Element):\n   raise TypeError('expected an Element, not %s' % type(e).__name__)\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n def remove(self, element):\n \n  self._children.remove(element)\n  \n  \n  \n  \n  \n  \n  \n  \n def getchildren(self):\n  warnings.warn(\n  \"This method will be removed in future versions.  \"\n  \"Use 'list(elem)' or iteration over elem instead.\",\n  DeprecationWarning, stacklevel=2\n  )\n  return self._children\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def find(self, path, namespaces=None):\n  return ElementPath.find(self, path, namespaces)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def findtext(self, path, default=None, namespaces=None):\n  return ElementPath.findtext(self, path, default, namespaces)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def findall(self, path, namespaces=None):\n  return ElementPath.findall(self, path, namespaces)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def iterfind(self, path, namespaces=None):\n  return ElementPath.iterfind(self, path, namespaces)\n  \n  \n  \n  \n  \n  \n def clear(self):\n  self.attrib.clear()\n  self._children = []\n  self.text = self.tail = None\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def get(self, key, default=None):\n  return self.attrib.get(key, default)\n  \n  \n  \n  \n  \n  \n  \n  \n def set(self, key, value):\n  self.attrib[key] = value\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def keys(self):\n  return self.attrib.keys()\n  \n  \n  \n  \n  \n  \n  \n  \n def items(self):\n  return self.attrib.items()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def iter(self, tag=None):\n  if tag == \"*\":\n   tag = None\n  if tag is None or self.tag == tag:\n   yield self\n  for e in self._children:\n   for e in e.iter(tag):\n    yield e\n    \n    \n def getiterator(self, tag=None):\n \n  warnings.warn(\n  \"This method will be removed in future versions.  \"\n  \"Use 'elem.iter()' or 'list(elem.iter())' instead.\",\n  PendingDeprecationWarning, stacklevel=2\n  )\n  return list(self.iter(tag))\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def itertext(self):\n  tag = self.tag\n  if not isinstance(tag, str) and tag is not None:\n   return\n  if self.text:\n   yield self.text\n  for e in self:\n   for s in e.itertext():\n    yield s\n   if e.tail:\n    yield e.tail\n    \n    \n_Element = _ElementInterface = Element\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef SubElement(parent, tag, attrib={}, **extra):\n attrib = attrib.copy()\n attrib.update(extra)\n element = parent.makeelement(tag, attrib)\n parent.append(element)\n return element\n \n \n \n \n \n \n \n \n \n \n \n \n \ndef Comment(text=None):\n element = Element(Comment)\n element.text = text\n return element\n \n \n \n \n \n \n \n \n \n \n \ndef ProcessingInstruction(target, text=None):\n element = Element(ProcessingInstruction)\n element.text = target\n if text:\n  element.text = element.text + \" \" + text\n return element\n \nPI = ProcessingInstruction\n\n\n\n\n\n\n\n\n\n\n\nclass QName:\n def __init__(self, text_or_uri, tag=None):\n  if tag:\n   text_or_uri = \"{%s}%s\" % (text_or_uri, tag)\n  self.text = text_or_uri\n def __str__(self):\n  return self.text\n def __repr__(self):\n  return '<QName %r>' % (self.text,)\n def __hash__(self):\n  return hash(self.text)\n def __le__(self, other):\n  if isinstance(other, QName):\n   return self.text <= other.text\n  return self.text <= other\n def __lt__(self, other):\n  if isinstance(other, QName):\n   return self.text < other.text\n  return self.text < other\n def __ge__(self, other):\n  if isinstance(other, QName):\n   return self.text >= other.text\n  return self.text >= other\n def __gt__(self, other):\n  if isinstance(other, QName):\n   return self.text > other.text\n  return self.text > other\n def __eq__(self, other):\n  if isinstance(other, QName):\n   return self.text == other.text\n  return self.text == other\n def __ne__(self, other):\n  if isinstance(other, QName):\n   return self.text != other.text\n  return self.text != other\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass ElementTree:\n\n def __init__(self, element=None, file=None):\n \n  self._root = element \n  if file:\n   self.parse(file)\n   \n   \n   \n   \n   \n   \n   \n def getroot(self):\n  return self._root\n  \n  \n  \n  \n  \n  \n  \n  \n def _setroot(self, element):\n \n  self._root = element\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def parse(self, source, parser=None):\n  close_source = False\n  if not hasattr(source, \"read\"):\n   source = open(source, \"rb\")\n   close_source = True\n  try:\n   if not parser:\n    parser = XMLParser(target=TreeBuilder())\n   while 1:\n    data = source.read(65536)\n    if not data:\n     break\n    parser.feed(data)\n   self._root = parser.close()\n   return self._root\n  finally:\n   if close_source:\n    source.close()\n    \n    \n    \n    \n    \n    \n    \n    \n    \n def iter(self, tag=None):\n \n  return self._root.iter(tag)\n  \n  \n def getiterator(self, tag=None):\n \n  warnings.warn(\n  \"This method will be removed in future versions.  \"\n  \"Use 'tree.iter()' or 'list(tree.iter())' instead.\",\n  PendingDeprecationWarning, stacklevel=2\n  )\n  return list(self.iter(tag))\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def find(self, path, namespaces=None):\n \n  if path[:1] == \"/\":\n   path = \".\" + path\n   warnings.warn(\n   \"This search is broken in 1.3 and earlier, and will be \"\n   \"fixed in a future version.  If you rely on the current \"\n   \"behaviour, change it to %r\" % path,\n   FutureWarning, stacklevel=2\n   )\n  return self._root.find(path, namespaces)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def findtext(self, path, default=None, namespaces=None):\n \n  if path[:1] == \"/\":\n   path = \".\" + path\n   warnings.warn(\n   \"This search is broken in 1.3 and earlier, and will be \"\n   \"fixed in a future version.  If you rely on the current \"\n   \"behaviour, change it to %r\" % path,\n   FutureWarning, stacklevel=2\n   )\n  return self._root.findtext(path, default, namespaces)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def findall(self, path, namespaces=None):\n \n  if path[:1] == \"/\":\n   path = \".\" + path\n   warnings.warn(\n   \"This search is broken in 1.3 and earlier, and will be \"\n   \"fixed in a future version.  If you rely on the current \"\n   \"behaviour, change it to %r\" % path,\n   FutureWarning, stacklevel=2\n   )\n  return self._root.findall(path, namespaces)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def iterfind(self, path, namespaces=None):\n \n  if path[:1] == \"/\":\n   path = \".\" + path\n   warnings.warn(\n   \"This search is broken in 1.3 and earlier, and will be \"\n   \"fixed in a future version.  If you rely on the current \"\n   \"behaviour, change it to %r\" % path,\n   FutureWarning, stacklevel=2\n   )\n  return self._root.iterfind(path, namespaces)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def write(self, file_or_filename,\n encoding=None,\n xml_declaration=None,\n default_namespace=None,\n method=None):\n  if not method:\n   method = \"xml\"\n  elif method not in _serialize:\n   raise ValueError(\"unknown method %r\" % method)\n  if not encoding:\n   if method == \"c14n\":\n    encoding = \"utf-8\"\n   else:\n    encoding = \"us-ascii\"\n  else:\n   encoding = encoding.lower()\n  with _get_writer(file_or_filename, encoding) as write:\n   if method == \"xml\" and (xml_declaration or\n   (xml_declaration is None and\n   encoding not in (\"utf-8\", \"us-ascii\", \"unicode\"))):\n    declared_encoding = encoding\n    if encoding == \"unicode\":\n    \n     import locale\n     declared_encoding = locale.getpreferredencoding()\n    write(\"<?xml version='1.0' encoding='%s'?>\\n\" % (\n    declared_encoding,))\n   if method == \"text\":\n    _serialize_text(write, self._root)\n   else:\n    qnames, namespaces = _namespaces(self._root, default_namespace)\n    serialize = _serialize[method]\n    serialize(write, self._root, qnames, namespaces)\n    \n def write_c14n(self, file):\n \n  return self.write(file, method=\"c14n\")\n  \n  \n  \n  \n@contextlib.contextmanager\ndef _get_writer(file_or_filename, encoding):\n\n try:\n  write = file_or_filename.write\n except AttributeError:\n \n  if encoding == \"unicode\":\n   file = open(file_or_filename, \"w\")\n  else:\n   file = open(file_or_filename, \"w\", encoding=encoding,\n   errors=\"xmlcharrefreplace\")\n  with file:\n   yield file.write\n else:\n \n \n  if encoding == \"unicode\":\n  \n   yield write\n  else:\n  \n   with contextlib.ExitStack() as stack:\n    if isinstance(file_or_filename, io.BufferedIOBase):\n     file = file_or_filename\n    elif isinstance(file_or_filename, io.RawIOBase):\n     file = io.BufferedWriter(file_or_filename)\n     \n     \n     stack.callback(file.detach)\n    else:\n    \n    \n     file = io.BufferedIOBase()\n     file.writable = lambda: True\n     file.write = write\n     try:\n     \n     \n      file.seekable = file_or_filename.seekable\n      file.tell = file_or_filename.tell\n     except AttributeError:\n      pass\n    file = io.TextIOWrapper(file,\n    encoding=encoding,\n    errors=\"xmlcharrefreplace\",\n    newline=\"\\n\")\n    \n    \n    stack.callback(file.detach)\n    yield file.write\n    \ndef _namespaces(elem, default_namespace=None):\n\n\n\n qnames = {None: None}\n \n \n namespaces = {}\n if default_namespace:\n  namespaces[default_namespace] = \"\"\n  \n def add_qname(qname):\n \n  try:\n   if qname[:1] == \"{\":\n    uri, tag = qname[1:].rsplit(\"}\", 1)\n    prefix = namespaces.get(uri)\n    if prefix is None:\n     prefix = _namespace_map.get(uri)\n     if prefix is None:\n      prefix = \"ns%d\" % len(namespaces)\n     if prefix != \"xml\":\n      namespaces[uri] = prefix\n    if prefix:\n     qnames[qname] = \"%s:%s\" % (prefix, tag)\n    else:\n     qnames[qname] = tag \n   else:\n    if default_namespace:\n    \n     raise ValueError(\n     \"cannot use non-qualified names with \"\n     \"default_namespace option\"\n     )\n    qnames[qname] = qname\n  except TypeError:\n   _raise_serialization_error(qname)\n   \n   \n for elem in elem.iter():\n  tag = elem.tag\n  if isinstance(tag, QName):\n   if tag.text not in qnames:\n    add_qname(tag.text)\n  elif isinstance(tag, str):\n   if tag not in qnames:\n    add_qname(tag)\n  elif tag is not None and tag is not Comment and tag is not PI:\n   _raise_serialization_error(tag)\n  for key, value in elem.items():\n   if isinstance(key, QName):\n    key = key.text\n   if key not in qnames:\n    add_qname(key)\n   if isinstance(value, QName) and value.text not in qnames:\n    add_qname(value.text)\n  text = elem.text\n  if isinstance(text, QName) and text.text not in qnames:\n   add_qname(text.text)\n return qnames, namespaces\n \ndef _serialize_xml(write, elem, qnames, namespaces):\n tag = elem.tag\n text = elem.text\n if tag is Comment:\n  write(\"<!--%s-->\" % text)\n elif tag is ProcessingInstruction:\n  write(\"<?%s?>\" % text)\n else:\n  tag = qnames[tag]\n  if tag is None:\n   if text:\n    write(_escape_cdata(text))\n   for e in elem:\n    _serialize_xml(write, e, qnames, None)\n  else:\n   write(\"<\" + tag)\n   items = list(elem.items())\n   if items or namespaces:\n    if namespaces:\n     for v, k in sorted(namespaces.items(),\n     key=lambda x: x[1]): \n      if k:\n       k = \":\" + k\n      write(\" xmlns%s=\\\"%s\\\"\" % (\n      k,\n      _escape_attrib(v)\n      ))\n    for k, v in sorted(items): \n     if isinstance(k, QName):\n      k = k.text\n     if isinstance(v, QName):\n      v = qnames[v.text]\n     else:\n      v = _escape_attrib(v)\n     write(\" %s=\\\"%s\\\"\" % (qnames[k], v))\n   if text or len(elem):\n    write(\">\")\n    if text:\n     write(_escape_cdata(text))\n    for e in elem:\n     _serialize_xml(write, e, qnames, None)\n    write(\"</\" + tag + \">\")\n   else:\n    write(\" />\")\n if elem.tail:\n  write(_escape_cdata(elem.tail))\n  \nHTML_EMPTY = (\"area\", \"base\", \"basefont\", \"br\", \"col\", \"frame\", \"hr\",\n\"img\", \"input\", \"isindex\", \"link\", \"meta\", \"param\")\n\ntry:\n HTML_EMPTY = set(HTML_EMPTY)\nexcept NameError:\n pass\n \ndef _serialize_html(write, elem, qnames, namespaces):\n tag = elem.tag\n text = elem.text\n if tag is Comment:\n  write(\"<!--%s-->\" % _escape_cdata(text))\n elif tag is ProcessingInstruction:\n  write(\"<?%s?>\" % _escape_cdata(text))\n else:\n  tag = qnames[tag]\n  if tag is None:\n   if text:\n    write(_escape_cdata(text))\n   for e in elem:\n    _serialize_html(write, e, qnames, None)\n  else:\n   write(\"<\" + tag)\n   items = list(elem.items())\n   if items or namespaces:\n    if namespaces:\n     for v, k in sorted(namespaces.items(),\n     key=lambda x: x[1]): \n      if k:\n       k = \":\" + k\n      write(\" xmlns%s=\\\"%s\\\"\" % (\n      k,\n      _escape_attrib(v)\n      ))\n    for k, v in sorted(items): \n     if isinstance(k, QName):\n      k = k.text\n     if isinstance(v, QName):\n      v = qnames[v.text]\n     else:\n      v = _escape_attrib_html(v)\n      \n     write(\" %s=\\\"%s\\\"\" % (qnames[k], v))\n   write(\">\")\n   tag = tag.lower()\n   if text:\n    if tag == \"script\" or tag == \"style\":\n     write(text)\n    else:\n     write(_escape_cdata(text))\n   for e in elem:\n    _serialize_html(write, e, qnames, None)\n   if tag not in HTML_EMPTY:\n    write(\"</\" + tag + \">\")\n if elem.tail:\n  write(_escape_cdata(elem.tail))\n  \ndef _serialize_text(write, elem):\n for part in elem.itertext():\n  write(part)\n if elem.tail:\n  write(elem.tail)\n  \n_serialize = {\n\"xml\": _serialize_xml,\n\"html\": _serialize_html,\n\"text\": _serialize_text,\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\ndef register_namespace(prefix, uri):\n if re.match(\"ns\\d+$\", prefix):\n  raise ValueError(\"Prefix format reserved for internal use\")\n for k, v in list(_namespace_map.items()):\n  if k == uri or v == prefix:\n   del _namespace_map[k]\n _namespace_map[uri] = prefix\n \n_namespace_map = {\n\n\"http://www.w3.org/XML/1998/namespace\": \"xml\",\n\"http://www.w3.org/1999/xhtml\": \"html\",\n\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\": \"rdf\",\n\"http://schemas.xmlsoap.org/wsdl/\": \"wsdl\",\n\n\"http://www.w3.org/2001/XMLSchema\": \"xs\",\n\"http://www.w3.org/2001/XMLSchema-instance\": \"xsi\",\n\n\"http://purl.org/dc/elements/1.1/\": \"dc\",\n}\n\nregister_namespace._namespace_map = _namespace_map\n\ndef _raise_serialization_error(text):\n raise TypeError(\n \"cannot serialize %r (type %s)\" % (text, type(text).__name__)\n )\n \ndef _escape_cdata(text):\n\n try:\n \n \n \n  if \"&\" in text:\n   text = text.replace(\"&\", \"&amp;\")\n  if \"<\" in text:\n   text = text.replace(\"<\", \"&lt;\")\n  if \">\" in text:\n   text = text.replace(\">\", \"&gt;\")\n  return text\n except (TypeError, AttributeError):\n  _raise_serialization_error(text)\n  \ndef _escape_attrib(text):\n\n try:\n  if \"&\" in text:\n   text = text.replace(\"&\", \"&amp;\")\n  if \"<\" in text:\n   text = text.replace(\"<\", \"&lt;\")\n  if \">\" in text:\n   text = text.replace(\">\", \"&gt;\")\n  if \"\\\"\" in text:\n   text = text.replace(\"\\\"\", \"&quot;\")\n  if \"\\n\" in text:\n   text = text.replace(\"\\n\", \"&#10;\")\n  return text\n except (TypeError, AttributeError):\n  _raise_serialization_error(text)\n  \ndef _escape_attrib_html(text):\n\n try:\n  if \"&\" in text:\n   text = text.replace(\"&\", \"&amp;\")\n  if \">\" in text:\n   text = text.replace(\">\", \"&gt;\")\n  if \"\\\"\" in text:\n   text = text.replace(\"\\\"\", \"&quot;\")\n  return text\n except (TypeError, AttributeError):\n  _raise_serialization_error(text)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef tostring(element, encoding=None, method=None):\n stream = io.StringIO() if encoding == 'unicode' else io.BytesIO()\n ElementTree(element).write(stream, encoding, method=method)\n return stream.getvalue()\n \n \n \n \n \n \n \n \n \n \n \n \n \n \nclass _ListDataStream(io.BufferedIOBase):\n \"\"\n def __init__(self, lst):\n  self.lst = lst\n  \n def writable(self):\n  return True\n  \n def seekable(self):\n  return True\n  \n def write(self, b):\n  self.lst.append(b)\n  \n def tell(self):\n  return len(self.lst)\n  \ndef tostringlist(element, encoding=None, method=None):\n lst = []\n stream = _ListDataStream(lst)\n ElementTree(element).write(stream, encoding, method=method)\n return lst\n \n \n \n \n \n \n \n \n \n \ndef dump(elem):\n\n if not isinstance(elem, ElementTree):\n  elem = ElementTree(elem)\n elem.write(sys.stdout, encoding=\"unicode\")\n tail = elem.getroot().tail\n if not tail or tail[-1] != \"\\n\":\n  sys.stdout.write(\"\\n\")\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef parse(source, parser=None):\n tree = ElementTree()\n tree.parse(source, parser)\n return tree\n \n \n \n \n \n \n \n \n \n \n \n \ndef iterparse(source, events=None, parser=None):\n close_source = False\n if not hasattr(source, \"read\"):\n  source = open(source, \"rb\")\n  close_source = True\n if not parser:\n  parser = XMLParser(target=TreeBuilder())\n return _IterParseIterator(source, events, parser, close_source)\n \nclass _IterParseIterator:\n\n def __init__(self, source, events, parser, close_source=False):\n  self._file = source\n  self._close_file = close_source\n  self._events = []\n  self._index = 0\n  self._error = None\n  self.root = self._root = None\n  self._parser = parser\n  \n  parser = self._parser._parser\n  append = self._events.append\n  if events is None:\n   events = [\"end\"]\n  for event in events:\n   if event == \"start\":\n    try:\n     parser.ordered_attributes = 1\n     parser.specified_attributes = 1\n     def handler(tag, attrib_in, event=event, append=append,\n     start=self._parser._start_list):\n      append((event, start(tag, attrib_in)))\n     parser.StartElementHandler = handler\n    except AttributeError:\n     def handler(tag, attrib_in, event=event, append=append,\n     start=self._parser._start):\n      append((event, start(tag, attrib_in)))\n     parser.StartElementHandler = handler\n   elif event == \"end\":\n    def handler(tag, event=event, append=append,\n    end=self._parser._end):\n     append((event, end(tag)))\n    parser.EndElementHandler = handler\n   elif event == \"start-ns\":\n    def handler(prefix, uri, event=event, append=append):\n     append((event, (prefix or \"\", uri or \"\")))\n    parser.StartNamespaceDeclHandler = handler\n   elif event == \"end-ns\":\n    def handler(prefix, event=event, append=append):\n     append((event, None))\n    parser.EndNamespaceDeclHandler = handler\n   else:\n    raise ValueError(\"unknown event %r\" % event)\n    \n def __next__(self):\n  while 1:\n   try:\n    item = self._events[self._index]\n    self._index += 1\n    return item\n   except IndexError:\n    pass\n   if self._error:\n    e = self._error\n    self._error = None\n    raise e\n   if self._parser is None:\n    self.root = self._root\n    if self._close_file:\n     self._file.close()\n    raise StopIteration\n    \n   del self._events[:]\n   self._index = 0\n   data = self._file.read(16384)\n   if data:\n    try:\n     self._parser.feed(data)\n    except SyntaxError as exc:\n     self._error = exc\n   else:\n    self._root = self._parser.close()\n    self._parser = None\n    \n def __iter__(self):\n  return self\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef XML(text, parser=None):\n if not parser:\n  parser = XMLParser(target=TreeBuilder())\n parser.feed(text)\n return parser.close()\n \n \n \n \n \n \n \n \n \n \n \ndef XMLID(text, parser=None):\n if not parser:\n  parser = XMLParser(target=TreeBuilder())\n parser.feed(text)\n tree = parser.close()\n ids = {}\n for elem in tree.iter():\n  id = elem.get(\"id\")\n  if id:\n   ids[id] = elem\n return tree, ids\n \n \n \n \n \n \n \n \n \nfromstring = XML\n\n\n\n\n\n\n\n\n\n\n\ndef fromstringlist(sequence, parser=None):\n if not parser:\n  parser = XMLParser(target=TreeBuilder())\n for text in sequence:\n  parser.feed(text)\n return parser.close()\n \n \n \n \n \n \n \n \n \n \n \n \n \n \nclass TreeBuilder:\n\n def __init__(self, element_factory=None):\n  self._data = [] \n  self._elem = [] \n  self._last = None \n  self._tail = None \n  if element_factory is None:\n   element_factory = Element\n  self._factory = element_factory\n  \n  \n  \n  \n  \n  \n  \n  \n def close(self):\n  assert len(self._elem) == 0, \"missing end tags\"\n  assert self._last is not None, \"missing toplevel element\"\n  return self._last\n  \n def _flush(self):\n  if self._data:\n   if self._last is not None:\n    text = \"\".join(self._data)\n    if self._tail:\n     assert self._last.tail is None, \"internal error (tail)\"\n     self._last.tail = text\n    else:\n     assert self._last.text is None, \"internal error (text)\"\n     self._last.text = text\n   self._data = []\n   \n   \n   \n   \n   \n   \n   \n def data(self, data):\n  self._data.append(data)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def start(self, tag, attrs):\n  self._flush()\n  self._last = elem = self._factory(tag, attrs)\n  if self._elem:\n   self._elem[-1].append(elem)\n  self._elem.append(elem)\n  self._tail = 0\n  return elem\n  \n  \n  \n  \n  \n  \n  \n  \n def end(self, tag):\n  self._flush()\n  self._last = self._elem.pop()\n  assert self._last.tag == tag, \"end tag mismatch (expected %s, got %s)\" % (\n  self._last.tag, tag)\n  self._tail = 1\n  return self._last\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass XMLParser:\n\n def __init__(self, html=0, target=None, encoding=None):\n  try:\n   from xml.parsers import expat\n  except ImportError:\n   try:\n    import pyexpat as expat\n   except ImportError:\n    raise ImportError(\n    \"No module named expat; use SimpleXMLTreeBuilder instead\"\n    )\n  parser = expat.ParserCreate(encoding, \"}\")\n  if target is None:\n   target = TreeBuilder()\n   \n  self.parser = self._parser = parser\n  self.target = self._target = target\n  self._error = expat.error\n  self._names = {} \n  \n  parser.DefaultHandlerExpand = self._default\n  if hasattr(target, 'start'):\n   parser.StartElementHandler = self._start\n  if hasattr(target, 'end'):\n   parser.EndElementHandler = self._end\n  if hasattr(target, 'data'):\n   parser.CharacterDataHandler = target.data\n   \n  if hasattr(target, 'comment'):\n   parser.CommentHandler = target.comment\n  if hasattr(target, 'pi'):\n   parser.ProcessingInstructionHandler = target.pi\n   \n  try:\n   parser.buffer_text = 1\n  except AttributeError:\n   pass\n   \n  try:\n   parser.ordered_attributes = 1\n   parser.specified_attributes = 1\n   if hasattr(target, 'start'):\n    parser.StartElementHandler = self._start_list\n  except AttributeError:\n   pass\n  self._doctype = None\n  self.entity = {}\n  try:\n   self.version = \"Expat %d.%d.%d\" % expat.version_info\n  except AttributeError:\n   pass \n   \n def _raiseerror(self, value):\n  err = ParseError(value)\n  err.code = value.code\n  err.position = value.lineno, value.offset\n  raise err\n  \n def _fixname(self, key):\n \n  try:\n   name = self._names[key]\n  except KeyError:\n   name = key\n   if \"}\" in name:\n    name = \"{\" + name\n   self._names[key] = name\n  return name\n  \n def _start(self, tag, attrib_in):\n  fixname = self._fixname\n  tag = fixname(tag)\n  attrib = {}\n  for key, value in attrib_in.items():\n   attrib[fixname(key)] = value\n  return self.target.start(tag, attrib)\n  \n def _start_list(self, tag, attrib_in):\n  fixname = self._fixname\n  tag = fixname(tag)\n  attrib = {}\n  if attrib_in:\n   for i in range(0, len(attrib_in), 2):\n    attrib[fixname(attrib_in[i])] = attrib_in[i+1]\n  return self.target.start(tag, attrib)\n  \n def _end(self, tag):\n  return self.target.end(self._fixname(tag))\n  \n def _default(self, text):\n  prefix = text[:1]\n  if prefix == \"&\":\n  \n   try:\n    data_handler = self.target.data\n   except AttributeError:\n    return\n   try:\n    data_handler(self.entity[text[1:-1]])\n   except KeyError:\n    from xml.parsers import expat\n    err = expat.error(\n    \"undefined entity %s: line %d, column %d\" %\n    (text, self.parser.ErrorLineNumber,\n    self.parser.ErrorColumnNumber)\n    )\n    err.code = 11 \n    err.lineno = self.parser.ErrorLineNumber\n    err.offset = self.parser.ErrorColumnNumber\n    raise err\n  elif prefix == \"<\" and text[:9] == \"<!DOCTYPE\":\n   self._doctype = [] \n  elif self._doctype is not None:\n  \n   if prefix == \">\":\n    self._doctype = None\n    return\n   text = text.strip()\n   if not text:\n    return\n   self._doctype.append(text)\n   n = len(self._doctype)\n   if n > 2:\n    type = self._doctype[1]\n    if type == \"PUBLIC\" and n == 4:\n     name, type, pubid, system = self._doctype\n     if pubid:\n      pubid = pubid[1:-1]\n    elif type == \"SYSTEM\" and n == 3:\n     name, type, system = self._doctype\n     pubid = None\n    else:\n     return\n    if hasattr(self.target, \"doctype\"):\n     self.target.doctype(name, pubid, system[1:-1])\n    elif self.doctype != self._XMLParser__doctype:\n    \n     self._XMLParser__doctype(name, pubid, system[1:-1])\n     self.doctype(name, pubid, system[1:-1])\n    self._doctype = None\n    \n    \n    \n    \n    \n    \n    \n    \n def doctype(self, name, pubid, system):\n  \"\"\n  warnings.warn(\n  \"This method of XMLParser is deprecated.  Define doctype() \"\n  \"method on the TreeBuilder target.\",\n  DeprecationWarning,\n  )\n  \n  \n __doctype = doctype\n \n \n \n \n \n \n def feed(self, data):\n  try:\n   self.parser.Parse(data, 0)\n  except self._error as v:\n   self._raiseerror(v)\n   \n   \n   \n   \n   \n   \n   \n def close(self):\n  try:\n   self.parser.Parse(\"\", 1) \n  except self._error as v:\n   self._raiseerror(v)\n  try:\n   close_handler = self.target.close\n  except AttributeError:\n   pass\n  else:\n   return close_handler()\n  finally:\n  \n   del self.parser, self._parser\n   del self.target, self._target\n   \n   \n   \ntry:\n\n from _elementtree import *\nexcept ImportError:\n pass\nelse:\n\n\n class ElementTree(ElementTree):\n  def parse(self, source, parser=None):\n   close_source = False\n   if not hasattr(source, 'read'):\n    source = open(source, 'rb')\n    close_source = True\n   try:\n    if parser is not None:\n     while True:\n      data = source.read(65536)\n      if not data:\n       break\n      parser.feed(data)\n     self._root = parser.close()\n    else:\n     parser = XMLParser()\n     self._root = parser._parse(source)\n    return self._root\n   finally:\n    if close_source:\n     source.close()\n     \n class iterparse:\n  \"\"\n  \n  root = None\n  def __init__(self, file, events=None, parser=None):\n   self._close_file = False\n   if not hasattr(file, 'read'):\n    file = open(file, 'rb')\n    self._close_file = True\n   self._file = file\n   self._events = []\n   self._index = 0\n   self._error = None\n   self.root = self._root = None\n   if parser is None:\n    parser = XMLParser(target=TreeBuilder())\n   self._parser = parser\n   self._parser._setevents(self._events, events)\n   \n  def __next__(self):\n   while True:\n    try:\n     item = self._events[self._index]\n     self._index += 1\n     return item\n    except IndexError:\n     pass\n    if self._error:\n     e = self._error\n     self._error = None\n     raise e\n    if self._parser is None:\n     self.root = self._root\n     if self._close_file:\n      self._file.close()\n     raise StopIteration\n     \n    del self._events[:]\n    self._index = 0\n    data = self._file.read(16384)\n    if data:\n     try:\n      self._parser.feed(data)\n     except SyntaxError as exc:\n      self._error = exc\n    else:\n     self._root = self._parser.close()\n     self._parser = None\n     \n  def __iter__(self):\n   return self\n   \n   \nXMLTreeBuilder = XMLParser\n\n\ntry:\n from ElementC14N import _serialize_c14n\n _serialize[\"c14n\"] = _serialize_c14n\nexcept ImportError:\n pass\n"], "calendar": [".py", "\"\"\n\nimport sys\nimport datetime\nimport locale as _locale\n\n__all__ = [\"IllegalMonthError\", \"IllegalWeekdayError\", \"setfirstweekday\",\n\"firstweekday\", \"isleap\", \"leapdays\", \"weekday\", \"monthrange\",\n\"monthcalendar\", \"prmonth\", \"month\", \"prcal\", \"calendar\",\n\"timegm\", \"month_name\", \"month_abbr\", \"day_name\", \"day_abbr\"]\n\n\nerror = ValueError\n\n\nclass IllegalMonthError(ValueError):\n def __init__(self, month):\n  self.month = month\n def __str__(self):\n  return \"bad month number %r; must be 1-12\" % self.month\n  \n  \nclass IllegalWeekdayError(ValueError):\n def __init__(self, weekday):\n  self.weekday = weekday\n def __str__(self):\n  return \"bad weekday number %r; must be 0 (Monday) to 6 (Sunday)\" % self.weekday\n  \n  \n  \nJanuary = 1\nFebruary = 2\n\n\nmdays = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n\n\n\n\n\nclass _localized_month:\n\n _months = [datetime.date(2001, i+1, 1).strftime for i in range(12)]\n _months.insert(0, lambda x: \"\")\n \n def __init__(self, format):\n  self.format = format\n  \n def __getitem__(self, i):\n  funcs = self._months[i]\n  if isinstance(i, slice):\n   return [f(self.format) for f in funcs]\n  else:\n   return funcs(self.format)\n   \n def __len__(self):\n  return 13\n  \n  \nclass _localized_day:\n\n\n _days = [datetime.date(2001, 1, i+1).strftime for i in range(7)]\n \n def __init__(self, format):\n  self.format = format\n  \n def __getitem__(self, i):\n  funcs = self._days[i]\n  if isinstance(i, slice):\n   return [f(self.format) for f in funcs]\n  else:\n   return funcs(self.format)\n   \n def __len__(self):\n  return 7\n  \n  \n  \nday_name = _localized_day('%A')\nday_abbr = _localized_day('%a')\n\n\nmonth_name = _localized_month('%B')\nmonth_abbr = _localized_month('%b')\n\n\n(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7)\n\n\ndef isleap(year):\n \"\"\n return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n \n \ndef leapdays(y1, y2):\n \"\"\n y1 -= 1\n y2 -= 1\n return (y2//4 - y1//4) - (y2//100 - y1//100) + (y2//400 - y1//400)\n \n \ndef weekday(year, month, day):\n \"\"\n return datetime.date(year, month, day).weekday()\n \n \ndef monthrange(year, month):\n \"\"\n if not 1 <= month <= 12:\n  raise IllegalMonthError(month)\n day1 = weekday(year, month, 1)\n ndays = mdays[month] + (month == February and isleap(year))\n return day1, ndays\n \n \nclass Calendar(object):\n \"\"\n \n def __init__(self, firstweekday=0):\n  self.firstweekday = firstweekday \n  \n def getfirstweekday(self):\n  return self._firstweekday % 7\n  \n def setfirstweekday(self, firstweekday):\n  self._firstweekday = firstweekday\n  \n firstweekday = property(getfirstweekday, setfirstweekday)\n \n def iterweekdays(self):\n  \"\"\n  for i in range(self.firstweekday, self.firstweekday + 7):\n   yield i%7\n   \n def itermonthdates(self, year, month):\n  \"\"\n  date = datetime.date(year, month, 1)\n  \n  days = (date.weekday() - self.firstweekday) % 7\n  date -= datetime.timedelta(days=days)\n  oneday = datetime.timedelta(days=1)\n  while True:\n   yield date\n   try:\n    date += oneday\n   except OverflowError:\n   \n    break\n   if date.month != month and date.weekday() == self.firstweekday:\n    break\n    \n def itermonthdays2(self, year, month):\n  \"\"\n  for date in self.itermonthdates(year, month):\n   if date.month != month:\n    yield (0, date.weekday())\n   else:\n    yield (date.day, date.weekday())\n    \n def itermonthdays(self, year, month):\n  \"\"\n  for date in self.itermonthdates(year, month):\n   if date.month != month:\n    yield 0\n   else:\n    yield date.day\n    \n def monthdatescalendar(self, year, month):\n  \"\"\n  dates = list(self.itermonthdates(year, month))\n  return [ dates[i:i+7] for i in range(0, len(dates), 7) ]\n  \n def monthdays2calendar(self, year, month):\n  \"\"\n  days = list(self.itermonthdays2(year, month))\n  return [ days[i:i+7] for i in range(0, len(days), 7) ]\n  \n def monthdayscalendar(self, year, month):\n  \"\"\n  days = list(self.itermonthdays(year, month))\n  return [ days[i:i+7] for i in range(0, len(days), 7) ]\n  \n def yeardatescalendar(self, year, width=3):\n  \"\"\n  months = [\n  self.monthdatescalendar(year, i)\n  for i in range(January, January+12)\n  ]\n  return [months[i:i+width] for i in range(0, len(months), width) ]\n  \n def yeardays2calendar(self, year, width=3):\n  \"\"\n  months = [\n  self.monthdays2calendar(year, i)\n  for i in range(January, January+12)\n  ]\n  return [months[i:i+width] for i in range(0, len(months), width) ]\n  \n def yeardayscalendar(self, year, width=3):\n  \"\"\n  months = [\n  self.monthdayscalendar(year, i)\n  for i in range(January, January+12)\n  ]\n  return [months[i:i+width] for i in range(0, len(months), width) ]\n  \n  \nclass TextCalendar(Calendar):\n \"\"\n \n def prweek(self, theweek, width):\n  \"\"\n  print(self.formatweek(theweek, width), end=' ')\n  \n def formatday(self, day, weekday, width):\n  \"\"\n  if day == 0:\n   s = ''\n  else:\n   s = '%2i' % day \n  return s.center(width)\n  \n def formatweek(self, theweek, width):\n  \"\"\n  return ' '.join(self.formatday(d, wd, width) for (d, wd) in theweek)\n  \n def formatweekday(self, day, width):\n  \"\"\n  if width >= 9:\n   names = day_name\n  else:\n   names = day_abbr\n  return names[day][:width].center(width)\n  \n def formatweekheader(self, width):\n  \"\"\n  return ' '.join(self.formatweekday(i, width) for i in self.iterweekdays())\n  \n def formatmonthname(self, theyear, themonth, width, withyear=True):\n  \"\"\n  s = month_name[themonth]\n  if withyear:\n   s = \"%s %r\" % (s, theyear)\n  return s.center(width)\n  \n def prmonth(self, theyear, themonth, w=0, l=0):\n  \"\"\n  print(self.formatmonth(theyear, themonth, w, l), end=' ')\n  \n def formatmonth(self, theyear, themonth, w=0, l=0):\n  \"\"\n  w = max(2, w)\n  l = max(1, l)\n  s = self.formatmonthname(theyear, themonth, 7 * (w + 1) - 1)\n  s = s.rstrip()\n  s += '\\n' * l\n  s += self.formatweekheader(w).rstrip()\n  s += '\\n' * l\n  for week in self.monthdays2calendar(theyear, themonth):\n   s += self.formatweek(week, w).rstrip()\n   s += '\\n' * l\n  return s\n  \n def formatyear(self, theyear, w=2, l=1, c=6, m=3):\n  \"\"\n  w = max(2, w)\n  l = max(1, l)\n  c = max(2, c)\n  colwidth = (w + 1) * 7 - 1\n  v = []\n  a = v.append\n  a(repr(theyear).center(colwidth*m+c*(m-1)).rstrip())\n  a('\\n'*l)\n  header = self.formatweekheader(w)\n  for (i, row) in enumerate(self.yeardays2calendar(theyear, m)):\n  \n   months = range(m*i+1, min(m*(i+1)+1, 13))\n   a('\\n'*l)\n   names = (self.formatmonthname(theyear, k, colwidth, False)\n   for k in months)\n   a(formatstring(names, colwidth, c).rstrip())\n   a('\\n'*l)\n   headers = (header for k in months)\n   a(formatstring(headers, colwidth, c).rstrip())\n   a('\\n'*l)\n   \n   height = max(len(cal) for cal in row)\n   for j in range(height):\n    weeks = []\n    for cal in row:\n     if j >= len(cal):\n      weeks.append('')\n     else:\n      weeks.append(self.formatweek(cal[j], w))\n    a(formatstring(weeks, colwidth, c).rstrip())\n    a('\\n' * l)\n  return ''.join(v)\n  \n def pryear(self, theyear, w=0, l=0, c=6, m=3):\n  \"\"\n  print(self.formatyear(theyear, w, l, c, m))\n  \n  \nclass HTMLCalendar(Calendar):\n \"\"\n \n \n cssclasses = [\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"]\n \n def formatday(self, day, weekday):\n  \"\"\n  if day == 0:\n   return '<td class=\"noday\">&nbsp;</td>' \n  else:\n   return '<td class=\"%s\">%d</td>' % (self.cssclasses[weekday], day)\n   \n def formatweek(self, theweek):\n  \"\"\n  s = ''.join(self.formatday(d, wd) for (d, wd) in theweek)\n  return '<tr>%s</tr>' % s\n  \n def formatweekday(self, day):\n  \"\"\n  return '<th class=\"%s\">%s</th>' % (self.cssclasses[day], day_abbr[day])\n  \n def formatweekheader(self):\n  \"\"\n  s = ''.join(self.formatweekday(i) for i in self.iterweekdays())\n  return '<tr>%s</tr>' % s\n  \n def formatmonthname(self, theyear, themonth, withyear=True):\n  \"\"\n  if withyear:\n   s = '%s %s' % (month_name[themonth], theyear)\n  else:\n   s = '%s' % month_name[themonth]\n  return '<tr><th colspan=\"7\" class=\"month\">%s</th></tr>' % s\n  \n def formatmonth(self, theyear, themonth, withyear=True):\n  \"\"\n  v = []\n  a = v.append\n  a('<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"month\">')\n  a('\\n')\n  a(self.formatmonthname(theyear, themonth, withyear=withyear))\n  a('\\n')\n  a(self.formatweekheader())\n  a('\\n')\n  for week in self.monthdays2calendar(theyear, themonth):\n   a(self.formatweek(week))\n   a('\\n')\n  a('</table>')\n  a('\\n')\n  return ''.join(v)\n  \n def formatyear(self, theyear, width=3):\n  \"\"\n  v = []\n  a = v.append\n  width = max(width, 1)\n  a('<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"year\">')\n  a('\\n')\n  a('<tr><th colspan=\"%d\" class=\"year\">%s</th></tr>' % (width, theyear))\n  for i in range(January, January+12, width):\n  \n   months = range(i, min(i+width, 13))\n   a('<tr>')\n   for m in months:\n    a('<td>')\n    a(self.formatmonth(theyear, m, withyear=False))\n    a('</td>')\n   a('</tr>')\n  a('</table>')\n  return ''.join(v)\n  \n def formatyearpage(self, theyear, width=3, css='calendar.css', encoding=None):\n  \"\"\n  if encoding is None:\n   encoding = sys.getdefaultencoding()\n  v = []\n  a = v.append\n  a('<?xml version=\"1.0\" encoding=\"%s\"?>\\n' % encoding)\n  a('<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\\n')\n  a('<html>\\n')\n  a('<head>\\n')\n  a('<meta http-equiv=\"Content-Type\" content=\"text/html; charset=%s\" />\\n' % encoding)\n  if css is not None:\n   a('<link rel=\"stylesheet\" type=\"text/css\" href=\"%s\" />\\n' % css)\n  a('<title>Calendar for %d</title>\\n' % theyear)\n  a('</head>\\n')\n  a('<body>\\n')\n  a(self.formatyear(theyear, width))\n  a('</body>\\n')\n  a('</html>\\n')\n  return ''.join(v).encode(encoding, \"xmlcharrefreplace\")\n  \n  \nclass different_locale:\n def __init__(self, locale):\n  self.locale = locale\n  \n def __enter__(self):\n  self.oldlocale = _locale.getlocale(_locale.LC_TIME)\n  _locale.setlocale(_locale.LC_TIME, self.locale)\n  \n def __exit__(self, *args):\n  _locale.setlocale(_locale.LC_TIME, self.oldlocale)\n  \n  \nclass LocaleTextCalendar(TextCalendar):\n \"\"\n \n def __init__(self, firstweekday=0, locale=None):\n  TextCalendar.__init__(self, firstweekday)\n  if locale is None:\n   locale = _locale.getdefaultlocale()\n  self.locale = locale\n  \n def formatweekday(self, day, width):\n  with different_locale(self.locale):\n   if width >= 9:\n    names = day_name\n   else:\n    names = day_abbr\n   name = names[day]\n   return name[:width].center(width)\n   \n def formatmonthname(self, theyear, themonth, width, withyear=True):\n  with different_locale(self.locale):\n   s = month_name[themonth]\n   if withyear:\n    s = \"%s %r\" % (s, theyear)\n   return s.center(width)\n   \n   \nclass LocaleHTMLCalendar(HTMLCalendar):\n \"\"\n def __init__(self, firstweekday=0, locale=None):\n  HTMLCalendar.__init__(self, firstweekday)\n  if locale is None:\n   locale = _locale.getdefaultlocale()\n  self.locale = locale\n  \n def formatweekday(self, day):\n  with different_locale(self.locale):\n   s = day_abbr[day]\n   return '<th class=\"%s\">%s</th>' % (self.cssclasses[day], s)\n   \n def formatmonthname(self, theyear, themonth, withyear=True):\n  with different_locale(self.locale):\n   s = month_name[themonth]\n   if withyear:\n    s = '%s %s' % (s, theyear)\n   return '<tr><th colspan=\"7\" class=\"month\">%s</th></tr>' % s\n   \n   \n   \nc = TextCalendar()\n\nfirstweekday = c.getfirstweekday\n\ndef setfirstweekday(firstweekday):\n if not MONDAY <= firstweekday <= SUNDAY:\n  raise IllegalWeekdayError(firstweekday)\n c.firstweekday = firstweekday\n \nmonthcalendar = c.monthdayscalendar\nprweek = c.prweek\nweek = c.formatweek\nweekheader = c.formatweekheader\nprmonth = c.prmonth\nmonth = c.formatmonth\ncalendar = c.formatyear\nprcal = c.pryear\n\n\n\n_colwidth = 7*3 - 1 \n_spacing = 6 \n\n\ndef format(cols, colwidth=_colwidth, spacing=_spacing):\n \"\"\n print(formatstring(cols, colwidth, spacing))\n \n \ndef formatstring(cols, colwidth=_colwidth, spacing=_spacing):\n \"\"\n spacing *= ' '\n return spacing.join(c.center(colwidth) for c in cols)\n \n \nEPOCH = 1970\n_EPOCH_ORD = datetime.date(EPOCH, 1, 1).toordinal()\n\n\ndef timegm(tuple):\n \"\"\n year, month, day, hour, minute, second = tuple[:6]\n days = datetime.date(year, month, 1).toordinal() - _EPOCH_ORD + day - 1\n hours = days*24 + hour\n minutes = hours*60 + minute\n seconds = minutes*60 + second\n return seconds\n \n \ndef main(args):\n import optparse\n parser = optparse.OptionParser(usage=\"usage: %prog [options] [year [month]]\")\n parser.add_option(\n \"-w\", \"--width\",\n dest=\"width\", type=\"int\", default=2,\n help=\"width of date column (default 2, text only)\"\n )\n parser.add_option(\n \"-l\", \"--lines\",\n dest=\"lines\", type=\"int\", default=1,\n help=\"number of lines for each week (default 1, text only)\"\n )\n parser.add_option(\n \"-s\", \"--spacing\",\n dest=\"spacing\", type=\"int\", default=6,\n help=\"spacing between months (default 6, text only)\"\n )\n parser.add_option(\n \"-m\", \"--months\",\n dest=\"months\", type=\"int\", default=3,\n help=\"months per row (default 3, text only)\"\n )\n parser.add_option(\n \"-c\", \"--css\",\n dest=\"css\", default=\"calendar.css\",\n help=\"CSS to use for page (html only)\"\n )\n parser.add_option(\n \"-L\", \"--locale\",\n dest=\"locale\", default=None,\n help=\"locale to be used from month and weekday names\"\n )\n parser.add_option(\n \"-e\", \"--encoding\",\n dest=\"encoding\", default=None,\n help=\"Encoding to use for output.\"\n )\n parser.add_option(\n \"-t\", \"--type\",\n dest=\"type\", default=\"text\",\n choices=(\"text\", \"html\"),\n help=\"output type (text or html)\"\n )\n \n (options, args) = parser.parse_args(args)\n \n if options.locale and not options.encoding:\n  parser.error(\"if --locale is specified --encoding is required\")\n  sys.exit(1)\n  \n locale = options.locale, options.encoding\n \n if options.type == \"html\":\n  if options.locale:\n   cal = LocaleHTMLCalendar(locale=locale)\n  else:\n   cal = HTMLCalendar()\n  encoding = options.encoding\n  if encoding is None:\n   encoding = sys.getdefaultencoding()\n  optdict = dict(encoding=encoding, css=options.css)\n  write = sys.stdout.buffer.write\n  if len(args) == 1:\n   write(cal.formatyearpage(datetime.date.today().year, **optdict))\n  elif len(args) == 2:\n   write(cal.formatyearpage(int(args[1]), **optdict))\n  else:\n   parser.error(\"incorrect number of arguments\")\n   sys.exit(1)\n else:\n  if options.locale:\n   cal = LocaleTextCalendar(locale=locale)\n  else:\n   cal = TextCalendar()\n  optdict = dict(w=options.width, l=options.lines)\n  if len(args) != 3:\n   optdict[\"c\"] = options.spacing\n   optdict[\"m\"] = options.months\n  if len(args) == 1:\n   result = cal.formatyear(datetime.date.today().year, **optdict)\n  elif len(args) == 2:\n   result = cal.formatyear(int(args[1]), **optdict)\n  elif len(args) == 3:\n   result = cal.formatmonth(int(args[1]), int(args[2]), **optdict)\n  else:\n   parser.error(\"incorrect number of arguments\")\n   sys.exit(1)\n  write = sys.stdout.write\n  if options.encoding:\n   result = result.encode(options.encoding)\n   write = sys.stdout.buffer.write\n  write(result)\n  \n  \nif __name__ == \"__main__\":\n main(sys.argv)\n"], "logging.handlers": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\n\nimport errno, logging, socket, os, pickle, struct, time, re\nfrom codecs import BOM_UTF8\nfrom stat import ST_DEV, ST_INO, ST_MTIME\nimport queue\ntry:\n import threading\nexcept ImportError: \n threading = None\n \n \n \n \n \nDEFAULT_TCP_LOGGING_PORT = 9020\nDEFAULT_UDP_LOGGING_PORT = 9021\nDEFAULT_HTTP_LOGGING_PORT = 9022\nDEFAULT_SOAP_LOGGING_PORT = 9023\nSYSLOG_UDP_PORT = 514\nSYSLOG_TCP_PORT = 514\n\n_MIDNIGHT = 24 * 60 * 60 \n\nclass BaseRotatingHandler(logging.FileHandler):\n \"\"\n def __init__(self, filename, mode, encoding=None, delay=False):\n  \"\"\n  logging.FileHandler.__init__(self, filename, mode, encoding, delay)\n  self.mode = mode\n  self.encoding = encoding\n  self.namer = None\n  self.rotator = None\n  \n def emit(self, record):\n  \"\"\n  try:\n   if self.shouldRollover(record):\n    self.doRollover()\n   logging.FileHandler.emit(self, record)\n  except (KeyboardInterrupt, SystemExit): \n   raise\n  except:\n   self.handleError(record)\n   \n def rotation_filename(self, default_name):\n  \"\"\n  if not callable(self.namer):\n   result = default_name\n  else:\n   result = self.namer(default_name)\n  return result\n  \n def rotate(self, source, dest):\n  \"\"\n  if not callable(self.rotator):\n  \n   if os.path.exists(source):\n    os.rename(source, dest)\n  else:\n   self.rotator(source, dest)\n   \nclass RotatingFileHandler(BaseRotatingHandler):\n \"\"\n def __init__(self, filename, mode='a', maxBytes=0, backupCount=0, encoding=None, delay=False):\n  \"\"\n  \n  \n  \n  \n  \n  if maxBytes > 0:\n   mode = 'a'\n  BaseRotatingHandler.__init__(self, filename, mode, encoding, delay)\n  self.maxBytes = maxBytes\n  self.backupCount = backupCount\n  \n def doRollover(self):\n  \"\"\n  if self.stream:\n   self.stream.close()\n   self.stream = None\n  if self.backupCount > 0:\n   for i in range(self.backupCount - 1, 0, -1):\n    sfn = self.rotation_filename(\"%s.%d\" % (self.baseFilename, i))\n    dfn = self.rotation_filename(\"%s.%d\" % (self.baseFilename,\n    i + 1))\n    if os.path.exists(sfn):\n     if os.path.exists(dfn):\n      os.remove(dfn)\n     os.rename(sfn, dfn)\n   dfn = self.rotation_filename(self.baseFilename + \".1\")\n   if os.path.exists(dfn):\n    os.remove(dfn)\n   self.rotate(self.baseFilename, dfn)\n  if not self.delay:\n   self.stream = self._open()\n   \n def shouldRollover(self, record):\n  \"\"\n  if self.stream is None: \n   self.stream = self._open()\n  if self.maxBytes > 0: \n   msg = \"%s\\n\" % self.format(record)\n   self.stream.seek(0, 2) \n   if self.stream.tell() + len(msg) >= self.maxBytes:\n    return 1\n  return 0\n  \nclass TimedRotatingFileHandler(BaseRotatingHandler):\n \"\"\n def __init__(self, filename, when='h', interval=1, backupCount=0, encoding=None, delay=False, utc=False):\n  BaseRotatingHandler.__init__(self, filename, 'a', encoding, delay)\n  self.when = when.upper()\n  self.backupCount = backupCount\n  self.utc = utc\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if self.when == 'S':\n   self.interval = 1 \n   self.suffix = \"%Y-%m-%d_%H-%M-%S\"\n   self.extMatch = r\"^\\d{4}-\\d{2}-\\d{2}_\\d{2}-\\d{2}-\\d{2}(\\.\\w+)?$\"\n  elif self.when == 'M':\n   self.interval = 60 \n   self.suffix = \"%Y-%m-%d_%H-%M\"\n   self.extMatch = r\"^\\d{4}-\\d{2}-\\d{2}_\\d{2}-\\d{2}(\\.\\w+)?$\"\n  elif self.when == 'H':\n   self.interval = 60 * 60 \n   self.suffix = \"%Y-%m-%d_%H\"\n   self.extMatch = r\"^\\d{4}-\\d{2}-\\d{2}_\\d{2}(\\.\\w+)?$\"\n  elif self.when == 'D' or self.when == 'MIDNIGHT':\n   self.interval = 60 * 60 * 24 \n   self.suffix = \"%Y-%m-%d\"\n   self.extMatch = r\"^\\d{4}-\\d{2}-\\d{2}(\\.\\w+)?$\"\n  elif self.when.startswith('W'):\n   self.interval = 60 * 60 * 24 * 7 \n   if len(self.when) != 2:\n    raise ValueError(\"You must specify a day for weekly rollover from 0 to 6 (0 is Monday): %s\" % self.when)\n   if self.when[1] < '0' or self.when[1] > '6':\n    raise ValueError(\"Invalid day specified for weekly rollover: %s\" % self.when)\n   self.dayOfWeek = int(self.when[1])\n   self.suffix = \"%Y-%m-%d\"\n   self.extMatch = r\"^\\d{4}-\\d{2}-\\d{2}(\\.\\w+)?$\"\n  else:\n   raise ValueError(\"Invalid rollover interval specified: %s\" % self.when)\n   \n  self.extMatch = re.compile(self.extMatch, re.ASCII)\n  self.interval = self.interval * interval \n  if os.path.exists(filename):\n   t = os.stat(filename)[ST_MTIME]\n  else:\n   t = int(time.time())\n  self.rolloverAt = self.computeRollover(t)\n  \n def computeRollover(self, currentTime):\n  \"\"\n  result = currentTime + self.interval\n  \n  \n  \n  \n  \n  \n  \n  if self.when == 'MIDNIGHT' or self.when.startswith('W'):\n  \n   if self.utc:\n    t = time.gmtime(currentTime)\n   else:\n    t = time.localtime(currentTime)\n   currentHour = t[3]\n   currentMinute = t[4]\n   currentSecond = t[5]\n   \n   r = _MIDNIGHT - ((currentHour * 60 + currentMinute) * 60 +\n   currentSecond)\n   result = currentTime + r\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   if self.when.startswith('W'):\n    day = t[6] \n    if day != self.dayOfWeek:\n     if day < self.dayOfWeek:\n      daysToWait = self.dayOfWeek - day\n     else:\n      daysToWait = 6 - day + self.dayOfWeek + 1\n     newRolloverAt = result + (daysToWait * (60 * 60 * 24))\n     if not self.utc:\n      dstNow = t[-1]\n      dstAtRollover = time.localtime(newRolloverAt)[-1]\n      if dstNow != dstAtRollover:\n       if not dstNow: \n        addend = -3600\n       else: \n        addend = 3600\n       newRolloverAt += addend\n     result = newRolloverAt\n  return result\n  \n def shouldRollover(self, record):\n  \"\"\n  t = int(time.time())\n  if t >= self.rolloverAt:\n   return 1\n  return 0\n  \n def getFilesToDelete(self):\n  \"\"\n  dirName, baseName = os.path.split(self.baseFilename)\n  fileNames = os.listdir(dirName)\n  result = []\n  prefix = baseName + \".\"\n  plen = len(prefix)\n  for fileName in fileNames:\n   if fileName[:plen] == prefix:\n    suffix = fileName[plen:]\n    if self.extMatch.match(suffix):\n     result.append(os.path.join(dirName, fileName))\n  result.sort()\n  if len(result) < self.backupCount:\n   result = []\n  else:\n   result = result[:len(result) - self.backupCount]\n  return result\n  \n def doRollover(self):\n  \"\"\n  if self.stream:\n   self.stream.close()\n   self.stream = None\n   \n  currentTime = int(time.time())\n  dstNow = time.localtime(currentTime)[-1]\n  t = self.rolloverAt - self.interval\n  if self.utc:\n   timeTuple = time.gmtime(t)\n  else:\n   timeTuple = time.localtime(t)\n   dstThen = timeTuple[-1]\n   if dstNow != dstThen:\n    if dstNow:\n     addend = 3600\n    else:\n     addend = -3600\n    timeTuple = time.localtime(t + addend)\n  dfn = self.rotation_filename(self.baseFilename + \".\" +\n  time.strftime(self.suffix, timeTuple))\n  if os.path.exists(dfn):\n   os.remove(dfn)\n  self.rotate(self.baseFilename, dfn)\n  if self.backupCount > 0:\n   for s in self.getFilesToDelete():\n    os.remove(s)\n  if not self.delay:\n   self.stream = self._open()\n  newRolloverAt = self.computeRollover(currentTime)\n  while newRolloverAt <= currentTime:\n   newRolloverAt = newRolloverAt + self.interval\n   \n  if (self.when == 'MIDNIGHT' or self.when.startswith('W')) and not self.utc:\n   dstAtRollover = time.localtime(newRolloverAt)[-1]\n   if dstNow != dstAtRollover:\n    if not dstNow: \n     addend = -3600\n    else: \n     addend = 3600\n    newRolloverAt += addend\n  self.rolloverAt = newRolloverAt\n  \nclass WatchedFileHandler(logging.FileHandler):\n \"\"\n def __init__(self, filename, mode='a', encoding=None, delay=False):\n  logging.FileHandler.__init__(self, filename, mode, encoding, delay)\n  self.dev, self.ino = -1, -1\n  self._statstream()\n  \n def _statstream(self):\n  if self.stream:\n   sres = os.fstat(self.stream.fileno())\n   self.dev, self.ino = sres[ST_DEV], sres[ST_INO]\n   \n def emit(self, record):\n  \"\"\n  \n  \n  \n  \n  try:\n  \n   sres = os.stat(self.baseFilename)\n  except OSError as err:\n   if err.errno == errno.ENOENT:\n    sres = None\n   else:\n    raise\n    \n  if not sres or sres[ST_DEV] != self.dev or sres[ST_INO] != self.ino:\n   if self.stream is not None:\n   \n    self.stream.flush()\n    self.stream.close()\n    \n    self.stream = self._open()\n    self._statstream()\n  logging.FileHandler.emit(self, record)\n  \n  \nclass SocketHandler(logging.Handler):\n \"\"\n \n def __init__(self, host, port):\n  \"\"\n  logging.Handler.__init__(self)\n  self.host = host\n  self.port = port\n  self.sock = None\n  self.closeOnError = False\n  self.retryTime = None\n  \n  \n  \n  self.retryStart = 1.0\n  self.retryMax = 30.0\n  self.retryFactor = 2.0\n  \n def makeSocket(self, timeout=1):\n  \"\"\n  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n  if hasattr(s, 'settimeout'):\n   s.settimeout(timeout)\n  try:\n   s.connect((self.host, self.port))\n   return s\n  except socket.error:\n   s.close()\n   raise\n   \n def createSocket(self):\n  \"\"\n  now = time.time()\n  \n  \n  \n  if self.retryTime is None:\n   attempt = True\n  else:\n   attempt = (now >= self.retryTime)\n  if attempt:\n   try:\n    self.sock = self.makeSocket()\n    self.retryTime = None \n   except socket.error:\n   \n    if self.retryTime is None:\n     self.retryPeriod = self.retryStart\n    else:\n     self.retryPeriod = self.retryPeriod * self.retryFactor\n     if self.retryPeriod > self.retryMax:\n      self.retryPeriod = self.retryMax\n    self.retryTime = now + self.retryPeriod\n    \n def send(self, s):\n  \"\"\n  if self.sock is None:\n   self.createSocket()\n   \n   \n   \n  if self.sock:\n   try:\n    if hasattr(self.sock, \"sendall\"):\n     self.sock.sendall(s)\n    else: \n     sentsofar = 0\n     left = len(s)\n     while left > 0:\n      sent = self.sock.send(s[sentsofar:])\n      sentsofar = sentsofar + sent\n      left = left - sent\n   except socket.error: \n    self.sock.close()\n    self.sock = None \n    \n def makePickle(self, record):\n  \"\"\n  ei = record.exc_info\n  if ei:\n  \n   dummy = self.format(record)\n   \n   \n   \n  d = dict(record.__dict__)\n  d['msg'] = record.getMessage()\n  d['args'] = None\n  d['exc_info'] = None\n  s = pickle.dumps(d, 1)\n  slen = struct.pack(\">L\", len(s))\n  return slen + s\n  \n def handleError(self, record):\n  \"\"\n  if self.closeOnError and self.sock:\n   self.sock.close()\n   self.sock = None \n  else:\n   logging.Handler.handleError(self, record)\n   \n def emit(self, record):\n  \"\"\n  try:\n   s = self.makePickle(record)\n   self.send(s)\n  except (KeyboardInterrupt, SystemExit): \n   raise\n  except:\n   self.handleError(record)\n   \n def close(self):\n  \"\"\n  self.acquire()\n  try:\n   if self.sock:\n    self.sock.close()\n    self.sock = None\n   logging.Handler.close(self)\n  finally:\n   self.release()\n   \nclass DatagramHandler(SocketHandler):\n \"\"\n def __init__(self, host, port):\n  \"\"\n  SocketHandler.__init__(self, host, port)\n  self.closeOnError = False\n  \n def makeSocket(self):\n  \"\"\n  s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n  return s\n  \n def send(self, s):\n  \"\"\n  if self.sock is None:\n   self.createSocket()\n  self.sock.sendto(s, (self.host, self.port))\n  \nclass SysLogHandler(logging.Handler):\n \"\"\n \n \n \n \n \n \n \n \n \n \n \n LOG_EMERG = 0 \n LOG_ALERT = 1 \n LOG_CRIT = 2 \n LOG_ERR = 3 \n LOG_WARNING = 4 \n LOG_NOTICE = 5 \n LOG_INFO = 6 \n LOG_DEBUG = 7 \n \n \n LOG_KERN = 0 \n LOG_USER = 1 \n LOG_MAIL = 2 \n LOG_DAEMON = 3 \n LOG_AUTH = 4 \n LOG_SYSLOG = 5 \n LOG_LPR = 6 \n LOG_NEWS = 7 \n LOG_UUCP = 8 \n LOG_CRON = 9 \n LOG_AUTHPRIV = 10 \n LOG_FTP = 11 \n \n \n LOG_LOCAL0 = 16 \n LOG_LOCAL1 = 17 \n LOG_LOCAL2 = 18 \n LOG_LOCAL3 = 19 \n LOG_LOCAL4 = 20 \n LOG_LOCAL5 = 21 \n LOG_LOCAL6 = 22 \n LOG_LOCAL7 = 23 \n \n priority_names = {\n \"alert\": LOG_ALERT,\n \"crit\": LOG_CRIT,\n \"critical\": LOG_CRIT,\n \"debug\": LOG_DEBUG,\n \"emerg\": LOG_EMERG,\n \"err\": LOG_ERR,\n \"error\": LOG_ERR, \n \"info\": LOG_INFO,\n \"notice\": LOG_NOTICE,\n \"panic\": LOG_EMERG, \n \"warn\": LOG_WARNING, \n \"warning\": LOG_WARNING,\n }\n \n facility_names = {\n \"auth\": LOG_AUTH,\n \"authpriv\": LOG_AUTHPRIV,\n \"cron\": LOG_CRON,\n \"daemon\": LOG_DAEMON,\n \"ftp\": LOG_FTP,\n \"kern\": LOG_KERN,\n \"lpr\": LOG_LPR,\n \"mail\": LOG_MAIL,\n \"news\": LOG_NEWS,\n \"security\": LOG_AUTH, \n \"syslog\": LOG_SYSLOG,\n \"user\": LOG_USER,\n \"uucp\": LOG_UUCP,\n \"local0\": LOG_LOCAL0,\n \"local1\": LOG_LOCAL1,\n \"local2\": LOG_LOCAL2,\n \"local3\": LOG_LOCAL3,\n \"local4\": LOG_LOCAL4,\n \"local5\": LOG_LOCAL5,\n \"local6\": LOG_LOCAL6,\n \"local7\": LOG_LOCAL7,\n }\n \n \n \n \n \n priority_map = {\n \"DEBUG\" : \"debug\",\n \"INFO\" : \"info\",\n \"WARNING\" : \"warning\",\n \"ERROR\" : \"error\",\n \"CRITICAL\" : \"critical\"\n }\n \n def __init__(self, address=('localhost', SYSLOG_UDP_PORT),\n facility=LOG_USER, socktype=None):\n  \"\"\n  logging.Handler.__init__(self)\n  \n  self.address = address\n  self.facility = facility\n  self.socktype = socktype\n  \n  if isinstance(address, str):\n   self.unixsocket = True\n   self._connect_unixsocket(address)\n  else:\n   self.unixsocket = False\n   if socktype is None:\n    socktype = socket.SOCK_DGRAM\n   self.socket = socket.socket(socket.AF_INET, socktype)\n   if socktype == socket.SOCK_STREAM:\n    self.socket.connect(address)\n   self.socktype = socktype\n  self.formatter = None\n  \n def _connect_unixsocket(self, address):\n  use_socktype = self.socktype\n  if use_socktype is None:\n   use_socktype = socket.SOCK_DGRAM\n  self.socket = socket.socket(socket.AF_UNIX, use_socktype)\n  try:\n   self.socket.connect(address)\n   \n   self.socktype = use_socktype\n  except socket.error:\n   self.socket.close()\n   if self.socktype is not None:\n   \n    raise\n   use_socktype = socket.SOCK_STREAM\n   self.socket = socket.socket(socket.AF_UNIX, use_socktype)\n   try:\n    self.socket.connect(address)\n    \n    self.socktype = use_socktype\n   except socket.error:\n    self.socket.close()\n    raise\n    \n def encodePriority(self, facility, priority):\n  \"\"\n  if isinstance(facility, str):\n   facility = self.facility_names[facility]\n  if isinstance(priority, str):\n   priority = self.priority_names[priority]\n  return (facility << 3) | priority\n  \n def close (self):\n  \"\"\n  self.acquire()\n  try:\n   self.socket.close()\n   logging.Handler.close(self)\n  finally:\n   self.release()\n   \n def mapPriority(self, levelName):\n  \"\"\n  return self.priority_map.get(levelName, \"warning\")\n  \n ident = '' \n append_nul = True \n \n def emit(self, record):\n  \"\"\n  msg = self.format(record)\n  if self.ident:\n   msg = self.ident + msg\n  if self.append_nul:\n   msg += '\\000'\n  \"\"\"\n        We need to convert record level to lowercase, maybe this will\n        change in the future.\n        \"\"\"  \n  prio = '<%d>' % self.encodePriority(self.facility,\n  self.mapPriority(record.levelname))\n  prio = prio.encode('utf-8')\n  \n  msg = msg.encode('utf-8')\n  msg = prio + msg\n  try:\n   if self.unixsocket:\n    try:\n     self.socket.send(msg)\n    except socket.error:\n     self.socket.close()\n     self._connect_unixsocket(self.address)\n     self.socket.send(msg)\n   elif self.socktype == socket.SOCK_DGRAM:\n    self.socket.sendto(msg, self.address)\n   else:\n    self.socket.sendall(msg)\n  except (KeyboardInterrupt, SystemExit): \n   raise\n  except:\n   self.handleError(record)\n   \nclass SMTPHandler(logging.Handler):\n \"\"\n def __init__(self, mailhost, fromaddr, toaddrs, subject,\n credentials=None, secure=None, timeout=5.0):\n  \"\"\n  logging.Handler.__init__(self)\n  if isinstance(mailhost, tuple):\n   self.mailhost, self.mailport = mailhost\n  else:\n   self.mailhost, self.mailport = mailhost, None\n  if isinstance(credentials, tuple):\n   self.username, self.password = credentials\n  else:\n   self.username = None\n  self.fromaddr = fromaddr\n  if isinstance(toaddrs, str):\n   toaddrs = [toaddrs]\n  self.toaddrs = toaddrs\n  self.subject = subject\n  self.secure = secure\n  self.timeout = timeout\n  \n def getSubject(self, record):\n  \"\"\n  return self.subject\n  \n def emit(self, record):\n  \"\"\n  try:\n   import smtplib\n   from email.utils import formatdate\n   port = self.mailport\n   if not port:\n    port = smtplib.SMTP_PORT\n   smtp = smtplib.SMTP(self.mailhost, port, timeout=self.timeout)\n   msg = self.format(record)\n   msg = \"From: %s\\r\\nTo: %s\\r\\nSubject: %s\\r\\nDate: %s\\r\\n\\r\\n%s\" % (\n   self.fromaddr,\n   \",\".join(self.toaddrs),\n   self.getSubject(record),\n   formatdate(), msg)\n   if self.username:\n    if self.secure is not None:\n     smtp.ehlo()\n     smtp.starttls(*self.secure)\n     smtp.ehlo()\n    smtp.login(self.username, self.password)\n   smtp.sendmail(self.fromaddr, self.toaddrs, msg)\n   smtp.quit()\n  except (KeyboardInterrupt, SystemExit): \n   raise\n  except:\n   self.handleError(record)\n   \nclass NTEventLogHandler(logging.Handler):\n \"\"\n def __init__(self, appname, dllname=None, logtype=\"Application\"):\n  logging.Handler.__init__(self)\n  try:\n   import win32evtlogutil, win32evtlog\n   self.appname = appname\n   self._welu = win32evtlogutil\n   if not dllname:\n    dllname = os.path.split(self._welu.__file__)\n    dllname = os.path.split(dllname[0])\n    dllname = os.path.join(dllname[0], r'win32service.pyd')\n   self.dllname = dllname\n   self.logtype = logtype\n   self._welu.AddSourceToRegistry(appname, dllname, logtype)\n   self.deftype = win32evtlog.EVENTLOG_ERROR_TYPE\n   self.typemap = {\n   logging.DEBUG : win32evtlog.EVENTLOG_INFORMATION_TYPE,\n   logging.INFO : win32evtlog.EVENTLOG_INFORMATION_TYPE,\n   logging.WARNING : win32evtlog.EVENTLOG_WARNING_TYPE,\n   logging.ERROR : win32evtlog.EVENTLOG_ERROR_TYPE,\n   logging.CRITICAL: win32evtlog.EVENTLOG_ERROR_TYPE,\n   }\n  except ImportError:\n   print(\"The Python Win32 extensions for NT (service, event \" \"logging) appear not to be available.\")\n   self._welu = None\n   \n def getMessageID(self, record):\n  \"\"\n  return 1\n  \n def getEventCategory(self, record):\n  \"\"\n  return 0\n  \n def getEventType(self, record):\n  \"\"\n  return self.typemap.get(record.levelno, self.deftype)\n  \n def emit(self, record):\n  \"\"\n  if self._welu:\n   try:\n    id = self.getMessageID(record)\n    cat = self.getEventCategory(record)\n    type = self.getEventType(record)\n    msg = self.format(record)\n    self._welu.ReportEvent(self.appname, id, cat, type, [msg])\n   except (KeyboardInterrupt, SystemExit): \n    raise\n   except:\n    self.handleError(record)\n    \n def close(self):\n  \"\"\n  \n  logging.Handler.close(self)\n  \nclass HTTPHandler(logging.Handler):\n \"\"\n def __init__(self, host, url, method=\"GET\", secure=False, credentials=None):\n  \"\"\n  logging.Handler.__init__(self)\n  method = method.upper()\n  if method not in [\"GET\", \"POST\"]:\n   raise ValueError(\"method must be GET or POST\")\n  self.host = host\n  self.url = url\n  self.method = method\n  self.secure = secure\n  self.credentials = credentials\n  \n def mapLogRecord(self, record):\n  \"\"\n  return record.__dict__\n  \n def emit(self, record):\n  \"\"\n  try:\n   import http.client, urllib.parse\n   host = self.host\n   if self.secure:\n    h = http.client.HTTPSConnection(host)\n   else:\n    h = http.client.HTTPConnection(host)\n   url = self.url\n   data = urllib.parse.urlencode(self.mapLogRecord(record))\n   if self.method == \"GET\":\n    if (url.find('?') >= 0):\n     sep = '&'\n    else:\n     sep = '?'\n    url = url + \"%c%s\" % (sep, data)\n   h.putrequest(self.method, url)\n   \n   \n   i = host.find(\":\")\n   if i >= 0:\n    host = host[:i]\n   h.putheader(\"Host\", host)\n   if self.method == \"POST\":\n    h.putheader(\"Content-type\",\n    \"application/x-www-form-urlencoded\")\n    h.putheader(\"Content-length\", str(len(data)))\n   if self.credentials:\n    import base64\n    s = ('u%s:%s' % self.credentials).encode('utf-8')\n    s = 'Basic ' + base64.b64encode(s).strip()\n    h.putheader('Authorization', s)\n   h.endheaders()\n   if self.method == \"POST\":\n    h.send(data.encode('utf-8'))\n   h.getresponse() \n  except (KeyboardInterrupt, SystemExit): \n   raise\n  except:\n   self.handleError(record)\n   \nclass BufferingHandler(logging.Handler):\n \"\"\n def __init__(self, capacity):\n  \"\"\n  logging.Handler.__init__(self)\n  self.capacity = capacity\n  self.buffer = []\n  \n def shouldFlush(self, record):\n  \"\"\n  return (len(self.buffer) >= self.capacity)\n  \n def emit(self, record):\n  \"\"\n  self.buffer.append(record)\n  if self.shouldFlush(record):\n   self.flush()\n   \n def flush(self):\n  \"\"\n  self.acquire()\n  try:\n   self.buffer = []\n  finally:\n   self.release()\n   \n def close(self):\n  \"\"\n  self.flush()\n  logging.Handler.close(self)\n  \nclass MemoryHandler(BufferingHandler):\n \"\"\n def __init__(self, capacity, flushLevel=logging.ERROR, target=None):\n  \"\"\n  BufferingHandler.__init__(self, capacity)\n  self.flushLevel = flushLevel\n  self.target = target\n  \n def shouldFlush(self, record):\n  \"\"\n  return (len(self.buffer) >= self.capacity) or (record.levelno >= self.flushLevel)\n  \n def setTarget(self, target):\n  \"\"\n  self.target = target\n  \n def flush(self):\n  \"\"\n  self.acquire()\n  try:\n   if self.target:\n    for record in self.buffer:\n     self.target.handle(record)\n    self.buffer = []\n  finally:\n   self.release()\n   \n def close(self):\n  \"\"\n  self.flush()\n  self.acquire()\n  try:\n   self.target = None\n   BufferingHandler.close(self)\n  finally:\n   self.release()\n   \n   \nclass QueueHandler(logging.Handler):\n \"\"\n \n def __init__(self, queue):\n  \"\"\n  logging.Handler.__init__(self)\n  self.queue = queue\n  \n def enqueue(self, record):\n  \"\"\n  self.queue.put_nowait(record)\n  \n def prepare(self, record):\n  \"\"\n  \n  \n  \n  \n  \n  \n  self.format(record)\n  record.msg = record.message\n  record.args = None\n  record.exc_info = None\n  return record\n  \n def emit(self, record):\n  \"\"\n  try:\n   self.enqueue(self.prepare(record))\n  except (KeyboardInterrupt, SystemExit): \n   raise\n  except:\n   self.handleError(record)\n   \nif threading:\n class QueueListener(object):\n  \"\"\n  _sentinel = None\n  \n  def __init__(self, queue, *handlers):\n   \"\"\n   self.queue = queue\n   self.handlers = handlers\n   self._stop = threading.Event()\n   self._thread = None\n   \n  def dequeue(self, block):\n   \"\"\n   return self.queue.get(block)\n   \n  def start(self):\n   \"\"\n   self._thread = t = threading.Thread(target=self._monitor)\n   t.setDaemon(True)\n   t.start()\n   \n  def prepare(self , record):\n   \"\"\n   return record\n   \n  def handle(self, record):\n   \"\"\n   record = self.prepare(record)\n   for handler in self.handlers:\n    handler.handle(record)\n    \n  def _monitor(self):\n   \"\"\n   q = self.queue\n   has_task_done = hasattr(q, 'task_done')\n   while not self._stop.isSet():\n    try:\n     record = self.dequeue(True)\n     if record is self._sentinel:\n      break\n     self.handle(record)\n     if has_task_done:\n      q.task_done()\n    except queue.Empty:\n     pass\n     \n   while True:\n    try:\n     record = self.dequeue(False)\n     if record is self._sentinel:\n      break\n     self.handle(record)\n     if has_task_done:\n      q.task_done()\n    except queue.Empty:\n     break\n     \n  def enqueue_sentinel(self):\n   \"\"\n   self.queue.put_nowait(self._sentinel)\n   \n  def stop(self):\n   \"\"\n   self._stop.set()\n   self.enqueue_sentinel()\n   self._thread.join()\n   self._thread = None\n"], "abc": [".py", "\n\n\n\"\"\n\nfrom _weakrefset import WeakSet\n\ndef abstractmethod(funcobj):\n \"\"\n funcobj.__isabstractmethod__ = True\n return funcobj\n \n \nclass abstractclassmethod(classmethod):\n \"\"\n \n __isabstractmethod__ = True\n \n def __init__(self, callable):\n  callable.__isabstractmethod__ = True\n  super().__init__(callable)\n  \n  \nclass abstractstaticmethod(staticmethod):\n \"\"\n \n __isabstractmethod__ = True\n \n def __init__(self, callable):\n  callable.__isabstractmethod__ = True\n  super().__init__(callable)\n  \n  \nclass abstractproperty(property):\n \"\"\n \n __isabstractmethod__ = True\n \n \nclass ABCMeta(type):\n\n \"\"\n \n \n \n \n _abc_invalidation_counter = 0\n \n def __new__(mcls, name, bases, namespace):\n  cls = super().__new__(mcls, name, bases, namespace)\n  \n  abstracts = {name\n  for name, value in namespace.items()\n  if getattr(value, \"__isabstractmethod__\", False)}\n  for base in bases:\n   for name in getattr(base, \"__abstractmethods__\", set()):\n    value = getattr(cls, name, None)\n    if getattr(value, \"__isabstractmethod__\", False):\n     abstracts.add(name)\n  cls.__abstractmethods__ = frozenset(abstracts)\n  \n  cls._abc_registry = WeakSet()\n  cls._abc_cache = WeakSet()\n  cls._abc_negative_cache = WeakSet()\n  cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter\n  return cls\n  \n def register(cls, subclass):\n  \"\"\n  if not isinstance(subclass, type):\n   raise TypeError(\"Can only register classes\")\n  if issubclass(subclass, cls):\n   return subclass \n   \n   \n  if issubclass(cls, subclass):\n  \n   raise RuntimeError(\"Refusing to create an inheritance cycle\")\n  cls._abc_registry.add(subclass)\n  ABCMeta._abc_invalidation_counter += 1 \n  return subclass\n  \n def _dump_registry(cls, file=None):\n  \"\"\n  print(\"Class: %s.%s\" % (cls.__module__, cls.__name__), file=file)\n  print(\"Inv.counter: %s\" % ABCMeta._abc_invalidation_counter, file=file)\n  for name in sorted(cls.__dict__.keys()):\n   if name.startswith(\"_abc_\"):\n    value = getattr(cls, name)\n    print(\"%s: %r\" % (name, value), file=file)\n    \n def __instancecheck__(cls, instance):\n  \"\"\n  \n  subclass = instance.__class__\n  if subclass in cls._abc_cache:\n   return True\n  subtype = type(instance)\n  if subtype is subclass:\n   if (cls._abc_negative_cache_version ==\n   ABCMeta._abc_invalidation_counter and\n   subclass in cls._abc_negative_cache):\n    return False\n    \n   return cls.__subclasscheck__(subclass)\n  return any(cls.__subclasscheck__(c) for c in {subclass, subtype})\n  \n def __subclasscheck__(cls, subclass):\n  \"\"\n  \n  if subclass in cls._abc_cache:\n   return True\n   \n  if cls._abc_negative_cache_version < ABCMeta._abc_invalidation_counter:\n  \n   cls._abc_negative_cache = WeakSet()\n   cls._abc_negative_cache_version = ABCMeta._abc_invalidation_counter\n  elif subclass in cls._abc_negative_cache:\n   return False\n   \n  ok = cls.__subclasshook__(subclass)\n  if ok is not NotImplemented:\n   assert isinstance(ok, bool)\n   if ok:\n    cls._abc_cache.add(subclass)\n   else:\n    cls._abc_negative_cache.add(subclass)\n   return ok\n   \n  if cls in getattr(subclass, '__mro__', ()):\n   cls._abc_cache.add(subclass)\n   return True\n   \n  for rcls in cls._abc_registry:\n   if issubclass(subclass, rcls):\n    cls._abc_cache.add(subclass)\n    return True\n    \n  for scls in cls.__subclasses__():\n   if issubclass(subclass, scls):\n    cls._abc_cache.add(subclass)\n    return True\n    \n  cls._abc_negative_cache.add(subclass)\n  return False\n"], "_thread": [".py", "\"\"\n\n\n__all__ = ['error', 'start_new_thread', 'exit', 'get_ident', 'allocate_lock',\n'interrupt_main', 'LockType']\n\n\nTIMEOUT_MAX = 2**31\n\n\n\n\n\n\nerror = RuntimeError\n\ndef start_new_thread(function, args, kwargs={}):\n \"\"\n if type(args) != type(tuple()):\n  raise TypeError(\"2nd arg must be a tuple\")\n if type(kwargs) != type(dict()):\n  raise TypeError(\"3rd arg must be a dict\")\n global _main\n _main = False\n try:\n  function(*args, **kwargs)\n except SystemExit:\n  pass\n except:\n  import traceback\n  traceback.print_exc()\n _main = True\n global _interrupt\n if _interrupt:\n  _interrupt = False\n  raise KeyboardInterrupt\n  \ndef exit():\n \"\"\n raise SystemExit\n \ndef get_ident():\n \"\"\n return -1\n \ndef allocate_lock():\n \"\"\n return LockType()\n \ndef stack_size(size=None):\n \"\"\n if size is not None:\n  raise error(\"setting thread stack size not supported\")\n return 0\n \nclass LockType(object):\n \"\"\n \n def __init__(self):\n  self.locked_status = False\n  \n def acquire(self, waitflag=None, timeout=-1):\n  \"\"\n  if waitflag is None or waitflag:\n   self.locked_status = True\n   return True\n  else:\n   if not self.locked_status:\n    self.locked_status = True\n    return True\n   else:\n    if timeout > 0:\n     import time\n     time.sleep(timeout)\n    return False\n    \n __enter__ = acquire\n \n def __exit__(self, typ, val, tb):\n  self.release()\n  \n def release(self):\n  \"\"\n  \n  \n  if not self.locked_status:\n   raise error\n  self.locked_status = False\n  return True\n  \n def locked(self):\n  return self.locked_status\n  \n  \n_interrupt = False\n\n_main = True\n\ndef interrupt_main():\n \"\"\n if _main:\n  raise KeyboardInterrupt\n else:\n  global _interrupt\n  _interrupt = True\n  \n  \nclass _local:\n pass"], "html.parser": [".py", "\"\"\n\n\n\n\n\n\n\n\n\nimport _markupbase\nimport re\nimport warnings\n\n\n\ninteresting_normal = re.compile('[&<]')\nincomplete = re.compile('&[a-zA-Z#]')\n\nentityref = re.compile('&([a-zA-Z][-.a-zA-Z0-9]*)[^a-zA-Z0-9]')\ncharref = re.compile('&#(?:[0-9]+|[xX][0-9a-fA-F]+)[^0-9a-fA-F]')\n\nstarttagopen = re.compile('<[a-zA-Z]')\npiclose = re.compile('>')\ncommentclose = re.compile(r'--\\s*>')\ntagfind = re.compile('([a-zA-Z][-.a-zA-Z0-9:_]*)(?:\\s|/(?!>))*')\n\n\ntagfind_tolerant = re.compile('[a-zA-Z][^\\t\\n\\r\\f />\\x00]*')\n\n\n\n\n\n\nattrfind = re.compile(\nr'\\s*([a-zA-Z_][-.:a-zA-Z_0-9]*)(\\s*=\\s*'\nr'(\\'[^\\']*\\'|\"[^\"]*\"|[^\\s\"\\'=<>`]*))?')\nattrfind_tolerant = re.compile(\nr'((?<=[\\'\"\\s/])[^\\s/>][^\\s/=>]*)(\\s*=+\\s*'\nr'(\\'[^\\']*\\'|\"[^\"]*\"|(?![\\'\"])[^>\\s]*))?(?:\\s|/(?!>))*')\nlocatestarttagend = re.compile(r\"\"\"\n  <[a-zA-Z][-.a-zA-Z0-9:_]*          # tag name\n  (?:\\s+                             # whitespace before attribute name\n    (?:[a-zA-Z_][-.:a-zA-Z0-9_]*     # attribute name\n      (?:\\s*=\\s*                     # value indicator\n        (?:'[^']*'                   # LITA-enclosed value\n          |\\\"[^\\\"]*\\\"                # LIT-enclosed value\n          |[^'\\\">\\s]+                # bare value\n         )\n       )?\n     )\n   )*\n  \\s*                                # trailing whitespace\n\"\"\", re.VERBOSE)\nlocatestarttagend_tolerant = re.compile(r\"\"\"\n  <[a-zA-Z][-.a-zA-Z0-9:_]*          # tag name\n  (?:[\\s/]*                          # optional whitespace before attribute name\n    (?:(?<=['\"\\s/])[^\\s/>][^\\s/=>]*  # attribute name\n      (?:\\s*=+\\s*                    # value indicator\n        (?:'[^']*'                   # LITA-enclosed value\n          |\"[^\"]*\"                   # LIT-enclosed value\n          |(?!['\"])[^>\\s]*           # bare value\n         )\n         (?:\\s*,)*                   # possibly followed by a comma\n       )?(?:\\s|/(?!>))*\n     )*\n   )?\n  \\s*                                # trailing whitespace\n\"\"\", re.VERBOSE)\nendendtag = re.compile('>')\n\n\nendtagfind = re.compile('</\\s*([a-zA-Z][-.a-zA-Z0-9:_]*)\\s*>')\n\n\nclass HTMLParseError(Exception):\n \"\"\n \n def __init__(self, msg, position=(None, None)):\n  assert msg\n  self.msg = msg\n  self.lineno = position[0]\n  self.offset = position[1]\n  \n def __str__(self):\n  result = self.msg\n  if self.lineno is not None:\n   result = result + \", at line %d\" % self.lineno\n  if self.offset is not None:\n   result = result + \", column %d\" % (self.offset + 1)\n  return result\n  \n  \nclass HTMLParser(_markupbase.ParserBase):\n \"\"\n \n CDATA_CONTENT_ELEMENTS = (\"script\", \"style\")\n \n def __init__(self, strict=False):\n  \"\"\n  if strict:\n   warnings.warn(\"The strict mode is deprecated.\",\n   DeprecationWarning, stacklevel=2)\n  self.strict = strict\n  self.reset()\n  \n def reset(self):\n  \"\"\n  self.rawdata = ''\n  self.lasttag = '???'\n  self.interesting = interesting_normal\n  self.cdata_elem = None\n  _markupbase.ParserBase.reset(self)\n  \n def feed(self, data):\n  \"\"\n  self.rawdata = self.rawdata + data\n  self.goahead(0)\n  \n def close(self):\n  \"\"\n  self.goahead(1)\n  \n def error(self, message):\n  raise HTMLParseError(message, self.getpos())\n  \n __starttag_text = None\n \n def get_starttag_text(self):\n  \"\"\n  return self.__starttag_text\n  \n def set_cdata_mode(self, elem):\n  self.cdata_elem = elem.lower()\n  self.interesting = re.compile(r'</\\s*%s\\s*>' % self.cdata_elem, re.I)\n  \n def clear_cdata_mode(self):\n  self.interesting = interesting_normal\n  self.cdata_elem = None\n  \n  \n  \n  \n def goahead(self, end):\n  rawdata = self.rawdata\n  i = 0\n  n = len(rawdata)\n  while i < n:\n   match = self.interesting.search(rawdata, i) \n   if match:\n    j = match.start()\n   else:\n    if self.cdata_elem:\n     break\n    j = n\n   if i < j: self.handle_data(rawdata[i:j])\n   i = self.updatepos(i, j)\n   if i == n: break\n   startswith = rawdata.startswith\n   if startswith('<', i):\n    if starttagopen.match(rawdata, i): \n     k = self.parse_starttag(i)\n    elif startswith(\"</\", i):\n     k = self.parse_endtag(i)\n    elif startswith(\"<!--\", i):\n     k = self.parse_comment(i)\n    elif startswith(\"<?\", i):\n     k = self.parse_pi(i)\n    elif startswith(\"<!\", i):\n     if self.strict:\n      k = self.parse_declaration(i)\n     else:\n      k = self.parse_html_declaration(i)\n    elif (i + 1) < n:\n     self.handle_data(\"<\")\n     k = i + 1\n    else:\n     break\n    if k < 0:\n     if not end:\n      break\n     if self.strict:\n      self.error(\"EOF in middle of construct\")\n     k = rawdata.find('>', i + 1)\n     if k < 0:\n      k = rawdata.find('<', i + 1)\n      if k < 0:\n       k = i + 1\n     else:\n      k += 1\n     self.handle_data(rawdata[i:k])\n    i = self.updatepos(i, k)\n   elif startswith(\"&#\", i):\n    match = charref.match(rawdata, i)\n    if match:\n     name = match.group()[2:-1]\n     self.handle_charref(name)\n     k = match.end()\n     if not startswith(';', k-1):\n      k = k - 1\n     i = self.updatepos(i, k)\n     continue\n    else:\n     if \";\" in rawdata[i:]: \n      self.handle_data(rawdata[0:2])\n      i = self.updatepos(i, 2)\n     break\n   elif startswith('&', i):\n    match = entityref.match(rawdata, i)\n    if match:\n     name = match.group(1)\n     self.handle_entityref(name)\n     k = match.end()\n     if not startswith(';', k-1):\n      k = k - 1\n     i = self.updatepos(i, k)\n     continue\n    match = incomplete.match(rawdata, i)\n    if match:\n    \n     if end and match.group() == rawdata[i:]:\n      if self.strict:\n       self.error(\"EOF in middle of entity or char ref\")\n      else:\n       k = match.end()\n       if k <= i:\n        k = n\n       i = self.updatepos(i, i + 1)\n       \n     break\n    elif (i + 1) < n:\n    \n    \n     self.handle_data(\"&\")\n     i = self.updatepos(i, i + 1)\n    else:\n     break\n   else:\n    assert 0, \"interesting.search() lied\"\n    \n  if end and i < n and not self.cdata_elem:\n   self.handle_data(rawdata[i:n])\n   i = self.updatepos(i, n)\n  self.rawdata = rawdata[i:]\n  \n  \n  \n  \n def parse_html_declaration(self, i):\n  rawdata = self.rawdata\n  assert rawdata[i:i+2] == '<!', ('unexpected call to '\n  'parse_html_declaration()')\n  if rawdata[i:i+4] == '<!--':\n  \n   return self.parse_comment(i)\n  elif rawdata[i:i+3] == '<![':\n   return self.parse_marked_section(i)\n  elif rawdata[i:i+9].lower() == '<!doctype':\n  \n   gtpos = rawdata.find('>', i+9)\n   if gtpos == -1:\n    return -1\n   self.handle_decl(rawdata[i+2:gtpos])\n   return gtpos+1\n  else:\n   return self.parse_bogus_comment(i)\n   \n   \n   \n def parse_bogus_comment(self, i, report=1):\n  rawdata = self.rawdata\n  assert rawdata[i:i+2] in ('<!', '</'), ('unexpected call to '\n  'parse_comment()')\n  pos = rawdata.find('>', i+2)\n  if pos == -1:\n   return -1\n  if report:\n   self.handle_comment(rawdata[i+2:pos])\n  return pos + 1\n  \n  \n def parse_pi(self, i):\n  rawdata = self.rawdata\n  assert rawdata[i:i+2] == '<?', 'unexpected call to parse_pi()'\n  match = piclose.search(rawdata, i+2) \n  if not match:\n   return -1\n  j = match.start()\n  self.handle_pi(rawdata[i+2: j])\n  j = match.end()\n  return j\n  \n  \n def parse_starttag(self, i):\n  self.__starttag_text = None\n  endpos = self.check_for_whole_start_tag(i)\n  if endpos < 0:\n   return endpos\n  rawdata = self.rawdata\n  self.__starttag_text = rawdata[i:endpos]\n  \n  \n  attrs = []\n  match = tagfind.match(rawdata, i+1)\n  assert match, 'unexpected call to parse_starttag()'\n  k = match.end()\n  self.lasttag = tag = match.group(1).lower()\n  while k < endpos:\n   if self.strict:\n    m = attrfind.match(rawdata, k)\n   else:\n    m = attrfind_tolerant.match(rawdata, k)\n   if not m:\n    break\n   attrname, rest, attrvalue = m.group(1, 2, 3)\n   if not rest:\n    attrvalue = None\n   elif attrvalue[:1] == '\\'' == attrvalue[-1:] or attrvalue[:1] == '\"' == attrvalue[-1:]:\n    attrvalue = attrvalue[1:-1]\n   if attrvalue:\n    attrvalue = self.unescape(attrvalue)\n   attrs.append((attrname.lower(), attrvalue))\n   k = m.end()\n   \n  end = rawdata[k:endpos].strip()\n  if end not in (\">\", \"/>\"):\n   lineno, offset = self.getpos()\n   if \"\\n\" in self.__starttag_text:\n    lineno = lineno + self.__starttag_text.count(\"\\n\")\n    offset = len(self.__starttag_text) - self.__starttag_text.rfind(\"\\n\")\n   else:\n    offset = offset + len(self.__starttag_text)\n   if self.strict:\n    self.error(\"junk characters in start tag: %r\"\n    % (rawdata[k:endpos][:20],))\n   self.handle_data(rawdata[i:endpos])\n   return endpos\n  if end.endswith('/>'):\n  \n   self.handle_startendtag(tag, attrs)\n  else:\n   self.handle_starttag(tag, attrs)\n   if tag in self.CDATA_CONTENT_ELEMENTS:\n    self.set_cdata_mode(tag)\n  return endpos\n  \n  \n  \n def check_for_whole_start_tag(self, i):\n  rawdata = self.rawdata\n  if self.strict:\n   m = locatestarttagend.match(rawdata, i)\n  else:\n   m = locatestarttagend_tolerant.match(rawdata, i)\n  if m:\n   j = m.end()\n   next = rawdata[j:j+1]\n   if next == \">\":\n    return j + 1\n   if next == \"/\":\n    if rawdata.startswith(\"/>\", j):\n     return j + 2\n    if rawdata.startswith(\"/\", j):\n    \n     return -1\n     \n    if self.strict:\n     self.updatepos(i, j + 1)\n     self.error(\"malformed empty start tag\")\n    if j > i:\n     return j\n    else:\n     return i + 1\n   if next == \"\":\n   \n    return -1\n   if next in (\"abcdefghijklmnopqrstuvwxyz=/\"\n   \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"):\n   \n   \n    return -1\n   if self.strict:\n    self.updatepos(i, j)\n    self.error(\"malformed start tag\")\n   if j > i:\n    return j\n   else:\n    return i + 1\n  raise AssertionError(\"we should not get here!\")\n  \n  \n def parse_endtag(self, i):\n  rawdata = self.rawdata\n  assert rawdata[i:i+2] == \"</\", \"unexpected call to parse_endtag\"\n  match = endendtag.search(rawdata, i+1) \n  if not match:\n   return -1\n  gtpos = match.end()\n  match = endtagfind.match(rawdata, i) \n  if not match:\n   if self.cdata_elem is not None:\n    self.handle_data(rawdata[i:gtpos])\n    return gtpos\n   if self.strict:\n    self.error(\"bad end tag: %r\" % (rawdata[i:gtpos],))\n    \n   namematch = tagfind_tolerant.match(rawdata, i+2)\n   if not namematch:\n   \n    if rawdata[i:i+3] == '</>':\n     return i+3\n    else:\n     return self.parse_bogus_comment(i)\n   tagname = namematch.group().lower()\n   \n   \n   \n   \n   gtpos = rawdata.find('>', namematch.end())\n   self.handle_endtag(tagname)\n   return gtpos+1\n   \n  elem = match.group(1).lower() \n  if self.cdata_elem is not None:\n   if elem != self.cdata_elem:\n    self.handle_data(rawdata[i:gtpos])\n    return gtpos\n    \n  self.handle_endtag(elem.lower())\n  self.clear_cdata_mode()\n  return gtpos\n  \n  \n def handle_startendtag(self, tag, attrs):\n  self.handle_starttag(tag, attrs)\n  self.handle_endtag(tag)\n  \n  \n def handle_starttag(self, tag, attrs):\n  pass\n  \n  \n def handle_endtag(self, tag):\n  pass\n  \n  \n def handle_charref(self, name):\n  pass\n  \n  \n def handle_entityref(self, name):\n  pass\n  \n  \n def handle_data(self, data):\n  pass\n  \n  \n def handle_comment(self, data):\n  pass\n  \n  \n def handle_decl(self, decl):\n  pass\n  \n  \n def handle_pi(self, data):\n  pass\n  \n def unknown_decl(self, data):\n  if self.strict:\n   self.error(\"unknown declaration: %r\" % (data,))\n   \n   \n def unescape(self, s):\n  if '&' not in s:\n   return s\n  def replaceEntities(s):\n   s = s.groups()[0]\n   try:\n    if s[0] == \"#\":\n     s = s[1:]\n     if s[0] in ['x','X']:\n      c = int(s[1:].rstrip(';'), 16)\n     else:\n      c = int(s.rstrip(';'))\n     return chr(c)\n   except ValueError:\n    return '&#' + s\n   else:\n    from html.entities import html5\n    if s in html5:\n     return html5[s]\n    elif s.endswith(';'):\n     return '&' + s\n    for x in range(2, len(s)):\n     if s[:x] in html5:\n      return html5[s[:x]] + s[x:]\n    else:\n     return '&' + s\n     \n  return re.sub(r\"&(#?[xX]?(?:[0-9a-fA-F]+;|\\w{1,32};?))\",\n  replaceEntities, s, flags=re.ASCII)\n"], "_multiprocessing": [".js", "// multiprocessing\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\nvar $s=[]\nfor(var $b in _b_) $s.push('var ' + $b +'=_b_[\"'+$b+'\"]')\neval($s.join(';'))\n\n//for(var $py_builtin in _b_){eval(\"var \"+$py_builtin+\"=_b_[$py_builtin]\")}\n\nvar $ProcessDict = {__class__:$B.$type,__name__:'Process'}\n\nvar $convert_args=function(args) {\n    var _list=[]\n    for(var i=0, _len_i = args.length; i < _len_i; i++) {\n      var _a=args[i]\n      if(isinstance(_a, str)){_list.push(\"'\"+_a+\"'\")} else {_list.push(_a)} \n    }\n\n    return _list.join(',')\n}\n\n$ProcessDict.__mro__ = [$ProcessDict, _b_.object.$dict]\n\n$ProcessDict.__str__=$ProcessDict.toString=$ProcessDict.__repr__=function(self){\n   return '<object Process>'\n}\n\n$ProcessDict.is_alive = function(self){return self.$alive}\n\n$ProcessDict.join = function(self, timeout){\n   // need to block until process is complete\n   // could probably use a addEventListener to execute all existing code\n   // after this join statement\n\n   self.$worker.addEventListener('message', function (e) {\n        var data=e.data\n        if (data.stdout != '') { // output stdout from process\n           $B.stdout.write(data.stdout)\n        }\n   }, false);\n}\n\n$ProcessDict.run = function(self){\n   //fix me\n}\n\n$ProcessDict.start = function(self){\n   //var _args=[]\n   //for(var i=0; i < self.$args.length; i++) {\n   //   var _a=self.$args[i]\n   //   if(isinstance(_a, str)){_args.push(\"'\"+_a+\"'\")} else {_args.push(_a)} \n   //}\n\n   self.$worker.postMessage({target: self.$target, \n                             args: $convert_args(self.$args),\n                          //   kwargs: self.$kwargs\n                           })\n   self.$worker.addEventListener('error', function(e) { throw e})\n   self.$alive=true\n}\n\n$ProcessDict.terminate = function(self){\n   self.$worker.terminate()\n   self.$alive=false\n}\n\n// variables\n//name\n//daemon\n//pid\n//exitcode\n\nfunction Process(){\n    //arguments group=None, target=None, name=None, args=(), kwargs=()\n\n    var $ns=$B.$MakeArgs('Process',arguments,[],[],null,'kw')\n    var kw=$ns['kw']\n\n    var target=_b_.dict.$dict.get($ns['kw'],'target',None)\n    var args=_b_.dict.$dict.get($ns['kw'],'args',tuple())\n\n    var worker = new Worker('/src/web_workers/multiprocessing.js')\n\n    var res = {\n        __class__:$ProcessDict,\n        $worker: worker,\n        name: $ns['name'] || None,\n        $target: target+'',\n        $args: args,\n        //$kwargs: $ns['kw'],\n        $alive: false\n    }\n    return res\n}\n\nProcess.__class__ = $B.$factory\nProcess.$dict = $ProcessDict\n\n\nvar $PoolDict = {__class__:$B.$type,__name__:'Pool'}\n\n$PoolDict.__mro__ = [$PoolDict, _b_.object.$dict]\n\n$PoolDict.__enter__ = function(self){}\n$PoolDict.__exit__ = function(self){}\n\n$PoolDict.__str__ = $PoolDict.toString = $PoolDict.__repr__=function(self){\n   return '<object Pool>'\n}\n\n$PoolDict.map = function(self){\n   var args = []\n   for(var i=1, _len_i = arguments.length; i < _len_i;i++) args.push(arguments[i])\n\n   var $ns=$B.$MakeArgs('Pool.map',args,['func', 'fargs'],[],'args','kw')\n   var func=$ns['func']\n   var fargs=$ns['fargs']\n\n   var _results=[]\n\n   fargs=iter(fargs)\n\n   var _pos=0\n   console.log(self.$processes)\n   _workers=[]\n   for(var i=0; i < self.$processes; i++) {\n       _workers[i] = new Worker('/src/web_workers/multiprocessing.js')\n       var arg\n\n       try{ \n          arg=getattr(fargs, '__next__')()\n       } catch(err) {\n          if (err.__name__ == 'StopIteration') {\n             __BRYTHON__.$pop_exc()\n          } else {\n             throw err\n          }\n       }\n       console.log(arg)\n       _workers[i].finished=false\n       _workers[i].postMessage({target: func+'', pos: _pos,\n                             args: $convert_args([arg])})\n       _pos++\n\n       _workers[i].addEventListener('message', function(e) {\n           _results[e.data.pos]=e.data.result\n           if (_results.length == args.length) return _results\n\n           try {\n               arg=getattr(fargs, '__next__')()\n               e.currentTarget.postMessage({target: func+'', pos: _pos,\n                                            args: $convert_args([arg])})\n               _pos++\n           } catch(err) {\n               if (err.__name__ != 'StopIteration') throw err\n               this.finished=true\n           }\n       }, false);\n   }\n}\n\n$PoolDict.apply_async = function(self){\n   var args = []\n   for(var i=1, _len_i = arguments.length; i < _len_i;i++){args.push(arguments[i])}\n\n   var $ns=$B.$MakeArgs('apply_async',args,['func', 'fargs'],[],'args','kw')\n   var func=$ns['func']\n   var fargs=$ns['fargs']\n\n   fargs=iter(fargs)\n\n   async_result = {}\n   async_result.get=function(timeout){\n                      console.log(results)\n                      console.log(fargs)\n                      return this.results}\n   async_result.results=[]\n\n   var _pos=0\n\n   _workers=[]\n   for(var i=0; i < self.$processes; i++) {\n       _workers[i] = new Worker('/src/web_workers/multiprocessing.js')\n       var arg\n\n       try{ \n          arg=getattr(fargs, '__next__')()\n       } catch(err) {\n          if (err.__name__ == 'StopIteration') {\n             $B.$pop_exc()\n          } else {\n             throw err\n          }\n       }\n       //console.log(arg)\n       //_workers[i].finished=false\n       _workers[i].postMessage({target: func+'', pos: _pos,\n                             args: $convert_args([arg])})\n       _pos++\n\n       _workers[i].addEventListener('message', function(e) {\n           async_result.results[e.data.pos]=e.data.result\n           //if (_results.length == args.length) return _results\n\n           try {\n               arg=getattr(fargs, '__next__')()\n               e.currentTarget.postMessage({target: func+'', pos: _pos,\n                                            args: $convert_args([arg])})\n               _pos++\n           } catch(err) {\n               if (err.__name__ != 'StopIteration') throw err\n               this.finished=true\n           }\n       }, false);\n   }\n\n   console.log(\"return\", async_result)\n   return async_result\n}\n\nfunction Pool(){\n    console.log(\"pool\")\n    console.log(arguments)\n    var $ns=$B.$MakeArgs('Pool',arguments,[],['processes'],'args','kw')\n    //var kw=$ns['kw']\n\n    var processes=$ns['processes']\n\n    if (processes == None) {\n       // look to see if we have stored cpu_count in local storage\n       // maybe we should create a brython config file with settings,etc..??\n\n       // if not there use a tool such as Core Estimator to calculate number of cpu's\n       // http://eligrey.com/blog/post/cpu-core-estimation-with-javascript\n    }\n\n    console.log(processes)\n    var res = {\n        __class__:$PoolDict,\n        $processes:processes\n    }\n    return res\n}\n\nPool.__class__ = $B.$factory\nPool.$dict = $PoolDict\n\nreturn {Process:Process, Pool:Pool}\n\n})(__BRYTHON__)\n"], "tarfile": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\n\nversion = \"0.9.0\"\n__author__ = \"Lars Gust\\u00e4bel (lars@gustaebel.de)\"\n__date__ = \"$Date: 2011-02-25 17:42:01 +0200 (Fri, 25 Feb 2011) $\"\n__cvsid__ = \"$Id: tarfile.py 88586 2011-02-25 15:42:01Z marc-andre.lemburg $\"\n__credits__ = \"Gustavo Niemeyer, Niels Gust\\u00e4bel, Richard Townsend.\"\n\n\n\n\nimport sys\nimport os\nimport io\nimport shutil\nimport stat\nimport time\nimport struct\nimport copy\nimport re\n\ntry:\n import grp, pwd\nexcept ImportError:\n grp = pwd = None\n \n \nsymlink_exception = (AttributeError, NotImplementedError)\ntry:\n\n\n symlink_exception += (WindowsError,)\nexcept NameError:\n pass\n \n \n__all__ = [\"TarFile\", \"TarInfo\", \"is_tarfile\", \"TarError\"]\n\nfrom builtins import open as _open \n\n\n\n\nNUL = b\"\\0\" \nBLOCKSIZE = 512 \nRECORDSIZE = BLOCKSIZE * 20 \nGNU_MAGIC = b\"ustar  \\0\" \nPOSIX_MAGIC = b\"ustar\\x0000\" \n\nLENGTH_NAME = 100 \nLENGTH_LINK = 100 \nLENGTH_PREFIX = 155 \n\nREGTYPE = b\"0\" \nAREGTYPE = b\"\\0\" \nLNKTYPE = b\"1\" \nSYMTYPE = b\"2\" \nCHRTYPE = b\"3\" \nBLKTYPE = b\"4\" \nDIRTYPE = b\"5\" \nFIFOTYPE = b\"6\" \nCONTTYPE = b\"7\" \n\nGNUTYPE_LONGNAME = b\"L\" \nGNUTYPE_LONGLINK = b\"K\" \nGNUTYPE_SPARSE = b\"S\" \n\nXHDTYPE = b\"x\" \nXGLTYPE = b\"g\" \nSOLARIS_XHDTYPE = b\"X\" \n\nUSTAR_FORMAT = 0 \nGNU_FORMAT = 1 \nPAX_FORMAT = 2 \nDEFAULT_FORMAT = GNU_FORMAT\n\n\n\n\n\nSUPPORTED_TYPES = (REGTYPE, AREGTYPE, LNKTYPE,\nSYMTYPE, DIRTYPE, FIFOTYPE,\nCONTTYPE, CHRTYPE, BLKTYPE,\nGNUTYPE_LONGNAME, GNUTYPE_LONGLINK,\nGNUTYPE_SPARSE)\n\n\nREGULAR_TYPES = (REGTYPE, AREGTYPE,\nCONTTYPE, GNUTYPE_SPARSE)\n\n\nGNU_TYPES = (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,\nGNUTYPE_SPARSE)\n\n\nPAX_FIELDS = (\"path\", \"linkpath\", \"size\", \"mtime\",\n\"uid\", \"gid\", \"uname\", \"gname\")\n\n\nPAX_NAME_FIELDS = {\"path\", \"linkpath\", \"uname\", \"gname\"}\n\n\n\nPAX_NUMBER_FIELDS = {\n\"atime\": float,\n\"ctime\": float,\n\"mtime\": float,\n\"uid\": int,\n\"gid\": int,\n\"size\": int\n}\n\n\n\n\nS_IFLNK = 0o120000 \nS_IFREG = 0o100000 \nS_IFBLK = 0o060000 \nS_IFDIR = 0o040000 \nS_IFCHR = 0o020000 \nS_IFIFO = 0o010000 \n\nTSUID = 0o4000 \nTSGID = 0o2000 \nTSVTX = 0o1000 \n\nTUREAD = 0o400 \nTUWRITE = 0o200 \nTUEXEC = 0o100 \nTGREAD = 0o040 \nTGWRITE = 0o020 \nTGEXEC = 0o010 \nTOREAD = 0o004 \nTOWRITE = 0o002 \nTOEXEC = 0o001 \n\n\n\n\nif os.name in (\"nt\", \"ce\"):\n ENCODING = \"utf-8\"\nelse:\n ENCODING = sys.getfilesystemencoding()\n \n \n \n \n \ndef stn(s, length, encoding, errors):\n \"\"\n s = s.encode(encoding, errors)\n return s[:length] + (length - len(s)) * NUL\n \ndef nts(s, encoding, errors):\n \"\"\n p = s.find(b\"\\0\")\n if p != -1:\n  s = s[:p]\n return s.decode(encoding, errors)\n \ndef nti(s):\n \"\"\n \n \n if s[0] in (0o200, 0o377):\n  n = 0\n  for i in range(len(s) - 1):\n   n <<= 8\n   n += s[i + 1]\n  if s[0] == 0o377:\n   n = -(256 ** (len(s) - 1) - n)\n else:\n  try:\n   n = int(nts(s, \"ascii\", \"strict\") or \"0\", 8)\n  except ValueError:\n   raise InvalidHeaderError(\"invalid header\")\n return n\n \ndef itn(n, digits=8, format=DEFAULT_FORMAT):\n \"\"\n \n \n \n \n \n \n \n \n if 0 <= n < 8 ** (digits - 1):\n  s = bytes(\"%0*o\" % (digits - 1, n), \"ascii\") + NUL\n elif format == GNU_FORMAT and -256 ** (digits - 1) <= n < 256 ** (digits - 1):\n  if n >= 0:\n   s = bytearray([0o200])\n  else:\n   s = bytearray([0o377])\n   n = 256 ** digits + n\n   \n  for i in range(digits - 1):\n   s.insert(1, n & 0o377)\n   n >>= 8\n else:\n  raise ValueError(\"overflow in number field\")\n  \n return s\n \ndef calc_chksums(buf):\n \"\"\n unsigned_chksum = 256 + sum(struct.unpack_from(\"148B8x356B\", buf))\n signed_chksum = 256 + sum(struct.unpack_from(\"148b8x356b\", buf))\n return unsigned_chksum, signed_chksum\n \ndef copyfileobj(src, dst, length=None):\n \"\"\n if length == 0:\n  return\n if length is None:\n  shutil.copyfileobj(src, dst)\n  return\n  \n BUFSIZE = 16 * 1024\n blocks, remainder = divmod(length, BUFSIZE)\n for b in range(blocks):\n  buf = src.read(BUFSIZE)\n  if len(buf) < BUFSIZE:\n   raise IOError(\"end of file reached\")\n  dst.write(buf)\n  \n if remainder != 0:\n  buf = src.read(remainder)\n  if len(buf) < remainder:\n   raise IOError(\"end of file reached\")\n  dst.write(buf)\n return\n \ndef filemode(mode):\n \"\"\n import warnings\n warnings.warn(\"deprecated in favor of stat.filemode\",\n DeprecationWarning, 2)\n return stat.filemode(mode)\n \n \nclass TarError(Exception):\n \"\"\n pass\nclass ExtractError(TarError):\n \"\"\n pass\nclass ReadError(TarError):\n \"\"\n pass\nclass CompressionError(TarError):\n \"\"\n pass\nclass StreamError(TarError):\n \"\"\n pass\nclass HeaderError(TarError):\n \"\"\n pass\nclass EmptyHeaderError(HeaderError):\n \"\"\n pass\nclass TruncatedHeaderError(HeaderError):\n \"\"\n pass\nclass EOFHeaderError(HeaderError):\n \"\"\n pass\nclass InvalidHeaderError(HeaderError):\n \"\"\n pass\nclass SubsequentHeaderError(HeaderError):\n \"\"\n pass\n \n \n \n \nclass _LowLevelFile:\n \"\"\n \n def __init__(self, name, mode):\n  mode = {\n  \"r\": os.O_RDONLY,\n  \"w\": os.O_WRONLY | os.O_CREAT | os.O_TRUNC,\n  }[mode]\n  if hasattr(os, \"O_BINARY\"):\n   mode |= os.O_BINARY\n  self.fd = os.open(name, mode, 0o666)\n  \n def close(self):\n  os.close(self.fd)\n  \n def read(self, size):\n  return os.read(self.fd, size)\n  \n def write(self, s):\n  os.write(self.fd, s)\n  \nclass _Stream:\n \"\"\n \n def __init__(self, name, mode, comptype, fileobj, bufsize):\n  \"\"\n  self._extfileobj = True\n  if fileobj is None:\n   fileobj = _LowLevelFile(name, mode)\n   self._extfileobj = False\n   \n  if comptype == '*':\n  \n  \n   fileobj = _StreamProxy(fileobj)\n   comptype = fileobj.getcomptype()\n   \n  self.name = name or \"\"\n  self.mode = mode\n  self.comptype = comptype\n  self.fileobj = fileobj\n  self.bufsize = bufsize\n  self.buf = b\"\"\n  self.pos = 0\n  self.closed = False\n  \n  try:\n   if comptype == \"gz\":\n    try:\n     import zlib\n    except ImportError:\n     raise CompressionError(\"zlib module is not available\")\n    self.zlib = zlib\n    self.crc = zlib.crc32(b\"\")\n    if mode == \"r\":\n     self._init_read_gz()\n     self.exception = zlib.error\n    else:\n     self._init_write_gz()\n     \n   elif comptype == \"bz2\":\n    try:\n     import bz2\n    except ImportError:\n     raise CompressionError(\"bz2 module is not available\")\n    if mode == \"r\":\n     self.dbuf = b\"\"\n     self.cmp = bz2.BZ2Decompressor()\n     self.exception = IOError\n    else:\n     self.cmp = bz2.BZ2Compressor()\n     \n   elif comptype == \"xz\":\n    try:\n     import lzma\n    except ImportError:\n     raise CompressionError(\"lzma module is not available\")\n    if mode == \"r\":\n     self.dbuf = b\"\"\n     self.cmp = lzma.LZMADecompressor()\n     self.exception = lzma.LZMAError\n    else:\n     self.cmp = lzma.LZMACompressor()\n     \n   elif comptype != \"tar\":\n    raise CompressionError(\"unknown compression type %r\" % comptype)\n    \n  except:\n   if not self._extfileobj:\n    self.fileobj.close()\n   self.closed = True\n   raise\n   \n def __del__(self):\n  if hasattr(self, \"closed\") and not self.closed:\n   self.close()\n   \n def _init_write_gz(self):\n  \"\"\n  self.cmp = self.zlib.compressobj(9, self.zlib.DEFLATED,\n  -self.zlib.MAX_WBITS,\n  self.zlib.DEF_MEM_LEVEL,\n  0)\n  timestamp = struct.pack(\"<L\", int(time.time()))\n  self.__write(b\"\\037\\213\\010\\010\" + timestamp + b\"\\002\\377\")\n  if self.name.endswith(\".gz\"):\n   self.name = self.name[:-3]\n   \n  self.__write(self.name.encode(\"iso-8859-1\", \"replace\") + NUL)\n  \n def write(self, s):\n  \"\"\n  if self.comptype == \"gz\":\n   self.crc = self.zlib.crc32(s, self.crc)\n  self.pos += len(s)\n  if self.comptype != \"tar\":\n   s = self.cmp.compress(s)\n  self.__write(s)\n  \n def __write(self, s):\n  \"\"\n  self.buf += s\n  while len(self.buf) > self.bufsize:\n   self.fileobj.write(self.buf[:self.bufsize])\n   self.buf = self.buf[self.bufsize:]\n   \n def close(self):\n  \"\"\n  if self.closed:\n   return\n   \n  if self.mode == \"w\" and self.comptype != \"tar\":\n   self.buf += self.cmp.flush()\n   \n  if self.mode == \"w\" and self.buf:\n   self.fileobj.write(self.buf)\n   self.buf = b\"\"\n   if self.comptype == \"gz\":\n   \n   \n   \n   \n   \n   \n    self.fileobj.write(struct.pack(\"<L\", self.crc & 0xffffffff))\n    self.fileobj.write(struct.pack(\"<L\", self.pos & 0xffffFFFF))\n    \n  if not self._extfileobj:\n   self.fileobj.close()\n   \n  self.closed = True\n  \n def _init_read_gz(self):\n  \"\"\n  self.cmp = self.zlib.decompressobj(-self.zlib.MAX_WBITS)\n  self.dbuf = b\"\"\n  \n  \n  if self.__read(2) != b\"\\037\\213\":\n   raise ReadError(\"not a gzip file\")\n  if self.__read(1) != b\"\\010\":\n   raise CompressionError(\"unsupported compression method\")\n   \n  flag = ord(self.__read(1))\n  self.__read(6)\n  \n  if flag & 4:\n   xlen = ord(self.__read(1)) + 256 * ord(self.__read(1))\n   self.read(xlen)\n  if flag & 8:\n   while True:\n    s = self.__read(1)\n    if not s or s == NUL:\n     break\n  if flag & 16:\n   while True:\n    s = self.__read(1)\n    if not s or s == NUL:\n     break\n  if flag & 2:\n   self.__read(2)\n   \n def tell(self):\n  \"\"\n  return self.pos\n  \n def seek(self, pos=0):\n  \"\"\n  if pos - self.pos >= 0:\n   blocks, remainder = divmod(pos - self.pos, self.bufsize)\n   for i in range(blocks):\n    self.read(self.bufsize)\n   self.read(remainder)\n  else:\n   raise StreamError(\"seeking backwards is not allowed\")\n  return self.pos\n  \n def read(self, size=None):\n  \"\"\n  if size is None:\n   t = []\n   while True:\n    buf = self._read(self.bufsize)\n    if not buf:\n     break\n    t.append(buf)\n   buf = \"\".join(t)\n  else:\n   buf = self._read(size)\n  self.pos += len(buf)\n  return buf\n  \n def _read(self, size):\n  \"\"\n  if self.comptype == \"tar\":\n   return self.__read(size)\n   \n  c = len(self.dbuf)\n  while c < size:\n   buf = self.__read(self.bufsize)\n   if not buf:\n    break\n   try:\n    buf = self.cmp.decompress(buf)\n   except self.exception:\n    raise ReadError(\"invalid compressed data\")\n   self.dbuf += buf\n   c += len(buf)\n  buf = self.dbuf[:size]\n  self.dbuf = self.dbuf[size:]\n  return buf\n  \n def __read(self, size):\n  \"\"\n  c = len(self.buf)\n  while c < size:\n   buf = self.fileobj.read(self.bufsize)\n   if not buf:\n    break\n   self.buf += buf\n   c += len(buf)\n  buf = self.buf[:size]\n  self.buf = self.buf[size:]\n  return buf\n  \n  \nclass _StreamProxy(object):\n \"\"\n \n def __init__(self, fileobj):\n  self.fileobj = fileobj\n  self.buf = self.fileobj.read(BLOCKSIZE)\n  \n def read(self, size):\n  self.read = self.fileobj.read\n  return self.buf\n  \n def getcomptype(self):\n  if self.buf.startswith(b\"\\x1f\\x8b\\x08\"):\n   return \"gz\"\n  elif self.buf[0:3] == b\"BZh\" and self.buf[4:10] == b\"1AY&SY\":\n   return \"bz2\"\n  elif self.buf.startswith((b\"\\x5d\\x00\\x00\\x80\", b\"\\xfd7zXZ\")):\n   return \"xz\"\n  else:\n   return \"tar\"\n   \n def close(self):\n  self.fileobj.close()\n  \n  \n  \n  \n  \nclass _FileInFile(object):\n \"\"\n \n def __init__(self, fileobj, offset, size, blockinfo=None):\n  self.fileobj = fileobj\n  self.offset = offset\n  self.size = size\n  self.position = 0\n  self.name = getattr(fileobj, \"name\", None)\n  self.closed = False\n  \n  if blockinfo is None:\n   blockinfo = [(0, size)]\n   \n   \n  self.map_index = 0\n  self.map = []\n  lastpos = 0\n  realpos = self.offset\n  for offset, size in blockinfo:\n   if offset > lastpos:\n    self.map.append((False, lastpos, offset, None))\n   self.map.append((True, offset, offset + size, realpos))\n   realpos += size\n   lastpos = offset + size\n  if lastpos < self.size:\n   self.map.append((False, lastpos, self.size, None))\n   \n def flush(self):\n  pass\n  \n def readable(self):\n  return True\n  \n def writable(self):\n  return False\n  \n def seekable(self):\n  return self.fileobj.seekable()\n  \n def tell(self):\n  \"\"\n  return self.position\n  \n def seek(self, position, whence=io.SEEK_SET):\n  \"\"\n  if whence == io.SEEK_SET:\n   self.position = min(max(position, 0), self.size)\n  elif whence == io.SEEK_CUR:\n   if position < 0:\n    self.position = max(self.position + position, 0)\n   else:\n    self.position = min(self.position + position, self.size)\n  elif whence == io.SEEK_END:\n   self.position = max(min(self.size + position, self.size), 0)\n  else:\n   raise ValueError(\"Invalid argument\")\n  return self.position\n  \n def read(self, size=None):\n  \"\"\n  if size is None:\n   size = self.size - self.position\n  else:\n   size = min(size, self.size - self.position)\n   \n  buf = b\"\"\n  while size > 0:\n   while True:\n    data, start, stop, offset = self.map[self.map_index]\n    if start <= self.position < stop:\n     break\n    else:\n     self.map_index += 1\n     if self.map_index == len(self.map):\n      self.map_index = 0\n   length = min(size, stop - self.position)\n   if data:\n    self.fileobj.seek(offset + (self.position - start))\n    buf += self.fileobj.read(length)\n   else:\n    buf += NUL * length\n   size -= length\n   self.position += length\n  return buf\n  \n def readinto(self, b):\n  buf = self.read(len(b))\n  b[:len(buf)] = buf\n  return len(buf)\n  \n def close(self):\n  self.closed = True\n  \n  \nclass ExFileObject(io.BufferedReader):\n\n def __init__(self, tarfile, tarinfo):\n  fileobj = _FileInFile(tarfile.fileobj, tarinfo.offset_data,\n  tarinfo.size, tarinfo.sparse)\n  super().__init__(fileobj)\n  \n  \n  \n  \n  \nclass TarInfo(object):\n \"\"\n \n __slots__ = (\"name\", \"mode\", \"uid\", \"gid\", \"size\", \"mtime\",\n \"chksum\", \"type\", \"linkname\", \"uname\", \"gname\",\n \"devmajor\", \"devminor\",\n \"offset\", \"offset_data\", \"pax_headers\", \"sparse\",\n \"tarfile\", \"_sparse_structs\", \"_link_target\")\n \n def __init__(self, name=\"\"):\n  \"\"\n  self.name = name \n  self.mode = 0o644 \n  self.uid = 0 \n  self.gid = 0 \n  self.size = 0 \n  self.mtime = 0 \n  self.chksum = 0 \n  self.type = REGTYPE \n  self.linkname = \"\" \n  self.uname = \"\" \n  self.gname = \"\" \n  self.devmajor = 0 \n  self.devminor = 0 \n  \n  self.offset = 0 \n  self.offset_data = 0 \n  \n  self.sparse = None \n  self.pax_headers = {} \n  \n  \n  \n def _getpath(self):\n  return self.name\n def _setpath(self, name):\n  self.name = name\n path = property(_getpath, _setpath)\n \n def _getlinkpath(self):\n  return self.linkname\n def _setlinkpath(self, linkname):\n  self.linkname = linkname\n linkpath = property(_getlinkpath, _setlinkpath)\n \n def __repr__(self):\n  return \"<%s %r at %#x>\" % (self.__class__.__name__,self.name,id(self))\n  \n def get_info(self):\n  \"\"\n  info = {\n  \"name\": self.name,\n  \"mode\": self.mode & 0o7777,\n  \"uid\": self.uid,\n  \"gid\": self.gid,\n  \"size\": self.size,\n  \"mtime\": self.mtime,\n  \"chksum\": self.chksum,\n  \"type\": self.type,\n  \"linkname\": self.linkname,\n  \"uname\": self.uname,\n  \"gname\": self.gname,\n  \"devmajor\": self.devmajor,\n  \"devminor\": self.devminor\n  }\n  \n  if info[\"type\"] == DIRTYPE and not info[\"name\"].endswith(\"/\"):\n   info[\"name\"] += \"/\"\n   \n  return info\n  \n def tobuf(self, format=DEFAULT_FORMAT, encoding=ENCODING, errors=\"surrogateescape\"):\n  \"\"\n  info = self.get_info()\n  \n  if format == USTAR_FORMAT:\n   return self.create_ustar_header(info, encoding, errors)\n  elif format == GNU_FORMAT:\n   return self.create_gnu_header(info, encoding, errors)\n  elif format == PAX_FORMAT:\n   return self.create_pax_header(info, encoding)\n  else:\n   raise ValueError(\"invalid format\")\n   \n def create_ustar_header(self, info, encoding, errors):\n  \"\"\n  info[\"magic\"] = POSIX_MAGIC\n  \n  if len(info[\"linkname\"]) > LENGTH_LINK:\n   raise ValueError(\"linkname is too long\")\n   \n  if len(info[\"name\"]) > LENGTH_NAME:\n   info[\"prefix\"], info[\"name\"] = self._posix_split_name(info[\"name\"])\n   \n  return self._create_header(info, USTAR_FORMAT, encoding, errors)\n  \n def create_gnu_header(self, info, encoding, errors):\n  \"\"\n  info[\"magic\"] = GNU_MAGIC\n  \n  buf = b\"\"\n  if len(info[\"linkname\"]) > LENGTH_LINK:\n   buf += self._create_gnu_long_header(info[\"linkname\"], GNUTYPE_LONGLINK, encoding, errors)\n   \n  if len(info[\"name\"]) > LENGTH_NAME:\n   buf += self._create_gnu_long_header(info[\"name\"], GNUTYPE_LONGNAME, encoding, errors)\n   \n  return buf + self._create_header(info, GNU_FORMAT, encoding, errors)\n  \n def create_pax_header(self, info, encoding):\n  \"\"\n  info[\"magic\"] = POSIX_MAGIC\n  pax_headers = self.pax_headers.copy()\n  \n  \n  \n  for name, hname, length in (\n  (\"name\", \"path\", LENGTH_NAME), (\"linkname\", \"linkpath\", LENGTH_LINK),\n  (\"uname\", \"uname\", 32), (\"gname\", \"gname\", 32)):\n  \n   if hname in pax_headers:\n   \n    continue\n    \n    \n   try:\n    info[name].encode(\"ascii\", \"strict\")\n   except UnicodeEncodeError:\n    pax_headers[hname] = info[name]\n    continue\n    \n   if len(info[name]) > length:\n    pax_headers[hname] = info[name]\n    \n    \n    \n  for name, digits in ((\"uid\", 8), (\"gid\", 8), (\"size\", 12), (\"mtime\", 12)):\n   if name in pax_headers:\n   \n    info[name] = 0\n    continue\n    \n   val = info[name]\n   if not 0 <= val < 8 ** (digits - 1) or isinstance(val, float):\n    pax_headers[name] = str(val)\n    info[name] = 0\n    \n    \n  if pax_headers:\n   buf = self._create_pax_generic_header(pax_headers, XHDTYPE, encoding)\n  else:\n   buf = b\"\"\n   \n  return buf + self._create_header(info, USTAR_FORMAT, \"ascii\", \"replace\")\n  \n @classmethod\n def create_pax_global_header(cls, pax_headers):\n  \"\"\n  return cls._create_pax_generic_header(pax_headers, XGLTYPE, \"utf-8\")\n  \n def _posix_split_name(self, name):\n  \"\"\n  prefix = name[:LENGTH_PREFIX + 1]\n  while prefix and prefix[-1] != \"/\":\n   prefix = prefix[:-1]\n   \n  name = name[len(prefix):]\n  prefix = prefix[:-1]\n  \n  if not prefix or len(name) > LENGTH_NAME:\n   raise ValueError(\"name is too long\")\n  return prefix, name\n  \n @staticmethod\n def _create_header(info, format, encoding, errors):\n  \"\"\n  parts = [\n  stn(info.get(\"name\", \"\"), 100, encoding, errors),\n  itn(info.get(\"mode\", 0) & 0o7777, 8, format),\n  itn(info.get(\"uid\", 0), 8, format),\n  itn(info.get(\"gid\", 0), 8, format),\n  itn(info.get(\"size\", 0), 12, format),\n  itn(info.get(\"mtime\", 0), 12, format),\n  b\"        \", \n  info.get(\"type\", REGTYPE),\n  stn(info.get(\"linkname\", \"\"), 100, encoding, errors),\n  info.get(\"magic\", POSIX_MAGIC),\n  stn(info.get(\"uname\", \"\"), 32, encoding, errors),\n  stn(info.get(\"gname\", \"\"), 32, encoding, errors),\n  itn(info.get(\"devmajor\", 0), 8, format),\n  itn(info.get(\"devminor\", 0), 8, format),\n  stn(info.get(\"prefix\", \"\"), 155, encoding, errors)\n  ]\n  \n  buf = struct.pack(\"%ds\" % BLOCKSIZE, b\"\".join(parts))\n  chksum = calc_chksums(buf[-BLOCKSIZE:])[0]\n  buf = buf[:-364] + bytes(\"%06o\\0\" % chksum, \"ascii\") + buf[-357:]\n  return buf\n  \n @staticmethod\n def _create_payload(payload):\n  \"\"\n  blocks, remainder = divmod(len(payload), BLOCKSIZE)\n  if remainder > 0:\n   payload += (BLOCKSIZE - remainder) * NUL\n  return payload\n  \n @classmethod\n def _create_gnu_long_header(cls, name, type, encoding, errors):\n  \"\"\n  name = name.encode(encoding, errors) + NUL\n  \n  info = {}\n  info[\"name\"] = \"././@LongLink\"\n  info[\"type\"] = type\n  info[\"size\"] = len(name)\n  info[\"magic\"] = GNU_MAGIC\n  \n  \n  return cls._create_header(info, USTAR_FORMAT, encoding, errors) + cls._create_payload(name)\n  \n @classmethod\n def _create_pax_generic_header(cls, pax_headers, type, encoding):\n  \"\"\n  \n  \n  binary = False\n  for keyword, value in pax_headers.items():\n   try:\n    value.encode(\"utf-8\", \"strict\")\n   except UnicodeEncodeError:\n    binary = True\n    break\n    \n  records = b\"\"\n  if binary:\n  \n   records += b\"21 hdrcharset=BINARY\\n\"\n   \n  for keyword, value in pax_headers.items():\n   keyword = keyword.encode(\"utf-8\")\n   if binary:\n   \n   \n    value = value.encode(encoding, \"surrogateescape\")\n   else:\n    value = value.encode(\"utf-8\")\n    \n   l = len(keyword) + len(value) + 3 \n   n = p = 0\n   while True:\n    n = l + len(str(p))\n    if n == p:\n     break\n    p = n\n   records += bytes(str(p), \"ascii\") + b\" \" + keyword + b\"=\" + value + b\"\\n\"\n   \n   \n   \n  info = {}\n  info[\"name\"] = \"././@PaxHeader\"\n  info[\"type\"] = type\n  info[\"size\"] = len(records)\n  info[\"magic\"] = POSIX_MAGIC\n  \n  \n  return cls._create_header(info, USTAR_FORMAT, \"ascii\", \"replace\") + cls._create_payload(records)\n  \n @classmethod\n def frombuf(cls, buf, encoding, errors):\n  \"\"\n  if len(buf) == 0:\n   raise EmptyHeaderError(\"empty header\")\n  if len(buf) != BLOCKSIZE:\n   raise TruncatedHeaderError(\"truncated header\")\n  if buf.count(NUL) == BLOCKSIZE:\n   raise EOFHeaderError(\"end of file header\")\n   \n  chksum = nti(buf[148:156])\n  if chksum not in calc_chksums(buf):\n   raise InvalidHeaderError(\"bad checksum\")\n   \n  obj = cls()\n  obj.name = nts(buf[0:100], encoding, errors)\n  obj.mode = nti(buf[100:108])\n  obj.uid = nti(buf[108:116])\n  obj.gid = nti(buf[116:124])\n  obj.size = nti(buf[124:136])\n  obj.mtime = nti(buf[136:148])\n  obj.chksum = chksum\n  obj.type = buf[156:157]\n  obj.linkname = nts(buf[157:257], encoding, errors)\n  obj.uname = nts(buf[265:297], encoding, errors)\n  obj.gname = nts(buf[297:329], encoding, errors)\n  obj.devmajor = nti(buf[329:337])\n  obj.devminor = nti(buf[337:345])\n  prefix = nts(buf[345:500], encoding, errors)\n  \n  \n  \n  if obj.type == AREGTYPE and obj.name.endswith(\"/\"):\n   obj.type = DIRTYPE\n   \n   \n   \n   \n  if obj.type == GNUTYPE_SPARSE:\n   pos = 386\n   structs = []\n   for i in range(4):\n    try:\n     offset = nti(buf[pos:pos + 12])\n     numbytes = nti(buf[pos + 12:pos + 24])\n    except ValueError:\n     break\n    structs.append((offset, numbytes))\n    pos += 24\n   isextended = bool(buf[482])\n   origsize = nti(buf[483:495])\n   obj._sparse_structs = (structs, isextended, origsize)\n   \n   \n  if obj.isdir():\n   obj.name = obj.name.rstrip(\"/\")\n   \n   \n  if prefix and obj.type not in GNU_TYPES:\n   obj.name = prefix + \"/\" + obj.name\n  return obj\n  \n @classmethod\n def fromtarfile(cls, tarfile):\n  \"\"\n  buf = tarfile.fileobj.read(BLOCKSIZE)\n  obj = cls.frombuf(buf, tarfile.encoding, tarfile.errors)\n  obj.offset = tarfile.fileobj.tell() - BLOCKSIZE\n  return obj._proc_member(tarfile)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _proc_member(self, tarfile):\n  \"\"\n  if self.type in (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK):\n   return self._proc_gnulong(tarfile)\n  elif self.type == GNUTYPE_SPARSE:\n   return self._proc_sparse(tarfile)\n  elif self.type in (XHDTYPE, XGLTYPE, SOLARIS_XHDTYPE):\n   return self._proc_pax(tarfile)\n  else:\n   return self._proc_builtin(tarfile)\n   \n def _proc_builtin(self, tarfile):\n  \"\"\n  self.offset_data = tarfile.fileobj.tell()\n  offset = self.offset_data\n  if self.isreg() or self.type not in SUPPORTED_TYPES:\n  \n   offset += self._block(self.size)\n  tarfile.offset = offset\n  \n  \n  \n  self._apply_pax_info(tarfile.pax_headers, tarfile.encoding, tarfile.errors)\n  \n  return self\n  \n def _proc_gnulong(self, tarfile):\n  \"\"\n  buf = tarfile.fileobj.read(self._block(self.size))\n  \n  \n  try:\n   next = self.fromtarfile(tarfile)\n  except HeaderError:\n   raise SubsequentHeaderError(\"missing or bad subsequent header\")\n   \n   \n   \n  next.offset = self.offset\n  if self.type == GNUTYPE_LONGNAME:\n   next.name = nts(buf, tarfile.encoding, tarfile.errors)\n  elif self.type == GNUTYPE_LONGLINK:\n   next.linkname = nts(buf, tarfile.encoding, tarfile.errors)\n   \n  return next\n  \n def _proc_sparse(self, tarfile):\n  \"\"\n  \n  structs, isextended, origsize = self._sparse_structs\n  del self._sparse_structs\n  \n  \n  while isextended:\n   buf = tarfile.fileobj.read(BLOCKSIZE)\n   pos = 0\n   for i in range(21):\n    try:\n     offset = nti(buf[pos:pos + 12])\n     numbytes = nti(buf[pos + 12:pos + 24])\n    except ValueError:\n     break\n    if offset and numbytes:\n     structs.append((offset, numbytes))\n    pos += 24\n   isextended = bool(buf[504])\n  self.sparse = structs\n  \n  self.offset_data = tarfile.fileobj.tell()\n  tarfile.offset = self.offset_data + self._block(self.size)\n  self.size = origsize\n  return self\n  \n def _proc_pax(self, tarfile):\n  \"\"\n  \n  buf = tarfile.fileobj.read(self._block(self.size))\n  \n  \n  \n  \n  if self.type == XGLTYPE:\n   pax_headers = tarfile.pax_headers\n  else:\n   pax_headers = tarfile.pax_headers.copy()\n   \n   \n   \n   \n   \n   \n  match = re.search(br\"\\d+ hdrcharset=([^\\n]+)\\n\", buf)\n  if match is not None:\n   pax_headers[\"hdrcharset\"] = match.group(1).decode(\"utf-8\")\n   \n   \n   \n   \n  hdrcharset = pax_headers.get(\"hdrcharset\")\n  if hdrcharset == \"BINARY\":\n   encoding = tarfile.encoding\n  else:\n   encoding = \"utf-8\"\n   \n   \n   \n   \n   \n  regex = re.compile(br\"(\\d+) ([^=]+)=\")\n  pos = 0\n  while True:\n   match = regex.match(buf, pos)\n   if not match:\n    break\n    \n   length, keyword = match.groups()\n   length = int(length)\n   value = buf[match.end(2) + 1:match.start(1) + length - 1]\n   \n   \n   \n   \n   \n   \n   \n   \n   keyword = self._decode_pax_field(keyword, \"utf-8\", \"utf-8\",\n   tarfile.errors)\n   if keyword in PAX_NAME_FIELDS:\n    value = self._decode_pax_field(value, encoding, tarfile.encoding,\n    tarfile.errors)\n   else:\n    value = self._decode_pax_field(value, \"utf-8\", \"utf-8\",\n    tarfile.errors)\n    \n   pax_headers[keyword] = value\n   pos += length\n   \n   \n  try:\n   next = self.fromtarfile(tarfile)\n  except HeaderError:\n   raise SubsequentHeaderError(\"missing or bad subsequent header\")\n   \n   \n  if \"GNU.sparse.map\" in pax_headers:\n  \n   self._proc_gnusparse_01(next, pax_headers)\n   \n  elif \"GNU.sparse.size\" in pax_headers:\n  \n   self._proc_gnusparse_00(next, pax_headers, buf)\n   \n  elif pax_headers.get(\"GNU.sparse.major\") == \"1\" and pax_headers.get(\"GNU.sparse.minor\") == \"0\":\n  \n   self._proc_gnusparse_10(next, pax_headers, tarfile)\n   \n  if self.type in (XHDTYPE, SOLARIS_XHDTYPE):\n  \n   next._apply_pax_info(pax_headers, tarfile.encoding, tarfile.errors)\n   next.offset = self.offset\n   \n   if \"size\" in pax_headers:\n   \n   \n   \n    offset = next.offset_data\n    if next.isreg() or next.type not in SUPPORTED_TYPES:\n     offset += next._block(next.size)\n    tarfile.offset = offset\n    \n  return next\n  \n def _proc_gnusparse_00(self, next, pax_headers, buf):\n  \"\"\n  offsets = []\n  for match in re.finditer(br\"\\d+ GNU.sparse.offset=(\\d+)\\n\", buf):\n   offsets.append(int(match.group(1)))\n  numbytes = []\n  for match in re.finditer(br\"\\d+ GNU.sparse.numbytes=(\\d+)\\n\", buf):\n   numbytes.append(int(match.group(1)))\n  next.sparse = list(zip(offsets, numbytes))\n  \n def _proc_gnusparse_01(self, next, pax_headers):\n  \"\"\n  sparse = [int(x) for x in pax_headers[\"GNU.sparse.map\"].split(\",\")]\n  next.sparse = list(zip(sparse[::2], sparse[1::2]))\n  \n def _proc_gnusparse_10(self, next, pax_headers, tarfile):\n  \"\"\n  fields = None\n  sparse = []\n  buf = tarfile.fileobj.read(BLOCKSIZE)\n  fields, buf = buf.split(b\"\\n\", 1)\n  fields = int(fields)\n  while len(sparse) < fields * 2:\n   if b\"\\n\" not in buf:\n    buf += tarfile.fileobj.read(BLOCKSIZE)\n   number, buf = buf.split(b\"\\n\", 1)\n   sparse.append(int(number))\n  next.offset_data = tarfile.fileobj.tell()\n  next.sparse = list(zip(sparse[::2], sparse[1::2]))\n  \n def _apply_pax_info(self, pax_headers, encoding, errors):\n  \"\"\n  for keyword, value in pax_headers.items():\n   if keyword == \"GNU.sparse.name\":\n    setattr(self, \"path\", value)\n   elif keyword == \"GNU.sparse.size\":\n    setattr(self, \"size\", int(value))\n   elif keyword == \"GNU.sparse.realsize\":\n    setattr(self, \"size\", int(value))\n   elif keyword in PAX_FIELDS:\n    if keyword in PAX_NUMBER_FIELDS:\n     try:\n      value = PAX_NUMBER_FIELDS[keyword](value)\n     except ValueError:\n      value = 0\n    if keyword == \"path\":\n     value = value.rstrip(\"/\")\n    setattr(self, keyword, value)\n    \n  self.pax_headers = pax_headers.copy()\n  \n def _decode_pax_field(self, value, encoding, fallback_encoding, fallback_errors):\n  \"\"\n  try:\n   return value.decode(encoding, \"strict\")\n  except UnicodeDecodeError:\n   return value.decode(fallback_encoding, fallback_errors)\n   \n def _block(self, count):\n  \"\"\n  blocks, remainder = divmod(count, BLOCKSIZE)\n  if remainder:\n   blocks += 1\n  return blocks * BLOCKSIZE\n  \n def isreg(self):\n  return self.type in REGULAR_TYPES\n def isfile(self):\n  return self.isreg()\n def isdir(self):\n  return self.type == DIRTYPE\n def issym(self):\n  return self.type == SYMTYPE\n def islnk(self):\n  return self.type == LNKTYPE\n def ischr(self):\n  return self.type == CHRTYPE\n def isblk(self):\n  return self.type == BLKTYPE\n def isfifo(self):\n  return self.type == FIFOTYPE\n def issparse(self):\n  return self.sparse is not None\n def isdev(self):\n  return self.type in (CHRTYPE, BLKTYPE, FIFOTYPE)\n  \n  \nclass TarFile(object):\n \"\"\n \n debug = 0 \n \n dereference = False \n \n \n ignore_zeros = False \n \n \n errorlevel = 1 \n \n \n \n format = DEFAULT_FORMAT \n \n encoding = ENCODING \n \n errors = None \n \n tarinfo = TarInfo \n \n fileobject = ExFileObject \n \n def __init__(self, name=None, mode=\"r\", fileobj=None, format=None,\n tarinfo=None, dereference=None, ignore_zeros=None, encoding=None,\n errors=\"surrogateescape\", pax_headers=None, debug=None, errorlevel=None):\n  \"\"\n  if len(mode) > 1 or mode not in \"raw\":\n   raise ValueError(\"mode must be 'r', 'a' or 'w'\")\n  self.mode = mode\n  self._mode = {\"r\": \"rb\", \"a\": \"r+b\", \"w\": \"wb\"}[mode]\n  \n  if not fileobj:\n   if self.mode == \"a\" and not os.path.exists(name):\n   \n    self.mode = \"w\"\n    self._mode = \"wb\"\n   fileobj = bltn_open(name, self._mode)\n   self._extfileobj = False\n  else:\n   if name is None and hasattr(fileobj, \"name\"):\n    name = fileobj.name\n   if hasattr(fileobj, \"mode\"):\n    self._mode = fileobj.mode\n   self._extfileobj = True\n  self.name = os.path.abspath(name) if name else None\n  self.fileobj = fileobj\n  \n  \n  if format is not None:\n   self.format = format\n  if tarinfo is not None:\n   self.tarinfo = tarinfo\n  if dereference is not None:\n   self.dereference = dereference\n  if ignore_zeros is not None:\n   self.ignore_zeros = ignore_zeros\n  if encoding is not None:\n   self.encoding = encoding\n  self.errors = errors\n  \n  if pax_headers is not None and self.format == PAX_FORMAT:\n   self.pax_headers = pax_headers\n  else:\n   self.pax_headers = {}\n   \n  if debug is not None:\n   self.debug = debug\n  if errorlevel is not None:\n   self.errorlevel = errorlevel\n   \n   \n  self.closed = False\n  self.members = [] \n  self._loaded = False \n  self.offset = self.fileobj.tell()\n  \n  self.inodes = {} \n  \n  \n  try:\n   if self.mode == \"r\":\n    self.firstmember = None\n    self.firstmember = self.next()\n    \n   if self.mode == \"a\":\n   \n   \n    while True:\n     self.fileobj.seek(self.offset)\n     try:\n      tarinfo = self.tarinfo.fromtarfile(self)\n      self.members.append(tarinfo)\n     except EOFHeaderError:\n      self.fileobj.seek(self.offset)\n      break\n     except HeaderError as e:\n      raise ReadError(str(e))\n      \n   if self.mode in \"aw\":\n    self._loaded = True\n    \n    if self.pax_headers:\n     buf = self.tarinfo.create_pax_global_header(self.pax_headers.copy())\n     self.fileobj.write(buf)\n     self.offset += len(buf)\n  except:\n   if not self._extfileobj:\n    self.fileobj.close()\n   self.closed = True\n   raise\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n @classmethod\n def open(cls, name=None, mode=\"r\", fileobj=None, bufsize=RECORDSIZE, **kwargs):\n  \"\"\n  \n  if not name and not fileobj:\n   raise ValueError(\"nothing to open\")\n   \n  if mode in (\"r\", \"r:*\"):\n  \n   for comptype in cls.OPEN_METH:\n    func = getattr(cls, cls.OPEN_METH[comptype])\n    if fileobj is not None:\n     saved_pos = fileobj.tell()\n    try:\n     return func(name, \"r\", fileobj, **kwargs)\n    except (ReadError, CompressionError) as e:\n     if fileobj is not None:\n      fileobj.seek(saved_pos)\n     continue\n   raise ReadError(\"file could not be opened successfully\")\n   \n  elif \":\" in mode:\n   filemode, comptype = mode.split(\":\", 1)\n   filemode = filemode or \"r\"\n   comptype = comptype or \"tar\"\n   \n   \n   \n   if comptype in cls.OPEN_METH:\n    func = getattr(cls, cls.OPEN_METH[comptype])\n   else:\n    raise CompressionError(\"unknown compression type %r\" % comptype)\n   return func(name, filemode, fileobj, **kwargs)\n   \n  elif \"|\" in mode:\n   filemode, comptype = mode.split(\"|\", 1)\n   filemode = filemode or \"r\"\n   comptype = comptype or \"tar\"\n   \n   if filemode not in \"rw\":\n    raise ValueError(\"mode must be 'r' or 'w'\")\n    \n   stream = _Stream(name, filemode, comptype, fileobj, bufsize)\n   try:\n    t = cls(name, filemode, stream, **kwargs)\n   except:\n    stream.close()\n    raise\n   t._extfileobj = False\n   return t\n   \n  elif mode in \"aw\":\n   return cls.taropen(name, mode, fileobj, **kwargs)\n   \n  raise ValueError(\"undiscernible mode\")\n  \n @classmethod\n def taropen(cls, name, mode=\"r\", fileobj=None, **kwargs):\n  \"\"\n  if len(mode) > 1 or mode not in \"raw\":\n   raise ValueError(\"mode must be 'r', 'a' or 'w'\")\n  return cls(name, mode, fileobj, **kwargs)\n  \n @classmethod\n def gzopen(cls, name, mode=\"r\", fileobj=None, compresslevel=9, **kwargs):\n  \"\"\n  if len(mode) > 1 or mode not in \"rw\":\n   raise ValueError(\"mode must be 'r' or 'w'\")\n   \n  try:\n   import gzip\n   gzip.GzipFile\n  except (ImportError, AttributeError):\n   raise CompressionError(\"gzip module is not available\")\n   \n  extfileobj = fileobj is not None\n  try:\n   fileobj = gzip.GzipFile(name, mode + \"b\", compresslevel, fileobj)\n   t = cls.taropen(name, mode, fileobj, **kwargs)\n  except IOError:\n   if not extfileobj and fileobj is not None:\n    fileobj.close()\n   if fileobj is None:\n    raise\n   raise ReadError(\"not a gzip file\")\n  except:\n   if not extfileobj and fileobj is not None:\n    fileobj.close()\n   raise\n  t._extfileobj = extfileobj\n  return t\n  \n @classmethod\n def bz2open(cls, name, mode=\"r\", fileobj=None, compresslevel=9, **kwargs):\n  \"\"\n  if len(mode) > 1 or mode not in \"rw\":\n   raise ValueError(\"mode must be 'r' or 'w'.\")\n   \n  try:\n   import bz2\n  except ImportError:\n   raise CompressionError(\"bz2 module is not available\")\n   \n  fileobj = bz2.BZ2File(fileobj or name, mode,\n  compresslevel=compresslevel)\n  \n  try:\n   t = cls.taropen(name, mode, fileobj, **kwargs)\n  except (IOError, EOFError):\n   fileobj.close()\n   raise ReadError(\"not a bzip2 file\")\n  t._extfileobj = False\n  return t\n  \n @classmethod\n def xzopen(cls, name, mode=\"r\", fileobj=None, preset=None, **kwargs):\n  \"\"\n  if mode not in (\"r\", \"w\"):\n   raise ValueError(\"mode must be 'r' or 'w'\")\n   \n  try:\n   import lzma\n  except ImportError:\n   raise CompressionError(\"lzma module is not available\")\n   \n  fileobj = lzma.LZMAFile(fileobj or name, mode, preset=preset)\n  \n  try:\n   t = cls.taropen(name, mode, fileobj, **kwargs)\n  except (lzma.LZMAError, EOFError):\n   fileobj.close()\n   raise ReadError(\"not an lzma file\")\n  t._extfileobj = False\n  return t\n  \n  \n OPEN_METH = {\n \"tar\": \"taropen\", \n \"gz\": \"gzopen\", \n \"bz2\": \"bz2open\", \n \"xz\": \"xzopen\" \n }\n \n \n \n \n def close(self):\n  \"\"\n  if self.closed:\n   return\n   \n  if self.mode in \"aw\":\n   self.fileobj.write(NUL * (BLOCKSIZE * 2))\n   self.offset += (BLOCKSIZE * 2)\n   \n   \n   blocks, remainder = divmod(self.offset, RECORDSIZE)\n   if remainder > 0:\n    self.fileobj.write(NUL * (RECORDSIZE - remainder))\n    \n  if not self._extfileobj:\n   self.fileobj.close()\n  self.closed = True\n  \n def getmember(self, name):\n  \"\"\n  tarinfo = self._getmember(name)\n  if tarinfo is None:\n   raise KeyError(\"filename %r not found\" % name)\n  return tarinfo\n  \n def getmembers(self):\n  \"\"\n  self._check()\n  if not self._loaded: \n   self._load() \n   \n  return self.members\n  \n def getnames(self):\n  \"\"\n  return [tarinfo.name for tarinfo in self.getmembers()]\n  \n def gettarinfo(self, name=None, arcname=None, fileobj=None):\n  \"\"\n  self._check(\"aw\")\n  \n  \n  \n  if fileobj is not None:\n   name = fileobj.name\n   \n   \n   \n   \n  if arcname is None:\n   arcname = name\n  drv, arcname = os.path.splitdrive(arcname)\n  arcname = arcname.replace(os.sep, \"/\")\n  arcname = arcname.lstrip(\"/\")\n  \n  \n  \n  tarinfo = self.tarinfo()\n  tarinfo.tarfile = self\n  \n  \n  \n  if fileobj is None:\n   if hasattr(os, \"lstat\") and not self.dereference:\n    statres = os.lstat(name)\n   else:\n    statres = os.stat(name)\n  else:\n   statres = os.fstat(fileobj.fileno())\n  linkname = \"\"\n  \n  stmd = statres.st_mode\n  if stat.S_ISREG(stmd):\n   inode = (statres.st_ino, statres.st_dev)\n   if not self.dereference and statres.st_nlink > 1 and inode in self.inodes and arcname != self.inodes[inode]:\n   \n   \n    type = LNKTYPE\n    linkname = self.inodes[inode]\n   else:\n   \n   \n    type = REGTYPE\n    if inode[0]:\n     self.inodes[inode] = arcname\n  elif stat.S_ISDIR(stmd):\n   type = DIRTYPE\n  elif stat.S_ISFIFO(stmd):\n   type = FIFOTYPE\n  elif stat.S_ISLNK(stmd):\n   type = SYMTYPE\n   linkname = os.readlink(name)\n  elif stat.S_ISCHR(stmd):\n   type = CHRTYPE\n  elif stat.S_ISBLK(stmd):\n   type = BLKTYPE\n  else:\n   return None\n   \n   \n   \n  tarinfo.name = arcname\n  tarinfo.mode = stmd\n  tarinfo.uid = statres.st_uid\n  tarinfo.gid = statres.st_gid\n  if type == REGTYPE:\n   tarinfo.size = statres.st_size\n  else:\n   tarinfo.size = 0\n  tarinfo.mtime = statres.st_mtime\n  tarinfo.type = type\n  tarinfo.linkname = linkname\n  if pwd:\n   try:\n    tarinfo.uname = pwd.getpwuid(tarinfo.uid)[0]\n   except KeyError:\n    pass\n  if grp:\n   try:\n    tarinfo.gname = grp.getgrgid(tarinfo.gid)[0]\n   except KeyError:\n    pass\n    \n  if type in (CHRTYPE, BLKTYPE):\n   if hasattr(os, \"major\") and hasattr(os, \"minor\"):\n    tarinfo.devmajor = os.major(statres.st_rdev)\n    tarinfo.devminor = os.minor(statres.st_rdev)\n  return tarinfo\n  \n def list(self, verbose=True):\n  \"\"\n  self._check()\n  \n  for tarinfo in self:\n   if verbose:\n    print(stat.filemode(tarinfo.mode), end=' ')\n    print(\"%s/%s\" % (tarinfo.uname or tarinfo.uid,\n    tarinfo.gname or tarinfo.gid), end=' ')\n    if tarinfo.ischr() or tarinfo.isblk():\n     print(\"%10s\" % (\"%d,%d\" % (tarinfo.devmajor, tarinfo.devminor)), end=' ')\n    else:\n     print(\"%10d\" % tarinfo.size, end=' ')\n    print(\"%d-%02d-%02d %02d:%02d:%02d\" % time.localtime(tarinfo.mtime)[:6], end=' ')\n    \n   print(tarinfo.name + (\"/\" if tarinfo.isdir() else \"\"), end=' ')\n   \n   if verbose:\n    if tarinfo.issym():\n     print(\"->\", tarinfo.linkname, end=' ')\n    if tarinfo.islnk():\n     print(\"link to\", tarinfo.linkname, end=' ')\n   print()\n   \n def add(self, name, arcname=None, recursive=True, exclude=None, *, filter=None):\n  \"\"\n  self._check(\"aw\")\n  \n  if arcname is None:\n   arcname = name\n   \n   \n  if exclude is not None:\n   import warnings\n   warnings.warn(\"use the filter argument instead\",\n   DeprecationWarning, 2)\n   if exclude(name):\n    self._dbg(2, \"tarfile: Excluded %r\" % name)\n    return\n    \n    \n  if self.name is not None and os.path.abspath(name) == self.name:\n   self._dbg(2, \"tarfile: Skipped %r\" % name)\n   return\n   \n  self._dbg(1, name)\n  \n  \n  tarinfo = self.gettarinfo(name, arcname)\n  \n  if tarinfo is None:\n   self._dbg(1, \"tarfile: Unsupported type %r\" % name)\n   return\n   \n   \n  if filter is not None:\n   tarinfo = filter(tarinfo)\n   if tarinfo is None:\n    self._dbg(2, \"tarfile: Excluded %r\" % name)\n    return\n    \n    \n  if tarinfo.isreg():\n   with bltn_open(name, \"rb\") as f:\n    self.addfile(tarinfo, f)\n    \n  elif tarinfo.isdir():\n   self.addfile(tarinfo)\n   if recursive:\n    for f in os.listdir(name):\n     self.add(os.path.join(name, f), os.path.join(arcname, f),\n     recursive, exclude, filter=filter)\n     \n  else:\n   self.addfile(tarinfo)\n   \n def addfile(self, tarinfo, fileobj=None):\n  \"\"\n  self._check(\"aw\")\n  \n  tarinfo = copy.copy(tarinfo)\n  \n  buf = tarinfo.tobuf(self.format, self.encoding, self.errors)\n  self.fileobj.write(buf)\n  self.offset += len(buf)\n  \n  \n  if fileobj is not None:\n   copyfileobj(fileobj, self.fileobj, tarinfo.size)\n   blocks, remainder = divmod(tarinfo.size, BLOCKSIZE)\n   if remainder > 0:\n    self.fileobj.write(NUL * (BLOCKSIZE - remainder))\n    blocks += 1\n   self.offset += blocks * BLOCKSIZE\n   \n  self.members.append(tarinfo)\n  \n def extractall(self, path=\".\", members=None):\n  \"\"\n  directories = []\n  \n  if members is None:\n   members = self\n   \n  for tarinfo in members:\n   if tarinfo.isdir():\n   \n    directories.append(tarinfo)\n    tarinfo = copy.copy(tarinfo)\n    tarinfo.mode = 0o700\n    \n   self.extract(tarinfo, path, set_attrs=not tarinfo.isdir())\n   \n   \n  directories.sort(key=lambda a: a.name)\n  directories.reverse()\n  \n  \n  for tarinfo in directories:\n   dirpath = os.path.join(path, tarinfo.name)\n   try:\n    self.chown(tarinfo, dirpath)\n    self.utime(tarinfo, dirpath)\n    self.chmod(tarinfo, dirpath)\n   except ExtractError as e:\n    if self.errorlevel > 1:\n     raise\n    else:\n     self._dbg(1, \"tarfile: %s\" % e)\n     \n def extract(self, member, path=\"\", set_attrs=True):\n  \"\"\n  self._check(\"r\")\n  \n  if isinstance(member, str):\n   tarinfo = self.getmember(member)\n  else:\n   tarinfo = member\n   \n   \n  if tarinfo.islnk():\n   tarinfo._link_target = os.path.join(path, tarinfo.linkname)\n   \n  try:\n   self._extract_member(tarinfo, os.path.join(path, tarinfo.name),\n   set_attrs=set_attrs)\n  except EnvironmentError as e:\n   if self.errorlevel > 0:\n    raise\n   else:\n    if e.filename is None:\n     self._dbg(1, \"tarfile: %s\" % e.strerror)\n    else:\n     self._dbg(1, \"tarfile: %s %r\" % (e.strerror, e.filename))\n  except ExtractError as e:\n   if self.errorlevel > 1:\n    raise\n   else:\n    self._dbg(1, \"tarfile: %s\" % e)\n    \n def extractfile(self, member):\n  \"\"\n  self._check(\"r\")\n  \n  if isinstance(member, str):\n   tarinfo = self.getmember(member)\n  else:\n   tarinfo = member\n   \n  if tarinfo.isreg() or tarinfo.type not in SUPPORTED_TYPES:\n  \n   return self.fileobject(self, tarinfo)\n   \n  elif tarinfo.islnk() or tarinfo.issym():\n   if isinstance(self.fileobj, _Stream):\n   \n   \n   \n    raise StreamError(\"cannot extract (sym)link as file object\")\n   else:\n   \n    return self.extractfile(self._find_link_target(tarinfo))\n  else:\n  \n  \n   return None\n   \n def _extract_member(self, tarinfo, targetpath, set_attrs=True):\n  \"\"\n  \n  \n  \n  targetpath = targetpath.rstrip(\"/\")\n  targetpath = targetpath.replace(\"/\", os.sep)\n  \n  \n  upperdirs = os.path.dirname(targetpath)\n  if upperdirs and not os.path.exists(upperdirs):\n  \n  \n   os.makedirs(upperdirs)\n   \n  if tarinfo.islnk() or tarinfo.issym():\n   self._dbg(1, \"%s -> %s\" % (tarinfo.name, tarinfo.linkname))\n  else:\n   self._dbg(1, tarinfo.name)\n   \n  if tarinfo.isreg():\n   self.makefile(tarinfo, targetpath)\n  elif tarinfo.isdir():\n   self.makedir(tarinfo, targetpath)\n  elif tarinfo.isfifo():\n   self.makefifo(tarinfo, targetpath)\n  elif tarinfo.ischr() or tarinfo.isblk():\n   self.makedev(tarinfo, targetpath)\n  elif tarinfo.islnk() or tarinfo.issym():\n   self.makelink(tarinfo, targetpath)\n  elif tarinfo.type not in SUPPORTED_TYPES:\n   self.makeunknown(tarinfo, targetpath)\n  else:\n   self.makefile(tarinfo, targetpath)\n   \n  if set_attrs:\n   self.chown(tarinfo, targetpath)\n   if not tarinfo.issym():\n    self.chmod(tarinfo, targetpath)\n    self.utime(tarinfo, targetpath)\n    \n    \n    \n    \n    \n    \n def makedir(self, tarinfo, targetpath):\n  \"\"\n  try:\n  \n  \n   os.mkdir(targetpath, 0o700)\n  except FileExistsError:\n   pass\n   \n def makefile(self, tarinfo, targetpath):\n  \"\"\n  source = self.fileobj\n  source.seek(tarinfo.offset_data)\n  with bltn_open(targetpath, \"wb\") as target:\n   if tarinfo.sparse is not None:\n    for offset, size in tarinfo.sparse:\n     target.seek(offset)\n     copyfileobj(source, target, size)\n   else:\n    copyfileobj(source, target, tarinfo.size)\n   target.seek(tarinfo.size)\n   target.truncate()\n   \n def makeunknown(self, tarinfo, targetpath):\n  \"\"\n  self.makefile(tarinfo, targetpath)\n  self._dbg(1, \"tarfile: Unknown file type %r, \" \"extracted as regular file.\" % tarinfo.type)\n  \n def makefifo(self, tarinfo, targetpath):\n  \"\"\n  if hasattr(os, \"mkfifo\"):\n   os.mkfifo(targetpath)\n  else:\n   raise ExtractError(\"fifo not supported by system\")\n   \n def makedev(self, tarinfo, targetpath):\n  \"\"\n  if not hasattr(os, \"mknod\") or not hasattr(os, \"makedev\"):\n   raise ExtractError(\"special devices not supported by system\")\n   \n  mode = tarinfo.mode\n  if tarinfo.isblk():\n   mode |= stat.S_IFBLK\n  else:\n   mode |= stat.S_IFCHR\n   \n  os.mknod(targetpath, mode,\n  os.makedev(tarinfo.devmajor, tarinfo.devminor))\n  \n def makelink(self, tarinfo, targetpath):\n  \"\"\n  try:\n  \n   if tarinfo.issym():\n    os.symlink(tarinfo.linkname, targetpath)\n   else:\n   \n    if os.path.exists(tarinfo._link_target):\n     os.link(tarinfo._link_target, targetpath)\n    else:\n     self._extract_member(self._find_link_target(tarinfo),\n     targetpath)\n  except symlink_exception:\n   try:\n    self._extract_member(self._find_link_target(tarinfo),\n    targetpath)\n   except KeyError:\n    raise ExtractError(\"unable to resolve link inside archive\")\n    \n def chown(self, tarinfo, targetpath):\n  \"\"\n  if pwd and hasattr(os, \"geteuid\") and os.geteuid() == 0:\n  \n   try:\n    g = grp.getgrnam(tarinfo.gname)[2]\n   except KeyError:\n    g = tarinfo.gid\n   try:\n    u = pwd.getpwnam(tarinfo.uname)[2]\n   except KeyError:\n    u = tarinfo.uid\n   try:\n    if tarinfo.issym() and hasattr(os, \"lchown\"):\n     os.lchown(targetpath, u, g)\n    else:\n     if sys.platform != \"os2emx\":\n      os.chown(targetpath, u, g)\n   except EnvironmentError as e:\n    raise ExtractError(\"could not change owner\")\n    \n def chmod(self, tarinfo, targetpath):\n  \"\"\n  if hasattr(os, 'chmod'):\n   try:\n    os.chmod(targetpath, tarinfo.mode)\n   except EnvironmentError as e:\n    raise ExtractError(\"could not change mode\")\n    \n def utime(self, tarinfo, targetpath):\n  \"\"\n  if not hasattr(os, 'utime'):\n   return\n  try:\n   os.utime(targetpath, (tarinfo.mtime, tarinfo.mtime))\n  except EnvironmentError as e:\n   raise ExtractError(\"could not change modification time\")\n   \n   \n def next(self):\n  \"\"\n  self._check(\"ra\")\n  if self.firstmember is not None:\n   m = self.firstmember\n   self.firstmember = None\n   return m\n   \n   \n  self.fileobj.seek(self.offset)\n  tarinfo = None\n  while True:\n   try:\n    tarinfo = self.tarinfo.fromtarfile(self)\n   except EOFHeaderError as e:\n    if self.ignore_zeros:\n     self._dbg(2, \"0x%X: %s\" % (self.offset, e))\n     self.offset += BLOCKSIZE\n     continue\n   except InvalidHeaderError as e:\n    if self.ignore_zeros:\n     self._dbg(2, \"0x%X: %s\" % (self.offset, e))\n     self.offset += BLOCKSIZE\n     continue\n    elif self.offset == 0:\n     raise ReadError(str(e))\n   except EmptyHeaderError:\n    if self.offset == 0:\n     raise ReadError(\"empty file\")\n   except TruncatedHeaderError as e:\n    if self.offset == 0:\n     raise ReadError(str(e))\n   except SubsequentHeaderError as e:\n    raise ReadError(str(e))\n   break\n   \n  if tarinfo is not None:\n   self.members.append(tarinfo)\n  else:\n   self._loaded = True\n   \n  return tarinfo\n  \n  \n  \n  \n def _getmember(self, name, tarinfo=None, normalize=False):\n  \"\"\n  \n  members = self.getmembers()\n  \n  \n  if tarinfo is not None:\n   members = members[:members.index(tarinfo)]\n   \n  if normalize:\n   name = os.path.normpath(name)\n   \n  for member in reversed(members):\n   if normalize:\n    member_name = os.path.normpath(member.name)\n   else:\n    member_name = member.name\n    \n   if name == member_name:\n    return member\n    \n def _load(self):\n  \"\"\n  while True:\n   tarinfo = self.next()\n   if tarinfo is None:\n    break\n  self._loaded = True\n  \n def _check(self, mode=None):\n  \"\"\n  if self.closed:\n   raise IOError(\"%s is closed\" % self.__class__.__name__)\n  if mode is not None and self.mode not in mode:\n   raise IOError(\"bad operation for mode %r\" % self.mode)\n   \n def _find_link_target(self, tarinfo):\n  \"\"\n  if tarinfo.issym():\n  \n   linkname = \"/\".join(filter(None, (os.path.dirname(tarinfo.name), tarinfo.linkname)))\n   limit = None\n  else:\n  \n  \n   linkname = tarinfo.linkname\n   limit = tarinfo\n   \n  member = self._getmember(linkname, tarinfo=limit, normalize=True)\n  if member is None:\n   raise KeyError(\"linkname %r not found\" % linkname)\n  return member\n  \n def __iter__(self):\n  \"\"\n  if self._loaded:\n   return iter(self.members)\n  else:\n   return TarIter(self)\n   \n def _dbg(self, level, msg):\n  \"\"\n  if level <= self.debug:\n   print(msg, file=sys.stderr)\n   \n def __enter__(self):\n  self._check()\n  return self\n  \n def __exit__(self, type, value, traceback):\n  if type is None:\n   self.close()\n  else:\n  \n  \n   if not self._extfileobj:\n    self.fileobj.close()\n   self.closed = True\n   \n   \nclass TarIter:\n \"\"\n \n def __init__(self, tarfile):\n  \"\"\n  self.tarfile = tarfile\n  self.index = 0\n def __iter__(self):\n  \"\"\n  return self\n def __next__(self):\n  \"\"\n  \n  \n  \n  \n  if self.index == 0 and self.tarfile.firstmember is not None:\n   tarinfo = self.tarfile.next()\n  elif self.index < len(self.tarfile.members):\n   tarinfo = self.tarfile.members[self.index]\n  elif not self.tarfile._loaded:\n   tarinfo = self.tarfile.next()\n   if not tarinfo:\n    self.tarfile._loaded = True\n    raise StopIteration\n  else:\n   raise StopIteration\n  self.index += 1\n  return tarinfo\n  \n  \n  \n  \ndef is_tarfile(name):\n \"\"\n try:\n  t = open(name)\n  t.close()\n  return True\n except TarError:\n  return False\n  \nbltn_open = open\nopen = TarFile.open\n"], "site-packages.pygame.pkgdata": [".py", "\"\"\n\n__all__ = ['getResource']\nimport sys\nimport os\n\n\nfrom io import StringIO\n\ntry:\n\n from pkg_resources import resource_stream\n _have_resource_stream = True\nexcept ImportError:\n _have_resource_stream = False\n \ndef getResource(identifier, pkgname=__name__):\n \"\"\n \n \n if _have_resource_stream:\n  return resource_stream(pkgname, identifier)\n  \n mod = sys.modules[pkgname]\n fn = getattr(mod, '__file__', None)\n if fn is None:\n  raise IOError(\"%r has no __file__!\")\n path = os.path.join(os.path.dirname(fn), identifier)\n loader = getattr(mod, '__loader__', None)\n if loader is not None:\n  try:\n   data = loader.get_data(path)\n  except IOError:\n   pass\n  else:\n   return StringIO(data)\n   \n return open(os.path.normpath(path), 'rb')\n"], "urllib": [".py", "", 1], "jqueryui.jquery-1.11.2": [".js", "/*!\n * jQuery JavaScript Library v1.11.2\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-17T15:27Z\n */\n\n(function( global, factory ) {\n\n    if ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n        // For CommonJS and CommonJS-like environments where a proper window is present,\n        // execute the factory and get jQuery\n        // For environments that do not inherently posses a window with a document\n        // (such as Node.js), expose a jQuery-making factory as module.exports\n        // This accentuates the need for the creation of a real window\n        // e.g. var jQuery = require(\"jquery\")(window);\n        // See ticket #14549 for more info\n        module.exports = global.document ?\n            factory( global, true ) :\n            function( w ) {\n                if ( !w.document ) {\n                    throw new Error( \"jQuery requires a window with a document\" );\n                }\n                return factory( w );\n            };\n    } else {\n        factory( global );\n    }\n\n// Pass this if window is not defined yet\n}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Can't do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n//\n\nvar deletedIds = [];\n\nvar slice = deletedIds.slice;\n\nvar concat = deletedIds.concat;\n\nvar push = deletedIds.push;\n\nvar indexOf = deletedIds.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n    version = \"1.11.2\",\n\n    // Define a local copy of jQuery\n    jQuery = function( selector, context ) {\n        // The jQuery object is actually just the init constructor 'enhanced'\n        // Need init if jQuery is called (just allow error to be thrown if not included)\n        return new jQuery.fn.init( selector, context );\n    },\n\n    // Support: Android<4.1, IE<9\n    // Make sure we trim BOM and NBSP\n    rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n    // Matches dashed string for camelizing\n    rmsPrefix = /^-ms-/,\n    rdashAlpha = /-([\\da-z])/gi,\n\n    // Used by jQuery.camelCase as callback to replace()\n    fcamelCase = function( all, letter ) {\n        return letter.toUpperCase();\n    };\n\njQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n    jquery: version,\n\n    constructor: jQuery,\n\n    // Start with an empty selector\n    selector: \"\",\n\n    // The default length of a jQuery object is 0\n    length: 0,\n\n    toArray: function() {\n        return slice.call( this );\n    },\n\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function( num ) {\n        return num != null ?\n\n            // Return just the one element from the set\n            ( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n            // Return all the elements in a clean array\n            slice.call( this );\n    },\n\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function( elems ) {\n\n        // Build a new jQuery matched element set\n        var ret = jQuery.merge( this.constructor(), elems );\n\n        // Add the old object onto the stack (as a reference)\n        ret.prevObject = this;\n        ret.context = this.context;\n\n        // Return the newly-formed element set\n        return ret;\n    },\n\n    // Execute a callback for every element in the matched set.\n    // (You can seed the arguments with an array of args, but this is\n    // only used internally.)\n    each: function( callback, args ) {\n        return jQuery.each( this, callback, args );\n    },\n\n    map: function( callback ) {\n        return this.pushStack( jQuery.map(this, function( elem, i ) {\n            return callback.call( elem, i, elem );\n        }));\n    },\n\n    slice: function() {\n        return this.pushStack( slice.apply( this, arguments ) );\n    },\n\n    first: function() {\n        return this.eq( 0 );\n    },\n\n    last: function() {\n        return this.eq( -1 );\n    },\n\n    eq: function( i ) {\n        var len = this.length,\n            j = +i + ( i < 0 ? len : 0 );\n        return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n    },\n\n    end: function() {\n        return this.prevObject || this.constructor(null);\n    },\n\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: push,\n    sort: deletedIds.sort,\n    splice: deletedIds.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n    var src, copyIsArray, copy, name, options, clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false;\n\n    // Handle a deep copy situation\n    if ( typeof target === \"boolean\" ) {\n        deep = target;\n\n        // skip the boolean and the target\n        target = arguments[ i ] || {};\n        i++;\n    }\n\n    // Handle case when target is a string or something (possible in deep copy)\n    if ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n        target = {};\n    }\n\n    // extend jQuery itself if only one argument is passed\n    if ( i === length ) {\n        target = this;\n        i--;\n    }\n\n    for ( ; i < length; i++ ) {\n        // Only deal with non-null/undefined values\n        if ( (options = arguments[ i ]) != null ) {\n            // Extend the base object\n            for ( name in options ) {\n                src = target[ name ];\n                copy = options[ name ];\n\n                // Prevent never-ending loop\n                if ( target === copy ) {\n                    continue;\n                }\n\n                // Recurse if we're merging plain objects or arrays\n                if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n                    if ( copyIsArray ) {\n                        copyIsArray = false;\n                        clone = src && jQuery.isArray(src) ? src : [];\n\n                    } else {\n                        clone = src && jQuery.isPlainObject(src) ? src : {};\n                    }\n\n                    // Never move original objects, clone them\n                    target[ name ] = jQuery.extend( deep, clone, copy );\n\n                // Don't bring in undefined values\n                } else if ( copy !== undefined ) {\n                    target[ name ] = copy;\n                }\n            }\n        }\n    }\n\n    // Return the modified object\n    return target;\n};\n\njQuery.extend({\n    // Unique for each copy of jQuery on the page\n    expando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n    // Assume jQuery is ready without the ready module\n    isReady: true,\n\n    error: function( msg ) {\n        throw new Error( msg );\n    },\n\n    noop: function() {},\n\n    // See test/unit/core.js for details concerning isFunction.\n    // Since version 1.3, DOM methods and functions like alert\n    // aren't supported. They return false on IE (#2968).\n    isFunction: function( obj ) {\n        return jQuery.type(obj) === \"function\";\n    },\n\n    isArray: Array.isArray || function( obj ) {\n        return jQuery.type(obj) === \"array\";\n    },\n\n    isWindow: function( obj ) {\n        /* jshint eqeqeq: false */\n        return obj != null && obj == obj.window;\n    },\n\n    isNumeric: function( obj ) {\n        // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n        // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n        // subtraction forces infinities to NaN\n        // adding 1 corrects loss of precision from parseFloat (#15100)\n        return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;\n    },\n\n    isEmptyObject: function( obj ) {\n        var name;\n        for ( name in obj ) {\n            return false;\n        }\n        return true;\n    },\n\n    isPlainObject: function( obj ) {\n        var key;\n\n        // Must be an Object.\n        // Because of IE, we also have to check the presence of the constructor property.\n        // Make sure that DOM nodes and window objects don't pass through, as well\n        if ( !obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n            return false;\n        }\n\n        try {\n            // Not own constructor property must be Object\n            if ( obj.constructor &&\n                !hasOwn.call(obj, \"constructor\") &&\n                !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n                return false;\n            }\n        } catch ( e ) {\n            // IE8,9 Will throw exceptions on certain host objects #9897\n            return false;\n        }\n\n        // Support: IE<9\n        // Handle iteration over inherited properties before own properties.\n        if ( support.ownLast ) {\n            for ( key in obj ) {\n                return hasOwn.call( obj, key );\n            }\n        }\n\n        // Own properties are enumerated firstly, so to speed up,\n        // if last one is own, then all properties are own.\n        for ( key in obj ) {}\n\n        return key === undefined || hasOwn.call( obj, key );\n    },\n\n    type: function( obj ) {\n        if ( obj == null ) {\n            return obj + \"\";\n        }\n        return typeof obj === \"object\" || typeof obj === \"function\" ?\n            class2type[ toString.call(obj) ] || \"object\" :\n            typeof obj;\n    },\n\n    // Evaluates a script in a global context\n    // Workarounds based on findings by Jim Driscoll\n    // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n    globalEval: function( data ) {\n        if ( data && jQuery.trim( data ) ) {\n            // We use execScript on Internet Explorer\n            // We use an anonymous function so that context is window\n            // rather than jQuery in Firefox\n            ( window.execScript || function( data ) {\n                window[ \"eval\" ].call( window, data );\n            } )( data );\n        }\n    },\n\n    // Convert dashed to camelCase; used by the css and data modules\n    // Microsoft forgot to hump their vendor prefix (#9572)\n    camelCase: function( string ) {\n        return string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n    },\n\n    nodeName: function( elem, name ) {\n        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n    },\n\n    // args is for internal usage only\n    each: function( obj, callback, args ) {\n        var value,\n            i = 0,\n            length = obj.length,\n            isArray = isArraylike( obj );\n\n        if ( args ) {\n            if ( isArray ) {\n                for ( ; i < length; i++ ) {\n                    value = callback.apply( obj[ i ], args );\n\n                    if ( value === false ) {\n                        break;\n                    }\n                }\n            } else {\n                for ( i in obj ) {\n                    value = callback.apply( obj[ i ], args );\n\n                    if ( value === false ) {\n                        break;\n                    }\n                }\n            }\n\n        // A special, fast, case for the most common use of each\n        } else {\n            if ( isArray ) {\n                for ( ; i < length; i++ ) {\n                    value = callback.call( obj[ i ], i, obj[ i ] );\n\n                    if ( value === false ) {\n                        break;\n                    }\n                }\n            } else {\n                for ( i in obj ) {\n                    value = callback.call( obj[ i ], i, obj[ i ] );\n\n                    if ( value === false ) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return obj;\n    },\n\n    // Support: Android<4.1, IE<9\n    trim: function( text ) {\n        return text == null ?\n            \"\" :\n            ( text + \"\" ).replace( rtrim, \"\" );\n    },\n\n    // results is for internal usage only\n    makeArray: function( arr, results ) {\n        var ret = results || [];\n\n        if ( arr != null ) {\n            if ( isArraylike( Object(arr) ) ) {\n                jQuery.merge( ret,\n                    typeof arr === \"string\" ?\n                    [ arr ] : arr\n                );\n            } else {\n                push.call( ret, arr );\n            }\n        }\n\n        return ret;\n    },\n\n    inArray: function( elem, arr, i ) {\n        var len;\n\n        if ( arr ) {\n            if ( indexOf ) {\n                return indexOf.call( arr, elem, i );\n            }\n\n            len = arr.length;\n            i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n\n            for ( ; i < len; i++ ) {\n                // Skip accessing in sparse arrays\n                if ( i in arr && arr[ i ] === elem ) {\n                    return i;\n                }\n            }\n        }\n\n        return -1;\n    },\n\n    merge: function( first, second ) {\n        var len = +second.length,\n            j = 0,\n            i = first.length;\n\n        while ( j < len ) {\n            first[ i++ ] = second[ j++ ];\n        }\n\n        // Support: IE<9\n        // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)\n        if ( len !== len ) {\n            while ( second[j] !== undefined ) {\n                first[ i++ ] = second[ j++ ];\n            }\n        }\n\n        first.length = i;\n\n        return first;\n    },\n\n    grep: function( elems, callback, invert ) {\n        var callbackInverse,\n            matches = [],\n            i = 0,\n            length = elems.length,\n            callbackExpect = !invert;\n\n        // Go through the array, only saving the items\n        // that pass the validator function\n        for ( ; i < length; i++ ) {\n            callbackInverse = !callback( elems[ i ], i );\n            if ( callbackInverse !== callbackExpect ) {\n                matches.push( elems[ i ] );\n            }\n        }\n\n        return matches;\n    },\n\n    // arg is for internal usage only\n    map: function( elems, callback, arg ) {\n        var value,\n            i = 0,\n            length = elems.length,\n            isArray = isArraylike( elems ),\n            ret = [];\n\n        // Go through the array, translating each of the items to their new values\n        if ( isArray ) {\n            for ( ; i < length; i++ ) {\n                value = callback( elems[ i ], i, arg );\n\n                if ( value != null ) {\n                    ret.push( value );\n                }\n            }\n\n        // Go through every key on the object,\n        } else {\n            for ( i in elems ) {\n                value = callback( elems[ i ], i, arg );\n\n                if ( value != null ) {\n                    ret.push( value );\n                }\n            }\n        }\n\n        // Flatten any nested arrays\n        return concat.apply( [], ret );\n    },\n\n    // A global GUID counter for objects\n    guid: 1,\n\n    // Bind a function to a context, optionally partially applying any\n    // arguments.\n    proxy: function( fn, context ) {\n        var args, proxy, tmp;\n\n        if ( typeof context === \"string\" ) {\n            tmp = fn[ context ];\n            context = fn;\n            fn = tmp;\n        }\n\n        // Quick check to determine if target is callable, in the spec\n        // this throws a TypeError, but we will just return undefined.\n        if ( !jQuery.isFunction( fn ) ) {\n            return undefined;\n        }\n\n        // Simulated bind\n        args = slice.call( arguments, 2 );\n        proxy = function() {\n            return fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n        };\n\n        // Set the guid of unique handler to the same of original handler, so it can be removed\n        proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n        return proxy;\n    },\n\n    now: function() {\n        return +( new Date() );\n    },\n\n    // jQuery.support is not used in Core but other projects attach their\n    // properties to it so it needs to exist.\n    support: support\n});\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n    class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n    var length = obj.length,\n        type = jQuery.type( obj );\n\n    if ( type === \"function\" || jQuery.isWindow( obj ) ) {\n        return false;\n    }\n\n    if ( obj.nodeType === 1 && length ) {\n        return true;\n    }\n\n    return type === \"array\" || length === 0 ||\n        typeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.0-pre\n * http://sizzlejs.com/\n *\n * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-16\n */\n(function( window ) {\n\nvar i,\n    support,\n    Expr,\n    getText,\n    isXML,\n    tokenize,\n    compile,\n    select,\n    outermostContext,\n    sortInput,\n    hasDuplicate,\n\n    // Local document vars\n    setDocument,\n    document,\n    docElem,\n    documentIsHTML,\n    rbuggyQSA,\n    rbuggyMatches,\n    matches,\n    contains,\n\n    // Instance-specific data\n    expando = \"sizzle\" + 1 * new Date(),\n    preferredDoc = window.document,\n    dirruns = 0,\n    done = 0,\n    classCache = createCache(),\n    tokenCache = createCache(),\n    compilerCache = createCache(),\n    sortOrder = function( a, b ) {\n        if ( a === b ) {\n            hasDuplicate = true;\n        }\n        return 0;\n    },\n\n    // General-purpose constants\n    MAX_NEGATIVE = 1 << 31,\n\n    // Instance methods\n    hasOwn = ({}).hasOwnProperty,\n    arr = [],\n    pop = arr.pop,\n    push_native = arr.push,\n    push = arr.push,\n    slice = arr.slice,\n    // Use a stripped-down indexOf as it's faster than native\n    // http://jsperf.com/thor-indexof-vs-for/5\n    indexOf = function( list, elem ) {\n        var i = 0,\n            len = list.length;\n        for ( ; i < len; i++ ) {\n            if ( list[i] === elem ) {\n                return i;\n            }\n        }\n        return -1;\n    },\n\n    booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n    // Regular expressions\n\n    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n    whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n    // http://www.w3.org/TR/css3-syntax/#characters\n    characterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n    // Loosely modeled on CSS identifier characters\n    // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n    identifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n    // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n    attributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\n        // Operator (capture 2)\n        \"*([*^$|!~]?=)\" + whitespace +\n        // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n        \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n        \"*\\\\]\",\n\n    pseudos = \":(\" + characterEncoding + \")(?:\\\\((\" +\n        // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n        // 1. quoted (capture 3; capture 4 or capture 5)\n        \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n        // 2. simple (capture 6)\n        \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n        // 3. anything else (capture 2)\n        \".*\" +\n        \")\\\\)|)\",\n\n    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n    rwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n    rtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n    rcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n    rcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n    rattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n    rpseudo = new RegExp( pseudos ),\n    ridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n    matchExpr = {\n        \"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n        \"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n        \"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n        \"ATTR\": new RegExp( \"^\" + attributes ),\n        \"PSEUDO\": new RegExp( \"^\" + pseudos ),\n        \"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n            \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n            \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n        \"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n        // For use in libraries implementing .is()\n        // We use this for POS matching in `select`\n        \"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n            whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n    },\n\n    rinputs = /^(?:input|select|textarea|button)$/i,\n    rheader = /^h\\d$/i,\n\n    rnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n    // Easily-parseable/retrievable ID or TAG or CLASS selectors\n    rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n    rsibling = /[+~]/,\n    rescape = /'|\\\\/g,\n\n    // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n    runescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n    funescape = function( _, escaped, escapedWhitespace ) {\n        var high = \"0x\" + escaped - 0x10000;\n        // NaN means non-codepoint\n        // Support: Firefox<24\n        // Workaround erroneous numeric interpretation of +\"0x\"\n        return high !== high || escapedWhitespace ?\n            escaped :\n            high < 0 ?\n                // BMP codepoint\n                String.fromCharCode( high + 0x10000 ) :\n                // Supplemental Plane codepoint (surrogate pair)\n                String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n    },\n\n    // Used for iframes\n    // See setDocument()\n    // Removing the function wrapper causes a \"Permission Denied\"\n    // error in IE\n    unloadHandler = function() {\n        setDocument();\n    };\n\n// Optimize for push.apply( _, NodeList )\ntry {\n    push.apply(\n        (arr = slice.call( preferredDoc.childNodes )),\n        preferredDoc.childNodes\n    );\n    // Support: Android<4.0\n    // Detect silently failing push.apply\n    arr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n    push = { apply: arr.length ?\n\n        // Leverage slice if possible\n        function( target, els ) {\n            push_native.apply( target, slice.call(els) );\n        } :\n\n        // Support: IE<9\n        // Otherwise append directly\n        function( target, els ) {\n            var j = target.length,\n                i = 0;\n            // Can't trust NodeList.length\n            while ( (target[j++] = els[i++]) ) {}\n            target.length = j - 1;\n        }\n    };\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n    var match, elem, m, nodeType,\n        // QSA vars\n        i, groups, old, nid, newContext, newSelector;\n\n    if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n        setDocument( context );\n    }\n\n    context = context || document;\n    results = results || [];\n    nodeType = context.nodeType;\n\n    if ( typeof selector !== \"string\" || !selector ||\n        nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n        return results;\n    }\n\n    if ( !seed && documentIsHTML ) {\n\n        // Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n        if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n            // Speed-up: Sizzle(\"#ID\")\n            if ( (m = match[1]) ) {\n                if ( nodeType === 9 ) {\n                    elem = context.getElementById( m );\n                    // Check parentNode to catch when Blackberry 4.6 returns\n                    // nodes that are no longer in the document (jQuery #6963)\n                    if ( elem && elem.parentNode ) {\n                        // Handle the case where IE, Opera, and Webkit return items\n                        // by name instead of ID\n                        if ( elem.id === m ) {\n                            results.push( elem );\n                            return results;\n                        }\n                    } else {\n                        return results;\n                    }\n                } else {\n                    // Context is not a document\n                    if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n                        contains( context, elem ) && elem.id === m ) {\n                        results.push( elem );\n                        return results;\n                    }\n                }\n\n            // Speed-up: Sizzle(\"TAG\")\n            } else if ( match[2] ) {\n                push.apply( results, context.getElementsByTagName( selector ) );\n                return results;\n\n            // Speed-up: Sizzle(\".CLASS\")\n            } else if ( (m = match[3]) && support.getElementsByClassName ) {\n                push.apply( results, context.getElementsByClassName( m ) );\n                return results;\n            }\n        }\n\n        // QSA path\n        if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n            nid = old = expando;\n            newContext = context;\n            newSelector = nodeType !== 1 && selector;\n\n            // qSA works strangely on Element-rooted queries\n            // We can work around this by specifying an extra ID on the root\n            // and working up from there (Thanks to Andrew Dupont for the technique)\n            // IE 8 doesn't work on object elements\n            if ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n                groups = tokenize( selector );\n\n                if ( (old = context.getAttribute(\"id\")) ) {\n                    nid = old.replace( rescape, \"\\\\$&\" );\n                } else {\n                    context.setAttribute( \"id\", nid );\n                }\n                nid = \"[id='\" + nid + \"'] \";\n\n                i = groups.length;\n                while ( i-- ) {\n                    groups[i] = nid + toSelector( groups[i] );\n                }\n                newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n                newSelector = groups.join(\",\");\n            }\n\n            if ( newSelector ) {\n                try {\n                    push.apply( results,\n                        newContext.querySelectorAll( newSelector )\n                    );\n                    return results;\n                } catch(qsaError) {\n                } finally {\n                    if ( !old ) {\n                        context.removeAttribute(\"id\");\n                    }\n                }\n            }\n        }\n    }\n\n    // All others\n    return select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *    property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *    deleting the oldest entry\n */\nfunction createCache() {\n    var keys = [];\n\n    function cache( key, value ) {\n        // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n        if ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n            // Only keep the most recent entries\n            delete cache[ keys.shift() ];\n        }\n        return (cache[ key + \" \" ] = value);\n    }\n    return cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n    fn[ expando ] = true;\n    return fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n    var div = document.createElement(\"div\");\n\n    try {\n        return !!fn( div );\n    } catch (e) {\n        return false;\n    } finally {\n        // Remove from its parent by default\n        if ( div.parentNode ) {\n            div.parentNode.removeChild( div );\n        }\n        // release memory in IE\n        div = null;\n    }\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n    var arr = attrs.split(\"|\"),\n        i = attrs.length;\n\n    while ( i-- ) {\n        Expr.attrHandle[ arr[i] ] = handler;\n    }\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n    var cur = b && a,\n        diff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n            ( ~b.sourceIndex || MAX_NEGATIVE ) -\n            ( ~a.sourceIndex || MAX_NEGATIVE );\n\n    // Use IE sourceIndex if available on both nodes\n    if ( diff ) {\n        return diff;\n    }\n\n    // Check if b follows a\n    if ( cur ) {\n        while ( (cur = cur.nextSibling) ) {\n            if ( cur === b ) {\n                return -1;\n            }\n        }\n    }\n\n    return a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n    return function( elem ) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && elem.type === type;\n    };\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n    return function( elem ) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && elem.type === type;\n    };\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n    return markFunction(function( argument ) {\n        argument = +argument;\n        return markFunction(function( seed, matches ) {\n            var j,\n                matchIndexes = fn( [], seed.length, argument ),\n                i = matchIndexes.length;\n\n            // Match elements found at the specified indexes\n            while ( i-- ) {\n                if ( seed[ (j = matchIndexes[i]) ] ) {\n                    seed[j] = !(matches[j] = seed[j]);\n                }\n            }\n        });\n    });\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n    return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n    // documentElement is verified for cases where it doesn't yet exist\n    // (such as loading iframes in IE - #4833)\n    var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n    return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n    var hasCompare, parent,\n        doc = node ? node.ownerDocument || node : preferredDoc;\n\n    // If no document and documentElement is available, return\n    if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n        return document;\n    }\n\n    // Set our document\n    document = doc;\n    docElem = doc.documentElement;\n    parent = doc.defaultView;\n\n    // Support: IE>8\n    // If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n    // IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n    // IE6-8 do not support the defaultView property so parent will be undefined\n    if ( parent && parent !== parent.top ) {\n        // IE11 does not have attachEvent, so all must suffer\n        if ( parent.addEventListener ) {\n            parent.addEventListener( \"unload\", unloadHandler, false );\n        } else if ( parent.attachEvent ) {\n            parent.attachEvent( \"onunload\", unloadHandler );\n        }\n    }\n\n    /* Support tests\n    ---------------------------------------------------------------------- */\n    documentIsHTML = !isXML( doc );\n\n    /* Attributes\n    ---------------------------------------------------------------------- */\n\n    // Support: IE<8\n    // Verify that getAttribute really returns attributes and not properties\n    // (excepting IE8 booleans)\n    support.attributes = assert(function( div ) {\n        div.className = \"i\";\n        return !div.getAttribute(\"className\");\n    });\n\n    /* getElement(s)By*\n    ---------------------------------------------------------------------- */\n\n    // Check if getElementsByTagName(\"*\") returns only elements\n    support.getElementsByTagName = assert(function( div ) {\n        div.appendChild( doc.createComment(\"\") );\n        return !div.getElementsByTagName(\"*\").length;\n    });\n\n    // Support: IE<9\n    support.getElementsByClassName = rnative.test( doc.getElementsByClassName );\n\n    // Support: IE<10\n    // Check if getElementById returns elements by name\n    // The broken getElementById methods don't pick up programatically-set names,\n    // so use a roundabout getElementsByName test\n    support.getById = assert(function( div ) {\n        docElem.appendChild( div ).id = expando;\n        return !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n    });\n\n    // ID find and filter\n    if ( support.getById ) {\n        Expr.find[\"ID\"] = function( id, context ) {\n            if ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n                var m = context.getElementById( id );\n                // Check parentNode to catch when Blackberry 4.6 returns\n                // nodes that are no longer in the document #6963\n                return m && m.parentNode ? [ m ] : [];\n            }\n        };\n        Expr.filter[\"ID\"] = function( id ) {\n            var attrId = id.replace( runescape, funescape );\n            return function( elem ) {\n                return elem.getAttribute(\"id\") === attrId;\n            };\n        };\n    } else {\n        // Support: IE6/7\n        // getElementById is not reliable as a find shortcut\n        delete Expr.find[\"ID\"];\n\n        Expr.filter[\"ID\"] =  function( id ) {\n            var attrId = id.replace( runescape, funescape );\n            return function( elem ) {\n                var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n                return node && node.value === attrId;\n            };\n        };\n    }\n\n    // Tag\n    Expr.find[\"TAG\"] = support.getElementsByTagName ?\n        function( tag, context ) {\n            if ( typeof context.getElementsByTagName !== \"undefined\" ) {\n                return context.getElementsByTagName( tag );\n\n            // DocumentFragment nodes don't have gEBTN\n            } else if ( support.qsa ) {\n                return context.querySelectorAll( tag );\n            }\n        } :\n\n        function( tag, context ) {\n            var elem,\n                tmp = [],\n                i = 0,\n                // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n                results = context.getElementsByTagName( tag );\n\n            // Filter out possible comments\n            if ( tag === \"*\" ) {\n                while ( (elem = results[i++]) ) {\n                    if ( elem.nodeType === 1 ) {\n                        tmp.push( elem );\n                    }\n                }\n\n                return tmp;\n            }\n            return results;\n        };\n\n    // Class\n    Expr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n        if ( documentIsHTML ) {\n            return context.getElementsByClassName( className );\n        }\n    };\n\n    /* QSA/matchesSelector\n    ---------------------------------------------------------------------- */\n\n    // QSA and matchesSelector support\n\n    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n    rbuggyMatches = [];\n\n    // qSa(:focus) reports false when true (Chrome 21)\n    // We allow this because of a bug in IE8/9 that throws an error\n    // whenever `document.activeElement` is accessed on an iframe\n    // So, we allow :focus to pass through QSA all the time to avoid the IE error\n    // See http://bugs.jquery.com/ticket/13378\n    rbuggyQSA = [];\n\n    if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n        // Build QSA regex\n        // Regex strategy adopted from Diego Perini\n        assert(function( div ) {\n            // Select is set to empty string on purpose\n            // This is to test IE's treatment of not explicitly\n            // setting a boolean content attribute,\n            // since its presence should be enough\n            // http://bugs.jquery.com/ticket/12359\n            docElem.appendChild( div ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n                \"<select id='\" + expando + \"-\\f]' msallowcapture=''>\" +\n                \"<option selected=''></option></select>\";\n\n            // Support: IE8, Opera 11-12.16\n            // Nothing should be selected when empty strings follow ^= or $= or *=\n            // The test attribute must be unknown in Opera but \"safe\" for WinRT\n            // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n            if ( div.querySelectorAll(\"[msallowcapture^='']\").length ) {\n                rbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n            }\n\n            // Support: IE8\n            // Boolean attributes and \"value\" are not treated correctly\n            if ( !div.querySelectorAll(\"[selected]\").length ) {\n                rbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n            }\n\n            // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n            if ( !div.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n                rbuggyQSA.push(\"~=\");\n            }\n\n            // Webkit/Opera - :checked should return selected option elements\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n            // IE8 throws error here and will not see later tests\n            if ( !div.querySelectorAll(\":checked\").length ) {\n                rbuggyQSA.push(\":checked\");\n            }\n\n            // Support: Safari 8+, iOS 8+\n            // https://bugs.webkit.org/show_bug.cgi?id=136851\n            // In-page `selector#id sibing-combinator selector` fails\n            if ( !div.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n                rbuggyQSA.push(\".#.+[+~]\");\n            }\n        });\n\n        assert(function( div ) {\n            // Support: Windows 8 Native Apps\n            // The type and name attributes are restricted during .innerHTML assignment\n            var input = doc.createElement(\"input\");\n            input.setAttribute( \"type\", \"hidden\" );\n            div.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n            // Support: IE8\n            // Enforce case-sensitivity of name attribute\n            if ( div.querySelectorAll(\"[name=d]\").length ) {\n                rbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n            }\n\n            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n            // IE8 throws error here and will not see later tests\n            if ( !div.querySelectorAll(\":enabled\").length ) {\n                rbuggyQSA.push( \":enabled\", \":disabled\" );\n            }\n\n            // Opera 10-11 does not throw on post-comma invalid pseudos\n            div.querySelectorAll(\"*,:x\");\n            rbuggyQSA.push(\",.*:\");\n        });\n    }\n\n    if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n        docElem.webkitMatchesSelector ||\n        docElem.mozMatchesSelector ||\n        docElem.oMatchesSelector ||\n        docElem.msMatchesSelector) )) ) {\n\n        assert(function( div ) {\n            // Check to see if it's possible to do matchesSelector\n            // on a disconnected node (IE 9)\n            support.disconnectedMatch = matches.call( div, \"div\" );\n\n            // This should fail with an exception\n            // Gecko does not error, returns false instead\n            matches.call( div, \"[s!='']:x\" );\n            rbuggyMatches.push( \"!=\", pseudos );\n        });\n    }\n\n    rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n    rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n    /* Contains\n    ---------------------------------------------------------------------- */\n    hasCompare = rnative.test( docElem.compareDocumentPosition );\n\n    // Element contains another\n    // Purposefully does not implement inclusive descendent\n    // As in, an element does not contain itself\n    contains = hasCompare || rnative.test( docElem.contains ) ?\n        function( a, b ) {\n            var adown = a.nodeType === 9 ? a.documentElement : a,\n                bup = b && b.parentNode;\n            return a === bup || !!( bup && bup.nodeType === 1 && (\n                adown.contains ?\n                    adown.contains( bup ) :\n                    a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n            ));\n        } :\n        function( a, b ) {\n            if ( b ) {\n                while ( (b = b.parentNode) ) {\n                    if ( b === a ) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n\n    /* Sorting\n    ---------------------------------------------------------------------- */\n\n    // Document order sorting\n    sortOrder = hasCompare ?\n    function( a, b ) {\n\n        // Flag for duplicate removal\n        if ( a === b ) {\n            hasDuplicate = true;\n            return 0;\n        }\n\n        // Sort on method existence if only one input has compareDocumentPosition\n        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n        if ( compare ) {\n            return compare;\n        }\n\n        // Calculate position if both inputs belong to the same document\n        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n            a.compareDocumentPosition( b ) :\n\n            // Otherwise we know they are disconnected\n            1;\n\n        // Disconnected nodes\n        if ( compare & 1 ||\n            (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n            // Choose the first element that is related to our preferred document\n            if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n                return -1;\n            }\n            if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n                return 1;\n            }\n\n            // Maintain original order\n            return sortInput ?\n                ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n                0;\n        }\n\n        return compare & 4 ? -1 : 1;\n    } :\n    function( a, b ) {\n        // Exit early if the nodes are identical\n        if ( a === b ) {\n            hasDuplicate = true;\n            return 0;\n        }\n\n        var cur,\n            i = 0,\n            aup = a.parentNode,\n            bup = b.parentNode,\n            ap = [ a ],\n            bp = [ b ];\n\n        // Parentless nodes are either documents or disconnected\n        if ( !aup || !bup ) {\n            return a === doc ? -1 :\n                b === doc ? 1 :\n                aup ? -1 :\n                bup ? 1 :\n                sortInput ?\n                ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n                0;\n\n        // If the nodes are siblings, we can do a quick check\n        } else if ( aup === bup ) {\n            return siblingCheck( a, b );\n        }\n\n        // Otherwise we need full lists of their ancestors for comparison\n        cur = a;\n        while ( (cur = cur.parentNode) ) {\n            ap.unshift( cur );\n        }\n        cur = b;\n        while ( (cur = cur.parentNode) ) {\n            bp.unshift( cur );\n        }\n\n        // Walk down the tree looking for a discrepancy\n        while ( ap[i] === bp[i] ) {\n            i++;\n        }\n\n        return i ?\n            // Do a sibling check if the nodes have a common ancestor\n            siblingCheck( ap[i], bp[i] ) :\n\n            // Otherwise nodes in our document sort first\n            ap[i] === preferredDoc ? -1 :\n            bp[i] === preferredDoc ? 1 :\n            0;\n    };\n\n    return doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n    return Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n    // Set document vars if needed\n    if ( ( elem.ownerDocument || elem ) !== document ) {\n        setDocument( elem );\n    }\n\n    // Make sure that attribute selectors are quoted\n    expr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n    if ( support.matchesSelector && documentIsHTML &&\n        ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n        ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n        try {\n            var ret = matches.call( elem, expr );\n\n            // IE 9's matchesSelector returns false on disconnected nodes\n            if ( ret || support.disconnectedMatch ||\n                    // As well, disconnected nodes are said to be in a document\n                    // fragment in IE 9\n                    elem.document && elem.document.nodeType !== 11 ) {\n                return ret;\n            }\n        } catch (e) {}\n    }\n\n    return Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n    // Set document vars if needed\n    if ( ( context.ownerDocument || context ) !== document ) {\n        setDocument( context );\n    }\n    return contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n    // Set document vars if needed\n    if ( ( elem.ownerDocument || elem ) !== document ) {\n        setDocument( elem );\n    }\n\n    var fn = Expr.attrHandle[ name.toLowerCase() ],\n        // Don't get fooled by Object.prototype properties (jQuery #13807)\n        val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n            fn( elem, name, !documentIsHTML ) :\n            undefined;\n\n    return val !== undefined ?\n        val :\n        support.attributes || !documentIsHTML ?\n            elem.getAttribute( name ) :\n            (val = elem.getAttributeNode(name)) && val.specified ?\n                val.value :\n                null;\n};\n\nSizzle.error = function( msg ) {\n    throw new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n    var elem,\n        duplicates = [],\n        j = 0,\n        i = 0;\n\n    // Unless we *know* we can detect duplicates, assume their presence\n    hasDuplicate = !support.detectDuplicates;\n    sortInput = !support.sortStable && results.slice( 0 );\n    results.sort( sortOrder );\n\n    if ( hasDuplicate ) {\n        while ( (elem = results[i++]) ) {\n            if ( elem === results[ i ] ) {\n                j = duplicates.push( i );\n            }\n        }\n        while ( j-- ) {\n            results.splice( duplicates[ j ], 1 );\n        }\n    }\n\n    // Clear input after sorting to release objects\n    // See https://github.com/jquery/sizzle/pull/225\n    sortInput = null;\n\n    return results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n    var node,\n        ret = \"\",\n        i = 0,\n        nodeType = elem.nodeType;\n\n    if ( !nodeType ) {\n        // If no nodeType, this is expected to be an array\n        while ( (node = elem[i++]) ) {\n            // Do not traverse comment nodes\n            ret += getText( node );\n        }\n    } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n        // Use textContent for elements\n        // innerText usage removed for consistency of new lines (jQuery #11153)\n        if ( typeof elem.textContent === \"string\" ) {\n            return elem.textContent;\n        } else {\n            // Traverse its children\n            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n                ret += getText( elem );\n            }\n        }\n    } else if ( nodeType === 3 || nodeType === 4 ) {\n        return elem.nodeValue;\n    }\n    // Do not include comment or processing instruction nodes\n\n    return ret;\n};\n\nExpr = Sizzle.selectors = {\n\n    // Can be adjusted by the user\n    cacheLength: 50,\n\n    createPseudo: markFunction,\n\n    match: matchExpr,\n\n    attrHandle: {},\n\n    find: {},\n\n    relative: {\n        \">\": { dir: \"parentNode\", first: true },\n        \" \": { dir: \"parentNode\" },\n        \"+\": { dir: \"previousSibling\", first: true },\n        \"~\": { dir: \"previousSibling\" }\n    },\n\n    preFilter: {\n        \"ATTR\": function( match ) {\n            match[1] = match[1].replace( runescape, funescape );\n\n            // Move the given value to match[3] whether quoted or unquoted\n            match[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n            if ( match[2] === \"~=\" ) {\n                match[3] = \" \" + match[3] + \" \";\n            }\n\n            return match.slice( 0, 4 );\n        },\n\n        \"CHILD\": function( match ) {\n            /* matches from matchExpr[\"CHILD\"]\n                1 type (only|nth|...)\n                2 what (child|of-type)\n                3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n                4 xn-component of xn+y argument ([+-]?\\d*n|)\n                5 sign of xn-component\n                6 x of xn-component\n                7 sign of y-component\n                8 y of y-component\n            */\n            match[1] = match[1].toLowerCase();\n\n            if ( match[1].slice( 0, 3 ) === \"nth\" ) {\n                // nth-* requires argument\n                if ( !match[3] ) {\n                    Sizzle.error( match[0] );\n                }\n\n                // numeric x and y parameters for Expr.filter.CHILD\n                // remember that false/true cast respectively to 0/1\n                match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n                match[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n            // other types prohibit arguments\n            } else if ( match[3] ) {\n                Sizzle.error( match[0] );\n            }\n\n            return match;\n        },\n\n        \"PSEUDO\": function( match ) {\n            var excess,\n                unquoted = !match[6] && match[2];\n\n            if ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n                return null;\n            }\n\n            // Accept quoted arguments as-is\n            if ( match[3] ) {\n                match[2] = match[4] || match[5] || \"\";\n\n            // Strip excess characters from unquoted arguments\n            } else if ( unquoted && rpseudo.test( unquoted ) &&\n                // Get excess from tokenize (recursively)\n                (excess = tokenize( unquoted, true )) &&\n                // advance to the next closing parenthesis\n                (excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n                // excess is a negative index\n                match[0] = match[0].slice( 0, excess );\n                match[2] = unquoted.slice( 0, excess );\n            }\n\n            // Return only captures needed by the pseudo filter method (type and argument)\n            return match.slice( 0, 3 );\n        }\n    },\n\n    filter: {\n\n        \"TAG\": function( nodeNameSelector ) {\n            var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n            return nodeNameSelector === \"*\" ?\n                function() { return true; } :\n                function( elem ) {\n                    return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n                };\n        },\n\n        \"CLASS\": function( className ) {\n            var pattern = classCache[ className + \" \" ];\n\n            return pattern ||\n                (pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n                classCache( className, function( elem ) {\n                    return pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n                });\n        },\n\n        \"ATTR\": function( name, operator, check ) {\n            return function( elem ) {\n                var result = Sizzle.attr( elem, name );\n\n                if ( result == null ) {\n                    return operator === \"!=\";\n                }\n                if ( !operator ) {\n                    return true;\n                }\n\n                result += \"\";\n\n                return operator === \"=\" ? result === check :\n                    operator === \"!=\" ? result !== check :\n                    operator === \"^=\" ? check && result.indexOf( check ) === 0 :\n                    operator === \"*=\" ? check && result.indexOf( check ) > -1 :\n                    operator === \"$=\" ? check && result.slice( -check.length ) === check :\n                    operator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n                    operator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n                    false;\n            };\n        },\n\n        \"CHILD\": function( type, what, argument, first, last ) {\n            var simple = type.slice( 0, 3 ) !== \"nth\",\n                forward = type.slice( -4 ) !== \"last\",\n                ofType = what === \"of-type\";\n\n            return first === 1 && last === 0 ?\n\n                // Shortcut for :nth-*(n)\n                function( elem ) {\n                    return !!elem.parentNode;\n                } :\n\n                function( elem, context, xml ) {\n                    var cache, outerCache, node, diff, nodeIndex, start,\n                        dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                        parent = elem.parentNode,\n                        name = ofType && elem.nodeName.toLowerCase(),\n                        useCache = !xml && !ofType;\n\n                    if ( parent ) {\n\n                        // :(first|last|only)-(child|of-type)\n                        if ( simple ) {\n                            while ( dir ) {\n                                node = elem;\n                                while ( (node = node[ dir ]) ) {\n                                    if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n                                        return false;\n                                    }\n                                }\n                                // Reverse direction for :only-* (if we haven't yet done so)\n                                start = dir = type === \"only\" && !start && \"nextSibling\";\n                            }\n                            return true;\n                        }\n\n                        start = [ forward ? parent.firstChild : parent.lastChild ];\n\n                        // non-xml :nth-child(...) stores cache data on `parent`\n                        if ( forward && useCache ) {\n                            // Seek `elem` from a previously-cached index\n                            outerCache = parent[ expando ] || (parent[ expando ] = {});\n                            cache = outerCache[ type ] || [];\n                            nodeIndex = cache[0] === dirruns && cache[1];\n                            diff = cache[0] === dirruns && cache[2];\n                            node = nodeIndex && parent.childNodes[ nodeIndex ];\n\n                            while ( (node = ++nodeIndex && node && node[ dir ] ||\n\n                                // Fallback to seeking `elem` from the start\n                                (diff = nodeIndex = 0) || start.pop()) ) {\n\n                                // When found, cache indexes on `parent` and break\n                                if ( node.nodeType === 1 && ++diff && node === elem ) {\n                                    outerCache[ type ] = [ dirruns, nodeIndex, diff ];\n                                    break;\n                                }\n                            }\n\n                        // Use previously-cached element index if available\n                        } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n                            diff = cache[1];\n\n                        // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n                        } else {\n                            // Use the same loop as above to seek `elem` from the start\n                            while ( (node = ++nodeIndex && node && node[ dir ] ||\n                                (diff = nodeIndex = 0) || start.pop()) ) {\n\n                                if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n                                    // Cache the index of each encountered element\n                                    if ( useCache ) {\n                                        (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n                                    }\n\n                                    if ( node === elem ) {\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n\n                        // Incorporate the offset, then check against cycle size\n                        diff -= last;\n                        return diff === first || ( diff % first === 0 && diff / first >= 0 );\n                    }\n                };\n        },\n\n        \"PSEUDO\": function( pseudo, argument ) {\n            // pseudo-class names are case-insensitive\n            // http://www.w3.org/TR/selectors/#pseudo-classes\n            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n            // Remember that setFilters inherits from pseudos\n            var args,\n                fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n                    Sizzle.error( \"unsupported pseudo: \" + pseudo );\n\n            // The user may use createPseudo to indicate that\n            // arguments are needed to create the filter function\n            // just as Sizzle does\n            if ( fn[ expando ] ) {\n                return fn( argument );\n            }\n\n            // But maintain support for old signatures\n            if ( fn.length > 1 ) {\n                args = [ pseudo, pseudo, \"\", argument ];\n                return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n                    markFunction(function( seed, matches ) {\n                        var idx,\n                            matched = fn( seed, argument ),\n                            i = matched.length;\n                        while ( i-- ) {\n                            idx = indexOf( seed, matched[i] );\n                            seed[ idx ] = !( matches[ idx ] = matched[i] );\n                        }\n                    }) :\n                    function( elem ) {\n                        return fn( elem, 0, args );\n                    };\n            }\n\n            return fn;\n        }\n    },\n\n    pseudos: {\n        // Potentially complex pseudos\n        \"not\": markFunction(function( selector ) {\n            // Trim the selector passed to compile\n            // to avoid treating leading and trailing\n            // spaces as combinators\n            var input = [],\n                results = [],\n                matcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n            return matcher[ expando ] ?\n                markFunction(function( seed, matches, context, xml ) {\n                    var elem,\n                        unmatched = matcher( seed, null, xml, [] ),\n                        i = seed.length;\n\n                    // Match elements unmatched by `matcher`\n                    while ( i-- ) {\n                        if ( (elem = unmatched[i]) ) {\n                            seed[i] = !(matches[i] = elem);\n                        }\n                    }\n                }) :\n                function( elem, context, xml ) {\n                    input[0] = elem;\n                    matcher( input, null, xml, results );\n                    // Don't keep the element (issue #299)\n                    input[0] = null;\n                    return !results.pop();\n                };\n        }),\n\n        \"has\": markFunction(function( selector ) {\n            return function( elem ) {\n                return Sizzle( selector, elem ).length > 0;\n            };\n        }),\n\n        \"contains\": markFunction(function( text ) {\n            text = text.replace( runescape, funescape );\n            return function( elem ) {\n                return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n            };\n        }),\n\n        // \"Whether an element is represented by a :lang() selector\n        // is based solely on the element's language value\n        // being equal to the identifier C,\n        // or beginning with the identifier C immediately followed by \"-\".\n        // The matching of C against the element's language value is performed case-insensitively.\n        // The identifier C does not have to be a valid language name.\"\n        // http://www.w3.org/TR/selectors/#lang-pseudo\n        \"lang\": markFunction( function( lang ) {\n            // lang value must be a valid identifier\n            if ( !ridentifier.test(lang || \"\") ) {\n                Sizzle.error( \"unsupported lang: \" + lang );\n            }\n            lang = lang.replace( runescape, funescape ).toLowerCase();\n            return function( elem ) {\n                var elemLang;\n                do {\n                    if ( (elemLang = documentIsHTML ?\n                        elem.lang :\n                        elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n                        elemLang = elemLang.toLowerCase();\n                        return elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n                    }\n                } while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n                return false;\n            };\n        }),\n\n        // Miscellaneous\n        \"target\": function( elem ) {\n            var hash = window.location && window.location.hash;\n            return hash && hash.slice( 1 ) === elem.id;\n        },\n\n        \"root\": function( elem ) {\n            return elem === docElem;\n        },\n\n        \"focus\": function( elem ) {\n            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n        },\n\n        // Boolean properties\n        \"enabled\": function( elem ) {\n            return elem.disabled === false;\n        },\n\n        \"disabled\": function( elem ) {\n            return elem.disabled === true;\n        },\n\n        \"checked\": function( elem ) {\n            // In CSS3, :checked should return both checked and selected elements\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n            var nodeName = elem.nodeName.toLowerCase();\n            return (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n        },\n\n        \"selected\": function( elem ) {\n            // Accessing this property makes selected-by-default\n            // options in Safari work properly\n            if ( elem.parentNode ) {\n                elem.parentNode.selectedIndex;\n            }\n\n            return elem.selected === true;\n        },\n\n        // Contents\n        \"empty\": function( elem ) {\n            // http://www.w3.org/TR/selectors/#empty-pseudo\n            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n            //   but not by others (comment: 8; processing instruction: 7; etc.)\n            // nodeType < 6 works because attributes (2) do not appear as children\n            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n                if ( elem.nodeType < 6 ) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        \"parent\": function( elem ) {\n            return !Expr.pseudos[\"empty\"]( elem );\n        },\n\n        // Element/input types\n        \"header\": function( elem ) {\n            return rheader.test( elem.nodeName );\n        },\n\n        \"input\": function( elem ) {\n            return rinputs.test( elem.nodeName );\n        },\n\n        \"button\": function( elem ) {\n            var name = elem.nodeName.toLowerCase();\n            return name === \"input\" && elem.type === \"button\" || name === \"button\";\n        },\n\n        \"text\": function( elem ) {\n            var attr;\n            return elem.nodeName.toLowerCase() === \"input\" &&\n                elem.type === \"text\" &&\n\n                // Support: IE<8\n                // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n                ( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n        },\n\n        // Position-in-collection\n        \"first\": createPositionalPseudo(function() {\n            return [ 0 ];\n        }),\n\n        \"last\": createPositionalPseudo(function( matchIndexes, length ) {\n            return [ length - 1 ];\n        }),\n\n        \"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n            return [ argument < 0 ? argument + length : argument ];\n        }),\n\n        \"even\": createPositionalPseudo(function( matchIndexes, length ) {\n            var i = 0;\n            for ( ; i < length; i += 2 ) {\n                matchIndexes.push( i );\n            }\n            return matchIndexes;\n        }),\n\n        \"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n            var i = 1;\n            for ( ; i < length; i += 2 ) {\n                matchIndexes.push( i );\n            }\n            return matchIndexes;\n        }),\n\n        \"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n            var i = argument < 0 ? argument + length : argument;\n            for ( ; --i >= 0; ) {\n                matchIndexes.push( i );\n            }\n            return matchIndexes;\n        }),\n\n        \"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n            var i = argument < 0 ? argument + length : argument;\n            for ( ; ++i < length; ) {\n                matchIndexes.push( i );\n            }\n            return matchIndexes;\n        })\n    }\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n    Expr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n    Expr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n    var matched, match, tokens, type,\n        soFar, groups, preFilters,\n        cached = tokenCache[ selector + \" \" ];\n\n    if ( cached ) {\n        return parseOnly ? 0 : cached.slice( 0 );\n    }\n\n    soFar = selector;\n    groups = [];\n    preFilters = Expr.preFilter;\n\n    while ( soFar ) {\n\n        // Comma and first run\n        if ( !matched || (match = rcomma.exec( soFar )) ) {\n            if ( match ) {\n                // Don't consume trailing commas as valid\n                soFar = soFar.slice( match[0].length ) || soFar;\n            }\n            groups.push( (tokens = []) );\n        }\n\n        matched = false;\n\n        // Combinators\n        if ( (match = rcombinators.exec( soFar )) ) {\n            matched = match.shift();\n            tokens.push({\n                value: matched,\n                // Cast descendant combinators to space\n                type: match[0].replace( rtrim, \" \" )\n            });\n            soFar = soFar.slice( matched.length );\n        }\n\n        // Filters\n        for ( type in Expr.filter ) {\n            if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n                (match = preFilters[ type ]( match ))) ) {\n                matched = match.shift();\n                tokens.push({\n                    value: matched,\n                    type: type,\n                    matches: match\n                });\n                soFar = soFar.slice( matched.length );\n            }\n        }\n\n        if ( !matched ) {\n            break;\n        }\n    }\n\n    // Return the length of the invalid excess\n    // if we're just parsing\n    // Otherwise, throw an error or return tokens\n    return parseOnly ?\n        soFar.length :\n        soFar ?\n            Sizzle.error( selector ) :\n            // Cache the tokens\n            tokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n    var i = 0,\n        len = tokens.length,\n        selector = \"\";\n    for ( ; i < len; i++ ) {\n        selector += tokens[i].value;\n    }\n    return selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n    var dir = combinator.dir,\n        checkNonElements = base && dir === \"parentNode\",\n        doneName = done++;\n\n    return combinator.first ?\n        // Check against closest ancestor/preceding element\n        function( elem, context, xml ) {\n            while ( (elem = elem[ dir ]) ) {\n                if ( elem.nodeType === 1 || checkNonElements ) {\n                    return matcher( elem, context, xml );\n                }\n            }\n        } :\n\n        // Check against all ancestor/preceding elements\n        function( elem, context, xml ) {\n            var oldCache, outerCache,\n                newCache = [ dirruns, doneName ];\n\n            // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n            if ( xml ) {\n                while ( (elem = elem[ dir ]) ) {\n                    if ( elem.nodeType === 1 || checkNonElements ) {\n                        if ( matcher( elem, context, xml ) ) {\n                            return true;\n                        }\n                    }\n                }\n            } else {\n                while ( (elem = elem[ dir ]) ) {\n                    if ( elem.nodeType === 1 || checkNonElements ) {\n                        outerCache = elem[ expando ] || (elem[ expando ] = {});\n                        if ( (oldCache = outerCache[ dir ]) &&\n                            oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n                            // Assign to newCache so results back-propagate to previous elements\n                            return (newCache[ 2 ] = oldCache[ 2 ]);\n                        } else {\n                            // Reuse newcache so results back-propagate to previous elements\n                            outerCache[ dir ] = newCache;\n\n                            // A match means we're done; a fail means we have to keep checking\n                            if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n}\n\nfunction elementMatcher( matchers ) {\n    return matchers.length > 1 ?\n        function( elem, context, xml ) {\n            var i = matchers.length;\n            while ( i-- ) {\n                if ( !matchers[i]( elem, context, xml ) ) {\n                    return false;\n                }\n            }\n            return true;\n        } :\n        matchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n    var i = 0,\n        len = contexts.length;\n    for ( ; i < len; i++ ) {\n        Sizzle( selector, contexts[i], results );\n    }\n    return results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n    var elem,\n        newUnmatched = [],\n        i = 0,\n        len = unmatched.length,\n        mapped = map != null;\n\n    for ( ; i < len; i++ ) {\n        if ( (elem = unmatched[i]) ) {\n            if ( !filter || filter( elem, context, xml ) ) {\n                newUnmatched.push( elem );\n                if ( mapped ) {\n                    map.push( i );\n                }\n            }\n        }\n    }\n\n    return newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n    if ( postFilter && !postFilter[ expando ] ) {\n        postFilter = setMatcher( postFilter );\n    }\n    if ( postFinder && !postFinder[ expando ] ) {\n        postFinder = setMatcher( postFinder, postSelector );\n    }\n    return markFunction(function( seed, results, context, xml ) {\n        var temp, i, elem,\n            preMap = [],\n            postMap = [],\n            preexisting = results.length,\n\n            // Get initial elements from seed or context\n            elems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\n            matcherIn = preFilter && ( seed || !selector ) ?\n                condense( elems, preMap, preFilter, context, xml ) :\n                elems,\n\n            matcherOut = matcher ?\n                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n                postFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n                    // ...intermediate processing is necessary\n                    [] :\n\n                    // ...otherwise use results directly\n                    results :\n                matcherIn;\n\n        // Find primary matches\n        if ( matcher ) {\n            matcher( matcherIn, matcherOut, context, xml );\n        }\n\n        // Apply postFilter\n        if ( postFilter ) {\n            temp = condense( matcherOut, postMap );\n            postFilter( temp, [], context, xml );\n\n            // Un-match failing elements by moving them back to matcherIn\n            i = temp.length;\n            while ( i-- ) {\n                if ( (elem = temp[i]) ) {\n                    matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n                }\n            }\n        }\n\n        if ( seed ) {\n            if ( postFinder || preFilter ) {\n                if ( postFinder ) {\n                    // Get the final matcherOut by condensing this intermediate into postFinder contexts\n                    temp = [];\n                    i = matcherOut.length;\n                    while ( i-- ) {\n                        if ( (elem = matcherOut[i]) ) {\n                            // Restore matcherIn since elem is not yet a final match\n                            temp.push( (matcherIn[i] = elem) );\n                        }\n                    }\n                    postFinder( null, (matcherOut = []), temp, xml );\n                }\n\n                // Move matched elements from seed to results to keep them synchronized\n                i = matcherOut.length;\n                while ( i-- ) {\n                    if ( (elem = matcherOut[i]) &&\n                        (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n                        seed[temp] = !(results[temp] = elem);\n                    }\n                }\n            }\n\n        // Add elements to results, through postFinder if defined\n        } else {\n            matcherOut = condense(\n                matcherOut === results ?\n                    matcherOut.splice( preexisting, matcherOut.length ) :\n                    matcherOut\n            );\n            if ( postFinder ) {\n                postFinder( null, results, matcherOut, xml );\n            } else {\n                push.apply( results, matcherOut );\n            }\n        }\n    });\n}\n\nfunction matcherFromTokens( tokens ) {\n    var checkContext, matcher, j,\n        len = tokens.length,\n        leadingRelative = Expr.relative[ tokens[0].type ],\n        implicitRelative = leadingRelative || Expr.relative[\" \"],\n        i = leadingRelative ? 1 : 0,\n\n        // The foundational matcher ensures that elements are reachable from top-level context(s)\n        matchContext = addCombinator( function( elem ) {\n            return elem === checkContext;\n        }, implicitRelative, true ),\n        matchAnyContext = addCombinator( function( elem ) {\n            return indexOf( checkContext, elem ) > -1;\n        }, implicitRelative, true ),\n        matchers = [ function( elem, context, xml ) {\n            var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n                (checkContext = context).nodeType ?\n                    matchContext( elem, context, xml ) :\n                    matchAnyContext( elem, context, xml ) );\n            // Avoid hanging onto element (issue #299)\n            checkContext = null;\n            return ret;\n        } ];\n\n    for ( ; i < len; i++ ) {\n        if ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n            matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n        } else {\n            matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n            // Return special upon seeing a positional matcher\n            if ( matcher[ expando ] ) {\n                // Find the next relative operator (if any) for proper handling\n                j = ++i;\n                for ( ; j < len; j++ ) {\n                    if ( Expr.relative[ tokens[j].type ] ) {\n                        break;\n                    }\n                }\n                return setMatcher(\n                    i > 1 && elementMatcher( matchers ),\n                    i > 1 && toSelector(\n                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n                        tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n                    ).replace( rtrim, \"$1\" ),\n                    matcher,\n                    i < j && matcherFromTokens( tokens.slice( i, j ) ),\n                    j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n                    j < len && toSelector( tokens )\n                );\n            }\n            matchers.push( matcher );\n        }\n    }\n\n    return elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n    var bySet = setMatchers.length > 0,\n        byElement = elementMatchers.length > 0,\n        superMatcher = function( seed, context, xml, results, outermost ) {\n            var elem, j, matcher,\n                matchedCount = 0,\n                i = \"0\",\n                unmatched = seed && [],\n                setMatched = [],\n                contextBackup = outermostContext,\n                // We must always have either seed elements or outermost context\n                elems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n                // Use integer dirruns iff this is the outermost matcher\n                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n                len = elems.length;\n\n            if ( outermost ) {\n                outermostContext = context !== document && context;\n            }\n\n            // Add elements passing elementMatchers directly to results\n            // Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n            // Support: IE<9, Safari\n            // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n            for ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n                if ( byElement && elem ) {\n                    j = 0;\n                    while ( (matcher = elementMatchers[j++]) ) {\n                        if ( matcher( elem, context, xml ) ) {\n                            results.push( elem );\n                            break;\n                        }\n                    }\n                    if ( outermost ) {\n                        dirruns = dirrunsUnique;\n                    }\n                }\n\n                // Track unmatched elements for set filters\n                if ( bySet ) {\n                    // They will have gone through all possible matchers\n                    if ( (elem = !matcher && elem) ) {\n                        matchedCount--;\n                    }\n\n                    // Lengthen the array for every element, matched or not\n                    if ( seed ) {\n                        unmatched.push( elem );\n                    }\n                }\n            }\n\n            // Apply set filters to unmatched elements\n            matchedCount += i;\n            if ( bySet && i !== matchedCount ) {\n                j = 0;\n                while ( (matcher = setMatchers[j++]) ) {\n                    matcher( unmatched, setMatched, context, xml );\n                }\n\n                if ( seed ) {\n                    // Reintegrate element matches to eliminate the need for sorting\n                    if ( matchedCount > 0 ) {\n                        while ( i-- ) {\n                            if ( !(unmatched[i] || setMatched[i]) ) {\n                                setMatched[i] = pop.call( results );\n                            }\n                        }\n                    }\n\n                    // Discard index placeholder values to get only actual matches\n                    setMatched = condense( setMatched );\n                }\n\n                // Add matches to results\n                push.apply( results, setMatched );\n\n                // Seedless set matches succeeding multiple successful matchers stipulate sorting\n                if ( outermost && !seed && setMatched.length > 0 &&\n                    ( matchedCount + setMatchers.length ) > 1 ) {\n\n                    Sizzle.uniqueSort( results );\n                }\n            }\n\n            // Override manipulation of globals by nested matchers\n            if ( outermost ) {\n                dirruns = dirrunsUnique;\n                outermostContext = contextBackup;\n            }\n\n            return unmatched;\n        };\n\n    return bySet ?\n        markFunction( superMatcher ) :\n        superMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n    var i,\n        setMatchers = [],\n        elementMatchers = [],\n        cached = compilerCache[ selector + \" \" ];\n\n    if ( !cached ) {\n        // Generate a function of recursive functions that can be used to check each element\n        if ( !match ) {\n            match = tokenize( selector );\n        }\n        i = match.length;\n        while ( i-- ) {\n            cached = matcherFromTokens( match[i] );\n            if ( cached[ expando ] ) {\n                setMatchers.push( cached );\n            } else {\n                elementMatchers.push( cached );\n            }\n        }\n\n        // Cache the compiled function\n        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n        // Save selector and tokenization\n        cached.selector = selector;\n    }\n    return cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n    var i, tokens, token, type, find,\n        compiled = typeof selector === \"function\" && selector,\n        match = !seed && tokenize( (selector = compiled.selector || selector) );\n\n    results = results || [];\n\n    // Try to minimize operations if there is no seed and only one group\n    if ( match.length === 1 ) {\n\n        // Take a shortcut and set the context if the root selector is an ID\n        tokens = match[0] = match[0].slice( 0 );\n        if ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n                support.getById && context.nodeType === 9 && documentIsHTML &&\n                Expr.relative[ tokens[1].type ] ) {\n\n            context = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n            if ( !context ) {\n                return results;\n\n            // Precompiled matchers will still verify ancestry, so step up a level\n            } else if ( compiled ) {\n                context = context.parentNode;\n            }\n\n            selector = selector.slice( tokens.shift().value.length );\n        }\n\n        // Fetch a seed set for right-to-left matching\n        i = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n        while ( i-- ) {\n            token = tokens[i];\n\n            // Abort if we hit a combinator\n            if ( Expr.relative[ (type = token.type) ] ) {\n                break;\n            }\n            if ( (find = Expr.find[ type ]) ) {\n                // Search, expanding context for leading sibling combinators\n                if ( (seed = find(\n                    token.matches[0].replace( runescape, funescape ),\n                    rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n                )) ) {\n\n                    // If seed is empty or no tokens remain, we can return early\n                    tokens.splice( i, 1 );\n                    selector = seed.length && toSelector( tokens );\n                    if ( !selector ) {\n                        push.apply( results, seed );\n                        return results;\n                    }\n\n                    break;\n                }\n            }\n        }\n    }\n\n    // Compile and execute a filtering function if one is not provided\n    // Provide `match` to avoid retokenization if we modified the selector above\n    ( compiled || compile( selector, match ) )(\n        seed,\n        context,\n        !documentIsHTML,\n        results,\n        rsibling.test( selector ) && testContext( context.parentNode ) || context\n    );\n    return results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n    // Should return 1, but returns 4 (following)\n    return div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n    div.innerHTML = \"<a href='#'></a>\";\n    return div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n    addHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n        if ( !isXML ) {\n            return elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n        }\n    });\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n    div.innerHTML = \"<input/>\";\n    div.firstChild.setAttribute( \"value\", \"\" );\n    return div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n    addHandle( \"value\", function( elem, name, isXML ) {\n        if ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n            return elem.defaultValue;\n        }\n    });\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n    return div.getAttribute(\"disabled\") == null;\n}) ) {\n    addHandle( booleans, function( elem, name, isXML ) {\n        var val;\n        if ( !isXML ) {\n            return elem[ name ] === true ? name.toLowerCase() :\n                    (val = elem.getAttributeNode( name )) && val.specified ?\n                    val.value :\n                null;\n        }\n    });\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n    if ( jQuery.isFunction( qualifier ) ) {\n        return jQuery.grep( elements, function( elem, i ) {\n            /* jshint -W018 */\n            return !!qualifier.call( elem, i, elem ) !== not;\n        });\n\n    }\n\n    if ( qualifier.nodeType ) {\n        return jQuery.grep( elements, function( elem ) {\n            return ( elem === qualifier ) !== not;\n        });\n\n    }\n\n    if ( typeof qualifier === \"string\" ) {\n        if ( risSimple.test( qualifier ) ) {\n            return jQuery.filter( qualifier, elements, not );\n        }\n\n        qualifier = jQuery.filter( qualifier, elements );\n    }\n\n    return jQuery.grep( elements, function( elem ) {\n        return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;\n    });\n}\n\njQuery.filter = function( expr, elems, not ) {\n    var elem = elems[ 0 ];\n\n    if ( not ) {\n        expr = \":not(\" + expr + \")\";\n    }\n\n    return elems.length === 1 && elem.nodeType === 1 ?\n        jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n        jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n            return elem.nodeType === 1;\n        }));\n};\n\njQuery.fn.extend({\n    find: function( selector ) {\n        var i,\n            ret = [],\n            self = this,\n            len = self.length;\n\n        if ( typeof selector !== \"string\" ) {\n            return this.pushStack( jQuery( selector ).filter(function() {\n                for ( i = 0; i < len; i++ ) {\n                    if ( jQuery.contains( self[ i ], this ) ) {\n                        return true;\n                    }\n                }\n            }) );\n        }\n\n        for ( i = 0; i < len; i++ ) {\n            jQuery.find( selector, self[ i ], ret );\n        }\n\n        // Needed because $( selector, context ) becomes $( context ).find( selector )\n        ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n        ret.selector = this.selector ? this.selector + \" \" + selector : selector;\n        return ret;\n    },\n    filter: function( selector ) {\n        return this.pushStack( winnow(this, selector || [], false) );\n    },\n    not: function( selector ) {\n        return this.pushStack( winnow(this, selector || [], true) );\n    },\n    is: function( selector ) {\n        return !!winnow(\n            this,\n\n            // If this is a positional/relative selector, check membership in the returned set\n            // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n            typeof selector === \"string\" && rneedsContext.test( selector ) ?\n                jQuery( selector ) :\n                selector || [],\n            false\n        ).length;\n    }\n});\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n    // Use the correct document accordingly with window argument (sandbox)\n    document = window.document,\n\n    // A simple way to check for HTML strings\n    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n    // Strict HTML recognition (#11290: must start with <)\n    rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n    init = jQuery.fn.init = function( selector, context ) {\n         \n        var match, elem;\n\n        // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n        if ( !selector ) {\n            return this;\n        }\n\n        // Handle HTML strings\n        if ( typeof selector === \"string\" ) {\n            if ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n                // Assume that strings that start and end with <> are HTML and skip the regex check\n                match = [ null, selector, null ];\n\n            } else {\n                match = rquickExpr.exec( selector );\n            }\n\n            // Match html or make sure no context is specified for #id\n            if ( match && (match[1] || !context) ) {\n\n                // HANDLE: $(html) -> $(array)\n                if ( match[1] ) {\n                    context = context instanceof jQuery ? context[0] : context;\n\n                    // scripts is true for back-compat\n                    // Intentionally let the error be thrown if parseHTML is not present\n                    jQuery.merge( this, jQuery.parseHTML(\n                        match[1],\n                        context && context.nodeType ? context.ownerDocument || context : document,\n                        true\n                    ) );\n\n                    // HANDLE: $(html, props)\n                    if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n                        for ( match in context ) {\n                            // Properties of context are called as methods if possible\n                            if ( jQuery.isFunction( this[ match ] ) ) {\n                                this[ match ]( context[ match ] );\n\n                            // ...and otherwise set as attributes\n                            } else {\n                                this.attr( match, context[ match ] );\n                            }\n                        }\n                    }\n\n                    return this;\n\n                // HANDLE: $(#id)\n                } else {\n                    elem = document.getElementById( match[2] );\n\n                    // Check parentNode to catch when Blackberry 4.6 returns\n                    // nodes that are no longer in the document #6963\n                    if ( elem && elem.parentNode ) {\n                        // Handle the case where IE and Opera return items\n                        // by name instead of ID\n                        if ( elem.id !== match[2] ) {\n                            return rootjQuery.find( selector );\n                        }\n\n                        // Otherwise, we inject the element directly into the jQuery object\n                        this.length = 1;\n                        this[0] = elem;\n                    }\n\n                    this.context = document;\n                    this.selector = selector;\n                    return this;\n                }\n\n            // HANDLE: $(expr, $(...))\n            } else if ( !context || context.jquery ) {\n                return ( context || rootjQuery ).find( selector );\n\n            // HANDLE: $(expr, context)\n            // (which is just equivalent to: $(context).find(expr)\n            } else {\n                return this.constructor( context ).find( selector );\n            }\n\n        // HANDLE: $(DOMElement)\n        } else if ( selector.nodeType ) {\n            this.context = this[0] = selector;\n            this.length = 1;\n            return this;\n\n        // HANDLE: $(function)\n        // Shortcut for document ready\n        } else if ( jQuery.isFunction( selector ) ) {\n            return typeof rootjQuery.ready !== \"undefined\" ?\n                rootjQuery.ready( selector ) :\n                // Execute immediately if ready is not present\n                selector( jQuery );\n        }\n\n        if ( selector.selector !== undefined ) {\n            this.selector = selector.selector;\n            this.context = selector.context;\n        }\n\n        return jQuery.makeArray( selector, this );\n    };\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n    // methods guaranteed to produce a unique set when starting from a unique set\n    guaranteedUnique = {\n        children: true,\n        contents: true,\n        next: true,\n        prev: true\n    };\n\njQuery.extend({\n    dir: function( elem, dir, until ) {\n        var matched = [],\n            cur = elem[ dir ];\n\n        while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {\n            if ( cur.nodeType === 1 ) {\n                matched.push( cur );\n            }\n            cur = cur[dir];\n        }\n        return matched;\n    },\n\n    sibling: function( n, elem ) {\n        var r = [];\n\n        for ( ; n; n = n.nextSibling ) {\n            if ( n.nodeType === 1 && n !== elem ) {\n                r.push( n );\n            }\n        }\n\n        return r;\n    }\n});\n\njQuery.fn.extend({\n    has: function( target ) {\n        var i,\n            targets = jQuery( target, this ),\n            len = targets.length;\n\n        return this.filter(function() {\n            for ( i = 0; i < len; i++ ) {\n                if ( jQuery.contains( this, targets[i] ) ) {\n                    return true;\n                }\n            }\n        });\n    },\n\n    closest: function( selectors, context ) {\n        var cur,\n            i = 0,\n            l = this.length,\n            matched = [],\n            pos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n                jQuery( selectors, context || this.context ) :\n                0;\n\n        for ( ; i < l; i++ ) {\n            for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n                // Always skip document fragments\n                if ( cur.nodeType < 11 && (pos ?\n                    pos.index(cur) > -1 :\n\n                    // Don't pass non-elements to Sizzle\n                    cur.nodeType === 1 &&\n                        jQuery.find.matchesSelector(cur, selectors)) ) {\n\n                    matched.push( cur );\n                    break;\n                }\n            }\n        }\n\n        return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n    },\n\n    // Determine the position of an element within\n    // the matched set of elements\n    index: function( elem ) {\n\n        // No argument, return index in parent\n        if ( !elem ) {\n            return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;\n        }\n\n        // index in selector\n        if ( typeof elem === \"string\" ) {\n            return jQuery.inArray( this[0], jQuery( elem ) );\n        }\n\n        // Locate the position of the desired element\n        return jQuery.inArray(\n            // If it receives a jQuery object, the first element is used\n            elem.jquery ? elem[0] : elem, this );\n    },\n\n    add: function( selector, context ) {\n        return this.pushStack(\n            jQuery.unique(\n                jQuery.merge( this.get(), jQuery( selector, context ) )\n            )\n        );\n    },\n\n    addBack: function( selector ) {\n        return this.add( selector == null ?\n            this.prevObject : this.prevObject.filter(selector)\n        );\n    }\n});\n\nfunction sibling( cur, dir ) {\n    do {\n        cur = cur[ dir ];\n    } while ( cur && cur.nodeType !== 1 );\n\n    return cur;\n}\n\njQuery.each({\n    parent: function( elem ) {\n        var parent = elem.parentNode;\n        return parent && parent.nodeType !== 11 ? parent : null;\n    },\n    parents: function( elem ) {\n        return jQuery.dir( elem, \"parentNode\" );\n    },\n    parentsUntil: function( elem, i, until ) {\n        return jQuery.dir( elem, \"parentNode\", until );\n    },\n    next: function( elem ) {\n        return sibling( elem, \"nextSibling\" );\n    },\n    prev: function( elem ) {\n        return sibling( elem, \"previousSibling\" );\n    },\n    nextAll: function( elem ) {\n        return jQuery.dir( elem, \"nextSibling\" );\n    },\n    prevAll: function( elem ) {\n        return jQuery.dir( elem, \"previousSibling\" );\n    },\n    nextUntil: function( elem, i, until ) {\n        return jQuery.dir( elem, \"nextSibling\", until );\n    },\n    prevUntil: function( elem, i, until ) {\n        return jQuery.dir( elem, \"previousSibling\", until );\n    },\n    siblings: function( elem ) {\n        return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n    },\n    children: function( elem ) {\n        return jQuery.sibling( elem.firstChild );\n    },\n    contents: function( elem ) {\n        return jQuery.nodeName( elem, \"iframe\" ) ?\n            elem.contentDocument || elem.contentWindow.document :\n            jQuery.merge( [], elem.childNodes );\n    }\n}, function( name, fn ) {\n    jQuery.fn[ name ] = function( until, selector ) {\n        var ret = jQuery.map( this, fn, until );\n\n        if ( name.slice( -5 ) !== \"Until\" ) {\n            selector = until;\n        }\n\n        if ( selector && typeof selector === \"string\" ) {\n            ret = jQuery.filter( selector, ret );\n        }\n\n        if ( this.length > 1 ) {\n            // Remove duplicates\n            if ( !guaranteedUnique[ name ] ) {\n                ret = jQuery.unique( ret );\n            }\n\n            // Reverse order for parents* and prev-derivatives\n            if ( rparentsprev.test( name ) ) {\n                ret = ret.reverse();\n            }\n        }\n\n        return this.pushStack( ret );\n    };\n});\nvar rnotwhite = (/\\S+/g);\n\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n    var object = optionsCache[ options ] = {};\n    jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n        object[ flag ] = true;\n    });\n    return object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *    options: an optional list of space-separated options that will change how\n *            the callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *    once:            will ensure the callback list can only be fired once (like a Deferred)\n *\n *    memory:            will keep track of previous values and will call any callback added\n *                    after the list has been fired right away with the latest \"memorized\"\n *                    values (like a Deferred)\n *\n *    unique:            will ensure a callback can only be added once (no duplicate in the list)\n *\n *    stopOnFalse:    interrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ?\n        ( optionsCache[ options ] || createOptions( options ) ) :\n        jQuery.extend( {}, options );\n\n    var // Flag to know if list is currently firing\n        firing,\n        // Last fire value (for non-forgettable lists)\n        memory,\n        // Flag to know if list was already fired\n        fired,\n        // End of the loop when firing\n        firingLength,\n        // Index of currently firing callback (modified by remove if needed)\n        firingIndex,\n        // First callback to fire (used internally by add and fireWith)\n        firingStart,\n        // Actual callback list\n        list = [],\n        // Stack of fire calls for repeatable lists\n        stack = !options.once && [],\n        // Fire callbacks\n        fire = function( data ) {\n            memory = options.memory && data;\n            fired = true;\n            firingIndex = firingStart || 0;\n            firingStart = 0;\n            firingLength = list.length;\n            firing = true;\n            for ( ; list && firingIndex < firingLength; firingIndex++ ) {\n                if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n                    memory = false; // To prevent further calls using add\n                    break;\n                }\n            }\n            firing = false;\n            if ( list ) {\n                if ( stack ) {\n                    if ( stack.length ) {\n                        fire( stack.shift() );\n                    }\n                } else if ( memory ) {\n                    list = [];\n                } else {\n                    self.disable();\n                }\n            }\n        },\n        // Actual Callbacks object\n        self = {\n            // Add a callback or a collection of callbacks to the list\n            add: function() {\n                if ( list ) {\n                    // First, we save the current length\n                    var start = list.length;\n                    (function add( args ) {\n                        jQuery.each( args, function( _, arg ) {\n                            var type = jQuery.type( arg );\n                            if ( type === \"function\" ) {\n                                if ( !options.unique || !self.has( arg ) ) {\n                                    list.push( arg );\n                                }\n                            } else if ( arg && arg.length && type !== \"string\" ) {\n                                // Inspect recursively\n                                add( arg );\n                            }\n                        });\n                    })( arguments );\n                    // Do we need to add the callbacks to the\n                    // current firing batch?\n                    if ( firing ) {\n                        firingLength = list.length;\n                    // With memory, if we're not firing then\n                    // we should call right away\n                    } else if ( memory ) {\n                        firingStart = start;\n                        fire( memory );\n                    }\n                }\n                return this;\n            },\n            // Remove a callback from the list\n            remove: function() {\n                if ( list ) {\n                    jQuery.each( arguments, function( _, arg ) {\n                        var index;\n                        while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n                            list.splice( index, 1 );\n                            // Handle firing indexes\n                            if ( firing ) {\n                                if ( index <= firingLength ) {\n                                    firingLength--;\n                                }\n                                if ( index <= firingIndex ) {\n                                    firingIndex--;\n                                }\n                            }\n                        }\n                    });\n                }\n                return this;\n            },\n            // Check if a given callback is in the list.\n            // If no argument is given, return whether or not list has callbacks attached.\n            has: function( fn ) {\n                return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n            },\n            // Remove all callbacks from the list\n            empty: function() {\n                list = [];\n                firingLength = 0;\n                return this;\n            },\n            // Have the list do nothing anymore\n            disable: function() {\n                list = stack = memory = undefined;\n                return this;\n            },\n            // Is it disabled?\n            disabled: function() {\n                return !list;\n            },\n            // Lock the list in its current state\n            lock: function() {\n                stack = undefined;\n                if ( !memory ) {\n                    self.disable();\n                }\n                return this;\n            },\n            // Is it locked?\n            locked: function() {\n                return !stack;\n            },\n            // Call all callbacks with the given context and arguments\n            fireWith: function( context, args ) {\n                if ( list && ( !fired || stack ) ) {\n                    args = args || [];\n                    args = [ context, args.slice ? args.slice() : args ];\n                    if ( firing ) {\n                        stack.push( args );\n                    } else {\n                        fire( args );\n                    }\n                }\n                return this;\n            },\n            // Call all the callbacks with the given arguments\n            fire: function() {\n                self.fireWith( this, arguments );\n                return this;\n            },\n            // To know if the callbacks have already been called at least once\n            fired: function() {\n                return !!fired;\n            }\n        };\n\n    return self;\n};\n\n\njQuery.extend({\n\n    Deferred: function( func ) {\n        var tuples = [\n                // action, add listener, listener list, final state\n                [ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n                [ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n                [ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n            ],\n            state = \"pending\",\n            promise = {\n                state: function() {\n                    return state;\n                },\n                always: function() {\n                    deferred.done( arguments ).fail( arguments );\n                    return this;\n                },\n                then: function( /* fnDone, fnFail, fnProgress */ ) {\n                    var fns = arguments;\n                    return jQuery.Deferred(function( newDefer ) {\n                        jQuery.each( tuples, function( i, tuple ) {\n                            var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n                            // deferred[ done | fail | progress ] for forwarding actions to newDefer\n                            deferred[ tuple[1] ](function() {\n                                var returned = fn && fn.apply( this, arguments );\n                                if ( returned && jQuery.isFunction( returned.promise ) ) {\n                                    returned.promise()\n                                        .done( newDefer.resolve )\n                                        .fail( newDefer.reject )\n                                        .progress( newDefer.notify );\n                                } else {\n                                    newDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n                                }\n                            });\n                        });\n                        fns = null;\n                    }).promise();\n                },\n                // Get a promise for this deferred\n                // If obj is provided, the promise aspect is added to the object\n                promise: function( obj ) {\n                    return obj != null ? jQuery.extend( obj, promise ) : promise;\n                }\n            },\n            deferred = {};\n\n        // Keep pipe for back-compat\n        promise.pipe = promise.then;\n\n        // Add list-specific methods\n        jQuery.each( tuples, function( i, tuple ) {\n            var list = tuple[ 2 ],\n                stateString = tuple[ 3 ];\n\n            // promise[ done | fail | progress ] = list.add\n            promise[ tuple[1] ] = list.add;\n\n            // Handle state\n            if ( stateString ) {\n                list.add(function() {\n                    // state = [ resolved | rejected ]\n                    state = stateString;\n\n                // [ reject_list | resolve_list ].disable; progress_list.lock\n                }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n            }\n\n            // deferred[ resolve | reject | notify ]\n            deferred[ tuple[0] ] = function() {\n                deferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n                return this;\n            };\n            deferred[ tuple[0] + \"With\" ] = list.fireWith;\n        });\n\n        // Make the deferred a promise\n        promise.promise( deferred );\n\n        // Call given func if any\n        if ( func ) {\n            func.call( deferred, deferred );\n        }\n\n        // All done!\n        return deferred;\n    },\n\n    // Deferred helper\n    when: function( subordinate /* , ..., subordinateN */ ) {\n        var i = 0,\n            resolveValues = slice.call( arguments ),\n            length = resolveValues.length,\n\n            // the count of uncompleted subordinates\n            remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n            // Update function for both resolve and progress values\n            updateFunc = function( i, contexts, values ) {\n                return function( value ) {\n                    contexts[ i ] = this;\n                    values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n                    if ( values === progressValues ) {\n                        deferred.notifyWith( contexts, values );\n\n                    } else if ( !(--remaining) ) {\n                        deferred.resolveWith( contexts, values );\n                    }\n                };\n            },\n\n            progressValues, progressContexts, resolveContexts;\n\n        // add listeners to Deferred subordinates; treat others as resolved\n        if ( length > 1 ) {\n            progressValues = new Array( length );\n            progressContexts = new Array( length );\n            resolveContexts = new Array( length );\n            for ( ; i < length; i++ ) {\n                if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n                    resolveValues[ i ].promise()\n                        .done( updateFunc( i, resolveContexts, resolveValues ) )\n                        .fail( deferred.reject )\n                        .progress( updateFunc( i, progressContexts, progressValues ) );\n                } else {\n                    --remaining;\n                }\n            }\n        }\n\n        // if we're not waiting on anything, resolve the master\n        if ( !remaining ) {\n            deferred.resolveWith( resolveContexts, resolveValues );\n        }\n\n        return deferred.promise();\n    }\n});\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n    // Add the callback\n    jQuery.ready.promise().done( fn );\n\n    return this;\n};\n\njQuery.extend({\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n\n    // Hold (or release) the ready event\n    holdReady: function( hold ) {\n        if ( hold ) {\n            jQuery.readyWait++;\n        } else {\n            jQuery.ready( true );\n        }\n    },\n\n    // Handle when the DOM is ready\n    ready: function( wait ) {\n\n        // Abort if there are pending holds or we're already ready\n        if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n            return;\n        }\n\n        // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n        if ( !document.body ) {\n            return setTimeout( jQuery.ready );\n        }\n\n        // Remember that the DOM is ready\n        jQuery.isReady = true;\n\n        // If a normal DOM Ready event fired, decrement, and wait if need be\n        if ( wait !== true && --jQuery.readyWait > 0 ) {\n            return;\n        }\n\n        // If there are functions bound, to execute\n        readyList.resolveWith( document, [ jQuery ] );\n\n        // Trigger any bound ready events\n        if ( jQuery.fn.triggerHandler ) {\n            jQuery( document ).triggerHandler( \"ready\" );\n            jQuery( document ).off( \"ready\" );\n        }\n    }\n});\n\n/**\n * Clean-up method for dom ready events\n */\nfunction detach() {\n    if ( document.addEventListener ) {\n        document.removeEventListener( \"DOMContentLoaded\", completed, false );\n        window.removeEventListener( \"load\", completed, false );\n\n    } else {\n        document.detachEvent( \"onreadystatechange\", completed );\n        window.detachEvent( \"onload\", completed );\n    }\n}\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n    // readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n    if ( document.addEventListener || event.type === \"load\" || document.readyState === \"complete\" ) {\n        detach();\n        jQuery.ready();\n    }\n}\n\njQuery.ready.promise = function( obj ) {\n    if ( !readyList ) {\n\n        readyList = jQuery.Deferred();\n\n        // Catch cases where $(document).ready() is called after the browser event has already occurred.\n        // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n        if ( document.readyState === \"complete\" ) {\n            // Handle it asynchronously to allow scripts the opportunity to delay ready\n            setTimeout( jQuery.ready );\n\n        // Standards-based browsers support DOMContentLoaded\n        } else if ( document.addEventListener ) {\n            // Use the handy event callback\n            document.addEventListener( \"DOMContentLoaded\", completed, false );\n\n            // A fallback to window.onload, that will always work\n            window.addEventListener( \"load\", completed, false );\n\n        // If IE event model is used\n        } else {\n            // Ensure firing before onload, maybe late but safe also for iframes\n            document.attachEvent( \"onreadystatechange\", completed );\n\n            // A fallback to window.onload, that will always work\n            window.attachEvent( \"onload\", completed );\n\n            // If IE and not a frame\n            // continually check to see if the document is ready\n            var top = false;\n\n            try {\n                top = window.frameElement == null && document.documentElement;\n            } catch(e) {}\n\n            if ( top && top.doScroll ) {\n                (function doScrollCheck() {\n                    if ( !jQuery.isReady ) {\n\n                        try {\n                            // Use the trick by Diego Perini\n                            // http://javascript.nwbox.com/IEContentLoaded/\n                            top.doScroll(\"left\");\n                        } catch(e) {\n                            return setTimeout( doScrollCheck, 50 );\n                        }\n\n                        // detach all dom ready events\n                        detach();\n\n                        // and execute any waiting functions\n                        jQuery.ready();\n                    }\n                })();\n            }\n        }\n    }\n    return readyList.promise( obj );\n};\n\n\nvar strundefined = typeof undefined;\n\n\n\n// Support: IE<9\n// Iteration over object's inherited properties before its own\nvar i;\nfor ( i in jQuery( support ) ) {\n    break;\n}\nsupport.ownLast = i !== \"0\";\n\n// Note: most support tests are defined in their respective modules.\n// false until the test is run\nsupport.inlineBlockNeedsLayout = false;\n\n// Execute ASAP in case we need to set body.style.zoom\njQuery(function() {\n    // Minified: var a,b,c,d\n    var val, div, body, container;\n\n    body = document.getElementsByTagName( \"body\" )[ 0 ];\n    if ( !body || !body.style ) {\n        // Return for frameset docs that don't have a body\n        return;\n    }\n\n    // Setup\n    div = document.createElement( \"div\" );\n    container = document.createElement( \"div\" );\n    container.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n    body.appendChild( container ).appendChild( div );\n\n    if ( typeof div.style.zoom !== strundefined ) {\n        // Support: IE<8\n        // Check if natively block-level elements act like inline-block\n        // elements when setting their display to 'inline' and giving\n        // them layout\n        div.style.cssText = \"display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1\";\n\n        support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;\n        if ( val ) {\n            // Prevent IE 6 from affecting layout for positioned elements #11048\n            // Prevent IE from shrinking the body in IE 7 mode #12869\n            // Support: IE<8\n            body.style.zoom = 1;\n        }\n    }\n\n    body.removeChild( container );\n});\n\n\n\n\n(function() {\n    var div = document.createElement( \"div\" );\n\n    // Execute the test only if not already executed in another module.\n    if (support.deleteExpando == null) {\n        // Support: IE<9\n        support.deleteExpando = true;\n        try {\n            delete div.test;\n        } catch( e ) {\n            support.deleteExpando = false;\n        }\n    }\n\n    // Null elements to avoid leaks in IE.\n    div = null;\n})();\n\n\n/**\n * Determines whether an object can have data\n */\njQuery.acceptData = function( elem ) {\n    var noData = jQuery.noData[ (elem.nodeName + \" \").toLowerCase() ],\n        nodeType = +elem.nodeType || 1;\n\n    // Do not set data on non-element DOM nodes because it will not be cleared (#8335).\n    return nodeType !== 1 && nodeType !== 9 ?\n        false :\n\n        // Nodes accept data unless otherwise specified; rejection can be conditional\n        !noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n};\n\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n    rmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n    // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n    if ( data === undefined && elem.nodeType === 1 ) {\n\n        var name = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\n        data = elem.getAttribute( name );\n\n        if ( typeof data === \"string\" ) {\n            try {\n                data = data === \"true\" ? true :\n                    data === \"false\" ? false :\n                    data === \"null\" ? null :\n                    // Only convert to a number if it doesn't change the string\n                    +data + \"\" === data ? +data :\n                    rbrace.test( data ) ? jQuery.parseJSON( data ) :\n                    data;\n            } catch( e ) {}\n\n            // Make sure we set the data so it isn't changed later\n            jQuery.data( elem, key, data );\n\n        } else {\n            data = undefined;\n        }\n    }\n\n    return data;\n}\n\n// checks a cache object for emptiness\nfunction isEmptyDataObject( obj ) {\n    var name;\n    for ( name in obj ) {\n\n        // if the public data object is empty, the private is still empty\n        if ( name === \"data\" && jQuery.isEmptyObject( obj[name] ) ) {\n            continue;\n        }\n        if ( name !== \"toJSON\" ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction internalData( elem, name, data, pvt /* Internal Use Only */ ) {\n    if ( !jQuery.acceptData( elem ) ) {\n        return;\n    }\n\n    var ret, thisCache,\n        internalKey = jQuery.expando,\n\n        // We have to handle DOM nodes and JS objects differently because IE6-7\n        // can't GC object references properly across the DOM-JS boundary\n        isNode = elem.nodeType,\n\n        // Only DOM nodes need the global jQuery cache; JS object data is\n        // attached directly to the object so GC can occur automatically\n        cache = isNode ? jQuery.cache : elem,\n\n        // Only defining an ID for JS objects if its cache already exists allows\n        // the code to shortcut on the same path as a DOM node with no cache\n        id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;\n\n    // Avoid doing any more work than we need to when trying to get data on an\n    // object that has no data at all\n    if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === \"string\" ) {\n        return;\n    }\n\n    if ( !id ) {\n        // Only DOM nodes need a new unique ID for each element since their data\n        // ends up in the global cache\n        if ( isNode ) {\n            id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;\n        } else {\n            id = internalKey;\n        }\n    }\n\n    if ( !cache[ id ] ) {\n        // Avoid exposing jQuery metadata on plain JS objects when the object\n        // is serialized using JSON.stringify\n        cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };\n    }\n\n    // An object can be passed to jQuery.data instead of a key/value pair; this gets\n    // shallow copied over onto the existing cache\n    if ( typeof name === \"object\" || typeof name === \"function\" ) {\n        if ( pvt ) {\n            cache[ id ] = jQuery.extend( cache[ id ], name );\n        } else {\n            cache[ id ].data = jQuery.extend( cache[ id ].data, name );\n        }\n    }\n\n    thisCache = cache[ id ];\n\n    // jQuery data() is stored in a separate object inside the object's internal data\n    // cache in order to avoid key collisions between internal data and user-defined\n    // data.\n    if ( !pvt ) {\n        if ( !thisCache.data ) {\n            thisCache.data = {};\n        }\n\n        thisCache = thisCache.data;\n    }\n\n    if ( data !== undefined ) {\n        thisCache[ jQuery.camelCase( name ) ] = data;\n    }\n\n    // Check for both converted-to-camel and non-converted data property names\n    // If a data property was specified\n    if ( typeof name === \"string\" ) {\n\n        // First Try to find as-is property data\n        ret = thisCache[ name ];\n\n        // Test for null|undefined property data\n        if ( ret == null ) {\n\n            // Try to find the camelCased property\n            ret = thisCache[ jQuery.camelCase( name ) ];\n        }\n    } else {\n        ret = thisCache;\n    }\n\n    return ret;\n}\n\nfunction internalRemoveData( elem, name, pvt ) {\n    if ( !jQuery.acceptData( elem ) ) {\n        return;\n    }\n\n    var thisCache, i,\n        isNode = elem.nodeType,\n\n        // See jQuery.data for more information\n        cache = isNode ? jQuery.cache : elem,\n        id = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\n    // If there is already no cache entry for this object, there is no\n    // purpose in continuing\n    if ( !cache[ id ] ) {\n        return;\n    }\n\n    if ( name ) {\n\n        thisCache = pvt ? cache[ id ] : cache[ id ].data;\n\n        if ( thisCache ) {\n\n            // Support array or space separated string names for data keys\n            if ( !jQuery.isArray( name ) ) {\n\n                // try the string as a key before any manipulation\n                if ( name in thisCache ) {\n                    name = [ name ];\n                } else {\n\n                    // split the camel cased version by spaces unless a key with the spaces exists\n                    name = jQuery.camelCase( name );\n                    if ( name in thisCache ) {\n                        name = [ name ];\n                    } else {\n                        name = name.split(\" \");\n                    }\n                }\n            } else {\n                // If \"name\" is an array of keys...\n                // When data is initially created, via (\"key\", \"val\") signature,\n                // keys will be converted to camelCase.\n                // Since there is no way to tell _how_ a key was added, remove\n                // both plain key and camelCase key. #12786\n                // This will only penalize the array argument path.\n                name = name.concat( jQuery.map( name, jQuery.camelCase ) );\n            }\n\n            i = name.length;\n            while ( i-- ) {\n                delete thisCache[ name[i] ];\n            }\n\n            // If there is no data left in the cache, we want to continue\n            // and let the cache object itself get destroyed\n            if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {\n                return;\n            }\n        }\n    }\n\n    // See jQuery.data for more information\n    if ( !pvt ) {\n        delete cache[ id ].data;\n\n        // Don't destroy the parent cache unless the internal data object\n        // had been the only thing left in it\n        if ( !isEmptyDataObject( cache[ id ] ) ) {\n            return;\n        }\n    }\n\n    // Destroy the cache\n    if ( isNode ) {\n        jQuery.cleanData( [ elem ], true );\n\n    // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n    /* jshint eqeqeq: false */\n    } else if ( support.deleteExpando || cache != cache.window ) {\n        /* jshint eqeqeq: true */\n        delete cache[ id ];\n\n    // When all else fails, null\n    } else {\n        cache[ id ] = null;\n    }\n}\n\njQuery.extend({\n    cache: {},\n\n    // The following elements (space-suffixed to avoid Object.prototype collisions)\n    // throw uncatchable exceptions if you attempt to set expando properties\n    noData: {\n        \"applet \": true,\n        \"embed \": true,\n        // ...but Flash objects (which have this classid) *can* handle expandos\n        \"object \": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"\n    },\n\n    hasData: function( elem ) {\n        elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];\n        return !!elem && !isEmptyDataObject( elem );\n    },\n\n    data: function( elem, name, data ) {\n        return internalData( elem, name, data );\n    },\n\n    removeData: function( elem, name ) {\n        return internalRemoveData( elem, name );\n    },\n\n    // For internal use only.\n    _data: function( elem, name, data ) {\n        return internalData( elem, name, data, true );\n    },\n\n    _removeData: function( elem, name ) {\n        return internalRemoveData( elem, name, true );\n    }\n});\n\njQuery.fn.extend({\n    data: function( key, value ) {\n        var i, name, data,\n            elem = this[0],\n            attrs = elem && elem.attributes;\n\n        // Special expections of .data basically thwart jQuery.access,\n        // so implement the relevant behavior ourselves\n\n        // Gets all values\n        if ( key === undefined ) {\n            if ( this.length ) {\n                data = jQuery.data( elem );\n\n                if ( elem.nodeType === 1 && !jQuery._data( elem, \"parsedAttrs\" ) ) {\n                    i = attrs.length;\n                    while ( i-- ) {\n\n                        // Support: IE11+\n                        // The attrs elements can be null (#14894)\n                        if ( attrs[ i ] ) {\n                            name = attrs[ i ].name;\n                            if ( name.indexOf( \"data-\" ) === 0 ) {\n                                name = jQuery.camelCase( name.slice(5) );\n                                dataAttr( elem, name, data[ name ] );\n                            }\n                        }\n                    }\n                    jQuery._data( elem, \"parsedAttrs\", true );\n                }\n            }\n\n            return data;\n        }\n\n        // Sets multiple values\n        if ( typeof key === \"object\" ) {\n            return this.each(function() {\n                jQuery.data( this, key );\n            });\n        }\n\n        return arguments.length > 1 ?\n\n            // Sets one value\n            this.each(function() {\n                jQuery.data( this, key, value );\n            }) :\n\n            // Gets one value\n            // Try to fetch any internally stored data first\n            elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;\n    },\n\n    removeData: function( key ) {\n        return this.each(function() {\n            jQuery.removeData( this, key );\n        });\n    }\n});\n\n\njQuery.extend({\n    queue: function( elem, type, data ) {\n        var queue;\n\n        if ( elem ) {\n            type = ( type || \"fx\" ) + \"queue\";\n            queue = jQuery._data( elem, type );\n\n            // Speed up dequeue by getting out quickly if this is just a lookup\n            if ( data ) {\n                if ( !queue || jQuery.isArray(data) ) {\n                    queue = jQuery._data( elem, type, jQuery.makeArray(data) );\n                } else {\n                    queue.push( data );\n                }\n            }\n            return queue || [];\n        }\n    },\n\n    dequeue: function( elem, type ) {\n        type = type || \"fx\";\n\n        var queue = jQuery.queue( elem, type ),\n            startLength = queue.length,\n            fn = queue.shift(),\n            hooks = jQuery._queueHooks( elem, type ),\n            next = function() {\n                jQuery.dequeue( elem, type );\n            };\n\n        // If the fx queue is dequeued, always remove the progress sentinel\n        if ( fn === \"inprogress\" ) {\n            fn = queue.shift();\n            startLength--;\n        }\n\n        if ( fn ) {\n\n            // Add a progress sentinel to prevent the fx queue from being\n            // automatically dequeued\n            if ( type === \"fx\" ) {\n                queue.unshift( \"inprogress\" );\n            }\n\n            // clear up the last queue stop function\n            delete hooks.stop;\n            fn.call( elem, next, hooks );\n        }\n\n        if ( !startLength && hooks ) {\n            hooks.empty.fire();\n        }\n    },\n\n    // not intended for public consumption - generates a queueHooks object, or returns the current one\n    _queueHooks: function( elem, type ) {\n        var key = type + \"queueHooks\";\n        return jQuery._data( elem, key ) || jQuery._data( elem, key, {\n            empty: jQuery.Callbacks(\"once memory\").add(function() {\n                jQuery._removeData( elem, type + \"queue\" );\n                jQuery._removeData( elem, key );\n            })\n        });\n    }\n});\n\njQuery.fn.extend({\n    queue: function( type, data ) {\n        var setter = 2;\n\n        if ( typeof type !== \"string\" ) {\n            data = type;\n            type = \"fx\";\n            setter--;\n        }\n\n        if ( arguments.length < setter ) {\n            return jQuery.queue( this[0], type );\n        }\n\n        return data === undefined ?\n            this :\n            this.each(function() {\n                var queue = jQuery.queue( this, type, data );\n\n                // ensure a hooks for this queue\n                jQuery._queueHooks( this, type );\n\n                if ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n                    jQuery.dequeue( this, type );\n                }\n            });\n    },\n    dequeue: function( type ) {\n        return this.each(function() {\n            jQuery.dequeue( this, type );\n        });\n    },\n    clearQueue: function( type ) {\n        return this.queue( type || \"fx\", [] );\n    },\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function( type, obj ) {\n        var tmp,\n            count = 1,\n            defer = jQuery.Deferred(),\n            elements = this,\n            i = this.length,\n            resolve = function() {\n                if ( !( --count ) ) {\n                    defer.resolveWith( elements, [ elements ] );\n                }\n            };\n\n        if ( typeof type !== \"string\" ) {\n            obj = type;\n            type = undefined;\n        }\n        type = type || \"fx\";\n\n        while ( i-- ) {\n            tmp = jQuery._data( elements[ i ], type + \"queueHooks\" );\n            if ( tmp && tmp.empty ) {\n                count++;\n                tmp.empty.add( resolve );\n            }\n        }\n        resolve();\n        return defer.promise( obj );\n    }\n});\nvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHidden = function( elem, el ) {\n        // isHidden might be called from jQuery#filter function;\n        // in that case, element will be second argument\n        elem = el || elem;\n        return jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n    };\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n    var i = 0,\n        length = elems.length,\n        bulk = key == null;\n\n    // Sets many values\n    if ( jQuery.type( key ) === \"object\" ) {\n        chainable = true;\n        for ( i in key ) {\n            jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n        }\n\n    // Sets one value\n    } else if ( value !== undefined ) {\n        chainable = true;\n\n        if ( !jQuery.isFunction( value ) ) {\n            raw = true;\n        }\n\n        if ( bulk ) {\n            // Bulk operations run against the entire set\n            if ( raw ) {\n                fn.call( elems, value );\n                fn = null;\n\n            // ...except when executing function values\n            } else {\n                bulk = fn;\n                fn = function( elem, key, value ) {\n                    return bulk.call( jQuery( elem ), value );\n                };\n            }\n        }\n\n        if ( fn ) {\n            for ( ; i < length; i++ ) {\n                fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n            }\n        }\n    }\n\n    return chainable ?\n        elems :\n\n        // Gets\n        bulk ?\n            fn.call( elems ) :\n            length ? fn( elems[0], key ) : emptyGet;\n};\nvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n(function() {\n    // Minified: var a,b,c\n    var input = document.createElement( \"input\" ),\n        div = document.createElement( \"div\" ),\n        fragment = document.createDocumentFragment();\n\n    // Setup\n    div.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\n    // IE strips leading whitespace when .innerHTML is used\n    support.leadingWhitespace = div.firstChild.nodeType === 3;\n\n    // Make sure that tbody elements aren't automatically inserted\n    // IE will insert them into empty tables\n    support.tbody = !div.getElementsByTagName( \"tbody\" ).length;\n\n    // Make sure that link elements get serialized correctly by innerHTML\n    // This requires a wrapper element in IE\n    support.htmlSerialize = !!div.getElementsByTagName( \"link\" ).length;\n\n    // Makes sure cloning an html5 element does not cause problems\n    // Where outerHTML is undefined, this still works\n    support.html5Clone =\n        document.createElement( \"nav\" ).cloneNode( true ).outerHTML !== \"<:nav></:nav>\";\n\n    // Check if a disconnected checkbox will retain its checked\n    // value of true after appended to the DOM (IE6/7)\n    input.type = \"checkbox\";\n    input.checked = true;\n    fragment.appendChild( input );\n    support.appendChecked = input.checked;\n\n    // Make sure textarea (and checkbox) defaultValue is properly cloned\n    // Support: IE6-IE11+\n    div.innerHTML = \"<textarea>x</textarea>\";\n    support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\n    // #11217 - WebKit loses check when the name is after the checked attribute\n    fragment.appendChild( div );\n    div.innerHTML = \"<input type='radio' checked='checked' name='t'/>\";\n\n    // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n    // old WebKit doesn't clone checked state correctly in fragments\n    support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n    // Support: IE<9\n    // Opera does not clone events (and typeof div.attachEvent === undefined).\n    // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()\n    support.noCloneEvent = true;\n    if ( div.attachEvent ) {\n        div.attachEvent( \"onclick\", function() {\n            support.noCloneEvent = false;\n        });\n\n        div.cloneNode( true ).click();\n    }\n\n    // Execute the test only if not already executed in another module.\n    if (support.deleteExpando == null) {\n        // Support: IE<9\n        support.deleteExpando = true;\n        try {\n            delete div.test;\n        } catch( e ) {\n            support.deleteExpando = false;\n        }\n    }\n})();\n\n\n(function() {\n    var i, eventName,\n        div = document.createElement( \"div\" );\n\n    // Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)\n    for ( i in { submit: true, change: true, focusin: true }) {\n        eventName = \"on\" + i;\n\n        if ( !(support[ i + \"Bubbles\" ] = eventName in window) ) {\n            // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\n            div.setAttribute( eventName, \"t\" );\n            support[ i + \"Bubbles\" ] = div.attributes[ eventName ].expando === false;\n        }\n    }\n\n    // Null elements to avoid leaks in IE.\n    div = null;\n})();\n\n\nvar rformElems = /^(?:input|select|textarea)$/i,\n    rkeyEvent = /^key/,\n    rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n    rtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n    return true;\n}\n\nfunction returnFalse() {\n    return false;\n}\n\nfunction safeActiveElement() {\n    try {\n        return document.activeElement;\n    } catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n    global: {},\n\n    add: function( elem, types, handler, data, selector ) {\n        var tmp, events, t, handleObjIn,\n            special, eventHandle, handleObj,\n            handlers, type, namespaces, origType,\n            elemData = jQuery._data( elem );\n\n        // Don't attach events to noData or text/comment nodes (but allow plain objects)\n        if ( !elemData ) {\n            return;\n        }\n\n        // Caller can pass in an object of custom data in lieu of the handler\n        if ( handler.handler ) {\n            handleObjIn = handler;\n            handler = handleObjIn.handler;\n            selector = handleObjIn.selector;\n        }\n\n        // Make sure that the handler has a unique ID, used to find/remove it later\n        if ( !handler.guid ) {\n            handler.guid = jQuery.guid++;\n        }\n\n        // Init the element's event structure and main handler, if this is the first\n        if ( !(events = elemData.events) ) {\n            events = elemData.events = {};\n        }\n        if ( !(eventHandle = elemData.handle) ) {\n            eventHandle = elemData.handle = function( e ) {\n                // Discard the second event of a jQuery.event.trigger() and\n                // when an event is called after a page has unloaded\n                return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?\n                    jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n                    undefined;\n            };\n            // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n            eventHandle.elem = elem;\n        }\n\n        // Handle multiple events separated by a space\n        types = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n        t = types.length;\n        while ( t-- ) {\n            tmp = rtypenamespace.exec( types[t] ) || [];\n            type = origType = tmp[1];\n            namespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n            // There *must* be a type, no attaching namespace-only handlers\n            if ( !type ) {\n                continue;\n            }\n\n            // If event changes its type, use the special event handlers for the changed type\n            special = jQuery.event.special[ type ] || {};\n\n            // If selector defined, determine special event api type, otherwise given type\n            type = ( selector ? special.delegateType : special.bindType ) || type;\n\n            // Update special based on newly reset type\n            special = jQuery.event.special[ type ] || {};\n\n            // handleObj is passed to all event handlers\n            handleObj = jQuery.extend({\n                type: type,\n                origType: origType,\n                data: data,\n                handler: handler,\n                guid: handler.guid,\n                selector: selector,\n                needsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n                namespace: namespaces.join(\".\")\n            }, handleObjIn );\n\n            // Init the event handler queue if we're the first\n            if ( !(handlers = events[ type ]) ) {\n                handlers = events[ type ] = [];\n                handlers.delegateCount = 0;\n\n                // Only use addEventListener/attachEvent if the special events handler returns false\n                if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n                    // Bind the global event handler to the element\n                    if ( elem.addEventListener ) {\n                        elem.addEventListener( type, eventHandle, false );\n\n                    } else if ( elem.attachEvent ) {\n                        elem.attachEvent( \"on\" + type, eventHandle );\n                    }\n                }\n            }\n\n            if ( special.add ) {\n                special.add.call( elem, handleObj );\n\n                if ( !handleObj.handler.guid ) {\n                    handleObj.handler.guid = handler.guid;\n                }\n            }\n\n            // Add to the element's handler list, delegates in front\n            if ( selector ) {\n                handlers.splice( handlers.delegateCount++, 0, handleObj );\n            } else {\n                handlers.push( handleObj );\n            }\n\n            // Keep track of which events have ever been used, for event optimization\n            jQuery.event.global[ type ] = true;\n        }\n\n        // Nullify elem to prevent memory leaks in IE\n        elem = null;\n    },\n\n    // Detach an event or set of events from an element\n    remove: function( elem, types, handler, selector, mappedTypes ) {\n        var j, handleObj, tmp,\n            origCount, t, events,\n            special, handlers, type,\n            namespaces, origType,\n            elemData = jQuery.hasData( elem ) && jQuery._data( elem );\n\n        if ( !elemData || !(events = elemData.events) ) {\n            return;\n        }\n\n        // Once for each type.namespace in types; type may be omitted\n        types = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n        t = types.length;\n        while ( t-- ) {\n            tmp = rtypenamespace.exec( types[t] ) || [];\n            type = origType = tmp[1];\n            namespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n            // Unbind all events (on this namespace, if provided) for the element\n            if ( !type ) {\n                for ( type in events ) {\n                    jQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n                }\n                continue;\n            }\n\n            special = jQuery.event.special[ type ] || {};\n            type = ( selector ? special.delegateType : special.bindType ) || type;\n            handlers = events[ type ] || [];\n            tmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n            // Remove matching events\n            origCount = j = handlers.length;\n            while ( j-- ) {\n                handleObj = handlers[ j ];\n\n                if ( ( mappedTypes || origType === handleObj.origType ) &&\n                    ( !handler || handler.guid === handleObj.guid ) &&\n                    ( !tmp || tmp.test( handleObj.namespace ) ) &&\n                    ( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n                    handlers.splice( j, 1 );\n\n                    if ( handleObj.selector ) {\n                        handlers.delegateCount--;\n                    }\n                    if ( special.remove ) {\n                        special.remove.call( elem, handleObj );\n                    }\n                }\n            }\n\n            // Remove generic event handler if we removed something and no more handlers exist\n            // (avoids potential for endless recursion during removal of special event handlers)\n            if ( origCount && !handlers.length ) {\n                if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n                    jQuery.removeEvent( elem, type, elemData.handle );\n                }\n\n                delete events[ type ];\n            }\n        }\n\n        // Remove the expando if it's no longer used\n        if ( jQuery.isEmptyObject( events ) ) {\n            delete elemData.handle;\n\n            // removeData also checks for emptiness and clears the expando if empty\n            // so use it instead of delete\n            jQuery._removeData( elem, \"events\" );\n        }\n    },\n\n    trigger: function( event, data, elem, onlyHandlers ) {\n        var handle, ontype, cur,\n            bubbleType, special, tmp, i,\n            eventPath = [ elem || document ],\n            type = hasOwn.call( event, \"type\" ) ? event.type : event,\n            namespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n        cur = tmp = elem = elem || document;\n\n        // Don't do events on text and comment nodes\n        if ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n            return;\n        }\n\n        // focus/blur morphs to focusin/out; ensure we're not firing them right now\n        if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n            return;\n        }\n\n        if ( type.indexOf(\".\") >= 0 ) {\n            // Namespaced trigger; create a regexp to match event type in handle()\n            namespaces = type.split(\".\");\n            type = namespaces.shift();\n            namespaces.sort();\n        }\n        ontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n        // Caller can pass in a jQuery.Event object, Object, or just an event type string\n        event = event[ jQuery.expando ] ?\n            event :\n            new jQuery.Event( type, typeof event === \"object\" && event );\n\n        // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n        event.isTrigger = onlyHandlers ? 2 : 3;\n        event.namespace = namespaces.join(\".\");\n        event.namespace_re = event.namespace ?\n            new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n            null;\n\n        // Clean up the event in case it is being reused\n        event.result = undefined;\n        if ( !event.target ) {\n            event.target = elem;\n        }\n\n        // Clone any incoming data and prepend the event, creating the handler arg list\n        data = data == null ?\n            [ event ] :\n            jQuery.makeArray( data, [ event ] );\n\n        // Allow special events to draw outside the lines\n        special = jQuery.event.special[ type ] || {};\n        if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n            return;\n        }\n\n        // Determine event propagation path in advance, per W3C events spec (#9951)\n        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n        if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n            bubbleType = special.delegateType || type;\n            if ( !rfocusMorph.test( bubbleType + type ) ) {\n                cur = cur.parentNode;\n            }\n            for ( ; cur; cur = cur.parentNode ) {\n                eventPath.push( cur );\n                tmp = cur;\n            }\n\n            // Only add window if we got to document (e.g., not plain obj or detached DOM)\n            if ( tmp === (elem.ownerDocument || document) ) {\n                eventPath.push( tmp.defaultView || tmp.parentWindow || window );\n            }\n        }\n\n        // Fire handlers on the event path\n        i = 0;\n        while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n            event.type = i > 1 ?\n                bubbleType :\n                special.bindType || type;\n\n            // jQuery handler\n            handle = ( jQuery._data( cur, \"events\" ) || {} )[ event.type ] && jQuery._data( cur, \"handle\" );\n            if ( handle ) {\n                handle.apply( cur, data );\n            }\n\n            // Native handler\n            handle = ontype && cur[ ontype ];\n            if ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n                event.result = handle.apply( cur, data );\n                if ( event.result === false ) {\n                    event.preventDefault();\n                }\n            }\n        }\n        event.type = type;\n\n        // If nobody prevented the default action, do it now\n        if ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n            if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n                jQuery.acceptData( elem ) ) {\n\n                // Call a native DOM method on the target with the same name name as the event.\n                // Can't use an .isFunction() check here because IE6/7 fails that test.\n                // Don't do default actions on window, that's where global variables be (#6170)\n                if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {\n\n                    // Don't re-trigger an onFOO event when we call its FOO() method\n                    tmp = elem[ ontype ];\n\n                    if ( tmp ) {\n                        elem[ ontype ] = null;\n                    }\n\n                    // Prevent re-triggering of the same event, since we already bubbled it above\n                    jQuery.event.triggered = type;\n                    try {\n                        elem[ type ]();\n                    } catch ( e ) {\n                        // IE<9 dies on focus/blur to hidden element (#1486,#12518)\n                        // only reproducible on winXP IE8 native, not IE9 in IE8 mode\n                    }\n                    jQuery.event.triggered = undefined;\n\n                    if ( tmp ) {\n                        elem[ ontype ] = tmp;\n                    }\n                }\n            }\n        }\n\n        return event.result;\n    },\n\n    dispatch: function( event ) {\n\n        // Make a writable jQuery.Event from the native event object\n        event = jQuery.event.fix( event );\n\n        var i, ret, handleObj, matched, j,\n            handlerQueue = [],\n            args = slice.call( arguments ),\n            handlers = ( jQuery._data( this, \"events\" ) || {} )[ event.type ] || [],\n            special = jQuery.event.special[ event.type ] || {};\n\n        // Use the fix-ed jQuery.Event rather than the (read-only) native event\n        args[0] = event;\n        event.delegateTarget = this;\n\n        // Call the preDispatch hook for the mapped type, and let it bail if desired\n        if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n            return;\n        }\n\n        // Determine handlers\n        handlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n        // Run delegates first; they may want to stop propagation beneath us\n        i = 0;\n        while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n            event.currentTarget = matched.elem;\n\n            j = 0;\n            while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n                // Triggered event must either 1) have no namespace, or\n                // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n                if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n                    event.handleObj = handleObj;\n                    event.data = handleObj.data;\n\n                    ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n                            .apply( matched.elem, args );\n\n                    if ( ret !== undefined ) {\n                        if ( (event.result = ret) === false ) {\n                            event.preventDefault();\n                            event.stopPropagation();\n                        }\n                    }\n                }\n            }\n        }\n\n        // Call the postDispatch hook for the mapped type\n        if ( special.postDispatch ) {\n            special.postDispatch.call( this, event );\n        }\n\n        return event.result;\n    },\n\n    handlers: function( event, handlers ) {\n        var sel, handleObj, matches, i,\n            handlerQueue = [],\n            delegateCount = handlers.delegateCount,\n            cur = event.target;\n\n        // Find delegate handlers\n        // Black-hole SVG <use> instance trees (#13180)\n        // Avoid non-left-click bubbling in Firefox (#3861)\n        if ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n            /* jshint eqeqeq: false */\n            for ( ; cur != this; cur = cur.parentNode || this ) {\n                /* jshint eqeqeq: true */\n\n                // Don't check non-elements (#13208)\n                // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n                if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== \"click\") ) {\n                    matches = [];\n                    for ( i = 0; i < delegateCount; i++ ) {\n                        handleObj = handlers[ i ];\n\n                        // Don't conflict with Object.prototype properties (#13203)\n                        sel = handleObj.selector + \" \";\n\n                        if ( matches[ sel ] === undefined ) {\n                            matches[ sel ] = handleObj.needsContext ?\n                                jQuery( sel, this ).index( cur ) >= 0 :\n                                jQuery.find( sel, this, null, [ cur ] ).length;\n                        }\n                        if ( matches[ sel ] ) {\n                            matches.push( handleObj );\n                        }\n                    }\n                    if ( matches.length ) {\n                        handlerQueue.push({ elem: cur, handlers: matches });\n                    }\n                }\n            }\n        }\n\n        // Add the remaining (directly-bound) handlers\n        if ( delegateCount < handlers.length ) {\n            handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n        }\n\n        return handlerQueue;\n    },\n\n    fix: function( event ) {\n        if ( event[ jQuery.expando ] ) {\n            return event;\n        }\n\n        // Create a writable copy of the event object and normalize some properties\n        var i, prop, copy,\n            type = event.type,\n            originalEvent = event,\n            fixHook = this.fixHooks[ type ];\n\n        if ( !fixHook ) {\n            this.fixHooks[ type ] = fixHook =\n                rmouseEvent.test( type ) ? this.mouseHooks :\n                rkeyEvent.test( type ) ? this.keyHooks :\n                {};\n        }\n        copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n        event = new jQuery.Event( originalEvent );\n\n        i = copy.length;\n        while ( i-- ) {\n            prop = copy[ i ];\n            event[ prop ] = originalEvent[ prop ];\n        }\n\n        // Support: IE<9\n        // Fix target property (#1925)\n        if ( !event.target ) {\n            event.target = originalEvent.srcElement || document;\n        }\n\n        // Support: Chrome 23+, Safari?\n        // Target should not be a text node (#504, #13143)\n        if ( event.target.nodeType === 3 ) {\n            event.target = event.target.parentNode;\n        }\n\n        // Support: IE<9\n        // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)\n        event.metaKey = !!event.metaKey;\n\n        return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n    },\n\n    // Includes some event props shared by KeyEvent and MouseEvent\n    props: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n    fixHooks: {},\n\n    keyHooks: {\n        props: \"char charCode key keyCode\".split(\" \"),\n        filter: function( event, original ) {\n\n            // Add which for key events\n            if ( event.which == null ) {\n                event.which = original.charCode != null ? original.charCode : original.keyCode;\n            }\n\n            return event;\n        }\n    },\n\n    mouseHooks: {\n        props: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n        filter: function( event, original ) {\n            var body, eventDoc, doc,\n                button = original.button,\n                fromElement = original.fromElement;\n\n            // Calculate pageX/Y if missing and clientX/Y available\n            if ( event.pageX == null && original.clientX != null ) {\n                eventDoc = event.target.ownerDocument || document;\n                doc = eventDoc.documentElement;\n                body = eventDoc.body;\n\n                event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n                event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n            }\n\n            // Add relatedTarget, if necessary\n            if ( !event.relatedTarget && fromElement ) {\n                event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n            }\n\n            // Add which for click: 1 === left; 2 === middle; 3 === right\n            // Note: button is not normalized, so don't use it\n            if ( !event.which && button !== undefined ) {\n                event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n            }\n\n            return event;\n        }\n    },\n\n    special: {\n        load: {\n            // Prevent triggered image.load events from bubbling to window.load\n            noBubble: true\n        },\n        focus: {\n            // Fire native event if possible so blur/focus sequence is correct\n            trigger: function() {\n                if ( this !== safeActiveElement() && this.focus ) {\n                    try {\n                        this.focus();\n                        return false;\n                    } catch ( e ) {\n                        // Support: IE<9\n                        // If we error on focus to hidden element (#1486, #12518),\n                        // let .trigger() run the handlers\n                    }\n                }\n            },\n            delegateType: \"focusin\"\n        },\n        blur: {\n            trigger: function() {\n                if ( this === safeActiveElement() && this.blur ) {\n                    this.blur();\n                    return false;\n                }\n            },\n            delegateType: \"focusout\"\n        },\n        click: {\n            // For checkbox, fire native event so checked state will be right\n            trigger: function() {\n                if ( jQuery.nodeName( this, \"input\" ) && this.type === \"checkbox\" && this.click ) {\n                    this.click();\n                    return false;\n                }\n            },\n\n            // For cross-browser consistency, don't fire native .click() on links\n            _default: function( event ) {\n                return jQuery.nodeName( event.target, \"a\" );\n            }\n        },\n\n        beforeunload: {\n            postDispatch: function( event ) {\n\n                // Support: Firefox 20+\n                // Firefox doesn't alert if the returnValue field is not set.\n                if ( event.result !== undefined && event.originalEvent ) {\n                    event.originalEvent.returnValue = event.result;\n                }\n            }\n        }\n    },\n\n    simulate: function( type, elem, event, bubble ) {\n        // Piggyback on a donor event to simulate a different one.\n        // Fake originalEvent to avoid donor's stopPropagation, but if the\n        // simulated event prevents default then we do the same on the donor.\n        var e = jQuery.extend(\n            new jQuery.Event(),\n            event,\n            {\n                type: type,\n                isSimulated: true,\n                originalEvent: {}\n            }\n        );\n        if ( bubble ) {\n            jQuery.event.trigger( e, null, elem );\n        } else {\n            jQuery.event.dispatch.call( elem, e );\n        }\n        if ( e.isDefaultPrevented() ) {\n            event.preventDefault();\n        }\n    }\n};\n\njQuery.removeEvent = document.removeEventListener ?\n    function( elem, type, handle ) {\n        if ( elem.removeEventListener ) {\n            elem.removeEventListener( type, handle, false );\n        }\n    } :\n    function( elem, type, handle ) {\n        var name = \"on\" + type;\n\n        if ( elem.detachEvent ) {\n\n            // #8545, #7054, preventing memory leaks for custom events in IE6-8\n            // detachEvent needed property on element, by name of that event, to properly expose it to GC\n            if ( typeof elem[ name ] === strundefined ) {\n                elem[ name ] = null;\n            }\n\n            elem.detachEvent( name, handle );\n        }\n    };\n\njQuery.Event = function( src, props ) {\n    // Allow instantiation without the 'new' keyword\n    if ( !(this instanceof jQuery.Event) ) {\n        return new jQuery.Event( src, props );\n    }\n\n    // Event object\n    if ( src && src.type ) {\n        this.originalEvent = src;\n        this.type = src.type;\n\n        // Events bubbling up the document may have been marked as prevented\n        // by a handler lower down the tree; reflect the correct value.\n        this.isDefaultPrevented = src.defaultPrevented ||\n                src.defaultPrevented === undefined &&\n                // Support: IE < 9, Android < 4.0\n                src.returnValue === false ?\n            returnTrue :\n            returnFalse;\n\n    // Event type\n    } else {\n        this.type = src;\n    }\n\n    // Put explicitly provided properties onto the event object\n    if ( props ) {\n        jQuery.extend( this, props );\n    }\n\n    // Create a timestamp if incoming event doesn't have one\n    this.timeStamp = src && src.timeStamp || jQuery.now();\n\n    // Mark it as fixed\n    this[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n\n    preventDefault: function() {\n        var e = this.originalEvent;\n\n        this.isDefaultPrevented = returnTrue;\n        if ( !e ) {\n            return;\n        }\n\n        // If preventDefault exists, run it on the original event\n        if ( e.preventDefault ) {\n            e.preventDefault();\n\n        // Support: IE\n        // Otherwise set the returnValue property of the original event to false\n        } else {\n            e.returnValue = false;\n        }\n    },\n    stopPropagation: function() {\n        var e = this.originalEvent;\n\n        this.isPropagationStopped = returnTrue;\n        if ( !e ) {\n            return;\n        }\n        // If stopPropagation exists, run it on the original event\n        if ( e.stopPropagation ) {\n            e.stopPropagation();\n        }\n\n        // Support: IE\n        // Set the cancelBubble property of the original event to true\n        e.cancelBubble = true;\n    },\n    stopImmediatePropagation: function() {\n        var e = this.originalEvent;\n\n        this.isImmediatePropagationStopped = returnTrue;\n\n        if ( e && e.stopImmediatePropagation ) {\n            e.stopImmediatePropagation();\n        }\n\n        this.stopPropagation();\n    }\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\njQuery.each({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\",\n    pointerenter: \"pointerover\",\n    pointerleave: \"pointerout\"\n}, function( orig, fix ) {\n    jQuery.event.special[ orig ] = {\n        delegateType: fix,\n        bindType: fix,\n\n        handle: function( event ) {\n            var ret,\n                target = this,\n                related = event.relatedTarget,\n                handleObj = event.handleObj;\n\n            // For mousenter/leave call the handler if related is outside the target.\n            // NB: No relatedTarget if the mouse left/entered the browser window\n            if ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n                event.type = handleObj.origType;\n                ret = handleObj.handler.apply( this, arguments );\n                event.type = fix;\n            }\n            return ret;\n        }\n    };\n});\n\n// IE submit delegation\nif ( !support.submitBubbles ) {\n\n    jQuery.event.special.submit = {\n        setup: function() {\n            // Only need this for delegated form submit events\n            if ( jQuery.nodeName( this, \"form\" ) ) {\n                return false;\n            }\n\n            // Lazy-add a submit handler when a descendant form may potentially be submitted\n            jQuery.event.add( this, \"click._submit keypress._submit\", function( e ) {\n                // Node name check avoids a VML-related crash in IE (#9807)\n                var elem = e.target,\n                    form = jQuery.nodeName( elem, \"input\" ) || jQuery.nodeName( elem, \"button\" ) ? elem.form : undefined;\n                if ( form && !jQuery._data( form, \"submitBubbles\" ) ) {\n                    jQuery.event.add( form, \"submit._submit\", function( event ) {\n                        event._submit_bubble = true;\n                    });\n                    jQuery._data( form, \"submitBubbles\", true );\n                }\n            });\n            // return undefined since we don't need an event listener\n        },\n\n        postDispatch: function( event ) {\n            // If form was submitted by the user, bubble the event up the tree\n            if ( event._submit_bubble ) {\n                delete event._submit_bubble;\n                if ( this.parentNode && !event.isTrigger ) {\n                    jQuery.event.simulate( \"submit\", this.parentNode, event, true );\n                }\n            }\n        },\n\n        teardown: function() {\n            // Only need this for delegated form submit events\n            if ( jQuery.nodeName( this, \"form\" ) ) {\n                return false;\n            }\n\n            // Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n            jQuery.event.remove( this, \"._submit\" );\n        }\n    };\n}\n\n// IE change delegation and checkbox/radio fix\nif ( !support.changeBubbles ) {\n\n    jQuery.event.special.change = {\n\n        setup: function() {\n\n            if ( rformElems.test( this.nodeName ) ) {\n                // IE doesn't fire change on a check/radio until blur; trigger it on click\n                // after a propertychange. Eat the blur-change in special.change.handle.\n                // This still fires onchange a second time for check/radio after blur.\n                if ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n                    jQuery.event.add( this, \"propertychange._change\", function( event ) {\n                        if ( event.originalEvent.propertyName === \"checked\" ) {\n                            this._just_changed = true;\n                        }\n                    });\n                    jQuery.event.add( this, \"click._change\", function( event ) {\n                        if ( this._just_changed && !event.isTrigger ) {\n                            this._just_changed = false;\n                        }\n                        // Allow triggered, simulated change events (#11500)\n                        jQuery.event.simulate( \"change\", this, event, true );\n                    });\n                }\n                return false;\n            }\n            // Delegated event; lazy-add a change handler on descendant inputs\n            jQuery.event.add( this, \"beforeactivate._change\", function( e ) {\n                var elem = e.target;\n\n                if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, \"changeBubbles\" ) ) {\n                    jQuery.event.add( elem, \"change._change\", function( event ) {\n                        if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {\n                            jQuery.event.simulate( \"change\", this.parentNode, event, true );\n                        }\n                    });\n                    jQuery._data( elem, \"changeBubbles\", true );\n                }\n            });\n        },\n\n        handle: function( event ) {\n            var elem = event.target;\n\n            // Swallow native change events from checkbox/radio, we already triggered them above\n            if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== \"radio\" && elem.type !== \"checkbox\") ) {\n                return event.handleObj.handler.apply( this, arguments );\n            }\n        },\n\n        teardown: function() {\n            jQuery.event.remove( this, \"._change\" );\n\n            return !rformElems.test( this.nodeName );\n        }\n    };\n}\n\n// Create \"bubbling\" focus and blur events\nif ( !support.focusinBubbles ) {\n    jQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n        // Attach a single capturing handler on the document while someone wants focusin/focusout\n        var handler = function( event ) {\n                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n            };\n\n        jQuery.event.special[ fix ] = {\n            setup: function() {\n                var doc = this.ownerDocument || this,\n                    attaches = jQuery._data( doc, fix );\n\n                if ( !attaches ) {\n                    doc.addEventListener( orig, handler, true );\n                }\n                jQuery._data( doc, fix, ( attaches || 0 ) + 1 );\n            },\n            teardown: function() {\n                var doc = this.ownerDocument || this,\n                    attaches = jQuery._data( doc, fix ) - 1;\n\n                if ( !attaches ) {\n                    doc.removeEventListener( orig, handler, true );\n                    jQuery._removeData( doc, fix );\n                } else {\n                    jQuery._data( doc, fix, attaches );\n                }\n            }\n        };\n    });\n}\n\njQuery.fn.extend({\n\n    on: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n        var type, origFn;\n\n        // Types can be a map of types/handlers\n        if ( typeof types === \"object\" ) {\n            // ( types-Object, selector, data )\n            if ( typeof selector !== \"string\" ) {\n                // ( types-Object, data )\n                data = data || selector;\n                selector = undefined;\n            }\n            for ( type in types ) {\n                this.on( type, selector, data, types[ type ], one );\n            }\n            return this;\n        }\n\n        if ( data == null && fn == null ) {\n            // ( types, fn )\n            fn = selector;\n            data = selector = undefined;\n        } else if ( fn == null ) {\n            if ( typeof selector === \"string\" ) {\n                // ( types, selector, fn )\n                fn = data;\n                data = undefined;\n            } else {\n                // ( types, data, fn )\n                fn = data;\n                data = selector;\n                selector = undefined;\n            }\n        }\n        if ( fn === false ) {\n            fn = returnFalse;\n        } else if ( !fn ) {\n            return this;\n        }\n\n        if ( one === 1 ) {\n            origFn = fn;\n            fn = function( event ) {\n                // Can use an empty set, since event contains the info\n                jQuery().off( event );\n                return origFn.apply( this, arguments );\n            };\n            // Use same guid so caller can remove using origFn\n            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n        }\n        return this.each( function() {\n            jQuery.event.add( this, types, fn, data, selector );\n        });\n    },\n    one: function( types, selector, data, fn ) {\n        return this.on( types, selector, data, fn, 1 );\n    },\n    off: function( types, selector, fn ) {\n        var handleObj, type;\n        if ( types && types.preventDefault && types.handleObj ) {\n            // ( event )  dispatched jQuery.Event\n            handleObj = types.handleObj;\n            jQuery( types.delegateTarget ).off(\n                handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n                handleObj.selector,\n                handleObj.handler\n            );\n            return this;\n        }\n        if ( typeof types === \"object\" ) {\n            // ( types-object [, selector] )\n            for ( type in types ) {\n                this.off( type, selector, types[ type ] );\n            }\n            return this;\n        }\n        if ( selector === false || typeof selector === \"function\" ) {\n            // ( types [, fn] )\n            fn = selector;\n            selector = undefined;\n        }\n        if ( fn === false ) {\n            fn = returnFalse;\n        }\n        return this.each(function() {\n            jQuery.event.remove( this, types, fn, selector );\n        });\n    },\n\n    trigger: function( type, data ) {\n        return this.each(function() {\n            jQuery.event.trigger( type, data, this );\n        });\n    },\n    triggerHandler: function( type, data ) {\n        var elem = this[0];\n        if ( elem ) {\n            return jQuery.event.trigger( type, data, elem, true );\n        }\n    }\n});\n\n\nfunction createSafeFragment( document ) {\n    var list = nodeNames.split( \"|\" ),\n        safeFrag = document.createDocumentFragment();\n\n    if ( safeFrag.createElement ) {\n        while ( list.length ) {\n            safeFrag.createElement(\n                list.pop()\n            );\n        }\n    }\n    return safeFrag;\n}\n\nvar nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" +\n        \"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n    rinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n    rnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n    rleadingWhitespace = /^\\s+/,\n    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n    rtagName = /<([\\w:]+)/,\n    rtbody = /<tbody/i,\n    rhtml = /<|&#?\\w+;/,\n    rnoInnerhtml = /<(?:script|style|link)/i,\n    // checked=\"checked\" or checked\n    rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n    rscriptType = /^$|\\/(?:java|ecma)script/i,\n    rscriptTypeMasked = /^true\\/(.*)/,\n    rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n    // We have to close these tags to support XHTML (#13200)\n    wrapMap = {\n        option: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n        legend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n        area: [ 1, \"<map>\", \"</map>\" ],\n        param: [ 1, \"<object>\", \"</object>\" ],\n        thead: [ 1, \"<table>\", \"</table>\" ],\n        tr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n        col: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n        td: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n        // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n        // unless wrapped in a div with non-breaking characters in front of it.\n        _default: support.htmlSerialize ? [ 0, \"\", \"\" ] : [ 1, \"X<div>\", \"</div>\"  ]\n    },\n    safeFragment = createSafeFragment( document ),\n    fragmentDiv = safeFragment.appendChild( document.createElement(\"div\") );\n\nwrapMap.optgroup = wrapMap.option;\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\nfunction getAll( context, tag ) {\n    var elems, elem,\n        i = 0,\n        found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || \"*\" ) :\n            typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || \"*\" ) :\n            undefined;\n\n    if ( !found ) {\n        for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {\n            if ( !tag || jQuery.nodeName( elem, tag ) ) {\n                found.push( elem );\n            } else {\n                jQuery.merge( found, getAll( elem, tag ) );\n            }\n        }\n    }\n\n    return tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n        jQuery.merge( [ context ], found ) :\n        found;\n}\n\n// Used in buildFragment, fixes the defaultChecked property\nfunction fixDefaultChecked( elem ) {\n    if ( rcheckableType.test( elem.type ) ) {\n        elem.defaultChecked = elem.checked;\n    }\n}\n\n// Support: IE<8\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n    return jQuery.nodeName( elem, \"table\" ) &&\n        jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n        elem.getElementsByTagName(\"tbody\")[0] ||\n            elem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n        elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n    elem.type = (jQuery.find.attr( elem, \"type\" ) !== null) + \"/\" + elem.type;\n    return elem;\n}\nfunction restoreScript( elem ) {\n    var match = rscriptTypeMasked.exec( elem.type );\n    if ( match ) {\n        elem.type = match[1];\n    } else {\n        elem.removeAttribute(\"type\");\n    }\n    return elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n    var elem,\n        i = 0;\n    for ( ; (elem = elems[i]) != null; i++ ) {\n        jQuery._data( elem, \"globalEval\", !refElements || jQuery._data( refElements[i], \"globalEval\" ) );\n    }\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\n    if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n        return;\n    }\n\n    var type, i, l,\n        oldData = jQuery._data( src ),\n        curData = jQuery._data( dest, oldData ),\n        events = oldData.events;\n\n    if ( events ) {\n        delete curData.handle;\n        curData.events = {};\n\n        for ( type in events ) {\n            for ( i = 0, l = events[ type ].length; i < l; i++ ) {\n                jQuery.event.add( dest, type, events[ type ][ i ] );\n            }\n        }\n    }\n\n    // make the cloned public data object a copy from the original\n    if ( curData.data ) {\n        curData.data = jQuery.extend( {}, curData.data );\n    }\n}\n\nfunction fixCloneNodeIssues( src, dest ) {\n    var nodeName, e, data;\n\n    // We do not need to do anything for non-Elements\n    if ( dest.nodeType !== 1 ) {\n        return;\n    }\n\n    nodeName = dest.nodeName.toLowerCase();\n\n    // IE6-8 copies events bound via attachEvent when using cloneNode.\n    if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {\n        data = jQuery._data( dest );\n\n        for ( e in data.events ) {\n            jQuery.removeEvent( dest, e, data.handle );\n        }\n\n        // Event data gets referenced instead of copied if the expando gets copied too\n        dest.removeAttribute( jQuery.expando );\n    }\n\n    // IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n    if ( nodeName === \"script\" && dest.text !== src.text ) {\n        disableScript( dest ).text = src.text;\n        restoreScript( dest );\n\n    // IE6-10 improperly clones children of object elements using classid.\n    // IE10 throws NoModificationAllowedError if parent is null, #12132.\n    } else if ( nodeName === \"object\" ) {\n        if ( dest.parentNode ) {\n            dest.outerHTML = src.outerHTML;\n        }\n\n        // This path appears unavoidable for IE9. When cloning an object\n        // element in IE9, the outerHTML strategy above is not sufficient.\n        // If the src has innerHTML and the destination does not,\n        // copy the src.innerHTML into the dest.innerHTML. #10324\n        if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {\n            dest.innerHTML = src.innerHTML;\n        }\n\n    } else if ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n        // IE6-8 fails to persist the checked state of a cloned checkbox\n        // or radio button. Worse, IE6-7 fail to give the cloned element\n        // a checked appearance if the defaultChecked value isn't also set\n\n        dest.defaultChecked = dest.checked = src.checked;\n\n        // IE6-7 get confused and end up setting the value of a cloned\n        // checkbox/radio button to an empty string instead of \"on\"\n        if ( dest.value !== src.value ) {\n            dest.value = src.value;\n        }\n\n    // IE6-8 fails to return the selected option to the default selected\n    // state when cloning options\n    } else if ( nodeName === \"option\" ) {\n        dest.defaultSelected = dest.selected = src.defaultSelected;\n\n    // IE6-8 fails to set the defaultValue to the correct value when\n    // cloning other types of input fields\n    } else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n        dest.defaultValue = src.defaultValue;\n    }\n}\n\njQuery.extend({\n    clone: function( elem, dataAndEvents, deepDataAndEvents ) {\n        var destElements, node, clone, i, srcElements,\n            inPage = jQuery.contains( elem.ownerDocument, elem );\n\n        if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( \"<\" + elem.nodeName + \">\" ) ) {\n            clone = elem.cloneNode( true );\n\n        // IE<=8 does not properly clone detached, unknown element nodes\n        } else {\n            fragmentDiv.innerHTML = elem.outerHTML;\n            fragmentDiv.removeChild( clone = fragmentDiv.firstChild );\n        }\n\n        if ( (!support.noCloneEvent || !support.noCloneChecked) &&\n                (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {\n\n            // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n            destElements = getAll( clone );\n            srcElements = getAll( elem );\n\n            // Fix all IE cloning issues\n            for ( i = 0; (node = srcElements[i]) != null; ++i ) {\n                // Ensure that the destination node is not null; Fixes #9587\n                if ( destElements[i] ) {\n                    fixCloneNodeIssues( node, destElements[i] );\n                }\n            }\n        }\n\n        // Copy the events from the original to the clone\n        if ( dataAndEvents ) {\n            if ( deepDataAndEvents ) {\n                srcElements = srcElements || getAll( elem );\n                destElements = destElements || getAll( clone );\n\n                for ( i = 0; (node = srcElements[i]) != null; i++ ) {\n                    cloneCopyEvent( node, destElements[i] );\n                }\n            } else {\n                cloneCopyEvent( elem, clone );\n            }\n        }\n\n        // Preserve script evaluation history\n        destElements = getAll( clone, \"script\" );\n        if ( destElements.length > 0 ) {\n            setGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n        }\n\n        destElements = srcElements = node = null;\n\n        // Return the cloned set\n        return clone;\n    },\n\n    buildFragment: function( elems, context, scripts, selection ) {\n        var j, elem, contains,\n            tmp, tag, tbody, wrap,\n            l = elems.length,\n\n            // Ensure a safe fragment\n            safe = createSafeFragment( context ),\n\n            nodes = [],\n            i = 0;\n\n        for ( ; i < l; i++ ) {\n            elem = elems[ i ];\n\n            if ( elem || elem === 0 ) {\n\n                // Add nodes directly\n                if ( jQuery.type( elem ) === \"object\" ) {\n                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n                // Convert non-html into a text node\n                } else if ( !rhtml.test( elem ) ) {\n                    nodes.push( context.createTextNode( elem ) );\n\n                // Convert html into DOM nodes\n                } else {\n                    tmp = tmp || safe.appendChild( context.createElement(\"div\") );\n\n                    // Deserialize a standard representation\n                    tag = (rtagName.exec( elem ) || [ \"\", \"\" ])[ 1 ].toLowerCase();\n                    wrap = wrapMap[ tag ] || wrapMap._default;\n\n                    tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[2];\n\n                    // Descend through wrappers to the right content\n                    j = wrap[0];\n                    while ( j-- ) {\n                        tmp = tmp.lastChild;\n                    }\n\n                    // Manually add leading whitespace removed by IE\n                    if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n                        nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );\n                    }\n\n                    // Remove IE's autoinserted <tbody> from table fragments\n                    if ( !support.tbody ) {\n\n                        // String was a <table>, *may* have spurious <tbody>\n                        elem = tag === \"table\" && !rtbody.test( elem ) ?\n                            tmp.firstChild :\n\n                            // String was a bare <thead> or <tfoot>\n                            wrap[1] === \"<table>\" && !rtbody.test( elem ) ?\n                                tmp :\n                                0;\n\n                        j = elem && elem.childNodes.length;\n                        while ( j-- ) {\n                            if ( jQuery.nodeName( (tbody = elem.childNodes[j]), \"tbody\" ) && !tbody.childNodes.length ) {\n                                elem.removeChild( tbody );\n                            }\n                        }\n                    }\n\n                    jQuery.merge( nodes, tmp.childNodes );\n\n                    // Fix #12392 for WebKit and IE > 9\n                    tmp.textContent = \"\";\n\n                    // Fix #12392 for oldIE\n                    while ( tmp.firstChild ) {\n                        tmp.removeChild( tmp.firstChild );\n                    }\n\n                    // Remember the top-level container for proper cleanup\n                    tmp = safe.lastChild;\n                }\n            }\n        }\n\n        // Fix #11356: Clear elements from fragment\n        if ( tmp ) {\n            safe.removeChild( tmp );\n        }\n\n        // Reset defaultChecked for any radios and checkboxes\n        // about to be appended to the DOM in IE 6/7 (#8060)\n        if ( !support.appendChecked ) {\n            jQuery.grep( getAll( nodes, \"input\" ), fixDefaultChecked );\n        }\n\n        i = 0;\n        while ( (elem = nodes[ i++ ]) ) {\n\n            // #4087 - If origin and destination elements are the same, and this is\n            // that element, do not do anything\n            if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n                continue;\n            }\n\n            contains = jQuery.contains( elem.ownerDocument, elem );\n\n            // Append to fragment\n            tmp = getAll( safe.appendChild( elem ), \"script\" );\n\n            // Preserve script evaluation history\n            if ( contains ) {\n                setGlobalEval( tmp );\n            }\n\n            // Capture executables\n            if ( scripts ) {\n                j = 0;\n                while ( (elem = tmp[ j++ ]) ) {\n                    if ( rscriptType.test( elem.type || \"\" ) ) {\n                        scripts.push( elem );\n                    }\n                }\n            }\n        }\n\n        tmp = null;\n\n        return safe;\n    },\n\n    cleanData: function( elems, /* internal */ acceptData ) {\n        var elem, type, id, data,\n            i = 0,\n            internalKey = jQuery.expando,\n            cache = jQuery.cache,\n            deleteExpando = support.deleteExpando,\n            special = jQuery.event.special;\n\n        for ( ; (elem = elems[i]) != null; i++ ) {\n            if ( acceptData || jQuery.acceptData( elem ) ) {\n\n                id = elem[ internalKey ];\n                data = id && cache[ id ];\n\n                if ( data ) {\n                    if ( data.events ) {\n                        for ( type in data.events ) {\n                            if ( special[ type ] ) {\n                                jQuery.event.remove( elem, type );\n\n                            // This is a shortcut to avoid jQuery.event.remove's overhead\n                            } else {\n                                jQuery.removeEvent( elem, type, data.handle );\n                            }\n                        }\n                    }\n\n                    // Remove cache only if it was not already removed by jQuery.event.remove\n                    if ( cache[ id ] ) {\n\n                        delete cache[ id ];\n\n                        // IE does not allow us to delete expando properties from nodes,\n                        // nor does it have a removeAttribute function on Document nodes;\n                        // we must handle all of these cases\n                        if ( deleteExpando ) {\n                            delete elem[ internalKey ];\n\n                        } else if ( typeof elem.removeAttribute !== strundefined ) {\n                            elem.removeAttribute( internalKey );\n\n                        } else {\n                            elem[ internalKey ] = null;\n                        }\n\n                        deletedIds.push( id );\n                    }\n                }\n            }\n        }\n    }\n});\n\njQuery.fn.extend({\n    text: function( value ) {\n        return access( this, function( value ) {\n            return value === undefined ?\n                jQuery.text( this ) :\n                this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );\n        }, null, value, arguments.length );\n    },\n\n    append: function() {\n        return this.domManip( arguments, function( elem ) {\n            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n                var target = manipulationTarget( this, elem );\n                target.appendChild( elem );\n            }\n        });\n    },\n\n    prepend: function() {\n        return this.domManip( arguments, function( elem ) {\n            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n                var target = manipulationTarget( this, elem );\n                target.insertBefore( elem, target.firstChild );\n            }\n        });\n    },\n\n    before: function() {\n        return this.domManip( arguments, function( elem ) {\n            if ( this.parentNode ) {\n                this.parentNode.insertBefore( elem, this );\n            }\n        });\n    },\n\n    after: function() {\n        return this.domManip( arguments, function( elem ) {\n            if ( this.parentNode ) {\n                this.parentNode.insertBefore( elem, this.nextSibling );\n            }\n        });\n    },\n\n    remove: function( selector, keepData /* Internal Use Only */ ) {\n        var elem,\n            elems = selector ? jQuery.filter( selector, this ) : this,\n            i = 0;\n\n        for ( ; (elem = elems[i]) != null; i++ ) {\n\n            if ( !keepData && elem.nodeType === 1 ) {\n                jQuery.cleanData( getAll( elem ) );\n            }\n\n            if ( elem.parentNode ) {\n                if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n                    setGlobalEval( getAll( elem, \"script\" ) );\n                }\n                elem.parentNode.removeChild( elem );\n            }\n        }\n\n        return this;\n    },\n\n    empty: function() {\n        var elem,\n            i = 0;\n\n        for ( ; (elem = this[i]) != null; i++ ) {\n            // Remove element nodes and prevent memory leaks\n            if ( elem.nodeType === 1 ) {\n                jQuery.cleanData( getAll( elem, false ) );\n            }\n\n            // Remove any remaining nodes\n            while ( elem.firstChild ) {\n                elem.removeChild( elem.firstChild );\n            }\n\n            // If this is a select, ensure that it displays empty (#12336)\n            // Support: IE<9\n            if ( elem.options && jQuery.nodeName( elem, \"select\" ) ) {\n                elem.options.length = 0;\n            }\n        }\n\n        return this;\n    },\n\n    clone: function( dataAndEvents, deepDataAndEvents ) {\n        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n        return this.map(function() {\n            return jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n        });\n    },\n\n    html: function( value ) {\n        return access( this, function( value ) {\n            var elem = this[ 0 ] || {},\n                i = 0,\n                l = this.length;\n\n            if ( value === undefined ) {\n                return elem.nodeType === 1 ?\n                    elem.innerHTML.replace( rinlinejQuery, \"\" ) :\n                    undefined;\n            }\n\n            // See if we can take a shortcut and just use innerHTML\n            if ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n                ( support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n                ( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n                !wrapMap[ (rtagName.exec( value ) || [ \"\", \"\" ])[ 1 ].toLowerCase() ] ) {\n\n                value = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n                try {\n                    for (; i < l; i++ ) {\n                        // Remove element nodes and prevent memory leaks\n                        elem = this[i] || {};\n                        if ( elem.nodeType === 1 ) {\n                            jQuery.cleanData( getAll( elem, false ) );\n                            elem.innerHTML = value;\n                        }\n                    }\n\n                    elem = 0;\n\n                // If using innerHTML throws an exception, use the fallback method\n                } catch(e) {}\n            }\n\n            if ( elem ) {\n                this.empty().append( value );\n            }\n        }, null, value, arguments.length );\n    },\n\n    replaceWith: function() {\n        var arg = arguments[ 0 ];\n\n        // Make the changes, replacing each context element with the new content\n        this.domManip( arguments, function( elem ) {\n            arg = this.parentNode;\n\n            jQuery.cleanData( getAll( this ) );\n\n            if ( arg ) {\n                arg.replaceChild( elem, this );\n            }\n        });\n\n        // Force removal if there was no new content (e.g., from empty arguments)\n        return arg && (arg.length || arg.nodeType) ? this : this.remove();\n    },\n\n    detach: function( selector ) {\n        return this.remove( selector, true );\n    },\n\n    domManip: function( args, callback ) {\n\n        // Flatten any nested arrays\n        args = concat.apply( [], args );\n\n        var first, node, hasScripts,\n            scripts, doc, fragment,\n            i = 0,\n            l = this.length,\n            set = this,\n            iNoClone = l - 1,\n            value = args[0],\n            isFunction = jQuery.isFunction( value );\n\n        // We can't cloneNode fragments that contain checked, in WebKit\n        if ( isFunction ||\n                ( l > 1 && typeof value === \"string\" &&\n                    !support.checkClone && rchecked.test( value ) ) ) {\n            return this.each(function( index ) {\n                var self = set.eq( index );\n                if ( isFunction ) {\n                    args[0] = value.call( this, index, self.html() );\n                }\n                self.domManip( args, callback );\n            });\n        }\n\n        if ( l ) {\n            fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n            first = fragment.firstChild;\n\n            if ( fragment.childNodes.length === 1 ) {\n                fragment = first;\n            }\n\n            if ( first ) {\n                scripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n                hasScripts = scripts.length;\n\n                // Use the original fragment for the last item instead of the first because it can end up\n                // being emptied incorrectly in certain situations (#8070).\n                for ( ; i < l; i++ ) {\n                    node = fragment;\n\n                    if ( i !== iNoClone ) {\n                        node = jQuery.clone( node, true, true );\n\n                        // Keep references to cloned scripts for later restoration\n                        if ( hasScripts ) {\n                            jQuery.merge( scripts, getAll( node, \"script\" ) );\n                        }\n                    }\n\n                    callback.call( this[i], node, i );\n                }\n\n                if ( hasScripts ) {\n                    doc = scripts[ scripts.length - 1 ].ownerDocument;\n\n                    // Reenable scripts\n                    jQuery.map( scripts, restoreScript );\n\n                    // Evaluate executable scripts on first document insertion\n                    for ( i = 0; i < hasScripts; i++ ) {\n                        node = scripts[ i ];\n                        if ( rscriptType.test( node.type || \"\" ) &&\n                            !jQuery._data( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n                            if ( node.src ) {\n                                // Optional AJAX dependency, but won't run scripts if not present\n                                if ( jQuery._evalUrl ) {\n                                    jQuery._evalUrl( node.src );\n                                }\n                            } else {\n                                jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || \"\" ).replace( rcleanScript, \"\" ) );\n                            }\n                        }\n                    }\n                }\n\n                // Fix #11809: Avoid leaking memory\n                fragment = first = null;\n            }\n        }\n\n        return this;\n    }\n});\n\njQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n}, function( name, original ) {\n    jQuery.fn[ name ] = function( selector ) {\n        var elems,\n            i = 0,\n            ret = [],\n            insert = jQuery( selector ),\n            last = insert.length - 1;\n\n        for ( ; i <= last; i++ ) {\n            elems = i === last ? this : this.clone(true);\n            jQuery( insert[i] )[ original ]( elems );\n\n            // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n            push.apply( ret, elems.get() );\n        }\n\n        return this.pushStack( ret );\n    };\n});\n\n\nvar iframe,\n    elemdisplay = {};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n    var style,\n        elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n        // getDefaultComputedStyle might be reliably used only on attached element\n        display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n\n            // Use of this method is a temporary fix (more like optmization) until something better comes along,\n            // since it was removed from specification and supported only in FF\n            style.display : jQuery.css( elem[ 0 ], \"display\" );\n\n    // We don't have any data stored on the element,\n    // so use \"detach\" method as fast way to get rid of the element\n    elem.detach();\n\n    return display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n    var doc = document,\n        display = elemdisplay[ nodeName ];\n\n    if ( !display ) {\n        display = actualDisplay( nodeName, doc );\n\n        // If the simple way fails, read from inside an iframe\n        if ( display === \"none\" || !display ) {\n\n            // Use the already-created iframe if possible\n            iframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n\n            // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n            doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;\n\n            // Support: IE\n            doc.write();\n            doc.close();\n\n            display = actualDisplay( nodeName, doc );\n            iframe.detach();\n        }\n\n        // Store the correct default display\n        elemdisplay[ nodeName ] = display;\n    }\n\n    return display;\n}\n\n\n(function() {\n    var shrinkWrapBlocksVal;\n\n    support.shrinkWrapBlocks = function() {\n        if ( shrinkWrapBlocksVal != null ) {\n            return shrinkWrapBlocksVal;\n        }\n\n        // Will be changed later if needed.\n        shrinkWrapBlocksVal = false;\n\n        // Minified: var b,c,d\n        var div, body, container;\n\n        body = document.getElementsByTagName( \"body\" )[ 0 ];\n        if ( !body || !body.style ) {\n            // Test fired too early or in an unsupported environment, exit.\n            return;\n        }\n\n        // Setup\n        div = document.createElement( \"div\" );\n        container = document.createElement( \"div\" );\n        container.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n        body.appendChild( container ).appendChild( div );\n\n        // Support: IE6\n        // Check if elements with layout shrink-wrap their children\n        if ( typeof div.style.zoom !== strundefined ) {\n            // Reset CSS: box-sizing; display; margin; border\n            div.style.cssText =\n                // Support: Firefox<29, Android 2.3\n                // Vendor-prefix box-sizing\n                \"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n                \"box-sizing:content-box;display:block;margin:0;border:0;\" +\n                \"padding:1px;width:1px;zoom:1\";\n            div.appendChild( document.createElement( \"div\" ) ).style.width = \"5px\";\n            shrinkWrapBlocksVal = div.offsetWidth !== 3;\n        }\n\n        body.removeChild( container );\n\n        return shrinkWrapBlocksVal;\n    };\n\n})();\nvar rmargin = (/^margin/);\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\n\n\nvar getStyles, curCSS,\n    rposition = /^(top|right|bottom|left)$/;\n\nif ( window.getComputedStyle ) {\n    getStyles = function( elem ) {\n        // Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n        // IE throws on elements created in popups\n        // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n        if ( elem.ownerDocument.defaultView.opener ) {\n            return elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n        }\n\n        return window.getComputedStyle( elem, null );\n    };\n\n    curCSS = function( elem, name, computed ) {\n        var width, minWidth, maxWidth, ret,\n            style = elem.style;\n\n        computed = computed || getStyles( elem );\n\n        // getPropertyValue is only needed for .css('filter') in IE9, see #12537\n        ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;\n\n        if ( computed ) {\n\n            if ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n                ret = jQuery.style( elem, name );\n            }\n\n            // A tribute to the \"awesome hack by Dean Edwards\"\n            // Chrome < 17 and Safari 5.0 uses \"computed value\" instead of \"used value\" for margin-right\n            // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n            if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n                // Remember the original values\n                width = style.width;\n                minWidth = style.minWidth;\n                maxWidth = style.maxWidth;\n\n                // Put in the new values to get a computed value out\n                style.minWidth = style.maxWidth = style.width = ret;\n                ret = computed.width;\n\n                // Revert the changed values\n                style.width = width;\n                style.minWidth = minWidth;\n                style.maxWidth = maxWidth;\n            }\n        }\n\n        // Support: IE\n        // IE returns zIndex value as an integer.\n        return ret === undefined ?\n            ret :\n            ret + \"\";\n    };\n} else if ( document.documentElement.currentStyle ) {\n    getStyles = function( elem ) {\n        return elem.currentStyle;\n    };\n\n    curCSS = function( elem, name, computed ) {\n        var left, rs, rsLeft, ret,\n            style = elem.style;\n\n        computed = computed || getStyles( elem );\n        ret = computed ? computed[ name ] : undefined;\n\n        // Avoid setting ret to empty string here\n        // so we don't default to auto\n        if ( ret == null && style && style[ name ] ) {\n            ret = style[ name ];\n        }\n\n        // From the awesome hack by Dean Edwards\n        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n        // If we're not dealing with a regular pixel number\n        // but a number that has a weird ending, we need to convert it to pixels\n        // but not position css attributes, as those are proportional to the parent element instead\n        // and we can't measure the parent instead because it might trigger a \"stacking dolls\" problem\n        if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {\n\n            // Remember the original values\n            left = style.left;\n            rs = elem.runtimeStyle;\n            rsLeft = rs && rs.left;\n\n            // Put in the new values to get a computed value out\n            if ( rsLeft ) {\n                rs.left = elem.currentStyle.left;\n            }\n            style.left = name === \"fontSize\" ? \"1em\" : ret;\n            ret = style.pixelLeft + \"px\";\n\n            // Revert the changed values\n            style.left = left;\n            if ( rsLeft ) {\n                rs.left = rsLeft;\n            }\n        }\n\n        // Support: IE\n        // IE returns zIndex value as an integer.\n        return ret === undefined ?\n            ret :\n            ret + \"\" || \"auto\";\n    };\n}\n\n\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n    // Define the hook, we'll check on the first run if it's really needed.\n    return {\n        get: function() {\n            var condition = conditionFn();\n\n            if ( condition == null ) {\n                // The test was not ready at this point; screw the hook this time\n                // but check again when needed next time.\n                return;\n            }\n\n            if ( condition ) {\n                // Hook not needed (or it's not possible to use it due to missing dependency),\n                // remove it.\n                // Since there are no other hooks for marginRight, remove the whole object.\n                delete this.get;\n                return;\n            }\n\n            // Hook needed; redefine it so that the support test is not executed again.\n\n            return (this.get = hookFn).apply( this, arguments );\n        }\n    };\n}\n\n\n(function() {\n    // Minified: var b,c,d,e,f,g, h,i\n    var div, style, a, pixelPositionVal, boxSizingReliableVal,\n        reliableHiddenOffsetsVal, reliableMarginRightVal;\n\n    // Setup\n    div = document.createElement( \"div\" );\n    div.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n    a = div.getElementsByTagName( \"a\" )[ 0 ];\n    style = a && a.style;\n\n    // Finish early in limited (non-browser) environments\n    if ( !style ) {\n        return;\n    }\n\n    style.cssText = \"float:left;opacity:.5\";\n\n    // Support: IE<9\n    // Make sure that element opacity exists (as opposed to filter)\n    support.opacity = style.opacity === \"0.5\";\n\n    // Verify style float existence\n    // (IE uses styleFloat instead of cssFloat)\n    support.cssFloat = !!style.cssFloat;\n\n    div.style.backgroundClip = \"content-box\";\n    div.cloneNode( true ).style.backgroundClip = \"\";\n    support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n    // Support: Firefox<29, Android 2.3\n    // Vendor-prefix box-sizing\n    support.boxSizing = style.boxSizing === \"\" || style.MozBoxSizing === \"\" ||\n        style.WebkitBoxSizing === \"\";\n\n    jQuery.extend(support, {\n        reliableHiddenOffsets: function() {\n            if ( reliableHiddenOffsetsVal == null ) {\n                computeStyleTests();\n            }\n            return reliableHiddenOffsetsVal;\n        },\n\n        boxSizingReliable: function() {\n            if ( boxSizingReliableVal == null ) {\n                computeStyleTests();\n            }\n            return boxSizingReliableVal;\n        },\n\n        pixelPosition: function() {\n            if ( pixelPositionVal == null ) {\n                computeStyleTests();\n            }\n            return pixelPositionVal;\n        },\n\n        // Support: Android 2.3\n        reliableMarginRight: function() {\n            if ( reliableMarginRightVal == null ) {\n                computeStyleTests();\n            }\n            return reliableMarginRightVal;\n        }\n    });\n\n    function computeStyleTests() {\n        // Minified: var b,c,d,j\n        var div, body, container, contents;\n\n        body = document.getElementsByTagName( \"body\" )[ 0 ];\n        if ( !body || !body.style ) {\n            // Test fired too early or in an unsupported environment, exit.\n            return;\n        }\n\n        // Setup\n        div = document.createElement( \"div\" );\n        container = document.createElement( \"div\" );\n        container.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n        body.appendChild( container ).appendChild( div );\n\n        div.style.cssText =\n            // Support: Firefox<29, Android 2.3\n            // Vendor-prefix box-sizing\n            \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n            \"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" +\n            \"border:1px;padding:1px;width:4px;position:absolute\";\n\n        // Support: IE<9\n        // Assume reasonable values in the absence of getComputedStyle\n        pixelPositionVal = boxSizingReliableVal = false;\n        reliableMarginRightVal = true;\n\n        // Check for getComputedStyle so that this code is not run in IE<9.\n        if ( window.getComputedStyle ) {\n            pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\n            boxSizingReliableVal =\n                ( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\n\n            // Support: Android 2.3\n            // Div with explicit width and no margin-right incorrectly\n            // gets computed margin-right based on width of container (#3333)\n            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n            contents = div.appendChild( document.createElement( \"div\" ) );\n\n            // Reset CSS: box-sizing; display; margin; border; padding\n            contents.style.cssText = div.style.cssText =\n                // Support: Firefox<29, Android 2.3\n                // Vendor-prefix box-sizing\n                \"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n                \"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n            contents.style.marginRight = contents.style.width = \"0\";\n            div.style.width = \"1px\";\n\n            reliableMarginRightVal =\n                !parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );\n\n            div.removeChild( contents );\n        }\n\n        // Support: IE8\n        // Check if table cells still have offsetWidth/Height when they are set\n        // to display:none and there are still other visible table cells in a\n        // table row; if so, offsetWidth/Height are not reliable for use when\n        // determining if an element has been hidden directly using\n        // display:none (it is still safe to use offsets if a parent element is\n        // hidden; don safety goggles and see bug #4512 for more information).\n        div.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n        contents = div.getElementsByTagName( \"td\" );\n        contents[ 0 ].style.cssText = \"margin:0;border:0;padding:0;display:none\";\n        reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;\n        if ( reliableHiddenOffsetsVal ) {\n            contents[ 0 ].style.display = \"\";\n            contents[ 1 ].style.display = \"none\";\n            reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;\n        }\n\n        body.removeChild( container );\n    }\n\n})();\n\n\n// A method for quickly swapping in/out CSS properties to get correct calculations.\njQuery.swap = function( elem, options, callback, args ) {\n    var ret, name,\n        old = {};\n\n    // Remember the old values, and insert the new ones\n    for ( name in options ) {\n        old[ name ] = elem.style[ name ];\n        elem.style[ name ] = options[ name ];\n    }\n\n    ret = callback.apply( elem, args || [] );\n\n    // Revert the old values\n    for ( name in options ) {\n        elem.style[ name ] = old[ name ];\n    }\n\n    return ret;\n};\n\n\nvar\n        ralpha = /alpha\\([^)]*\\)/i,\n    ropacity = /opacity\\s*=\\s*([^)]*)/,\n\n    // swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n    rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n    rnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n    rrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n\n    cssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n    cssNormalTransform = {\n        letterSpacing: \"0\",\n        fontWeight: \"400\"\n    },\n\n    cssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n    // shortcut for names that are not vendor prefixed\n    if ( name in style ) {\n        return name;\n    }\n\n    // check for vendor prefixed names\n    var capName = name.charAt(0).toUpperCase() + name.slice(1),\n        origName = name,\n        i = cssPrefixes.length;\n\n    while ( i-- ) {\n        name = cssPrefixes[ i ] + capName;\n        if ( name in style ) {\n            return name;\n        }\n    }\n\n    return origName;\n}\n\nfunction showHide( elements, show ) {\n    var display, elem, hidden,\n        values = [],\n        index = 0,\n        length = elements.length;\n\n    for ( ; index < length; index++ ) {\n        elem = elements[ index ];\n        if ( !elem.style ) {\n            continue;\n        }\n\n        values[ index ] = jQuery._data( elem, \"olddisplay\" );\n        display = elem.style.display;\n        if ( show ) {\n            // Reset the inline display of this element to learn if it is\n            // being hidden by cascaded rules or not\n            if ( !values[ index ] && display === \"none\" ) {\n                elem.style.display = \"\";\n            }\n\n            // Set elements which have been overridden with display: none\n            // in a stylesheet to whatever the default browser style is\n            // for such an element\n            if ( elem.style.display === \"\" && isHidden( elem ) ) {\n                values[ index ] = jQuery._data( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n            }\n        } else {\n            hidden = isHidden( elem );\n\n            if ( display && display !== \"none\" || !hidden ) {\n                jQuery._data( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n            }\n        }\n    }\n\n    // Set the display of most of the elements in a second loop\n    // to avoid the constant reflow\n    for ( index = 0; index < length; index++ ) {\n        elem = elements[ index ];\n        if ( !elem.style ) {\n            continue;\n        }\n        if ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n            elem.style.display = show ? values[ index ] || \"\" : \"none\";\n        }\n    }\n\n    return elements;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n    var matches = rnumsplit.exec( value );\n    return matches ?\n        // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n        Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n        value;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n    var i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n        // If we already have the right measurement, avoid augmentation\n        4 :\n        // Otherwise initialize for horizontal or vertical properties\n        name === \"width\" ? 1 : 0,\n\n        val = 0;\n\n    for ( ; i < 4; i += 2 ) {\n        // both box models exclude margin, so add it if we want it\n        if ( extra === \"margin\" ) {\n            val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n        }\n\n        if ( isBorderBox ) {\n            // border-box includes padding, so remove it if we want content\n            if ( extra === \"content\" ) {\n                val -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n            }\n\n            // at this point, extra isn't border nor margin, so remove border\n            if ( extra !== \"margin\" ) {\n                val -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n            }\n        } else {\n            // at this point, extra isn't content, so add padding\n            val += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n            // at this point, extra isn't content nor padding, so add border\n            if ( extra !== \"padding\" ) {\n                val += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n            }\n        }\n    }\n\n    return val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n    // Start with offset property, which is equivalent to the border-box value\n    var valueIsBorderBox = true,\n        val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n        styles = getStyles( elem ),\n        isBorderBox = support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n    // some non-html elements return undefined for offsetWidth, so check for null/undefined\n    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n    if ( val <= 0 || val == null ) {\n        // Fall back to computed then uncomputed css if necessary\n        val = curCSS( elem, name, styles );\n        if ( val < 0 || val == null ) {\n            val = elem.style[ name ];\n        }\n\n        // Computed unit is not pixels. Stop here and return.\n        if ( rnumnonpx.test(val) ) {\n            return val;\n        }\n\n        // we need the check for style in case a browser which returns unreliable values\n        // for getComputedStyle silently falls back to the reliable elem.style\n        valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );\n\n        // Normalize \"\", auto, and prepare for extra\n        val = parseFloat( val ) || 0;\n    }\n\n    // use the active box-sizing model to add/subtract irrelevant styles\n    return ( val +\n        augmentWidthOrHeight(\n            elem,\n            name,\n            extra || ( isBorderBox ? \"border\" : \"content\" ),\n            valueIsBorderBox,\n            styles\n        )\n    ) + \"px\";\n}\n\njQuery.extend({\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n        opacity: {\n            get: function( elem, computed ) {\n                if ( computed ) {\n                    // We should always get a number back from opacity\n                    var ret = curCSS( elem, \"opacity\" );\n                    return ret === \"\" ? \"1\" : ret;\n                }\n            }\n        }\n    },\n\n    // Don't automatically add \"px\" to these possibly-unitless properties\n    cssNumber: {\n        \"columnCount\": true,\n        \"fillOpacity\": true,\n        \"flexGrow\": true,\n        \"flexShrink\": true,\n        \"fontWeight\": true,\n        \"lineHeight\": true,\n        \"opacity\": true,\n        \"order\": true,\n        \"orphans\": true,\n        \"widows\": true,\n        \"zIndex\": true,\n        \"zoom\": true\n    },\n\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {\n        // normalize float css property\n        \"float\": support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n    },\n\n    // Get and set the style property on a DOM Node\n    style: function( elem, name, value, extra ) {\n        // Don't set styles on text and comment nodes\n        if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n            return;\n        }\n\n        // Make sure that we're working with the right name\n        var ret, type, hooks,\n            origName = jQuery.camelCase( name ),\n            style = elem.style;\n\n        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n        // gets hook for the prefixed version\n        // followed by the unprefixed version\n        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n        // Check if we're setting a value\n        if ( value !== undefined ) {\n            type = typeof value;\n\n            // convert relative number strings (+= or -=) to relative numbers. #7345\n            if ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n                value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n                // Fixes bug #9237\n                type = \"number\";\n            }\n\n            // Make sure that null and NaN values aren't set. See: #7116\n            if ( value == null || value !== value ) {\n                return;\n            }\n\n            // If a number was passed in, add 'px' to the (except for certain CSS properties)\n            if ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n                value += \"px\";\n            }\n\n            // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n            // but it would mean to define eight (for every problematic property) identical functions\n            if ( !support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0 ) {\n                style[ name ] = \"inherit\";\n            }\n\n            // If a hook was provided, use that value, otherwise just set the specified value\n            if ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\n                // Support: IE\n                // Swallow errors from 'invalid' CSS values (#5509)\n                try {\n                    style[ name ] = value;\n                } catch(e) {}\n            }\n\n        } else {\n            // If a hook was provided get the non-computed value from there\n            if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n                return ret;\n            }\n\n            // Otherwise just get the value from the style object\n            return style[ name ];\n        }\n    },\n\n    css: function( elem, name, extra, styles ) {\n        var num, val, hooks,\n            origName = jQuery.camelCase( name );\n\n        // Make sure that we're working with the right name\n        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n        // gets hook for the prefixed version\n        // followed by the unprefixed version\n        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n        // If a hook was provided get the computed value from there\n        if ( hooks && \"get\" in hooks ) {\n            val = hooks.get( elem, true, extra );\n        }\n\n        // Otherwise, if a way to get the computed value exists, use that\n        if ( val === undefined ) {\n            val = curCSS( elem, name, styles );\n        }\n\n        //convert \"normal\" to computed value\n        if ( val === \"normal\" && name in cssNormalTransform ) {\n            val = cssNormalTransform[ name ];\n        }\n\n        // Return, converting to number if forced or a qualifier was provided and val looks numeric\n        if ( extra === \"\" || extra ) {\n            num = parseFloat( val );\n            return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n        }\n        return val;\n    }\n});\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n    jQuery.cssHooks[ name ] = {\n        get: function( elem, computed, extra ) {\n            if ( computed ) {\n                // certain elements can have dimension info if we invisibly show them\n                // however, it must have a current display style that would benefit from this\n                return rdisplayswap.test( jQuery.css( elem, \"display\" ) ) && elem.offsetWidth === 0 ?\n                    jQuery.swap( elem, cssShow, function() {\n                        return getWidthOrHeight( elem, name, extra );\n                    }) :\n                    getWidthOrHeight( elem, name, extra );\n            }\n        },\n\n        set: function( elem, value, extra ) {\n            var styles = extra && getStyles( elem );\n            return setPositiveNumber( elem, value, extra ?\n                augmentWidthOrHeight(\n                    elem,\n                    name,\n                    extra,\n                    support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n                    styles\n                ) : 0\n            );\n        }\n    };\n});\n\nif ( !support.opacity ) {\n    jQuery.cssHooks.opacity = {\n        get: function( elem, computed ) {\n            // IE uses filters for opacity\n            return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\" ) ?\n                ( 0.01 * parseFloat( RegExp.$1 ) ) + \"\" :\n                computed ? \"1\" : \"\";\n        },\n\n        set: function( elem, value ) {\n            var style = elem.style,\n                currentStyle = elem.currentStyle,\n                opacity = jQuery.isNumeric( value ) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n                filter = currentStyle && currentStyle.filter || style.filter || \"\";\n\n            // IE has trouble with opacity if it does not have layout\n            // Force it by setting the zoom level\n            style.zoom = 1;\n\n            // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n            // if value === \"\", then remove inline opacity #12685\n            if ( ( value >= 1 || value === \"\" ) &&\n                    jQuery.trim( filter.replace( ralpha, \"\" ) ) === \"\" &&\n                    style.removeAttribute ) {\n\n                // Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n                // if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n                // style.removeAttribute is IE Only, but so apparently is this code path...\n                style.removeAttribute( \"filter\" );\n\n                // if there is no filter style applied in a css rule or unset inline opacity, we are done\n                if ( value === \"\" || currentStyle && !currentStyle.filter ) {\n                    return;\n                }\n            }\n\n            // otherwise, set new filter values\n            style.filter = ralpha.test( filter ) ?\n                filter.replace( ralpha, opacity ) :\n                filter + \" \" + opacity;\n        }\n    };\n}\n\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n    function( elem, computed ) {\n        if ( computed ) {\n            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n            // Work around by temporarily setting element display to inline-block\n            return jQuery.swap( elem, { \"display\": \"inline-block\" },\n                curCSS, [ elem, \"marginRight\" ] );\n        }\n    }\n);\n\n// These hooks are used by animate to expand properties\njQuery.each({\n    margin: \"\",\n    padding: \"\",\n    border: \"Width\"\n}, function( prefix, suffix ) {\n    jQuery.cssHooks[ prefix + suffix ] = {\n        expand: function( value ) {\n            var i = 0,\n                expanded = {},\n\n                // assumes a single number if not a string\n                parts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n            for ( ; i < 4; i++ ) {\n                expanded[ prefix + cssExpand[ i ] + suffix ] =\n                    parts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n            }\n\n            return expanded;\n        }\n    };\n\n    if ( !rmargin.test( prefix ) ) {\n        jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n    }\n});\n\njQuery.fn.extend({\n    css: function( name, value ) {\n        return access( this, function( elem, name, value ) {\n            var styles, len,\n                map = {},\n                i = 0;\n\n            if ( jQuery.isArray( name ) ) {\n                styles = getStyles( elem );\n                len = name.length;\n\n                for ( ; i < len; i++ ) {\n                    map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n                }\n\n                return map;\n            }\n\n            return value !== undefined ?\n                jQuery.style( elem, name, value ) :\n                jQuery.css( elem, name );\n        }, name, value, arguments.length > 1 );\n    },\n    show: function() {\n        return showHide( this, true );\n    },\n    hide: function() {\n        return showHide( this );\n    },\n    toggle: function( state ) {\n        if ( typeof state === \"boolean\" ) {\n            return state ? this.show() : this.hide();\n        }\n\n        return this.each(function() {\n            if ( isHidden( this ) ) {\n                jQuery( this ).show();\n            } else {\n                jQuery( this ).hide();\n            }\n        });\n    }\n});\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n    return new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n    constructor: Tween,\n    init: function( elem, options, prop, end, easing, unit ) {\n        this.elem = elem;\n        this.prop = prop;\n        this.easing = easing || \"swing\";\n        this.options = options;\n        this.start = this.now = this.cur();\n        this.end = end;\n        this.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n    },\n    cur: function() {\n        var hooks = Tween.propHooks[ this.prop ];\n\n        return hooks && hooks.get ?\n            hooks.get( this ) :\n            Tween.propHooks._default.get( this );\n    },\n    run: function( percent ) {\n        var eased,\n            hooks = Tween.propHooks[ this.prop ];\n\n        if ( this.options.duration ) {\n            this.pos = eased = jQuery.easing[ this.easing ](\n                percent, this.options.duration * percent, 0, 1, this.options.duration\n            );\n        } else {\n            this.pos = eased = percent;\n        }\n        this.now = ( this.end - this.start ) * eased + this.start;\n\n        if ( this.options.step ) {\n            this.options.step.call( this.elem, this.now, this );\n        }\n\n        if ( hooks && hooks.set ) {\n            hooks.set( this );\n        } else {\n            Tween.propHooks._default.set( this );\n        }\n        return this;\n    }\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n    _default: {\n        get: function( tween ) {\n            var result;\n\n            if ( tween.elem[ tween.prop ] != null &&\n                (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n                return tween.elem[ tween.prop ];\n            }\n\n            // passing an empty string as a 3rd parameter to .css will automatically\n            // attempt a parseFloat and fallback to a string if the parse fails\n            // so, simple values such as \"10px\" are parsed to Float.\n            // complex values such as \"rotate(1rad)\" are returned as is.\n            result = jQuery.css( tween.elem, tween.prop, \"\" );\n            // Empty strings, null, undefined and \"auto\" are converted to 0.\n            return !result || result === \"auto\" ? 0 : result;\n        },\n        set: function( tween ) {\n            // use step hook for back compat - use cssHook if its there - use .style if its\n            // available and use plain properties where available\n            if ( jQuery.fx.step[ tween.prop ] ) {\n                jQuery.fx.step[ tween.prop ]( tween );\n            } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n                jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n            } else {\n                tween.elem[ tween.prop ] = tween.now;\n            }\n        }\n    }\n};\n\n// Support: IE <=9\n// Panic based approach to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function( tween ) {\n        if ( tween.elem.nodeType && tween.elem.parentNode ) {\n            tween.elem[ tween.prop ] = tween.now;\n        }\n    }\n};\n\njQuery.easing = {\n    linear: function( p ) {\n        return p;\n    },\n    swing: function( p ) {\n        return 0.5 - Math.cos( p * Math.PI ) / 2;\n    }\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n    fxNow, timerId,\n    rfxtypes = /^(?:toggle|show|hide)$/,\n    rfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n    rrun = /queueHooks$/,\n    animationPrefilters = [ defaultPrefilter ],\n    tweeners = {\n        \"*\": [ function( prop, value ) {\n            var tween = this.createTween( prop, value ),\n                target = tween.cur(),\n                parts = rfxnum.exec( value ),\n                unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n                // Starting value computation is required for potential unit mismatches\n                start = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n                    rfxnum.exec( jQuery.css( tween.elem, prop ) ),\n                scale = 1,\n                maxIterations = 20;\n\n            if ( start && start[ 3 ] !== unit ) {\n                // Trust units reported by jQuery.css\n                unit = unit || start[ 3 ];\n\n                // Make sure we update the tween properties later on\n                parts = parts || [];\n\n                // Iteratively approximate from a nonzero starting point\n                start = +target || 1;\n\n                do {\n                    // If previous iteration zeroed out, double until we get *something*\n                    // Use a string for doubling factor so we don't accidentally see scale as unchanged below\n                    scale = scale || \".5\";\n\n                    // Adjust and apply\n                    start = start / scale;\n                    jQuery.style( tween.elem, prop, start + unit );\n\n                // Update scale, tolerating zero or NaN from tween.cur()\n                // And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n                } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n            }\n\n            // Update tween properties\n            if ( parts ) {\n                start = tween.start = +start || +target || 0;\n                tween.unit = unit;\n                // If a +=/-= token was provided, we're doing a relative animation\n                tween.end = parts[ 1 ] ?\n                    start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n                    +parts[ 2 ];\n            }\n\n            return tween;\n        } ]\n    };\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n    setTimeout(function() {\n        fxNow = undefined;\n    });\n    return ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n    var which,\n        attrs = { height: type },\n        i = 0;\n\n    // if we include width, step value is 1 to do all cssExpand values,\n    // if we don't include width, step value is 2 to skip over Left and Right\n    includeWidth = includeWidth ? 1 : 0;\n    for ( ; i < 4 ; i += 2 - includeWidth ) {\n        which = cssExpand[ i ];\n        attrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n    }\n\n    if ( includeWidth ) {\n        attrs.opacity = attrs.width = type;\n    }\n\n    return attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n    var tween,\n        collection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n        index = 0,\n        length = collection.length;\n    for ( ; index < length; index++ ) {\n        if ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n            // we're done with this property\n            return tween;\n        }\n    }\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n    /* jshint validthis: true */\n    var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n        anim = this,\n        orig = {},\n        style = elem.style,\n        hidden = elem.nodeType && isHidden( elem ),\n        dataShow = jQuery._data( elem, \"fxshow\" );\n\n    // handle queue: false promises\n    if ( !opts.queue ) {\n        hooks = jQuery._queueHooks( elem, \"fx\" );\n        if ( hooks.unqueued == null ) {\n            hooks.unqueued = 0;\n            oldfire = hooks.empty.fire;\n            hooks.empty.fire = function() {\n                if ( !hooks.unqueued ) {\n                    oldfire();\n                }\n            };\n        }\n        hooks.unqueued++;\n\n        anim.always(function() {\n            // doing this makes sure that the complete handler will be called\n            // before this completes\n            anim.always(function() {\n                hooks.unqueued--;\n                if ( !jQuery.queue( elem, \"fx\" ).length ) {\n                    hooks.empty.fire();\n                }\n            });\n        });\n    }\n\n    // height/width overflow pass\n    if ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n        // Make sure that nothing sneaks out\n        // Record all 3 overflow attributes because IE does not\n        // change the overflow attribute when overflowX and\n        // overflowY are set to the same value\n        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n        // Set display property to inline-block for height/width\n        // animations on inline elements that are having width/height animated\n        display = jQuery.css( elem, \"display\" );\n\n        // Test default display if display is currently \"none\"\n        checkDisplay = display === \"none\" ?\n            jQuery._data( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n\n        if ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n            // inline-level elements accept inline-block;\n            // block-level elements need to be inline with layout\n            if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === \"inline\" ) {\n                style.display = \"inline-block\";\n            } else {\n                style.zoom = 1;\n            }\n        }\n    }\n\n    if ( opts.overflow ) {\n        style.overflow = \"hidden\";\n        if ( !support.shrinkWrapBlocks() ) {\n            anim.always(function() {\n                style.overflow = opts.overflow[ 0 ];\n                style.overflowX = opts.overflow[ 1 ];\n                style.overflowY = opts.overflow[ 2 ];\n            });\n        }\n    }\n\n    // show/hide pass\n    for ( prop in props ) {\n        value = props[ prop ];\n        if ( rfxtypes.exec( value ) ) {\n            delete props[ prop ];\n            toggle = toggle || value === \"toggle\";\n            if ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n                // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n                if ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n                    hidden = true;\n                } else {\n                    continue;\n                }\n            }\n            orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n        // Any non-fx value stops us from restoring the original display value\n        } else {\n            display = undefined;\n        }\n    }\n\n    if ( !jQuery.isEmptyObject( orig ) ) {\n        if ( dataShow ) {\n            if ( \"hidden\" in dataShow ) {\n                hidden = dataShow.hidden;\n            }\n        } else {\n            dataShow = jQuery._data( elem, \"fxshow\", {} );\n        }\n\n        // store state if its toggle - enables .stop().toggle() to \"reverse\"\n        if ( toggle ) {\n            dataShow.hidden = !hidden;\n        }\n        if ( hidden ) {\n            jQuery( elem ).show();\n        } else {\n            anim.done(function() {\n                jQuery( elem ).hide();\n            });\n        }\n        anim.done(function() {\n            var prop;\n            jQuery._removeData( elem, \"fxshow\" );\n            for ( prop in orig ) {\n                jQuery.style( elem, prop, orig[ prop ] );\n            }\n        });\n        for ( prop in orig ) {\n            tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n            if ( !( prop in dataShow ) ) {\n                dataShow[ prop ] = tween.start;\n                if ( hidden ) {\n                    tween.end = tween.start;\n                    tween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n                }\n            }\n        }\n\n    // If this is a noop like .hide().hide(), restore an overwritten display value\n    } else if ( (display === \"none\" ? defaultDisplay( elem.nodeName ) : display) === \"inline\" ) {\n        style.display = display;\n    }\n}\n\nfunction propFilter( props, specialEasing ) {\n    var index, name, easing, value, hooks;\n\n    // camelCase, specialEasing and expand cssHook pass\n    for ( index in props ) {\n        name = jQuery.camelCase( index );\n        easing = specialEasing[ name ];\n        value = props[ index ];\n        if ( jQuery.isArray( value ) ) {\n            easing = value[ 1 ];\n            value = props[ index ] = value[ 0 ];\n        }\n\n        if ( index !== name ) {\n            props[ name ] = value;\n            delete props[ index ];\n        }\n\n        hooks = jQuery.cssHooks[ name ];\n        if ( hooks && \"expand\" in hooks ) {\n            value = hooks.expand( value );\n            delete props[ name ];\n\n            // not quite $.extend, this wont overwrite keys already present.\n            // also - reusing 'index' from above because we have the correct \"name\"\n            for ( index in value ) {\n                if ( !( index in props ) ) {\n                    props[ index ] = value[ index ];\n                    specialEasing[ index ] = easing;\n                }\n            }\n        } else {\n            specialEasing[ name ] = easing;\n        }\n    }\n}\n\nfunction Animation( elem, properties, options ) {\n    var result,\n        stopped,\n        index = 0,\n        length = animationPrefilters.length,\n        deferred = jQuery.Deferred().always( function() {\n            // don't match elem in the :animated selector\n            delete tick.elem;\n        }),\n        tick = function() {\n            if ( stopped ) {\n                return false;\n            }\n            var currentTime = fxNow || createFxNow(),\n                remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n                // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n                temp = remaining / animation.duration || 0,\n                percent = 1 - temp,\n                index = 0,\n                length = animation.tweens.length;\n\n            for ( ; index < length ; index++ ) {\n                animation.tweens[ index ].run( percent );\n            }\n\n            deferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n            if ( percent < 1 && length ) {\n                return remaining;\n            } else {\n                deferred.resolveWith( elem, [ animation ] );\n                return false;\n            }\n        },\n        animation = deferred.promise({\n            elem: elem,\n            props: jQuery.extend( {}, properties ),\n            opts: jQuery.extend( true, { specialEasing: {} }, options ),\n            originalProperties: properties,\n            originalOptions: options,\n            startTime: fxNow || createFxNow(),\n            duration: options.duration,\n            tweens: [],\n            createTween: function( prop, end ) {\n                var tween = jQuery.Tween( elem, animation.opts, prop, end,\n                        animation.opts.specialEasing[ prop ] || animation.opts.easing );\n                animation.tweens.push( tween );\n                return tween;\n            },\n            stop: function( gotoEnd ) {\n                var index = 0,\n                    // if we are going to the end, we want to run all the tweens\n                    // otherwise we skip this part\n                    length = gotoEnd ? animation.tweens.length : 0;\n                if ( stopped ) {\n                    return this;\n                }\n                stopped = true;\n                for ( ; index < length ; index++ ) {\n                    animation.tweens[ index ].run( 1 );\n                }\n\n                // resolve when we played the last frame\n                // otherwise, reject\n                if ( gotoEnd ) {\n                    deferred.resolveWith( elem, [ animation, gotoEnd ] );\n                } else {\n                    deferred.rejectWith( elem, [ animation, gotoEnd ] );\n                }\n                return this;\n            }\n        }),\n        props = animation.props;\n\n    propFilter( props, animation.opts.specialEasing );\n\n    for ( ; index < length ; index++ ) {\n        result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n        if ( result ) {\n            return result;\n        }\n    }\n\n    jQuery.map( props, createTween, animation );\n\n    if ( jQuery.isFunction( animation.opts.start ) ) {\n        animation.opts.start.call( elem, animation );\n    }\n\n    jQuery.fx.timer(\n        jQuery.extend( tick, {\n            elem: elem,\n            anim: animation,\n            queue: animation.opts.queue\n        })\n    );\n\n    // attach callbacks from options\n    return animation.progress( animation.opts.progress )\n        .done( animation.opts.done, animation.opts.complete )\n        .fail( animation.opts.fail )\n        .always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n    tweener: function( props, callback ) {\n        if ( jQuery.isFunction( props ) ) {\n            callback = props;\n            props = [ \"*\" ];\n        } else {\n            props = props.split(\" \");\n        }\n\n        var prop,\n            index = 0,\n            length = props.length;\n\n        for ( ; index < length ; index++ ) {\n            prop = props[ index ];\n            tweeners[ prop ] = tweeners[ prop ] || [];\n            tweeners[ prop ].unshift( callback );\n        }\n    },\n\n    prefilter: function( callback, prepend ) {\n        if ( prepend ) {\n            animationPrefilters.unshift( callback );\n        } else {\n            animationPrefilters.push( callback );\n        }\n    }\n});\n\njQuery.speed = function( speed, easing, fn ) {\n    var opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n        complete: fn || !fn && easing ||\n            jQuery.isFunction( speed ) && speed,\n        duration: speed,\n        easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n    };\n\n    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n        opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n    // normalize opt.queue - true/undefined/null -> \"fx\"\n    if ( opt.queue == null || opt.queue === true ) {\n        opt.queue = \"fx\";\n    }\n\n    // Queueing\n    opt.old = opt.complete;\n\n    opt.complete = function() {\n        if ( jQuery.isFunction( opt.old ) ) {\n            opt.old.call( this );\n        }\n\n        if ( opt.queue ) {\n            jQuery.dequeue( this, opt.queue );\n        }\n    };\n\n    return opt;\n};\n\njQuery.fn.extend({\n    fadeTo: function( speed, to, easing, callback ) {\n\n        // show any hidden elements after setting opacity to 0\n        return this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n            // animate to the value specified\n            .end().animate({ opacity: to }, speed, easing, callback );\n    },\n    animate: function( prop, speed, easing, callback ) {\n        var empty = jQuery.isEmptyObject( prop ),\n            optall = jQuery.speed( speed, easing, callback ),\n            doAnimation = function() {\n                // Operate on a copy of prop so per-property easing won't be lost\n                var anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n                // Empty animations, or finishing resolves immediately\n                if ( empty || jQuery._data( this, \"finish\" ) ) {\n                    anim.stop( true );\n                }\n            };\n            doAnimation.finish = doAnimation;\n\n        return empty || optall.queue === false ?\n            this.each( doAnimation ) :\n            this.queue( optall.queue, doAnimation );\n    },\n    stop: function( type, clearQueue, gotoEnd ) {\n        var stopQueue = function( hooks ) {\n            var stop = hooks.stop;\n            delete hooks.stop;\n            stop( gotoEnd );\n        };\n\n        if ( typeof type !== \"string\" ) {\n            gotoEnd = clearQueue;\n            clearQueue = type;\n            type = undefined;\n        }\n        if ( clearQueue && type !== false ) {\n            this.queue( type || \"fx\", [] );\n        }\n\n        return this.each(function() {\n            var dequeue = true,\n                index = type != null && type + \"queueHooks\",\n                timers = jQuery.timers,\n                data = jQuery._data( this );\n\n            if ( index ) {\n                if ( data[ index ] && data[ index ].stop ) {\n                    stopQueue( data[ index ] );\n                }\n            } else {\n                for ( index in data ) {\n                    if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n                        stopQueue( data[ index ] );\n                    }\n                }\n            }\n\n            for ( index = timers.length; index--; ) {\n                if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n                    timers[ index ].anim.stop( gotoEnd );\n                    dequeue = false;\n                    timers.splice( index, 1 );\n                }\n            }\n\n            // start the next in the queue if the last step wasn't forced\n            // timers currently will call their complete callbacks, which will dequeue\n            // but only if they were gotoEnd\n            if ( dequeue || !gotoEnd ) {\n                jQuery.dequeue( this, type );\n            }\n        });\n    },\n    finish: function( type ) {\n        if ( type !== false ) {\n            type = type || \"fx\";\n        }\n        return this.each(function() {\n            var index,\n                data = jQuery._data( this ),\n                queue = data[ type + \"queue\" ],\n                hooks = data[ type + \"queueHooks\" ],\n                timers = jQuery.timers,\n                length = queue ? queue.length : 0;\n\n            // enable finishing flag on private data\n            data.finish = true;\n\n            // empty the queue first\n            jQuery.queue( this, type, [] );\n\n            if ( hooks && hooks.stop ) {\n                hooks.stop.call( this, true );\n            }\n\n            // look for any active animations, and finish them\n            for ( index = timers.length; index--; ) {\n                if ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n                    timers[ index ].anim.stop( true );\n                    timers.splice( index, 1 );\n                }\n            }\n\n            // look for any animations in the old queue and finish them\n            for ( index = 0; index < length; index++ ) {\n                if ( queue[ index ] && queue[ index ].finish ) {\n                    queue[ index ].finish.call( this );\n                }\n            }\n\n            // turn off finishing flag\n            delete data.finish;\n        });\n    }\n});\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n    var cssFn = jQuery.fn[ name ];\n    jQuery.fn[ name ] = function( speed, easing, callback ) {\n        return speed == null || typeof speed === \"boolean\" ?\n            cssFn.apply( this, arguments ) :\n            this.animate( genFx( name, true ), speed, easing, callback );\n    };\n});\n\n// Generate shortcuts for custom animations\njQuery.each({\n    slideDown: genFx(\"show\"),\n    slideUp: genFx(\"hide\"),\n    slideToggle: genFx(\"toggle\"),\n    fadeIn: { opacity: \"show\" },\n    fadeOut: { opacity: \"hide\" },\n    fadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n    jQuery.fn[ name ] = function( speed, easing, callback ) {\n        return this.animate( props, speed, easing, callback );\n    };\n});\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n    var timer,\n        timers = jQuery.timers,\n        i = 0;\n\n    fxNow = jQuery.now();\n\n    for ( ; i < timers.length; i++ ) {\n        timer = timers[ i ];\n        // Checks the timer has not already been removed\n        if ( !timer() && timers[ i ] === timer ) {\n            timers.splice( i--, 1 );\n        }\n    }\n\n    if ( !timers.length ) {\n        jQuery.fx.stop();\n    }\n    fxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n    jQuery.timers.push( timer );\n    if ( timer() ) {\n        jQuery.fx.start();\n    } else {\n        jQuery.timers.pop();\n    }\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n    if ( !timerId ) {\n        timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n    }\n};\n\njQuery.fx.stop = function() {\n    clearInterval( timerId );\n    timerId = null;\n};\n\njQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    // Default speed\n    _default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n    type = type || \"fx\";\n\n    return this.queue( type, function( next, hooks ) {\n        var timeout = setTimeout( next, time );\n        hooks.stop = function() {\n            clearTimeout( timeout );\n        };\n    });\n};\n\n\n(function() {\n    // Minified: var a,b,c,d,e\n    var input, div, select, a, opt;\n\n    // Setup\n    div = document.createElement( \"div\" );\n    div.setAttribute( \"className\", \"t\" );\n    div.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n    a = div.getElementsByTagName(\"a\")[ 0 ];\n\n    // First batch of tests.\n    select = document.createElement(\"select\");\n    opt = select.appendChild( document.createElement(\"option\") );\n    input = div.getElementsByTagName(\"input\")[ 0 ];\n\n    a.style.cssText = \"top:1px\";\n\n    // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n    support.getSetAttribute = div.className !== \"t\";\n\n    // Get the style information from getAttribute\n    // (IE uses .cssText instead)\n    support.style = /top/.test( a.getAttribute(\"style\") );\n\n    // Make sure that URLs aren't manipulated\n    // (IE normalizes it by default)\n    support.hrefNormalized = a.getAttribute(\"href\") === \"/a\";\n\n    // Check the default checkbox/radio value (\"\" on WebKit; \"on\" elsewhere)\n    support.checkOn = !!input.value;\n\n    // Make sure that a selected-by-default option has a working selected property.\n    // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n    support.optSelected = opt.selected;\n\n    // Tests for enctype support on a form (#6743)\n    support.enctype = !!document.createElement(\"form\").enctype;\n\n    // Make sure that the options inside disabled selects aren't marked as disabled\n    // (WebKit marks them as disabled)\n    select.disabled = true;\n    support.optDisabled = !opt.disabled;\n\n    // Support: IE8 only\n    // Check if we can trust getAttribute(\"value\")\n    input = document.createElement( \"input\" );\n    input.setAttribute( \"value\", \"\" );\n    support.input = input.getAttribute( \"value\" ) === \"\";\n\n    // Check if an input maintains its value after becoming a radio\n    input.value = \"t\";\n    input.setAttribute( \"type\", \"radio\" );\n    support.radioValue = input.value === \"t\";\n})();\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend({\n    val: function( value ) {\n        var hooks, ret, isFunction,\n            elem = this[0];\n\n        if ( !arguments.length ) {\n            if ( elem ) {\n                hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n                if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n                    return ret;\n                }\n\n                ret = elem.value;\n\n                return typeof ret === \"string\" ?\n                    // handle most common string cases\n                    ret.replace(rreturn, \"\") :\n                    // handle cases where value is null/undef or number\n                    ret == null ? \"\" : ret;\n            }\n\n            return;\n        }\n\n        isFunction = jQuery.isFunction( value );\n\n        return this.each(function( i ) {\n            var val;\n\n            if ( this.nodeType !== 1 ) {\n                return;\n            }\n\n            if ( isFunction ) {\n                val = value.call( this, i, jQuery( this ).val() );\n            } else {\n                val = value;\n            }\n\n            // Treat null/undefined as \"\"; convert numbers to string\n            if ( val == null ) {\n                val = \"\";\n            } else if ( typeof val === \"number\" ) {\n                val += \"\";\n            } else if ( jQuery.isArray( val ) ) {\n                val = jQuery.map( val, function( value ) {\n                    return value == null ? \"\" : value + \"\";\n                });\n            }\n\n            hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n            // If set returns undefined, fall back to normal setting\n            if ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n                this.value = val;\n            }\n        });\n    }\n});\n\njQuery.extend({\n    valHooks: {\n        option: {\n            get: function( elem ) {\n                var val = jQuery.find.attr( elem, \"value\" );\n                return val != null ?\n                    val :\n                    // Support: IE10-11+\n                    // option.text throws exceptions (#14686, #14858)\n                    jQuery.trim( jQuery.text( elem ) );\n            }\n        },\n        select: {\n            get: function( elem ) {\n                var value, option,\n                    options = elem.options,\n                    index = elem.selectedIndex,\n                    one = elem.type === \"select-one\" || index < 0,\n                    values = one ? null : [],\n                    max = one ? index + 1 : options.length,\n                    i = index < 0 ?\n                        max :\n                        one ? index : 0;\n\n                // Loop through all the selected options\n                for ( ; i < max; i++ ) {\n                    option = options[ i ];\n\n                    // oldIE doesn't update selected after form reset (#2551)\n                    if ( ( option.selected || i === index ) &&\n                            // Don't return options that are disabled or in a disabled optgroup\n                            ( support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null ) &&\n                            ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n                        // Get the specific value for the option\n                        value = jQuery( option ).val();\n\n                        // We don't need an array for one selects\n                        if ( one ) {\n                            return value;\n                        }\n\n                        // Multi-Selects return an array\n                        values.push( value );\n                    }\n                }\n\n                return values;\n            },\n\n            set: function( elem, value ) {\n                var optionSet, option,\n                    options = elem.options,\n                    values = jQuery.makeArray( value ),\n                    i = options.length;\n\n                while ( i-- ) {\n                    option = options[ i ];\n\n                    if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {\n\n                        // Support: IE6\n                        // When new option element is added to select box we need to\n                        // force reflow of newly added node in order to workaround delay\n                        // of initialization properties\n                        try {\n                            option.selected = optionSet = true;\n\n                        } catch ( _ ) {\n\n                            // Will be executed only in IE6\n                            option.scrollHeight;\n                        }\n\n                    } else {\n                        option.selected = false;\n                    }\n                }\n\n                // Force browsers to behave consistently when non-matching value is set\n                if ( !optionSet ) {\n                    elem.selectedIndex = -1;\n                }\n\n                return options;\n            }\n        }\n    }\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n    jQuery.valHooks[ this ] = {\n        set: function( elem, value ) {\n            if ( jQuery.isArray( value ) ) {\n                return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n            }\n        }\n    };\n    if ( !support.checkOn ) {\n        jQuery.valHooks[ this ].get = function( elem ) {\n            // Support: Webkit\n            // \"\" is returned instead of \"on\" if a value isn't specified\n            return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n        };\n    }\n});\n\n\n\n\nvar nodeHook, boolHook,\n    attrHandle = jQuery.expr.attrHandle,\n    ruseDefault = /^(?:checked|selected)$/i,\n    getSetAttribute = support.getSetAttribute,\n    getSetInput = support.input;\n\njQuery.fn.extend({\n    attr: function( name, value ) {\n        return access( this, jQuery.attr, name, value, arguments.length > 1 );\n    },\n\n    removeAttr: function( name ) {\n        return this.each(function() {\n            jQuery.removeAttr( this, name );\n        });\n    }\n});\n\njQuery.extend({\n    attr: function( elem, name, value ) {\n        var hooks, ret,\n            nType = elem.nodeType;\n\n        // don't get/set attributes on text, comment and attribute nodes\n        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n            return;\n        }\n\n        // Fallback to prop when attributes are not supported\n        if ( typeof elem.getAttribute === strundefined ) {\n            return jQuery.prop( elem, name, value );\n        }\n\n        // All attributes are lowercase\n        // Grab necessary hook if one is defined\n        if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n            name = name.toLowerCase();\n            hooks = jQuery.attrHooks[ name ] ||\n                ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n        }\n\n        if ( value !== undefined ) {\n\n            if ( value === null ) {\n                jQuery.removeAttr( elem, name );\n\n            } else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n                return ret;\n\n            } else {\n                elem.setAttribute( name, value + \"\" );\n                return value;\n            }\n\n        } else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n            return ret;\n\n        } else {\n            ret = jQuery.find.attr( elem, name );\n\n            // Non-existent attributes return null, we normalize to undefined\n            return ret == null ?\n                undefined :\n                ret;\n        }\n    },\n\n    removeAttr: function( elem, value ) {\n        var name, propName,\n            i = 0,\n            attrNames = value && value.match( rnotwhite );\n\n        if ( attrNames && elem.nodeType === 1 ) {\n            while ( (name = attrNames[i++]) ) {\n                propName = jQuery.propFix[ name ] || name;\n\n                // Boolean attributes get special treatment (#10870)\n                if ( jQuery.expr.match.bool.test( name ) ) {\n                    // Set corresponding property to false\n                    if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n                        elem[ propName ] = false;\n                    // Support: IE<9\n                    // Also clear defaultChecked/defaultSelected (if appropriate)\n                    } else {\n                        elem[ jQuery.camelCase( \"default-\" + name ) ] =\n                            elem[ propName ] = false;\n                    }\n\n                // See #9699 for explanation of this approach (setting first, then removal)\n                } else {\n                    jQuery.attr( elem, name, \"\" );\n                }\n\n                elem.removeAttribute( getSetAttribute ? name : propName );\n            }\n        }\n    },\n\n    attrHooks: {\n        type: {\n            set: function( elem, value ) {\n                if ( !support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n                    // Setting the type on a radio button after the value resets the value in IE6-9\n                    // Reset value to default in case type is set after value during creation\n                    var val = elem.value;\n                    elem.setAttribute( \"type\", value );\n                    if ( val ) {\n                        elem.value = val;\n                    }\n                    return value;\n                }\n            }\n        }\n    }\n});\n\n// Hook for boolean attributes\nboolHook = {\n    set: function( elem, value, name ) {\n        if ( value === false ) {\n            // Remove boolean attributes when set to false\n            jQuery.removeAttr( elem, name );\n        } else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n            // IE<8 needs the *property* name\n            elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );\n\n        // Use defaultChecked and defaultSelected for oldIE\n        } else {\n            elem[ jQuery.camelCase( \"default-\" + name ) ] = elem[ name ] = true;\n        }\n\n        return name;\n    }\n};\n\n// Retrieve booleans specially\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\n    var getter = attrHandle[ name ] || jQuery.find.attr;\n\n    attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?\n        function( elem, name, isXML ) {\n            var ret, handle;\n            if ( !isXML ) {\n                // Avoid an infinite loop by temporarily removing this function from the getter\n                handle = attrHandle[ name ];\n                attrHandle[ name ] = ret;\n                ret = getter( elem, name, isXML ) != null ?\n                    name.toLowerCase() :\n                    null;\n                attrHandle[ name ] = handle;\n            }\n            return ret;\n        } :\n        function( elem, name, isXML ) {\n            if ( !isXML ) {\n                return elem[ jQuery.camelCase( \"default-\" + name ) ] ?\n                    name.toLowerCase() :\n                    null;\n            }\n        };\n});\n\n// fix oldIE attroperties\nif ( !getSetInput || !getSetAttribute ) {\n    jQuery.attrHooks.value = {\n        set: function( elem, value, name ) {\n            if ( jQuery.nodeName( elem, \"input\" ) ) {\n                // Does not return so that setAttribute is also used\n                elem.defaultValue = value;\n            } else {\n                // Use nodeHook if defined (#1954); otherwise setAttribute is fine\n                return nodeHook && nodeHook.set( elem, value, name );\n            }\n        }\n    };\n}\n\n// IE6/7 do not support getting/setting some attributes with get/setAttribute\nif ( !getSetAttribute ) {\n\n    // Use this for any attribute in IE6/7\n    // This fixes almost every IE6/7 issue\n    nodeHook = {\n        set: function( elem, value, name ) {\n            // Set the existing or create a new attribute node\n            var ret = elem.getAttributeNode( name );\n            if ( !ret ) {\n                elem.setAttributeNode(\n                    (ret = elem.ownerDocument.createAttribute( name ))\n                );\n            }\n\n            ret.value = value += \"\";\n\n            // Break association with cloned elements by also using setAttribute (#9646)\n            if ( name === \"value\" || value === elem.getAttribute( name ) ) {\n                return value;\n            }\n        }\n    };\n\n    // Some attributes are constructed with empty-string values when not defined\n    attrHandle.id = attrHandle.name = attrHandle.coords =\n        function( elem, name, isXML ) {\n            var ret;\n            if ( !isXML ) {\n                return (ret = elem.getAttributeNode( name )) && ret.value !== \"\" ?\n                    ret.value :\n                    null;\n            }\n        };\n\n    // Fixing value retrieval on a button requires this module\n    jQuery.valHooks.button = {\n        get: function( elem, name ) {\n            var ret = elem.getAttributeNode( name );\n            if ( ret && ret.specified ) {\n                return ret.value;\n            }\n        },\n        set: nodeHook.set\n    };\n\n    // Set contenteditable to false on removals(#10429)\n    // Setting to empty string throws an error as an invalid value\n    jQuery.attrHooks.contenteditable = {\n        set: function( elem, value, name ) {\n            nodeHook.set( elem, value === \"\" ? false : value, name );\n        }\n    };\n\n    // Set width and height to auto instead of 0 on empty string( Bug #8150 )\n    // This is for removals\n    jQuery.each([ \"width\", \"height\" ], function( i, name ) {\n        jQuery.attrHooks[ name ] = {\n            set: function( elem, value ) {\n                if ( value === \"\" ) {\n                    elem.setAttribute( name, \"auto\" );\n                    return value;\n                }\n            }\n        };\n    });\n}\n\nif ( !support.style ) {\n    jQuery.attrHooks.style = {\n        get: function( elem ) {\n            // Return undefined in the case of empty string\n            // Note: IE uppercases css property names, but if we were to .toLowerCase()\n            // .cssText, that would destroy case senstitivity in URL's, like in \"background\"\n            return elem.style.cssText || undefined;\n        },\n        set: function( elem, value ) {\n            return ( elem.style.cssText = value + \"\" );\n        }\n    };\n}\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button|object)$/i,\n    rclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend({\n    prop: function( name, value ) {\n        return access( this, jQuery.prop, name, value, arguments.length > 1 );\n    },\n\n    removeProp: function( name ) {\n        name = jQuery.propFix[ name ] || name;\n        return this.each(function() {\n            // try/catch handles cases where IE balks (such as removing a property on window)\n            try {\n                this[ name ] = undefined;\n                delete this[ name ];\n            } catch( e ) {}\n        });\n    }\n});\n\njQuery.extend({\n    propFix: {\n        \"for\": \"htmlFor\",\n        \"class\": \"className\"\n    },\n\n    prop: function( elem, name, value ) {\n        var ret, hooks, notxml,\n            nType = elem.nodeType;\n\n        // don't get/set properties on text, comment and attribute nodes\n        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n            return;\n        }\n\n        notxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n        if ( notxml ) {\n            // Fix name and attach hooks\n            name = jQuery.propFix[ name ] || name;\n            hooks = jQuery.propHooks[ name ];\n        }\n\n        if ( value !== undefined ) {\n            return hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n                ret :\n                ( elem[ name ] = value );\n\n        } else {\n            return hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n                ret :\n                elem[ name ];\n        }\n    },\n\n    propHooks: {\n        tabIndex: {\n            get: function( elem ) {\n                // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n                // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n                // Use proper attribute retrieval(#12072)\n                var tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n                return tabindex ?\n                    parseInt( tabindex, 10 ) :\n                    rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n                        0 :\n                        -1;\n            }\n        }\n    }\n});\n\n// Some attributes require a special call on IE\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !support.hrefNormalized ) {\n    // href/src property should get the full normalized URL (#10299/#12915)\n    jQuery.each([ \"href\", \"src\" ], function( i, name ) {\n        jQuery.propHooks[ name ] = {\n            get: function( elem ) {\n                return elem.getAttribute( name, 4 );\n            }\n        };\n    });\n}\n\n// Support: Safari, IE9+\n// mis-reports the default selected property of an option\n// Accessing the parent's selectedIndex property fixes it\nif ( !support.optSelected ) {\n    jQuery.propHooks.selected = {\n        get: function( elem ) {\n            var parent = elem.parentNode;\n\n            if ( parent ) {\n                parent.selectedIndex;\n\n                // Make sure that it also works with optgroups, see #5701\n                if ( parent.parentNode ) {\n                    parent.parentNode.selectedIndex;\n                }\n            }\n            return null;\n        }\n    };\n}\n\njQuery.each([\n    \"tabIndex\",\n    \"readOnly\",\n    \"maxLength\",\n    \"cellSpacing\",\n    \"cellPadding\",\n    \"rowSpan\",\n    \"colSpan\",\n    \"useMap\",\n    \"frameBorder\",\n    \"contentEditable\"\n], function() {\n    jQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n// IE6/7 call enctype encoding\nif ( !support.enctype ) {\n    jQuery.propFix.enctype = \"encoding\";\n}\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\njQuery.fn.extend({\n    addClass: function( value ) {\n        var classes, elem, cur, clazz, j, finalValue,\n            i = 0,\n            len = this.length,\n            proceed = typeof value === \"string\" && value;\n\n        if ( jQuery.isFunction( value ) ) {\n            return this.each(function( j ) {\n                jQuery( this ).addClass( value.call( this, j, this.className ) );\n            });\n        }\n\n        if ( proceed ) {\n            // The disjunction here is for better compressibility (see removeClass)\n            classes = ( value || \"\" ).match( rnotwhite ) || [];\n\n            for ( ; i < len; i++ ) {\n                elem = this[ i ];\n                cur = elem.nodeType === 1 && ( elem.className ?\n                    ( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n                    \" \"\n                );\n\n                if ( cur ) {\n                    j = 0;\n                    while ( (clazz = classes[j++]) ) {\n                        if ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n                            cur += clazz + \" \";\n                        }\n                    }\n\n                    // only assign if different to avoid unneeded rendering.\n                    finalValue = jQuery.trim( cur );\n                    if ( elem.className !== finalValue ) {\n                        elem.className = finalValue;\n                    }\n                }\n            }\n        }\n\n        return this;\n    },\n\n    removeClass: function( value ) {\n        var classes, elem, cur, clazz, j, finalValue,\n            i = 0,\n            len = this.length,\n            proceed = arguments.length === 0 || typeof value === \"string\" && value;\n\n        if ( jQuery.isFunction( value ) ) {\n            return this.each(function( j ) {\n                jQuery( this ).removeClass( value.call( this, j, this.className ) );\n            });\n        }\n        if ( proceed ) {\n            classes = ( value || \"\" ).match( rnotwhite ) || [];\n\n            for ( ; i < len; i++ ) {\n                elem = this[ i ];\n                // This expression is here for better compressibility (see addClass)\n                cur = elem.nodeType === 1 && ( elem.className ?\n                    ( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n                    \"\"\n                );\n\n                if ( cur ) {\n                    j = 0;\n                    while ( (clazz = classes[j++]) ) {\n                        // Remove *all* instances\n                        while ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n                            cur = cur.replace( \" \" + clazz + \" \", \" \" );\n                        }\n                    }\n\n                    // only assign if different to avoid unneeded rendering.\n                    finalValue = value ? jQuery.trim( cur ) : \"\";\n                    if ( elem.className !== finalValue ) {\n                        elem.className = finalValue;\n                    }\n                }\n            }\n        }\n\n        return this;\n    },\n\n    toggleClass: function( value, stateVal ) {\n        var type = typeof value;\n\n        if ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n            return stateVal ? this.addClass( value ) : this.removeClass( value );\n        }\n\n        if ( jQuery.isFunction( value ) ) {\n            return this.each(function( i ) {\n                jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n            });\n        }\n\n        return this.each(function() {\n            if ( type === \"string\" ) {\n                // toggle individual class names\n                var className,\n                    i = 0,\n                    self = jQuery( this ),\n                    classNames = value.match( rnotwhite ) || [];\n\n                while ( (className = classNames[ i++ ]) ) {\n                    // check each className given, space separated list\n                    if ( self.hasClass( className ) ) {\n                        self.removeClass( className );\n                    } else {\n                        self.addClass( className );\n                    }\n                }\n\n            // Toggle whole class name\n            } else if ( type === strundefined || type === \"boolean\" ) {\n                if ( this.className ) {\n                    // store className if set\n                    jQuery._data( this, \"__className__\", this.className );\n                }\n\n                // If the element has a class name or if we're passed \"false\",\n                // then remove the whole classname (if there was one, the above saved it).\n                // Otherwise bring back whatever was previously saved (if anything),\n                // falling back to the empty string if nothing was stored.\n                this.className = this.className || value === false ? \"\" : jQuery._data( this, \"__className__\" ) || \"\";\n            }\n        });\n    },\n\n    hasClass: function( selector ) {\n        var className = \" \" + selector + \" \",\n            i = 0,\n            l = this.length;\n        for ( ; i < l; i++ ) {\n            if ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n});\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n    \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n    \"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n    // Handle event binding\n    jQuery.fn[ name ] = function( data, fn ) {\n        return arguments.length > 0 ?\n            this.on( name, null, data, fn ) :\n            this.trigger( name );\n    };\n});\n\njQuery.fn.extend({\n    hover: function( fnOver, fnOut ) {\n        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n    },\n\n    bind: function( types, data, fn ) {\n        return this.on( types, null, data, fn );\n    },\n    unbind: function( types, fn ) {\n        return this.off( types, null, fn );\n    },\n\n    delegate: function( selector, types, data, fn ) {\n        return this.on( types, selector, data, fn );\n    },\n    undelegate: function( selector, types, fn ) {\n        // ( namespace ) or ( selector, types [, fn] )\n        return arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n    }\n});\n\n\nvar nonce = jQuery.now();\n\nvar rquery = (/\\?/);\n\n\n\nvar rvalidtokens = /(,)|(\\[|{)|(}|])|\"(?:[^\"\\\\\\r\\n]|\\\\[\"\\\\\\/bfnrt]|\\\\u[\\da-fA-F]{4})*\"\\s*:?|true|false|null|-?(?!0\\d)\\d+(?:\\.\\d+|)(?:[eE][+-]?\\d+|)/g;\n\njQuery.parseJSON = function( data ) {\n    // Attempt to parse using the native JSON parser first\n    if ( window.JSON && window.JSON.parse ) {\n        // Support: Android 2.3\n        // Workaround failure to string-cast null input\n        return window.JSON.parse( data + \"\" );\n    }\n\n    var requireNonComma,\n        depth = null,\n        str = jQuery.trim( data + \"\" );\n\n    // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains\n    // after removing valid tokens\n    return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {\n\n        // Force termination if we see a misplaced comma\n        if ( requireNonComma && comma ) {\n            depth = 0;\n        }\n\n        // Perform no more replacements after returning to outermost depth\n        if ( depth === 0 ) {\n            return token;\n        }\n\n        // Commas must not follow \"[\", \"{\", or \",\"\n        requireNonComma = open || comma;\n\n        // Determine new depth\n        // array/object open (\"[\" or \"{\"): depth += true - false (increment)\n        // array/object close (\"]\" or \"}\"): depth += false - true (decrement)\n        // other cases (\",\" or primitive): depth += true - true (numeric cast)\n        depth += !close - !open;\n\n        // Remove this token\n        return \"\";\n    }) ) ?\n        ( Function( \"return \" + str ) )() :\n        jQuery.error( \"Invalid JSON: \" + data );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n    var xml, tmp;\n    if ( !data || typeof data !== \"string\" ) {\n        return null;\n    }\n    try {\n        if ( window.DOMParser ) { // Standard\n            tmp = new DOMParser();\n            xml = tmp.parseFromString( data, \"text/xml\" );\n        } else { // IE\n            xml = new ActiveXObject( \"Microsoft.XMLDOM\" );\n            xml.async = \"false\";\n            xml.loadXML( data );\n        }\n    } catch( e ) {\n        xml = undefined;\n    }\n    if ( !xml || !xml.documentElement || xml.getElementsByTagName( \"parsererror\" ).length ) {\n        jQuery.error( \"Invalid XML: \" + data );\n    }\n    return xml;\n};\n\n\nvar\n    // Document location\n    ajaxLocParts,\n    ajaxLocation,\n\n    rhash = /#.*$/,\n    rts = /([?&])_=[^&]*/,\n    rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg, // IE leaves an \\r character at EOL\n    // #7653, #8125, #8152: local protocol detection\n    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n    rnoContent = /^(?:GET|HEAD)$/,\n    rprotocol = /^\\/\\//,\n    rurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n    /* Prefilters\n     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n     * 2) These are called:\n     *    - BEFORE asking for a transport\n     *    - AFTER param serialization (s.data is a string if s.processData is true)\n     * 3) key is the dataType\n     * 4) the catchall symbol \"*\" can be used\n     * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n     */\n    prefilters = {},\n\n    /* Transports bindings\n     * 1) key is the dataType\n     * 2) the catchall symbol \"*\" can be used\n     * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n     */\n    transports = {},\n\n    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n    allTypes = \"*/\".concat(\"*\");\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\ntry {\n    ajaxLocation = location.href;\n} catch( e ) {\n    // Use the href attribute of an A element\n    // since IE will modify it given document.location\n    ajaxLocation = document.createElement( \"a\" );\n    ajaxLocation.href = \"\";\n    ajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function( dataTypeExpression, func ) {\n\n        if ( typeof dataTypeExpression !== \"string\" ) {\n            func = dataTypeExpression;\n            dataTypeExpression = \"*\";\n        }\n\n        var dataType,\n            i = 0,\n            dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n        if ( jQuery.isFunction( func ) ) {\n            // For each dataType in the dataTypeExpression\n            while ( (dataType = dataTypes[i++]) ) {\n                // Prepend if requested\n                if ( dataType.charAt( 0 ) === \"+\" ) {\n                    dataType = dataType.slice( 1 ) || \"*\";\n                    (structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n                // Otherwise append\n                } else {\n                    (structure[ dataType ] = structure[ dataType ] || []).push( func );\n                }\n            }\n        }\n    };\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n    var inspected = {},\n        seekingTransport = ( structure === transports );\n\n    function inspect( dataType ) {\n        var selected;\n        inspected[ dataType ] = true;\n        jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n            var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n            if ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n                options.dataTypes.unshift( dataTypeOrTransport );\n                inspect( dataTypeOrTransport );\n                return false;\n            } else if ( seekingTransport ) {\n                return !( selected = dataTypeOrTransport );\n            }\n        });\n        return selected;\n    }\n\n    return inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n    var deep, key,\n        flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n    for ( key in src ) {\n        if ( src[ key ] !== undefined ) {\n            ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n        }\n    }\n    if ( deep ) {\n        jQuery.extend( true, target, deep );\n    }\n\n    return target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n    var firstDataType, ct, finalDataType, type,\n        contents = s.contents,\n        dataTypes = s.dataTypes;\n\n    // Remove auto dataType and get content-type in the process\n    while ( dataTypes[ 0 ] === \"*\" ) {\n        dataTypes.shift();\n        if ( ct === undefined ) {\n            ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n        }\n    }\n\n    // Check if we're dealing with a known content-type\n    if ( ct ) {\n        for ( type in contents ) {\n            if ( contents[ type ] && contents[ type ].test( ct ) ) {\n                dataTypes.unshift( type );\n                break;\n            }\n        }\n    }\n\n    // Check to see if we have a response for the expected dataType\n    if ( dataTypes[ 0 ] in responses ) {\n        finalDataType = dataTypes[ 0 ];\n    } else {\n        // Try convertible dataTypes\n        for ( type in responses ) {\n            if ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n                finalDataType = type;\n                break;\n            }\n            if ( !firstDataType ) {\n                firstDataType = type;\n            }\n        }\n        // Or just use first one\n        finalDataType = finalDataType || firstDataType;\n    }\n\n    // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n    if ( finalDataType ) {\n        if ( finalDataType !== dataTypes[ 0 ] ) {\n            dataTypes.unshift( finalDataType );\n        }\n        return responses[ finalDataType ];\n    }\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n    var conv2, current, conv, tmp, prev,\n        converters = {},\n        // Work with a copy of dataTypes in case we need to modify it for conversion\n        dataTypes = s.dataTypes.slice();\n\n    // Create converters map with lowercased keys\n    if ( dataTypes[ 1 ] ) {\n        for ( conv in s.converters ) {\n            converters[ conv.toLowerCase() ] = s.converters[ conv ];\n        }\n    }\n\n    current = dataTypes.shift();\n\n    // Convert to each sequential dataType\n    while ( current ) {\n\n        if ( s.responseFields[ current ] ) {\n            jqXHR[ s.responseFields[ current ] ] = response;\n        }\n\n        // Apply the dataFilter if provided\n        if ( !prev && isSuccess && s.dataFilter ) {\n            response = s.dataFilter( response, s.dataType );\n        }\n\n        prev = current;\n        current = dataTypes.shift();\n\n        if ( current ) {\n\n            // There's only work to do if current dataType is non-auto\n            if ( current === \"*\" ) {\n\n                current = prev;\n\n            // Convert response if prev dataType is non-auto and differs from current\n            } else if ( prev !== \"*\" && prev !== current ) {\n\n                // Seek a direct converter\n                conv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n                // If none found, seek a pair\n                if ( !conv ) {\n                    for ( conv2 in converters ) {\n\n                        // If conv2 outputs current\n                        tmp = conv2.split( \" \" );\n                        if ( tmp[ 1 ] === current ) {\n\n                            // If prev can be converted to accepted input\n                            conv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n                                converters[ \"* \" + tmp[ 0 ] ];\n                            if ( conv ) {\n                                // Condense equivalence converters\n                                if ( conv === true ) {\n                                    conv = converters[ conv2 ];\n\n                                // Otherwise, insert the intermediate dataType\n                                } else if ( converters[ conv2 ] !== true ) {\n                                    current = tmp[ 0 ];\n                                    dataTypes.unshift( tmp[ 1 ] );\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                // Apply converter (if not an equivalence)\n                if ( conv !== true ) {\n\n                    // Unless errors are allowed to bubble, catch and return them\n                    if ( conv && s[ \"throws\" ] ) {\n                        response = conv( response );\n                    } else {\n                        try {\n                            response = conv( response );\n                        } catch ( e ) {\n                            return { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return { state: \"success\", data: response };\n}\n\njQuery.extend({\n\n    // Counter for holding the number of active queries\n    active: 0,\n\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n\n    ajaxSettings: {\n        url: ajaxLocation,\n        type: \"GET\",\n        isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n        global: true,\n        processData: true,\n        async: true,\n        contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n        /*\n        timeout: 0,\n        data: null,\n        dataType: null,\n        username: null,\n        password: null,\n        cache: null,\n        throws: false,\n        traditional: false,\n        headers: {},\n        */\n\n        accepts: {\n            \"*\": allTypes,\n            text: \"text/plain\",\n            html: \"text/html\",\n            xml: \"application/xml, text/xml\",\n            json: \"application/json, text/javascript\"\n        },\n\n        contents: {\n            xml: /xml/,\n            html: /html/,\n            json: /json/\n        },\n\n        responseFields: {\n            xml: \"responseXML\",\n            text: \"responseText\",\n            json: \"responseJSON\"\n        },\n\n        // Data converters\n        // Keys separate source (or catchall \"*\") and destination types with a single space\n        converters: {\n\n            // Convert anything to text\n            \"* text\": String,\n\n            // Text to html (true = no transformation)\n            \"text html\": true,\n\n            // Evaluate text as a json expression\n            \"text json\": jQuery.parseJSON,\n\n            // Parse text as xml\n            \"text xml\": jQuery.parseXML\n        },\n\n        // For options that shouldn't be deep extended:\n        // you can add your own custom options here if\n        // and when you create one that shouldn't be\n        // deep extended (see ajaxExtend)\n        flatOptions: {\n            url: true,\n            context: true\n        }\n    },\n\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function( target, settings ) {\n        return settings ?\n\n            // Building a settings object\n            ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n            // Extending ajaxSettings\n            ajaxExtend( jQuery.ajaxSettings, target );\n    },\n\n    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n    ajaxTransport: addToPrefiltersOrTransports( transports ),\n\n    // Main method\n    ajax: function( url, options ) {\n\n        // If url is an object, simulate pre-1.5 signature\n        if ( typeof url === \"object\" ) {\n            options = url;\n            url = undefined;\n        }\n\n        // Force options to be an object\n        options = options || {};\n\n        var // Cross-domain detection vars\n            parts,\n            // Loop variable\n            i,\n            // URL without anti-cache param\n            cacheURL,\n            // Response headers as string\n            responseHeadersString,\n            // timeout handle\n            timeoutTimer,\n\n            // To know if global events are to be dispatched\n            fireGlobals,\n\n            transport,\n            // Response headers\n            responseHeaders,\n            // Create the final options object\n            s = jQuery.ajaxSetup( {}, options ),\n            // Callbacks context\n            callbackContext = s.context || s,\n            // Context for global events is callbackContext if it is a DOM node or jQuery collection\n            globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n                jQuery( callbackContext ) :\n                jQuery.event,\n            // Deferreds\n            deferred = jQuery.Deferred(),\n            completeDeferred = jQuery.Callbacks(\"once memory\"),\n            // Status-dependent callbacks\n            statusCode = s.statusCode || {},\n            // Headers (they are sent all at once)\n            requestHeaders = {},\n            requestHeadersNames = {},\n            // The jqXHR state\n            state = 0,\n            // Default abort message\n            strAbort = \"canceled\",\n            // Fake xhr\n            jqXHR = {\n                readyState: 0,\n\n                // Builds headers hashtable if needed\n                getResponseHeader: function( key ) {\n                    var match;\n                    if ( state === 2 ) {\n                        if ( !responseHeaders ) {\n                            responseHeaders = {};\n                            while ( (match = rheaders.exec( responseHeadersString )) ) {\n                                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n                            }\n                        }\n                        match = responseHeaders[ key.toLowerCase() ];\n                    }\n                    return match == null ? null : match;\n                },\n\n                // Raw string\n                getAllResponseHeaders: function() {\n                    return state === 2 ? responseHeadersString : null;\n                },\n\n                // Caches the header\n                setRequestHeader: function( name, value ) {\n                    var lname = name.toLowerCase();\n                    if ( !state ) {\n                        name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n                        requestHeaders[ name ] = value;\n                    }\n                    return this;\n                },\n\n                // Overrides response content-type header\n                overrideMimeType: function( type ) {\n                    if ( !state ) {\n                        s.mimeType = type;\n                    }\n                    return this;\n                },\n\n                // Status-dependent callbacks\n                statusCode: function( map ) {\n                    var code;\n                    if ( map ) {\n                        if ( state < 2 ) {\n                            for ( code in map ) {\n                                // Lazy-add the new callback in a way that preserves old ones\n                                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n                            }\n                        } else {\n                            // Execute the appropriate callbacks\n                            jqXHR.always( map[ jqXHR.status ] );\n                        }\n                    }\n                    return this;\n                },\n\n                // Cancel the request\n                abort: function( statusText ) {\n                    var finalText = statusText || strAbort;\n                    if ( transport ) {\n                        transport.abort( finalText );\n                    }\n                    done( 0, finalText );\n                    return this;\n                }\n            };\n\n        // Attach deferreds\n        deferred.promise( jqXHR ).complete = completeDeferred.add;\n        jqXHR.success = jqXHR.done;\n        jqXHR.error = jqXHR.fail;\n\n        // Remove hash character (#7531: and string promotion)\n        // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n        // Handle falsy url in the settings object (#10093: consistency with old signature)\n        // We also use the url parameter if available\n        s.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" ).replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n        // Alias method option to type as per ticket #12004\n        s.type = options.method || options.type || s.method || s.type;\n\n        // Extract dataTypes list\n        s.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n        // A cross-domain request is in order when we have a protocol:host:port mismatch\n        if ( s.crossDomain == null ) {\n            parts = rurl.exec( s.url.toLowerCase() );\n            s.crossDomain = !!( parts &&\n                ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n                    ( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n            );\n        }\n\n        // Convert data if not already a string\n        if ( s.data && s.processData && typeof s.data !== \"string\" ) {\n            s.data = jQuery.param( s.data, s.traditional );\n        }\n\n        // Apply prefilters\n        inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n        // If request was aborted inside a prefilter, stop there\n        if ( state === 2 ) {\n            return jqXHR;\n        }\n\n        // We can fire global events as of now if asked to\n        // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n        fireGlobals = jQuery.event && s.global;\n\n        // Watch for a new set of requests\n        if ( fireGlobals && jQuery.active++ === 0 ) {\n            jQuery.event.trigger(\"ajaxStart\");\n        }\n\n        // Uppercase the type\n        s.type = s.type.toUpperCase();\n\n        // Determine if request has content\n        s.hasContent = !rnoContent.test( s.type );\n\n        // Save the URL in case we're toying with the If-Modified-Since\n        // and/or If-None-Match header later on\n        cacheURL = s.url;\n\n        // More options handling for requests with no content\n        if ( !s.hasContent ) {\n\n            // If data is available, append data to url\n            if ( s.data ) {\n                cacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n                // #9682: remove data so that it's not used in an eventual retry\n                delete s.data;\n            }\n\n            // Add anti-cache in url if needed\n            if ( s.cache === false ) {\n                s.url = rts.test( cacheURL ) ?\n\n                    // If there is already a '_' parameter, set its value\n                    cacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n                    // Otherwise add one to the end\n                    cacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n            }\n        }\n\n        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n        if ( s.ifModified ) {\n            if ( jQuery.lastModified[ cacheURL ] ) {\n                jqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n            }\n            if ( jQuery.etag[ cacheURL ] ) {\n                jqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n            }\n        }\n\n        // Set the correct header, if data is being sent\n        if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n            jqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n        }\n\n        // Set the Accepts header for the server, depending on the dataType\n        jqXHR.setRequestHeader(\n            \"Accept\",\n            s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n                s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n                s.accepts[ \"*\" ]\n        );\n\n        // Check for headers option\n        for ( i in s.headers ) {\n            jqXHR.setRequestHeader( i, s.headers[ i ] );\n        }\n\n        // Allow custom headers/mimetypes and early abort\n        if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n            // Abort if not done already and return\n            return jqXHR.abort();\n        }\n\n        // aborting is no longer a cancellation\n        strAbort = \"abort\";\n\n        // Install callbacks on deferreds\n        for ( i in { success: 1, error: 1, complete: 1 } ) {\n            jqXHR[ i ]( s[ i ] );\n        }\n\n        // Get transport\n        transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n        // If no transport, we auto-abort\n        if ( !transport ) {\n            done( -1, \"No Transport\" );\n        } else {\n            jqXHR.readyState = 1;\n\n            // Send global event\n            if ( fireGlobals ) {\n                globalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n            }\n            // Timeout\n            if ( s.async && s.timeout > 0 ) {\n                timeoutTimer = setTimeout(function() {\n                    jqXHR.abort(\"timeout\");\n                }, s.timeout );\n            }\n\n            try {\n                state = 1;\n                transport.send( requestHeaders, done );\n            } catch ( e ) {\n                // Propagate exception as error if not done\n                if ( state < 2 ) {\n                    done( -1, e );\n                // Simply rethrow otherwise\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // Callback for when everything is done\n        function done( status, nativeStatusText, responses, headers ) {\n            var isSuccess, success, error, response, modified,\n                statusText = nativeStatusText;\n\n            // Called once\n            if ( state === 2 ) {\n                return;\n            }\n\n            // State is \"done\" now\n            state = 2;\n\n            // Clear timeout if it exists\n            if ( timeoutTimer ) {\n                clearTimeout( timeoutTimer );\n            }\n\n            // Dereference transport for early garbage collection\n            // (no matter how long the jqXHR object will be used)\n            transport = undefined;\n\n            // Cache response headers\n            responseHeadersString = headers || \"\";\n\n            // Set readyState\n            jqXHR.readyState = status > 0 ? 4 : 0;\n\n            // Determine if successful\n            isSuccess = status >= 200 && status < 300 || status === 304;\n\n            // Get response data\n            if ( responses ) {\n                response = ajaxHandleResponses( s, jqXHR, responses );\n            }\n\n            // Convert no matter what (that way responseXXX fields are always set)\n            response = ajaxConvert( s, response, jqXHR, isSuccess );\n\n            // If successful, handle type chaining\n            if ( isSuccess ) {\n\n                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n                if ( s.ifModified ) {\n                    modified = jqXHR.getResponseHeader(\"Last-Modified\");\n                    if ( modified ) {\n                        jQuery.lastModified[ cacheURL ] = modified;\n                    }\n                    modified = jqXHR.getResponseHeader(\"etag\");\n                    if ( modified ) {\n                        jQuery.etag[ cacheURL ] = modified;\n                    }\n                }\n\n                // if no content\n                if ( status === 204 || s.type === \"HEAD\" ) {\n                    statusText = \"nocontent\";\n\n                // if not modified\n                } else if ( status === 304 ) {\n                    statusText = \"notmodified\";\n\n                // If we have data, let's convert it\n                } else {\n                    statusText = response.state;\n                    success = response.data;\n                    error = response.error;\n                    isSuccess = !error;\n                }\n            } else {\n                // We extract error from statusText\n                // then normalize statusText and status for non-aborts\n                error = statusText;\n                if ( status || !statusText ) {\n                    statusText = \"error\";\n                    if ( status < 0 ) {\n                        status = 0;\n                    }\n                }\n            }\n\n            // Set data for the fake xhr object\n            jqXHR.status = status;\n            jqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n            // Success/Error\n            if ( isSuccess ) {\n                deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n            } else {\n                deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n            }\n\n            // Status-dependent callbacks\n            jqXHR.statusCode( statusCode );\n            statusCode = undefined;\n\n            if ( fireGlobals ) {\n                globalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n                    [ jqXHR, s, isSuccess ? success : error ] );\n            }\n\n            // Complete\n            completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n            if ( fireGlobals ) {\n                globalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n                // Handle the global AJAX counter\n                if ( !( --jQuery.active ) ) {\n                    jQuery.event.trigger(\"ajaxStop\");\n                }\n            }\n        }\n\n        return jqXHR;\n    },\n\n    getJSON: function( url, data, callback ) {\n        return jQuery.get( url, data, callback, \"json\" );\n    },\n\n    getScript: function( url, callback ) {\n        return jQuery.get( url, undefined, callback, \"script\" );\n    }\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n    jQuery[ method ] = function( url, data, callback, type ) {\n        // shift arguments if data argument was omitted\n        if ( jQuery.isFunction( data ) ) {\n            type = type || callback;\n            callback = data;\n            data = undefined;\n        }\n\n        return jQuery.ajax({\n            url: url,\n            type: method,\n            dataType: type,\n            data: data,\n            success: callback\n        });\n    };\n});\n\n\njQuery._evalUrl = function( url ) {\n    return jQuery.ajax({\n        url: url,\n        type: \"GET\",\n        dataType: \"script\",\n        async: false,\n        global: false,\n        \"throws\": true\n    });\n};\n\n\njQuery.fn.extend({\n    wrapAll: function( html ) {\n        if ( jQuery.isFunction( html ) ) {\n            return this.each(function(i) {\n                jQuery(this).wrapAll( html.call(this, i) );\n            });\n        }\n\n        if ( this[0] ) {\n            // The elements to wrap the target around\n            var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);\n\n            if ( this[0].parentNode ) {\n                wrap.insertBefore( this[0] );\n            }\n\n            wrap.map(function() {\n                var elem = this;\n\n                while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n                    elem = elem.firstChild;\n                }\n\n                return elem;\n            }).append( this );\n        }\n\n        return this;\n    },\n\n    wrapInner: function( html ) {\n        if ( jQuery.isFunction( html ) ) {\n            return this.each(function(i) {\n                jQuery(this).wrapInner( html.call(this, i) );\n            });\n        }\n\n        return this.each(function() {\n            var self = jQuery( this ),\n                contents = self.contents();\n\n            if ( contents.length ) {\n                contents.wrapAll( html );\n\n            } else {\n                self.append( html );\n            }\n        });\n    },\n\n    wrap: function( html ) {\n        var isFunction = jQuery.isFunction( html );\n\n        return this.each(function(i) {\n            jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n        });\n    },\n\n    unwrap: function() {\n        return this.parent().each(function() {\n            if ( !jQuery.nodeName( this, \"body\" ) ) {\n                jQuery( this ).replaceWith( this.childNodes );\n            }\n        }).end();\n    }\n});\n\n\njQuery.expr.filters.hidden = function( elem ) {\n    // Support: Opera <= 12.12\n    // Opera reports offsetWidths and offsetHeights less than zero on some elements\n    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||\n        (!support.reliableHiddenOffsets() &&\n            ((elem.style && elem.style.display) || jQuery.css( elem, \"display\" )) === \"none\");\n};\n\njQuery.expr.filters.visible = function( elem ) {\n    return !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n    rbracket = /\\[\\]$/,\n    rCRLF = /\\r?\\n/g,\n    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n    rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n    var name;\n\n    if ( jQuery.isArray( obj ) ) {\n        // Serialize array item.\n        jQuery.each( obj, function( i, v ) {\n            if ( traditional || rbracket.test( prefix ) ) {\n                // Treat each array item as a scalar.\n                add( prefix, v );\n\n            } else {\n                // Item is non-scalar (array or object), encode its numeric index.\n                buildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n            }\n        });\n\n    } else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n        // Serialize object item.\n        for ( name in obj ) {\n            buildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n        }\n\n    } else {\n        // Serialize scalar item.\n        add( prefix, obj );\n    }\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n    var prefix,\n        s = [],\n        add = function( key, value ) {\n            // If value is a function, invoke it and return its value\n            value = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n            s[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n        };\n\n    // Set traditional to true for jQuery <= 1.3.2 behavior.\n    if ( traditional === undefined ) {\n        traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n    }\n\n    // If an array was passed in, assume that it is an array of form elements.\n    if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n        // Serialize the form elements\n        jQuery.each( a, function() {\n            add( this.name, this.value );\n        });\n\n    } else {\n        // If traditional, encode the \"old\" way (the way 1.3.2 or older\n        // did it), otherwise encode params recursively.\n        for ( prefix in a ) {\n            buildParams( prefix, a[ prefix ], traditional, add );\n        }\n    }\n\n    // Return the resulting serialization\n    return s.join( \"&\" ).replace( r20, \"+\" );\n};\n\njQuery.fn.extend({\n    serialize: function() {\n        return jQuery.param( this.serializeArray() );\n    },\n    serializeArray: function() {\n        return this.map(function() {\n            // Can add propHook for \"elements\" to filter or add form elements\n            var elements = jQuery.prop( this, \"elements\" );\n            return elements ? jQuery.makeArray( elements ) : this;\n        })\n        .filter(function() {\n            var type = this.type;\n            // Use .is(\":disabled\") so that fieldset[disabled] works\n            return this.name && !jQuery( this ).is( \":disabled\" ) &&\n                rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n                ( this.checked || !rcheckableType.test( type ) );\n        })\n        .map(function( i, elem ) {\n            var val = jQuery( this ).val();\n\n            return val == null ?\n                null :\n                jQuery.isArray( val ) ?\n                    jQuery.map( val, function( val ) {\n                        return { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n                    }) :\n                    { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n        }).get();\n    }\n});\n\n\n// Create the request object\n// (This is still attached to ajaxSettings for backward compatibility)\njQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?\n    // Support: IE6+\n    function() {\n\n        // XHR cannot access local files, always use ActiveX for that case\n        return !this.isLocal &&\n\n            // Support: IE7-8\n            // oldIE XHR does not support non-RFC2616 methods (#13240)\n            // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx\n            // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9\n            // Although this check for six methods instead of eight\n            // since IE also does not support \"trace\" and \"connect\"\n            /^(get|post|head|put|delete|options)$/i.test( this.type ) &&\n\n            createStandardXHR() || createActiveXHR();\n    } :\n    // For all other browsers, use the standard XMLHttpRequest object\n    createStandardXHR;\n\nvar xhrId = 0,\n    xhrCallbacks = {},\n    xhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE<10\n// Open requests must be manually aborted on unload (#5280)\n// See https://support.microsoft.com/kb/2856746 for more info\nif ( window.attachEvent ) {\n    window.attachEvent( \"onunload\", function() {\n        for ( var key in xhrCallbacks ) {\n            xhrCallbacks[ key ]( undefined, true );\n        }\n    });\n}\n\n// Determine support properties\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nxhrSupported = support.ajax = !!xhrSupported;\n\n// Create transport if the browser can provide an xhr\nif ( xhrSupported ) {\n\n    jQuery.ajaxTransport(function( options ) {\n        // Cross domain only allowed if supported through XMLHttpRequest\n        if ( !options.crossDomain || support.cors ) {\n\n            var callback;\n\n            return {\n                send: function( headers, complete ) {\n                    var i,\n                        xhr = options.xhr(),\n                        id = ++xhrId;\n\n                    // Open the socket\n                    xhr.open( options.type, options.url, options.async, options.username, options.password );\n\n                    // Apply custom fields if provided\n                    if ( options.xhrFields ) {\n                        for ( i in options.xhrFields ) {\n                            xhr[ i ] = options.xhrFields[ i ];\n                        }\n                    }\n\n                    // Override mime type if needed\n                    if ( options.mimeType && xhr.overrideMimeType ) {\n                        xhr.overrideMimeType( options.mimeType );\n                    }\n\n                    // X-Requested-With header\n                    // For cross-domain requests, seeing as conditions for a preflight are\n                    // akin to a jigsaw puzzle, we simply never set it to be sure.\n                    // (it can always be set on a per-request basis or even using ajaxSetup)\n                    // For same-domain requests, won't change header if already provided.\n                    if ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n                        headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n                    }\n\n                    // Set headers\n                    for ( i in headers ) {\n                        // Support: IE<9\n                        // IE's ActiveXObject throws a 'Type Mismatch' exception when setting\n                        // request header to a null-value.\n                        //\n                        // To keep consistent with other XHR implementations, cast the value\n                        // to string and ignore `undefined`.\n                        if ( headers[ i ] !== undefined ) {\n                            xhr.setRequestHeader( i, headers[ i ] + \"\" );\n                        }\n                    }\n\n                    // Do send the request\n                    // This may raise an exception which is actually\n                    // handled in jQuery.ajax (so no try/catch here)\n                    xhr.send( ( options.hasContent && options.data ) || null );\n\n                    // Listener\n                    callback = function( _, isAbort ) {\n                        var status, statusText, responses;\n\n                        // Was never called and is aborted or complete\n                        if ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n                            // Clean up\n                            delete xhrCallbacks[ id ];\n                            callback = undefined;\n                            xhr.onreadystatechange = jQuery.noop;\n\n                            // Abort manually if needed\n                            if ( isAbort ) {\n                                if ( xhr.readyState !== 4 ) {\n                                    xhr.abort();\n                                }\n                            } else {\n                                responses = {};\n                                status = xhr.status;\n\n                                // Support: IE<10\n                                // Accessing binary-data responseText throws an exception\n                                // (#11426)\n                                if ( typeof xhr.responseText === \"string\" ) {\n                                    responses.text = xhr.responseText;\n                                }\n\n                                // Firefox throws an exception when accessing\n                                // statusText for faulty cross-domain requests\n                                try {\n                                    statusText = xhr.statusText;\n                                } catch( e ) {\n                                    // We normalize with Webkit giving an empty statusText\n                                    statusText = \"\";\n                                }\n\n                                // Filter status for non standard behaviors\n\n                                // If the request is local and we have data: assume a success\n                                // (success with no data won't get notified, that's the best we\n                                // can do given current implementations)\n                                if ( !status && options.isLocal && !options.crossDomain ) {\n                                    status = responses.text ? 200 : 404;\n                                // IE - #1450: sometimes returns 1223 when it should be 204\n                                } else if ( status === 1223 ) {\n                                    status = 204;\n                                }\n                            }\n                        }\n\n                        // Call complete if needed\n                        if ( responses ) {\n                            complete( status, statusText, responses, xhr.getAllResponseHeaders() );\n                        }\n                    };\n\n                    if ( !options.async ) {\n                        // if we're in sync mode we fire the callback\n                        callback();\n                    } else if ( xhr.readyState === 4 ) {\n                        // (IE6 & IE7) if it's in cache and has been\n                        // retrieved directly we need to fire the callback\n                        setTimeout( callback );\n                    } else {\n                        // Add to the list of active xhr callbacks\n                        xhr.onreadystatechange = xhrCallbacks[ id ] = callback;\n                    }\n                },\n\n                abort: function() {\n                    if ( callback ) {\n                        callback( undefined, true );\n                    }\n                }\n            };\n        }\n    });\n}\n\n// Functions to create xhrs\nfunction createStandardXHR() {\n    try {\n        return new window.XMLHttpRequest();\n    } catch( e ) {}\n}\n\nfunction createActiveXHR() {\n    try {\n        return new window.ActiveXObject( \"Microsoft.XMLHTTP\" );\n    } catch( e ) {}\n}\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup({\n    accepts: {\n        script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n    },\n    contents: {\n        script: /(?:java|ecma)script/\n    },\n    converters: {\n        \"text script\": function( text ) {\n            jQuery.globalEval( text );\n            return text;\n        }\n    }\n});\n\n// Handle cache's special case and global\njQuery.ajaxPrefilter( \"script\", function( s ) {\n    if ( s.cache === undefined ) {\n        s.cache = false;\n    }\n    if ( s.crossDomain ) {\n        s.type = \"GET\";\n        s.global = false;\n    }\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function(s) {\n\n    // This transport only deals with cross domain requests\n    if ( s.crossDomain ) {\n\n        var script,\n            head = document.head || jQuery(\"head\")[0] || document.documentElement;\n\n        return {\n\n            send: function( _, callback ) {\n\n                script = document.createElement(\"script\");\n\n                script.async = true;\n\n                if ( s.scriptCharset ) {\n                    script.charset = s.scriptCharset;\n                }\n\n                script.src = s.url;\n\n                // Attach handlers for all browsers\n                script.onload = script.onreadystatechange = function( _, isAbort ) {\n\n                    if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n                        // Handle memory leak in IE\n                        script.onload = script.onreadystatechange = null;\n\n                        // Remove the script\n                        if ( script.parentNode ) {\n                            script.parentNode.removeChild( script );\n                        }\n\n                        // Dereference the script\n                        script = null;\n\n                        // Callback if not abort\n                        if ( !isAbort ) {\n                            callback( 200, \"success\" );\n                        }\n                    }\n                };\n\n                // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n                // Use native DOM manipulation to avoid our domManip AJAX trickery\n                head.insertBefore( script, head.firstChild );\n            },\n\n            abort: function() {\n                if ( script ) {\n                    script.onload( undefined, true );\n                }\n            }\n        };\n    }\n});\n\n\n\n\nvar oldCallbacks = [],\n    rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n    jsonp: \"callback\",\n    jsonpCallback: function() {\n        var callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n        this[ callback ] = true;\n        return callback;\n    }\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n    var callbackName, overwritten, responseContainer,\n        jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n            \"url\" :\n            typeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n        );\n\n    // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n    if ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n        // Get callback name, remembering preexisting value associated with it\n        callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n            s.jsonpCallback() :\n            s.jsonpCallback;\n\n        // Insert callback into url or form data\n        if ( jsonProp ) {\n            s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n        } else if ( s.jsonp !== false ) {\n            s.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n        }\n\n        // Use data converter to retrieve json after script execution\n        s.converters[\"script json\"] = function() {\n            if ( !responseContainer ) {\n                jQuery.error( callbackName + \" was not called\" );\n            }\n            return responseContainer[ 0 ];\n        };\n\n        // force json dataType\n        s.dataTypes[ 0 ] = \"json\";\n\n        // Install callback\n        overwritten = window[ callbackName ];\n        window[ callbackName ] = function() {\n            responseContainer = arguments;\n        };\n\n        // Clean-up function (fires after converters)\n        jqXHR.always(function() {\n            // Restore preexisting value\n            window[ callbackName ] = overwritten;\n\n            // Save back as free\n            if ( s[ callbackName ] ) {\n                // make sure that re-using the options doesn't screw things around\n                s.jsonpCallback = originalSettings.jsonpCallback;\n\n                // save the callback name for future use\n                oldCallbacks.push( callbackName );\n            }\n\n            // Call if it was a function and we have a response\n            if ( responseContainer && jQuery.isFunction( overwritten ) ) {\n                overwritten( responseContainer[ 0 ] );\n            }\n\n            responseContainer = overwritten = undefined;\n        });\n\n        // Delegate to script\n        return \"script\";\n    }\n});\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context, defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n    if ( !data || typeof data !== \"string\" ) {\n        return null;\n    }\n    if ( typeof context === \"boolean\" ) {\n        keepScripts = context;\n        context = false;\n    }\n    context = context || document;\n\n    var parsed = rsingleTag.exec( data ),\n        scripts = !keepScripts && [];\n\n    // Single tag\n    if ( parsed ) {\n        return [ context.createElement( parsed[1] ) ];\n    }\n\n    parsed = jQuery.buildFragment( [ data ], context, scripts );\n\n    if ( scripts && scripts.length ) {\n        jQuery( scripts ).remove();\n    }\n\n    return jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n    if ( typeof url !== \"string\" && _load ) {\n        return _load.apply( this, arguments );\n    }\n\n    var selector, response, type,\n        self = this,\n        off = url.indexOf(\" \");\n\n    if ( off >= 0 ) {\n        selector = jQuery.trim( url.slice( off, url.length ) );\n        url = url.slice( 0, off );\n    }\n\n    // If it's a function\n    if ( jQuery.isFunction( params ) ) {\n\n        // We assume that it's the callback\n        callback = params;\n        params = undefined;\n\n    // Otherwise, build a param string\n    } else if ( params && typeof params === \"object\" ) {\n        type = \"POST\";\n    }\n\n    // If we have elements to modify, make the request\n    if ( self.length > 0 ) {\n        jQuery.ajax({\n            url: url,\n\n            // if \"type\" variable is undefined, then \"GET\" method will be used\n            type: type,\n            dataType: \"html\",\n            data: params\n        }).done(function( responseText ) {\n\n            // Save response for use in complete callback\n            response = arguments;\n\n            self.html( selector ?\n\n                // If a selector was specified, locate the right elements in a dummy div\n                // Exclude scripts to avoid IE 'Permission Denied' errors\n                jQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n                // Otherwise use the full result\n                responseText );\n\n        }).complete( callback && function( jqXHR, status ) {\n            self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n        });\n    }\n\n    return this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n    jQuery.fn[ type ] = function( fn ) {\n        return this.on( type, fn );\n    };\n});\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n    return jQuery.grep(jQuery.timers, function( fn ) {\n        return elem === fn.elem;\n    }).length;\n};\n\n\n\n\n\nvar docElem = window.document.documentElement;\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n    return jQuery.isWindow( elem ) ?\n        elem :\n        elem.nodeType === 9 ?\n            elem.defaultView || elem.parentWindow :\n            false;\n}\n\njQuery.offset = {\n    setOffset: function( elem, options, i ) {\n        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n            position = jQuery.css( elem, \"position\" ),\n            curElem = jQuery( elem ),\n            props = {};\n\n        // set position first, in-case top/left are set even on static elem\n        if ( position === \"static\" ) {\n            elem.style.position = \"relative\";\n        }\n\n        curOffset = curElem.offset();\n        curCSSTop = jQuery.css( elem, \"top\" );\n        curCSSLeft = jQuery.css( elem, \"left\" );\n        calculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n            jQuery.inArray(\"auto\", [ curCSSTop, curCSSLeft ] ) > -1;\n\n        // need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n        if ( calculatePosition ) {\n            curPosition = curElem.position();\n            curTop = curPosition.top;\n            curLeft = curPosition.left;\n        } else {\n            curTop = parseFloat( curCSSTop ) || 0;\n            curLeft = parseFloat( curCSSLeft ) || 0;\n        }\n\n        if ( jQuery.isFunction( options ) ) {\n            options = options.call( elem, i, curOffset );\n        }\n\n        if ( options.top != null ) {\n            props.top = ( options.top - curOffset.top ) + curTop;\n        }\n        if ( options.left != null ) {\n            props.left = ( options.left - curOffset.left ) + curLeft;\n        }\n\n        if ( \"using\" in options ) {\n            options.using.call( elem, props );\n        } else {\n            curElem.css( props );\n        }\n    }\n};\n\njQuery.fn.extend({\n    offset: function( options ) {\n        if ( arguments.length ) {\n            return options === undefined ?\n                this :\n                this.each(function( i ) {\n                    jQuery.offset.setOffset( this, options, i );\n                });\n        }\n\n        var docElem, win,\n            box = { top: 0, left: 0 },\n            elem = this[ 0 ],\n            doc = elem && elem.ownerDocument;\n\n        if ( !doc ) {\n            return;\n        }\n\n        docElem = doc.documentElement;\n\n        // Make sure it's not a disconnected DOM node\n        if ( !jQuery.contains( docElem, elem ) ) {\n            return box;\n        }\n\n        // If we don't have gBCR, just use 0,0 rather than error\n        // BlackBerry 5, iOS 3 (original iPhone)\n        if ( typeof elem.getBoundingClientRect !== strundefined ) {\n            box = elem.getBoundingClientRect();\n        }\n        win = getWindow( doc );\n        return {\n            top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),\n            left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )\n        };\n    },\n\n    position: function() {\n        if ( !this[ 0 ] ) {\n            return;\n        }\n\n        var offsetParent, offset,\n            parentOffset = { top: 0, left: 0 },\n            elem = this[ 0 ];\n\n        // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n        if ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n            // we assume that getBoundingClientRect is available when computed position is fixed\n            offset = elem.getBoundingClientRect();\n        } else {\n            // Get *real* offsetParent\n            offsetParent = this.offsetParent();\n\n            // Get correct offsets\n            offset = this.offset();\n            if ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n                parentOffset = offsetParent.offset();\n            }\n\n            // Add offsetParent borders\n            parentOffset.top  += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n            parentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n        }\n\n        // Subtract parent offsets and element margins\n        // note: when an element has margin: auto the offsetLeft and marginLeft\n        // are the same in Safari causing offset.left to incorrectly be 0\n        return {\n            top:  offset.top  - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n            left: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true)\n        };\n    },\n\n    offsetParent: function() {\n        return this.map(function() {\n            var offsetParent = this.offsetParent || docElem;\n\n            while ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n                offsetParent = offsetParent.offsetParent;\n            }\n            return offsetParent || docElem;\n        });\n    }\n});\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n    var top = /Y/.test( prop );\n\n    jQuery.fn[ method ] = function( val ) {\n        return access( this, function( elem, method, val ) {\n            var win = getWindow( elem );\n\n            if ( val === undefined ) {\n                return win ? (prop in win) ? win[ prop ] :\n                    win.document.documentElement[ method ] :\n                    elem[ method ];\n            }\n\n            if ( win ) {\n                win.scrollTo(\n                    !top ? val : jQuery( win ).scrollLeft(),\n                    top ? val : jQuery( win ).scrollTop()\n                );\n\n            } else {\n                elem[ method ] = val;\n            }\n        }, method, val, arguments.length, null );\n    };\n});\n\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// getComputedStyle returns percent when specified for top/left/bottom/right\n// rather than make the css module depend on the offset module, we just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n    jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n        function( elem, computed ) {\n            if ( computed ) {\n                computed = curCSS( elem, prop );\n                // if curCSS returns percentage, fallback to offset\n                return rnumnonpx.test( computed ) ?\n                    jQuery( elem ).position()[ prop ] + \"px\" :\n                    computed;\n            }\n        }\n    );\n});\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n    jQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n        // margin is only for outerHeight, outerWidth\n        jQuery.fn[ funcName ] = function( margin, value ) {\n            var chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n                extra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n            return access( this, function( elem, type, value ) {\n                var doc;\n\n                if ( jQuery.isWindow( elem ) ) {\n                    // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n                    // isn't a whole lot we can do. See pull request at this URL for discussion:\n                    // https://github.com/jquery/jquery/pull/764\n                    return elem.document.documentElement[ \"client\" + name ];\n                }\n\n                // Get document width or height\n                if ( elem.nodeType === 9 ) {\n                    doc = elem.documentElement;\n\n                    // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest\n                    // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.\n                    return Math.max(\n                        elem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n                        elem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n                        doc[ \"client\" + name ]\n                    );\n                }\n\n                return value === undefined ?\n                    // Get width or height on the element, requesting but not forcing parseFloat\n                    jQuery.css( elem, type, extra ) :\n\n                    // Set width or height on the element\n                    jQuery.style( elem, type, value, extra );\n            }, type, chainable ? margin : undefined, chainable, null );\n        };\n    });\n});\n\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n    return this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n    define( \"jquery\", [], function() {\n        return jQuery;\n    });\n}\n\n\n\n\nvar\n    // Map over jQuery in case of overwrite\n    _jQuery = window.jQuery,\n\n    // Map over the $ in case of overwrite\n    _$ = window.$;\n\njQuery.noConflict = function( deep ) {\n    if ( window.$ === jQuery ) {\n        window.$ = _$;\n    }\n\n    if ( deep && window.jQuery === jQuery ) {\n        window.jQuery = _jQuery;\n    }\n\n    return jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in\n// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n    window.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n\n}));\n"], "crypto_js.rollups.sha224": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(g,l){var f={},k=f.lib={},h=function(){},m=k.Base={extend:function(a){h.prototype=this;var c=new h;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nq=k.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=l?c:4*a.length},toString:function(a){return(a||s).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=g.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*g.random()|0);return new q.init(c,a)}}),t=f.enc={},s=t.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,\n2),16)<<24-4*(b%8);return new q.init(d,c/2)}},n=t.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new q.init(d,c)}},j=t.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},\nw=k.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?g.ceil(f):g.max((f|0)-this._minBufferSize,0);a=f*e;b=g.min(4*a,b);if(a){for(var u=0;u<a;u+=e)this._doProcessBlock(d,u);u=d.splice(0,a);c.sigBytes-=b}return new q.init(u,b)},clone:function(){var a=m.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});k.Hasher=w.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){w.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new v.HMAC.init(a,\nd)).finalize(c)}}});var v=f.algo={};return f}(Math);\n(function(g){for(var l=CryptoJS,f=l.lib,k=f.WordArray,h=f.Hasher,f=l.algo,m=[],q=[],t=function(a){return 4294967296*(a-(a|0))|0},s=2,n=0;64>n;){var j;a:{j=s;for(var w=g.sqrt(j),v=2;v<=w;v++)if(!(j%v)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=t(g.pow(s,0.5))),q[n]=t(g.pow(s,1/3)),n++);s++}var a=[],f=f.SHA256=h.extend({_doReset:function(){this._hash=new k.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],k=b[3],h=b[4],l=b[5],m=b[6],n=b[7],p=0;64>p;p++){if(16>p)a[p]=\nc[d+p]|0;else{var j=a[p-15],r=a[p-2];a[p]=((j<<25|j>>>7)^(j<<14|j>>>18)^j>>>3)+a[p-7]+((r<<15|r>>>17)^(r<<13|r>>>19)^r>>>10)+a[p-16]}j=n+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&l^~h&m)+q[p]+a[p];r=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);n=m;m=l;l=h;h=k+j|0;k=g;g=f;f=e;e=j+r|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+k|0;b[4]=b[4]+h|0;b[5]=b[5]+l|0;b[6]=b[6]+m|0;b[7]=b[7]+n|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;\nd[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=g.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=h.clone.call(this);a._hash=this._hash.clone();return a}});l.SHA256=h._createHelper(f);l.HmacSHA256=h._createHmacHelper(f)})(Math);\n(function(){var g=CryptoJS,l=g.lib.WordArray,f=g.algo,k=f.SHA256,f=f.SHA224=k.extend({_doReset:function(){this._hash=new l.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var f=k._doFinalize.call(this);f.sigBytes-=4;return f}});g.SHA224=k._createHelper(f);g.HmacSHA224=k._createHmacHelper(f)})();\n"], "jqueryui.jquery-1.11.2.min": [".js", "/*! jQuery v1.11.2 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */\n!function(a,b){\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\"jQuery requires a window with a document\");return b(a)}:b(a)}(\"undefined\"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=\"1.11.2\",m=function(a,b){return new m.fn.init(a,b)},n=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,o=/^-ms-/,p=/-([\\da-z])/gi,q=function(a,b){return b.toUpperCase()};m.fn=m.prototype={jquery:l,constructor:m,selector:\"\",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=m.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return m.each(this,a,b)},map:function(a){return this.pushStack(m.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},m.extend=m.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\"boolean\"==typeof g&&(j=g,g=arguments[h]||{},h++),\"object\"==typeof g||m.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(m.isPlainObject(c)||(b=m.isArray(c)))?(b?(b=!1,f=a&&m.isArray(a)?a:[]):f=a&&m.isPlainObject(a)?a:{},g[d]=m.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},m.extend({expando:\"jQuery\"+(l+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\"function\"===m.type(a)},isArray:Array.isArray||function(a){return\"array\"===m.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return!m.isArray(a)&&a-parseFloat(a)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||\"object\"!==m.type(a)||a.nodeType||m.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,\"constructor\")&&!j.call(a.constructor.prototype,\"isPrototypeOf\"))return!1}catch(c){return!1}if(k.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+\"\":\"object\"==typeof a||\"function\"==typeof a?h[i.call(a)]||\"object\":typeof a},globalEval:function(b){b&&m.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(o,\"ms-\").replace(p,q)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=r(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?\"\":(a+\"\").replace(n,\"\")},makeArray:function(a,b){var c=b||[];return null!=a&&(r(Object(a))?m.merge(c,\"string\"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=r(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return\"string\"==typeof b&&(f=a[b],b=a,a=f),m.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||m.guid++,e):void 0},now:function(){return+new Date},support:k}),m.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(a,b){h[\"[object \"+b+\"]\"]=b.toLowerCase()});function r(a){var b=a.length,c=m.type(a);return\"function\"===c||m.isWindow(a)?!1:1===a.nodeType&&b?!0:\"array\"===c||0===b||\"number\"==typeof b&&b>0&&b-1 in a}var s=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=\"sizzle\"+1*new Date,v=a.document,w=0,x=0,y=hb(),z=hb(),A=hb(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",L=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",M=\"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",N=M.replace(\"w\",\"w#\"),O=\"\\\\[\"+L+\"*(\"+M+\")(?:\"+L+\"*([*^$|!~]?=)\"+L+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+N+\"))|)\"+L+\"*\\\\]\",P=\":(\"+M+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+O+\")*)|.*)\\\\)|)\",Q=new RegExp(L+\"+\",\"g\"),R=new RegExp(\"^\"+L+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+L+\"+$\",\"g\"),S=new RegExp(\"^\"+L+\"*,\"+L+\"*\"),T=new RegExp(\"^\"+L+\"*([>+~]|\"+L+\")\"+L+\"*\"),U=new RegExp(\"=\"+L+\"*([^\\\\]'\\\"]*?)\"+L+\"*\\\\]\",\"g\"),V=new RegExp(P),W=new RegExp(\"^\"+N+\"$\"),X={ID:new RegExp(\"^#(\"+M+\")\"),CLASS:new RegExp(\"^\\\\.(\"+M+\")\"),TAG:new RegExp(\"^(\"+M.replace(\"w\",\"w*\")+\")\"),ATTR:new RegExp(\"^\"+O),PSEUDO:new RegExp(\"^\"+P),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+L+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+L+\"*(?:([+-]|)\"+L+\"*(\\\\d+)|))\"+L+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+K+\")$\",\"i\"),needsContext:new RegExp(\"^\"+L+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+L+\"*((?:-\\\\d)?\\\\d*)\"+L+\"*\\\\)|)(?=[^-]|$)\",\"i\")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\\d$/i,$=/^[^{]+\\{\\s*\\[native \\w/,_=/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,ab=/[+~]/,bb=/'|\\\\/g,cb=new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\"+L+\"?|(\"+L+\")|.)\",\"ig\"),db=function(a,b,c){var d=\"0x\"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},eb=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fb){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function gb(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,\"string\"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&\"object\"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute(\"id\"))?s=r.replace(bb,\"\\\\$&\"):b.setAttribute(\"id\",s),s=\"[id='\"+s+\"'] \",l=o.length;while(l--)o[l]=s+rb(o[l]);w=ab.test(a)&&pb(b.parentNode)||b,x=o.join(\",\")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute(\"id\")}}}return i(a.replace(R,\"$1\"),b,d,e)}function hb(){var a=[];function b(c,e){return a.push(c+\" \")>d.cacheLength&&delete b[a.shift()],b[c+\" \"]=e}return b}function ib(a){return a[u]=!0,a}function jb(a){var b=n.createElement(\"div\");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function kb(a,b){var c=a.split(\"|\"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function lb(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function mb(a){return function(b){var c=b.nodeName.toLowerCase();return\"input\"===c&&b.type===a}}function nb(a){return function(b){var c=b.nodeName.toLowerCase();return(\"input\"===c||\"button\"===c)&&b.type===a}}function ob(a){return ib(function(b){return b=+b,ib(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pb(a){return a&&\"undefined\"!=typeof a.getElementsByTagName&&a}c=gb.support={},f=gb.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?\"HTML\"!==b.nodeName:!1},m=gb.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener(\"unload\",eb,!1):e.attachEvent&&e.attachEvent(\"onunload\",eb)),p=!f(g),c.attributes=jb(function(a){return a.className=\"i\",!a.getAttribute(\"className\")}),c.getElementsByTagName=jb(function(a){return a.appendChild(g.createComment(\"\")),!a.getElementsByTagName(\"*\").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=jb(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if(\"undefined\"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){return a.getAttribute(\"id\")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){var c=\"undefined\"!=typeof a.getAttributeNode&&a.getAttributeNode(\"id\");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return\"undefined\"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if(\"*\"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(jb(function(a){o.appendChild(a).innerHTML=\"<a id='\"+u+\"'></a><select id='\"+u+\"-\\f]' msallowcapture=''><option selected=''></option></select>\",a.querySelectorAll(\"[msallowcapture^='']\").length&&q.push(\"[*^$]=\"+L+\"*(?:''|\\\"\\\")\"),a.querySelectorAll(\"[selected]\").length||q.push(\"\\\\[\"+L+\"*(?:value|\"+K+\")\"),a.querySelectorAll(\"[id~=\"+u+\"-]\").length||q.push(\"~=\"),a.querySelectorAll(\":checked\").length||q.push(\":checked\"),a.querySelectorAll(\"a#\"+u+\"+*\").length||q.push(\".#.+[+~]\")}),jb(function(a){var b=g.createElement(\"input\");b.setAttribute(\"type\",\"hidden\"),a.appendChild(b).setAttribute(\"name\",\"D\"),a.querySelectorAll(\"[name=d]\").length&&q.push(\"name\"+L+\"*[*^$|!~]?=\"),a.querySelectorAll(\":enabled\").length||q.push(\":enabled\",\":disabled\"),a.querySelectorAll(\"*,:x\"),q.push(\",.*:\")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&jb(function(a){c.disconnectedMatch=s.call(a,\"div\"),s.call(a,\"[s!='']:x\"),r.push(\"!=\",P)}),q=q.length&&new RegExp(q.join(\"|\")),r=r.length&&new RegExp(r.join(\"|\")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return lb(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?lb(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},gb.matches=function(a,b){return gb(a,null,null,b)},gb.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,\"='$1']\"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return gb(b,n,null,[a]).length>0},gb.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},gb.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},gb.error=function(a){throw new Error(\"Syntax error, unrecognized expression: \"+a)},gb.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=gb.getText=function(a){var b,c=\"\",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if(\"string\"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=gb.selectors={cacheLength:50,createPseudo:ib,match:X,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(cb,db),a[3]=(a[3]||a[4]||a[5]||\"\").replace(cb,db),\"~=\"===a[2]&&(a[3]=\" \"+a[3]+\" \"),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),\"nth\"===a[1].slice(0,3)?(a[3]||gb.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*(\"even\"===a[3]||\"odd\"===a[3])),a[5]=+(a[7]+a[8]||\"odd\"===a[3])):a[3]&&gb.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||\"\":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(\")\",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(cb,db).toLowerCase();return\"*\"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+\" \"];return b||(b=new RegExp(\"(^|\"+L+\")\"+a+\"(\"+L+\"|$)\"))&&y(a,function(a){return b.test(\"string\"==typeof a.className&&a.className||\"undefined\"!=typeof a.getAttribute&&a.getAttribute(\"class\")||\"\")})},ATTR:function(a,b,c){return function(d){var e=gb.attr(d,a);return null==e?\"!=\"===b:b?(e+=\"\",\"=\"===b?e===c:\"!=\"===b?e!==c:\"^=\"===b?c&&0===e.indexOf(c):\"*=\"===b?c&&e.indexOf(c)>-1:\"$=\"===b?c&&e.slice(-c.length)===c:\"~=\"===b?(\" \"+e.replace(Q,\" \")+\" \").indexOf(c)>-1:\"|=\"===b?e===c||e.slice(0,c.length+1)===c+\"-\":!1):!0}},CHILD:function(a,b,c,d,e){var f=\"nth\"!==a.slice(0,3),g=\"last\"!==a.slice(-4),h=\"of-type\"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?\"nextSibling\":\"previousSibling\",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p=\"only\"===a&&!o&&\"nextSibling\"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||gb.error(\"unsupported pseudo: \"+a);return e[u]?e(b):e.length>1?(c=[a,a,\"\",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ib(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ib(function(a){var b=[],c=[],d=h(a.replace(R,\"$1\"));return d[u]?ib(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ib(function(a){return function(b){return gb(a,b).length>0}}),contains:ib(function(a){return a=a.replace(cb,db),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ib(function(a){return W.test(a||\"\")||gb.error(\"unsupported lang: \"+a),a=a.replace(cb,db).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute(\"xml:lang\")||b.getAttribute(\"lang\"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+\"-\");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return\"input\"===b&&!!a.checked||\"option\"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return\"input\"===b&&\"button\"===a.type||\"button\"===b},text:function(a){var b;return\"input\"===a.nodeName.toLowerCase()&&\"text\"===a.type&&(null==(b=a.getAttribute(\"type\"))||\"text\"===b.toLowerCase())},first:ob(function(){return[0]}),last:ob(function(a,b){return[b-1]}),eq:ob(function(a,b,c){return[0>c?c+b:c]}),even:ob(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:ob(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:ob(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:ob(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=mb(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=nb(b);function qb(){}qb.prototype=d.filters=d.pseudos,d.setFilters=new qb,g=gb.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+\" \"];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R,\" \")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?gb.error(a):z(a,i).slice(0)};function rb(a){for(var b=0,c=a.length,d=\"\";c>b;b++)d+=a[b].value;return d}function sb(a,b,c){var d=b.dir,e=c&&\"parentNode\"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function tb(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ub(a,b,c){for(var d=0,e=b.length;e>d;d++)gb(a,b[d],c);return c}function vb(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wb(a,b,c,d,e,f){return d&&!d[u]&&(d=wb(d)),e&&!e[u]&&(e=wb(e,f)),ib(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ub(b||\"*\",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:vb(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=vb(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=vb(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xb(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[\" \"],i=g?1:0,k=sb(function(a){return a===b},h,!0),l=sb(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sb(tb(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wb(i>1&&tb(m),i>1&&rb(a.slice(0,i-1).concat({value:\" \"===a[i-2].type?\"*\":\"\"})).replace(R,\"$1\"),c,e>i&&xb(a.slice(i,e)),f>e&&xb(a=a.slice(e)),f>e&&rb(a))}m.push(c)}return tb(m)}function yb(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q=\"0\",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG(\"*\",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=vb(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&gb.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ib(f):f}return h=gb.compile=function(a,b){var c,d=[],e=[],f=A[a+\" \"];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xb(b[c]),f[u]?d.push(f):e.push(f);f=A(a,yb(e,d)),f.selector=a}return f},i=gb.select=function(a,b,e,f){var i,j,k,l,m,n=\"function\"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&\"ID\"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(cb,db),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(cb,db),ab.test(j[0].type)&&pb(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&rb(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,ab.test(a)&&pb(b.parentNode)||b),e},c.sortStable=u.split(\"\").sort(B).join(\"\")===u,c.detectDuplicates=!!l,m(),c.sortDetached=jb(function(a){return 1&a.compareDocumentPosition(n.createElement(\"div\"))}),jb(function(a){return a.innerHTML=\"<a href='#'></a>\",\"#\"===a.firstChild.getAttribute(\"href\")})||kb(\"type|href|height|width\",function(a,b,c){return c?void 0:a.getAttribute(b,\"type\"===b.toLowerCase()?1:2)}),c.attributes&&jb(function(a){return a.innerHTML=\"<input/>\",a.firstChild.setAttribute(\"value\",\"\"),\"\"===a.firstChild.getAttribute(\"value\")})||kb(\"value\",function(a,b,c){return c||\"input\"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),jb(function(a){return null==a.getAttribute(\"disabled\")})||kb(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),gb}(a);m.find=s,m.expr=s.selectors,m.expr[\":\"]=m.expr.pseudos,m.unique=s.uniqueSort,m.text=s.getText,m.isXMLDoc=s.isXML,m.contains=s.contains;var t=m.expr.match.needsContext,u=/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,v=/^.[^:#\\[\\.,]*$/;function w(a,b,c){if(m.isFunction(b))return m.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return m.grep(a,function(a){return a===b!==c});if(\"string\"==typeof b){if(v.test(b))return m.filter(b,a,c);b=m.filter(b,a)}return m.grep(a,function(a){return m.inArray(a,b)>=0!==c})}m.filter=function(a,b,c){var d=b[0];return c&&(a=\":not(\"+a+\")\"),1===b.length&&1===d.nodeType?m.find.matchesSelector(d,a)?[d]:[]:m.find.matches(a,m.grep(b,function(a){return 1===a.nodeType}))},m.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if(\"string\"!=typeof a)return this.pushStack(m(a).filter(function(){for(b=0;e>b;b++)if(m.contains(d[b],this))return!0}));for(b=0;e>b;b++)m.find(a,d[b],c);return c=this.pushStack(e>1?m.unique(c):c),c.selector=this.selector?this.selector+\" \"+a:a,c},filter:function(a){return this.pushStack(w(this,a||[],!1))},not:function(a){return this.pushStack(w(this,a||[],!0))},is:function(a){return!!w(this,\"string\"==typeof a&&t.test(a)?m(a):a||[],!1).length}});var x,y=a.document,z=/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,A=m.fn.init=function(a,b){var c,d;if(!a)return this;if(\"string\"==typeof a){if(c=\"<\"===a.charAt(0)&&\">\"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||x).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof m?b[0]:b,m.merge(this,m.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:y,!0)),u.test(c[1])&&m.isPlainObject(b))for(c in b)m.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}if(d=y.getElementById(c[2]),d&&d.parentNode){if(d.id!==c[2])return x.find(a);this.length=1,this[0]=d}return this.context=y,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):m.isFunction(a)?\"undefined\"!=typeof x.ready?x.ready(a):a(m):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),m.makeArray(a,this))};A.prototype=m.fn,x=m(y);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};m.extend({dir:function(a,b,c){var d=[],e=a[b];while(e&&9!==e.nodeType&&(void 0===c||1!==e.nodeType||!m(e).is(c)))1===e.nodeType&&d.push(e),e=e[b];return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),m.fn.extend({has:function(a){var b,c=m(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(m.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=t.test(a)||\"string\"!=typeof a?m(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&m.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?m.unique(f):f)},index:function(a){return a?\"string\"==typeof a?m.inArray(this[0],m(a)):m.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(m.unique(m.merge(this.get(),m(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}m.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return m.dir(a,\"parentNode\")},parentsUntil:function(a,b,c){return m.dir(a,\"parentNode\",c)},next:function(a){return D(a,\"nextSibling\")},prev:function(a){return D(a,\"previousSibling\")},nextAll:function(a){return m.dir(a,\"nextSibling\")},prevAll:function(a){return m.dir(a,\"previousSibling\")},nextUntil:function(a,b,c){return m.dir(a,\"nextSibling\",c)},prevUntil:function(a,b,c){return m.dir(a,\"previousSibling\",c)},siblings:function(a){return m.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return m.sibling(a.firstChild)},contents:function(a){return m.nodeName(a,\"iframe\")?a.contentDocument||a.contentWindow.document:m.merge([],a.childNodes)}},function(a,b){m.fn[a]=function(c,d){var e=m.map(this,b,c);return\"Until\"!==a.slice(-5)&&(d=c),d&&\"string\"==typeof d&&(e=m.filter(d,e)),this.length>1&&(C[a]||(e=m.unique(e)),B.test(a)&&(e=e.reverse())),this.pushStack(e)}});var E=/\\S+/g,F={};function G(a){var b=F[a]={};return m.each(a.match(E)||[],function(a,c){b[c]=!0}),b}m.Callbacks=function(a){a=\"string\"==typeof a?F[a]||G(a):m.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(c=a.memory&&l,d=!0,f=g||0,g=0,e=h.length,b=!0;h&&e>f;f++)if(h[f].apply(l[0],l[1])===!1&&a.stopOnFalse){c=!1;break}b=!1,h&&(i?i.length&&j(i.shift()):c?h=[]:k.disable())},k={add:function(){if(h){var d=h.length;!function f(b){m.each(b,function(b,c){var d=m.type(c);\"function\"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&\"string\"!==d&&f(c)})}(arguments),b?e=h.length:c&&(g=d,j(c))}return this},remove:function(){return h&&m.each(arguments,function(a,c){var d;while((d=m.inArray(c,h,d))>-1)h.splice(d,1),b&&(e>=d&&e--,f>=d&&f--)}),this},has:function(a){return a?m.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],e=0,this},disable:function(){return h=i=c=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,c||k.disable(),this},locked:function(){return!i},fireWith:function(a,c){return!h||d&&!i||(c=c||[],c=[a,c.slice?c.slice():c],b?i.push(c):j(c)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!d}};return k},m.extend({Deferred:function(a){var b=[[\"resolve\",\"done\",m.Callbacks(\"once memory\"),\"resolved\"],[\"reject\",\"fail\",m.Callbacks(\"once memory\"),\"rejected\"],[\"notify\",\"progress\",m.Callbacks(\"memory\")]],c=\"pending\",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return m.Deferred(function(c){m.each(b,function(b,f){var g=m.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&m.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+\"With\"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?m.extend(a,d):d}},e={};return d.pipe=d.then,m.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+\"With\"](this===e?d:this,arguments),this},e[f[0]+\"With\"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&m.isFunction(a.promise)?e:0,g=1===f?a:m.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&m.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;m.fn.ready=function(a){return m.ready.promise().done(a),this},m.extend({isReady:!1,readyWait:1,holdReady:function(a){a?m.readyWait++:m.ready(!0)},ready:function(a){if(a===!0?!--m.readyWait:!m.isReady){if(!y.body)return setTimeout(m.ready);m.isReady=!0,a!==!0&&--m.readyWait>0||(H.resolveWith(y,[m]),m.fn.triggerHandler&&(m(y).triggerHandler(\"ready\"),m(y).off(\"ready\")))}}});function I(){y.addEventListener?(y.removeEventListener(\"DOMContentLoaded\",J,!1),a.removeEventListener(\"load\",J,!1)):(y.detachEvent(\"onreadystatechange\",J),a.detachEvent(\"onload\",J))}function J(){(y.addEventListener||\"load\"===event.type||\"complete\"===y.readyState)&&(I(),m.ready())}m.ready.promise=function(b){if(!H)if(H=m.Deferred(),\"complete\"===y.readyState)setTimeout(m.ready);else if(y.addEventListener)y.addEventListener(\"DOMContentLoaded\",J,!1),a.addEventListener(\"load\",J,!1);else{y.attachEvent(\"onreadystatechange\",J),a.attachEvent(\"onload\",J);var c=!1;try{c=null==a.frameElement&&y.documentElement}catch(d){}c&&c.doScroll&&!function e(){if(!m.isReady){try{c.doScroll(\"left\")}catch(a){return setTimeout(e,50)}I(),m.ready()}}()}return H.promise(b)};var K=\"undefined\",L;for(L in m(k))break;k.ownLast=\"0\"!==L,k.inlineBlockNeedsLayout=!1,m(function(){var a,b,c,d;c=y.getElementsByTagName(\"body\")[0],c&&c.style&&(b=y.createElement(\"div\"),d=y.createElement(\"div\"),d.style.cssText=\"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText=\"display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1\",k.inlineBlockNeedsLayout=a=3===b.offsetWidth,a&&(c.style.zoom=1)),c.removeChild(d))}),function(){var a=y.createElement(\"div\");if(null==k.deleteExpando){k.deleteExpando=!0;try{delete a.test}catch(b){k.deleteExpando=!1}}a=null}(),m.acceptData=function(a){var b=m.noData[(a.nodeName+\" \").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute(\"classid\")===b};var M=/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,N=/([A-Z])/g;function O(a,b,c){if(void 0===c&&1===a.nodeType){var d=\"data-\"+b.replace(N,\"-$1\").toLowerCase();if(c=a.getAttribute(d),\"string\"==typeof c){try{c=\"true\"===c?!0:\"false\"===c?!1:\"null\"===c?null:+c+\"\"===c?+c:M.test(c)?m.parseJSON(c):c}catch(e){}m.data(a,b,c)}else c=void 0}return c}function P(a){var b;for(b in a)if((\"data\"!==b||!m.isEmptyObject(a[b]))&&\"toJSON\"!==b)return!1;\nreturn!0}function Q(a,b,d,e){if(m.acceptData(a)){var f,g,h=m.expando,i=a.nodeType,j=i?m.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||\"string\"!=typeof b)return k||(k=i?a[h]=c.pop()||m.guid++:h),j[k]||(j[k]=i?{}:{toJSON:m.noop}),(\"object\"==typeof b||\"function\"==typeof b)&&(e?j[k]=m.extend(j[k],b):j[k].data=m.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[m.camelCase(b)]=d),\"string\"==typeof b?(f=g[b],null==f&&(f=g[m.camelCase(b)])):f=g,f}}function R(a,b,c){if(m.acceptData(a)){var d,e,f=a.nodeType,g=f?m.cache:a,h=f?a[m.expando]:m.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){m.isArray(b)?b=b.concat(m.map(b,m.camelCase)):b in d?b=[b]:(b=m.camelCase(b),b=b in d?[b]:b.split(\" \")),e=b.length;while(e--)delete d[b[e]];if(c?!P(d):!m.isEmptyObject(d))return}(c||(delete g[h].data,P(g[h])))&&(f?m.cleanData([a],!0):k.deleteExpando||g!=g.window?delete g[h]:g[h]=null)}}}m.extend({cache:{},noData:{\"applet \":!0,\"embed \":!0,\"object \":\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"},hasData:function(a){return a=a.nodeType?m.cache[a[m.expando]]:a[m.expando],!!a&&!P(a)},data:function(a,b,c){return Q(a,b,c)},removeData:function(a,b){return R(a,b)},_data:function(a,b,c){return Q(a,b,c,!0)},_removeData:function(a,b){return R(a,b,!0)}}),m.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=m.data(f),1===f.nodeType&&!m._data(f,\"parsedAttrs\"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf(\"data-\")&&(d=m.camelCase(d.slice(5)),O(f,d,e[d])));m._data(f,\"parsedAttrs\",!0)}return e}return\"object\"==typeof a?this.each(function(){m.data(this,a)}):arguments.length>1?this.each(function(){m.data(this,a,b)}):f?O(f,a,m.data(f,a)):void 0},removeData:function(a){return this.each(function(){m.removeData(this,a)})}}),m.extend({queue:function(a,b,c){var d;return a?(b=(b||\"fx\")+\"queue\",d=m._data(a,b),c&&(!d||m.isArray(c)?d=m._data(a,b,m.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||\"fx\";var c=m.queue(a,b),d=c.length,e=c.shift(),f=m._queueHooks(a,b),g=function(){m.dequeue(a,b)};\"inprogress\"===e&&(e=c.shift(),d--),e&&(\"fx\"===b&&c.unshift(\"inprogress\"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+\"queueHooks\";return m._data(a,c)||m._data(a,c,{empty:m.Callbacks(\"once memory\").add(function(){m._removeData(a,b+\"queue\"),m._removeData(a,c)})})}}),m.fn.extend({queue:function(a,b){var c=2;return\"string\"!=typeof a&&(b=a,a=\"fx\",c--),arguments.length<c?m.queue(this[0],a):void 0===b?this:this.each(function(){var c=m.queue(this,a,b);m._queueHooks(this,a),\"fx\"===a&&\"inprogress\"!==c[0]&&m.dequeue(this,a)})},dequeue:function(a){return this.each(function(){m.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||\"fx\",[])},promise:function(a,b){var c,d=1,e=m.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};\"string\"!=typeof a&&(b=a,a=void 0),a=a||\"fx\";while(g--)c=m._data(f[g],a+\"queueHooks\"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var S=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,T=[\"Top\",\"Right\",\"Bottom\",\"Left\"],U=function(a,b){return a=b||a,\"none\"===m.css(a,\"display\")||!m.contains(a.ownerDocument,a)},V=m.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if(\"object\"===m.type(c)){e=!0;for(h in c)m.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,m.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(m(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},W=/^(?:checkbox|radio)$/i;!function(){var a=y.createElement(\"input\"),b=y.createElement(\"div\"),c=y.createDocumentFragment();if(b.innerHTML=\"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\",k.leadingWhitespace=3===b.firstChild.nodeType,k.tbody=!b.getElementsByTagName(\"tbody\").length,k.htmlSerialize=!!b.getElementsByTagName(\"link\").length,k.html5Clone=\"<:nav></:nav>\"!==y.createElement(\"nav\").cloneNode(!0).outerHTML,a.type=\"checkbox\",a.checked=!0,c.appendChild(a),k.appendChecked=a.checked,b.innerHTML=\"<textarea>x</textarea>\",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue,c.appendChild(b),b.innerHTML=\"<input type='radio' checked='checked' name='t'/>\",k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,k.noCloneEvent=!0,b.attachEvent&&(b.attachEvent(\"onclick\",function(){k.noCloneEvent=!1}),b.cloneNode(!0).click()),null==k.deleteExpando){k.deleteExpando=!0;try{delete b.test}catch(d){k.deleteExpando=!1}}}(),function(){var b,c,d=y.createElement(\"div\");for(b in{submit:!0,change:!0,focusin:!0})c=\"on\"+b,(k[b+\"Bubbles\"]=c in a)||(d.setAttribute(c,\"t\"),k[b+\"Bubbles\"]=d.attributes[c].expando===!1);d=null}();var X=/^(?:input|select|textarea)$/i,Y=/^key/,Z=/^(?:mouse|pointer|contextmenu)|click/,$=/^(?:focusinfocus|focusoutblur)$/,_=/^([^.]*)(?:\\.(.+)|)$/;function ab(){return!0}function bb(){return!1}function cb(){try{return y.activeElement}catch(a){}}m.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=m.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return typeof m===K||a&&m.event.triggered===a.type?void 0:m.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||\"\").match(E)||[\"\"],h=b.length;while(h--)f=_.exec(b[h])||[],o=q=f[1],p=(f[2]||\"\").split(\".\").sort(),o&&(j=m.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=m.event.special[o]||{},l=m.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&m.expr.match.needsContext.test(e),namespace:p.join(\".\")},i),(n=g[o])||(n=g[o]=[],n.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent(\"on\"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?n.splice(n.delegateCount++,0,l):n.push(l),m.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,n,o,p,q,r=m.hasData(a)&&m._data(a);if(r&&(k=r.events)){b=(b||\"\").match(E)||[\"\"],j=b.length;while(j--)if(h=_.exec(b[j])||[],o=q=h[1],p=(h[2]||\"\").split(\".\").sort(),o){l=m.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,n=k[o]||[],h=h[2]&&new RegExp(\"(^|\\\\.)\"+p.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),i=f=n.length;while(f--)g=n[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&(\"**\"!==d||!g.selector)||(n.splice(f,1),g.selector&&n.delegateCount--,l.remove&&l.remove.call(a,g));i&&!n.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||m.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)m.event.remove(a,o+b[j],c,d,!0);m.isEmptyObject(k)&&(delete r.handle,m._removeData(a,\"events\"))}},trigger:function(b,c,d,e){var f,g,h,i,k,l,n,o=[d||y],p=j.call(b,\"type\")?b.type:b,q=j.call(b,\"namespace\")?b.namespace.split(\".\"):[];if(h=l=d=d||y,3!==d.nodeType&&8!==d.nodeType&&!$.test(p+m.event.triggered)&&(p.indexOf(\".\")>=0&&(q=p.split(\".\"),p=q.shift(),q.sort()),g=p.indexOf(\":\")<0&&\"on\"+p,b=b[m.expando]?b:new m.Event(p,\"object\"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=q.join(\".\"),b.namespace_re=b.namespace?new RegExp(\"(^|\\\\.)\"+q.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:m.makeArray(c,[b]),k=m.event.special[p]||{},e||!k.trigger||k.trigger.apply(d,c)!==!1)){if(!e&&!k.noBubble&&!m.isWindow(d)){for(i=k.delegateType||p,$.test(i+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),l=h;l===(d.ownerDocument||y)&&o.push(l.defaultView||l.parentWindow||a)}n=0;while((h=o[n++])&&!b.isPropagationStopped())b.type=n>1?i:k.bindType||p,f=(m._data(h,\"events\")||{})[b.type]&&m._data(h,\"handle\"),f&&f.apply(h,c),f=g&&h[g],f&&f.apply&&m.acceptData(h)&&(b.result=f.apply(h,c),b.result===!1&&b.preventDefault());if(b.type=p,!e&&!b.isDefaultPrevented()&&(!k._default||k._default.apply(o.pop(),c)===!1)&&m.acceptData(d)&&g&&d[p]&&!m.isWindow(d)){l=d[g],l&&(d[g]=null),m.event.triggered=p;try{d[p]()}catch(r){}m.event.triggered=void 0,l&&(d[g]=l)}return b.result}},dispatch:function(a){a=m.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(m._data(this,\"events\")||{})[a.type]||[],k=m.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=m.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,g=0;while((e=f.handlers[g++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(e.namespace))&&(a.handleObj=e,a.data=e.data,c=((m.event.special[e.origType]||{}).handle||e.handler).apply(f.elem,i),void 0!==c&&(a.result=c)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||\"click\"!==a.type))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||\"click\"!==a.type)){for(e=[],f=0;h>f;f++)d=b[f],c=d.selector+\" \",void 0===e[c]&&(e[c]=d.needsContext?m(c,this).index(i)>=0:m.find(c,this,null,[i]).length),e[c]&&e.push(d);e.length&&g.push({elem:i,handlers:e})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[m.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=Z.test(e)?this.mouseHooks:Y.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new m.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=f.srcElement||y),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,g.filter?g.filter(a,f):a},props:\"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),fixHooks:{},keyHooks:{props:\"char charCode key keyCode\".split(\" \"),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:\"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),filter:function(a,b){var c,d,e,f=b.button,g=b.fromElement;return null==a.pageX&&null!=b.clientX&&(d=a.target.ownerDocument||y,e=d.documentElement,c=d.body,a.pageX=b.clientX+(e&&e.scrollLeft||c&&c.scrollLeft||0)-(e&&e.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||c&&c.scrollTop||0)-(e&&e.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&g&&(a.relatedTarget=g===a.target?b.toElement:g),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==cb()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:\"focusin\"},blur:{trigger:function(){return this===cb()&&this.blur?(this.blur(),!1):void 0},delegateType:\"focusout\"},click:{trigger:function(){return m.nodeName(this,\"input\")&&\"checkbox\"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return m.nodeName(a.target,\"a\")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=m.extend(new m.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?m.event.trigger(e,null,b):m.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},m.removeEvent=y.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d=\"on\"+b;a.detachEvent&&(typeof a[d]===K&&(a[d]=null),a.detachEvent(d,c))},m.Event=function(a,b){return this instanceof m.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?ab:bb):this.type=a,b&&m.extend(this,b),this.timeStamp=a&&a.timeStamp||m.now(),void(this[m.expando]=!0)):new m.Event(a,b)},m.Event.prototype={isDefaultPrevented:bb,isPropagationStopped:bb,isImmediatePropagationStopped:bb,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=ab,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=ab,a&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=ab,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},m.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(a,b){m.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!m.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.submitBubbles||(m.event.special.submit={setup:function(){return m.nodeName(this,\"form\")?!1:void m.event.add(this,\"click._submit keypress._submit\",function(a){var b=a.target,c=m.nodeName(b,\"input\")||m.nodeName(b,\"button\")?b.form:void 0;c&&!m._data(c,\"submitBubbles\")&&(m.event.add(c,\"submit._submit\",function(a){a._submit_bubble=!0}),m._data(c,\"submitBubbles\",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&m.event.simulate(\"submit\",this.parentNode,a,!0))},teardown:function(){return m.nodeName(this,\"form\")?!1:void m.event.remove(this,\"._submit\")}}),k.changeBubbles||(m.event.special.change={setup:function(){return X.test(this.nodeName)?((\"checkbox\"===this.type||\"radio\"===this.type)&&(m.event.add(this,\"propertychange._change\",function(a){\"checked\"===a.originalEvent.propertyName&&(this._just_changed=!0)}),m.event.add(this,\"click._change\",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),m.event.simulate(\"change\",this,a,!0)})),!1):void m.event.add(this,\"beforeactivate._change\",function(a){var b=a.target;X.test(b.nodeName)&&!m._data(b,\"changeBubbles\")&&(m.event.add(b,\"change._change\",function(a){!this.parentNode||a.isSimulated||a.isTrigger||m.event.simulate(\"change\",this.parentNode,a,!0)}),m._data(b,\"changeBubbles\",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||\"radio\"!==b.type&&\"checkbox\"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return m.event.remove(this,\"._change\"),!X.test(this.nodeName)}}),k.focusinBubbles||m.each({focus:\"focusin\",blur:\"focusout\"},function(a,b){var c=function(a){m.event.simulate(b,a.target,m.event.fix(a),!0)};m.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=m._data(d,b);e||d.addEventListener(a,c,!0),m._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=m._data(d,b)-1;e?m._data(d,b,e):(d.removeEventListener(a,c,!0),m._removeData(d,b))}}}),m.fn.extend({on:function(a,b,c,d,e){var f,g;if(\"object\"==typeof a){\"string\"!=typeof b&&(c=c||b,b=void 0);for(f in a)this.on(f,b,c,a[f],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&(\"string\"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=bb;else if(!d)return this;return 1===e&&(g=d,d=function(a){return m().off(a),g.apply(this,arguments)},d.guid=g.guid||(g.guid=m.guid++)),this.each(function(){m.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,m(a.delegateTarget).off(d.namespace?d.origType+\".\"+d.namespace:d.origType,d.selector,d.handler),this;if(\"object\"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||\"function\"==typeof b)&&(c=b,b=void 0),c===!1&&(c=bb),this.each(function(){m.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){m.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?m.event.trigger(a,b,c,!0):void 0}});function db(a){var b=eb.split(\"|\"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}var eb=\"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",fb=/ jQuery\\d+=\"(?:null|\\d+)\"/g,gb=new RegExp(\"<(?:\"+eb+\")[\\\\s/>]\",\"i\"),hb=/^\\s+/,ib=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,jb=/<([\\w:]+)/,kb=/<tbody/i,lb=/<|&#?\\w+;/,mb=/<(?:script|style|link)/i,nb=/checked\\s*(?:[^=]|=\\s*.checked.)/i,ob=/^$|\\/(?:java|ecma)script/i,pb=/^true\\/(.*)/,qb=/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,rb={option:[1,\"<select multiple='multiple'>\",\"</select>\"],legend:[1,\"<fieldset>\",\"</fieldset>\"],area:[1,\"<map>\",\"</map>\"],param:[1,\"<object>\",\"</object>\"],thead:[1,\"<table>\",\"</table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],col:[2,\"<table><tbody></tbody><colgroup>\",\"</colgroup></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:k.htmlSerialize?[0,\"\",\"\"]:[1,\"X<div>\",\"</div>\"]},sb=db(y),tb=sb.appendChild(y.createElement(\"div\"));rb.optgroup=rb.option,rb.tbody=rb.tfoot=rb.colgroup=rb.caption=rb.thead,rb.th=rb.td;function ub(a,b){var c,d,e=0,f=typeof a.getElementsByTagName!==K?a.getElementsByTagName(b||\"*\"):typeof a.querySelectorAll!==K?a.querySelectorAll(b||\"*\"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||m.nodeName(d,b)?f.push(d):m.merge(f,ub(d,b));return void 0===b||b&&m.nodeName(a,b)?m.merge([a],f):f}function vb(a){W.test(a.type)&&(a.defaultChecked=a.checked)}function wb(a,b){return m.nodeName(a,\"table\")&&m.nodeName(11!==b.nodeType?b:b.firstChild,\"tr\")?a.getElementsByTagName(\"tbody\")[0]||a.appendChild(a.ownerDocument.createElement(\"tbody\")):a}function xb(a){return a.type=(null!==m.find.attr(a,\"type\"))+\"/\"+a.type,a}function yb(a){var b=pb.exec(a.type);return b?a.type=b[1]:a.removeAttribute(\"type\"),a}function zb(a,b){for(var c,d=0;null!=(c=a[d]);d++)m._data(c,\"globalEval\",!b||m._data(b[d],\"globalEval\"))}function Ab(a,b){if(1===b.nodeType&&m.hasData(a)){var c,d,e,f=m._data(a),g=m._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)m.event.add(b,c,h[c][d])}g.data&&(g.data=m.extend({},g.data))}}function Bb(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!k.noCloneEvent&&b[m.expando]){e=m._data(b);for(d in e.events)m.removeEvent(b,d,e.handle);b.removeAttribute(m.expando)}\"script\"===c&&b.text!==a.text?(xb(b).text=a.text,yb(b)):\"object\"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),k.html5Clone&&a.innerHTML&&!m.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):\"input\"===c&&W.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):\"option\"===c?b.defaultSelected=b.selected=a.defaultSelected:(\"input\"===c||\"textarea\"===c)&&(b.defaultValue=a.defaultValue)}}m.extend({clone:function(a,b,c){var d,e,f,g,h,i=m.contains(a.ownerDocument,a);if(k.html5Clone||m.isXMLDoc(a)||!gb.test(\"<\"+a.nodeName+\">\")?f=a.cloneNode(!0):(tb.innerHTML=a.outerHTML,tb.removeChild(f=tb.firstChild)),!(k.noCloneEvent&&k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||m.isXMLDoc(a)))for(d=ub(f),h=ub(a),g=0;null!=(e=h[g]);++g)d[g]&&Bb(e,d[g]);if(b)if(c)for(h=h||ub(a),d=d||ub(f),g=0;null!=(e=h[g]);g++)Ab(e,d[g]);else Ab(a,f);return d=ub(f,\"script\"),d.length>0&&zb(d,!i&&ub(a,\"script\")),d=h=e=null,f},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,l,n=a.length,o=db(b),p=[],q=0;n>q;q++)if(f=a[q],f||0===f)if(\"object\"===m.type(f))m.merge(p,f.nodeType?[f]:f);else if(lb.test(f)){h=h||o.appendChild(b.createElement(\"div\")),i=(jb.exec(f)||[\"\",\"\"])[1].toLowerCase(),l=rb[i]||rb._default,h.innerHTML=l[1]+f.replace(ib,\"<$1></$2>\")+l[2],e=l[0];while(e--)h=h.lastChild;if(!k.leadingWhitespace&&hb.test(f)&&p.push(b.createTextNode(hb.exec(f)[0])),!k.tbody){f=\"table\"!==i||kb.test(f)?\"<table>\"!==l[1]||kb.test(f)?0:h:h.firstChild,e=f&&f.childNodes.length;while(e--)m.nodeName(j=f.childNodes[e],\"tbody\")&&!j.childNodes.length&&f.removeChild(j)}m.merge(p,h.childNodes),h.textContent=\"\";while(h.firstChild)h.removeChild(h.firstChild);h=o.lastChild}else p.push(b.createTextNode(f));h&&o.removeChild(h),k.appendChecked||m.grep(ub(p,\"input\"),vb),q=0;while(f=p[q++])if((!d||-1===m.inArray(f,d))&&(g=m.contains(f.ownerDocument,f),h=ub(o.appendChild(f),\"script\"),g&&zb(h),c)){e=0;while(f=h[e++])ob.test(f.type||\"\")&&c.push(f)}return h=null,o},cleanData:function(a,b){for(var d,e,f,g,h=0,i=m.expando,j=m.cache,l=k.deleteExpando,n=m.event.special;null!=(d=a[h]);h++)if((b||m.acceptData(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)n[e]?m.event.remove(d,e):m.removeEvent(d,e,g.handle);j[f]&&(delete j[f],l?delete d[i]:typeof d.removeAttribute!==K?d.removeAttribute(i):d[i]=null,c.push(f))}}}),m.fn.extend({text:function(a){return V(this,function(a){return void 0===a?m.text(this):this.empty().append((this[0]&&this[0].ownerDocument||y).createTextNode(a))},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wb(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=wb(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?m.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||m.cleanData(ub(c)),c.parentNode&&(b&&m.contains(c.ownerDocument,c)&&zb(ub(c,\"script\")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&m.cleanData(ub(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&m.nodeName(a,\"select\")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return m.clone(this,a,b)})},html:function(a){return V(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(fb,\"\"):void 0;if(!(\"string\"!=typeof a||mb.test(a)||!k.htmlSerialize&&gb.test(a)||!k.leadingWhitespace&&hb.test(a)||rb[(jb.exec(a)||[\"\",\"\"])[1].toLowerCase()])){a=a.replace(ib,\"<$1></$2>\");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(m.cleanData(ub(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,m.cleanData(ub(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,n=this,o=l-1,p=a[0],q=m.isFunction(p);if(q||l>1&&\"string\"==typeof p&&!k.checkClone&&nb.test(p))return this.each(function(c){var d=n.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(i=m.buildFragment(a,this[0].ownerDocument,!1,this),c=i.firstChild,1===i.childNodes.length&&(i=c),c)){for(g=m.map(ub(i,\"script\"),xb),f=g.length;l>j;j++)d=i,j!==o&&(d=m.clone(d,!0,!0),f&&m.merge(g,ub(d,\"script\"))),b.call(this[j],d,j);if(f)for(h=g[g.length-1].ownerDocument,m.map(g,yb),j=0;f>j;j++)d=g[j],ob.test(d.type||\"\")&&!m._data(d,\"globalEval\")&&m.contains(h,d)&&(d.src?m._evalUrl&&m._evalUrl(d.src):m.globalEval((d.text||d.textContent||d.innerHTML||\"\").replace(qb,\"\")));i=c=null}return this}}),m.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(a,b){m.fn[a]=function(a){for(var c,d=0,e=[],g=m(a),h=g.length-1;h>=d;d++)c=d===h?this:this.clone(!0),m(g[d])[b](c),f.apply(e,c.get());return this.pushStack(e)}});var Cb,Db={};function Eb(b,c){var d,e=m(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:m.css(e[0],\"display\");return e.detach(),f}function Fb(a){var b=y,c=Db[a];return c||(c=Eb(a,b),\"none\"!==c&&c||(Cb=(Cb||m(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement),b=(Cb[0].contentWindow||Cb[0].contentDocument).document,b.write(),b.close(),c=Eb(a,b),Cb.detach()),Db[a]=c),c}!function(){var a;k.shrinkWrapBlocks=function(){if(null!=a)return a;a=!1;var b,c,d;return c=y.getElementsByTagName(\"body\")[0],c&&c.style?(b=y.createElement(\"div\"),d=y.createElement(\"div\"),d.style.cssText=\"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\",c.appendChild(d).appendChild(b),typeof b.style.zoom!==K&&(b.style.cssText=\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1\",b.appendChild(y.createElement(\"div\")).style.width=\"5px\",a=3!==b.offsetWidth),c.removeChild(d),a):void 0}}();var Gb=/^margin/,Hb=new RegExp(\"^(\"+S+\")(?!px)[a-z%]+$\",\"i\"),Ib,Jb,Kb=/^(top|right|bottom|left)$/;a.getComputedStyle?(Ib=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)},Jb=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ib(a),g=c?c.getPropertyValue(b)||c[b]:void 0,c&&(\"\"!==g||m.contains(a.ownerDocument,a)||(g=m.style(a,b)),Hb.test(g)&&Gb.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0===g?g:g+\"\"}):y.documentElement.currentStyle&&(Ib=function(a){return a.currentStyle},Jb=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ib(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Hb.test(g)&&!Kb.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left=\"fontSize\"===b?\"1em\":g,g=h.pixelLeft+\"px\",h.left=d,f&&(e.left=f)),void 0===g?g:g+\"\"||\"auto\"});function Lb(a,b){return{get:function(){var c=a();if(null!=c)return c?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d,e,f,g,h;if(b=y.createElement(\"div\"),b.innerHTML=\"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\",d=b.getElementsByTagName(\"a\")[0],c=d&&d.style){c.cssText=\"float:left;opacity:.5\",k.opacity=\"0.5\"===c.opacity,k.cssFloat=!!c.cssFloat,b.style.backgroundClip=\"content-box\",b.cloneNode(!0).style.backgroundClip=\"\",k.clearCloneStyle=\"content-box\"===b.style.backgroundClip,k.boxSizing=\"\"===c.boxSizing||\"\"===c.MozBoxSizing||\"\"===c.WebkitBoxSizing,m.extend(k,{reliableHiddenOffsets:function(){return null==g&&i(),g},boxSizingReliable:function(){return null==f&&i(),f},pixelPosition:function(){return null==e&&i(),e},reliableMarginRight:function(){return null==h&&i(),h}});function i(){var b,c,d,i;c=y.getElementsByTagName(\"body\")[0],c&&c.style&&(b=y.createElement(\"div\"),d=y.createElement(\"div\"),d.style.cssText=\"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\",c.appendChild(d).appendChild(b),b.style.cssText=\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute\",e=f=!1,h=!0,a.getComputedStyle&&(e=\"1%\"!==(a.getComputedStyle(b,null)||{}).top,f=\"4px\"===(a.getComputedStyle(b,null)||{width:\"4px\"}).width,i=b.appendChild(y.createElement(\"div\")),i.style.cssText=b.style.cssText=\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0\",i.style.marginRight=i.style.width=\"0\",b.style.width=\"1px\",h=!parseFloat((a.getComputedStyle(i,null)||{}).marginRight),b.removeChild(i)),b.innerHTML=\"<table><tr><td></td><td>t</td></tr></table>\",i=b.getElementsByTagName(\"td\"),i[0].style.cssText=\"margin:0;border:0;padding:0;display:none\",g=0===i[0].offsetHeight,g&&(i[0].style.display=\"\",i[1].style.display=\"none\",g=0===i[0].offsetHeight),c.removeChild(d))}}}(),m.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var Mb=/alpha\\([^)]*\\)/i,Nb=/opacity\\s*=\\s*([^)]*)/,Ob=/^(none|table(?!-c[ea]).+)/,Pb=new RegExp(\"^(\"+S+\")(.*)$\",\"i\"),Qb=new RegExp(\"^([+-])=(\"+S+\")\",\"i\"),Rb={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Sb={letterSpacing:\"0\",fontWeight:\"400\"},Tb=[\"Webkit\",\"O\",\"Moz\",\"ms\"];function Ub(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=Tb.length;while(e--)if(b=Tb[e]+c,b in a)return b;return d}function Vb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=m._data(d,\"olddisplay\"),c=d.style.display,b?(f[g]||\"none\"!==c||(d.style.display=\"\"),\"\"===d.style.display&&U(d)&&(f[g]=m._data(d,\"olddisplay\",Fb(d.nodeName)))):(e=U(d),(c&&\"none\"!==c||!e)&&m._data(d,\"olddisplay\",e?c:m.css(d,\"display\"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&\"none\"!==d.style.display&&\"\"!==d.style.display||(d.style.display=b?f[g]||\"\":\"none\"));return a}function Wb(a,b,c){var d=Pb.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||\"px\"):b}function Xb(a,b,c,d,e){for(var f=c===(d?\"border\":\"content\")?4:\"width\"===b?1:0,g=0;4>f;f+=2)\"margin\"===c&&(g+=m.css(a,c+T[f],!0,e)),d?(\"content\"===c&&(g-=m.css(a,\"padding\"+T[f],!0,e)),\"margin\"!==c&&(g-=m.css(a,\"border\"+T[f]+\"Width\",!0,e))):(g+=m.css(a,\"padding\"+T[f],!0,e),\"padding\"!==c&&(g+=m.css(a,\"border\"+T[f]+\"Width\",!0,e)));return g}function Yb(a,b,c){var d=!0,e=\"width\"===b?a.offsetWidth:a.offsetHeight,f=Ib(a),g=k.boxSizing&&\"border-box\"===m.css(a,\"boxSizing\",!1,f);if(0>=e||null==e){if(e=Jb(a,b,f),(0>e||null==e)&&(e=a.style[b]),Hb.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Xb(a,b,c||(g?\"border\":\"content\"),d,f)+\"px\"}m.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Jb(a,\"opacity\");return\"\"===c?\"1\":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{\"float\":k.cssFloat?\"cssFloat\":\"styleFloat\"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=m.camelCase(b),i=a.style;if(b=m.cssProps[h]||(m.cssProps[h]=Ub(i,h)),g=m.cssHooks[b]||m.cssHooks[h],void 0===c)return g&&\"get\"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,\"string\"===f&&(e=Qb.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(m.css(a,b)),f=\"number\"),null!=c&&c===c&&(\"number\"!==f||m.cssNumber[h]||(c+=\"px\"),k.clearCloneStyle||\"\"!==c||0!==b.indexOf(\"background\")||(i[b]=\"inherit\"),!(g&&\"set\"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=m.camelCase(b);return b=m.cssProps[h]||(m.cssProps[h]=Ub(a.style,h)),g=m.cssHooks[b]||m.cssHooks[h],g&&\"get\"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Jb(a,b,d)),\"normal\"===f&&b in Sb&&(f=Sb[b]),\"\"===c||c?(e=parseFloat(f),c===!0||m.isNumeric(e)?e||0:f):f}}),m.each([\"height\",\"width\"],function(a,b){m.cssHooks[b]={get:function(a,c,d){return c?Ob.test(m.css(a,\"display\"))&&0===a.offsetWidth?m.swap(a,Rb,function(){return Yb(a,b,d)}):Yb(a,b,d):void 0},set:function(a,c,d){var e=d&&Ib(a);return Wb(a,c,d?Xb(a,b,d,k.boxSizing&&\"border-box\"===m.css(a,\"boxSizing\",!1,e),e):0)}}}),k.opacity||(m.cssHooks.opacity={get:function(a,b){return Nb.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||\"\")?.01*parseFloat(RegExp.$1)+\"\":b?\"1\":\"\"},set:function(a,b){var c=a.style,d=a.currentStyle,e=m.isNumeric(b)?\"alpha(opacity=\"+100*b+\")\":\"\",f=d&&d.filter||c.filter||\"\";c.zoom=1,(b>=1||\"\"===b)&&\"\"===m.trim(f.replace(Mb,\"\"))&&c.removeAttribute&&(c.removeAttribute(\"filter\"),\"\"===b||d&&!d.filter)||(c.filter=Mb.test(f)?f.replace(Mb,e):f+\" \"+e)}}),m.cssHooks.marginRight=Lb(k.reliableMarginRight,function(a,b){return b?m.swap(a,{display:\"inline-block\"},Jb,[a,\"marginRight\"]):void 0}),m.each({margin:\"\",padding:\"\",border:\"Width\"},function(a,b){m.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f=\"string\"==typeof c?c.split(\" \"):[c];4>d;d++)e[a+T[d]+b]=f[d]||f[d-2]||f[0];return e}},Gb.test(a)||(m.cssHooks[a+b].set=Wb)}),m.fn.extend({css:function(a,b){return V(this,function(a,b,c){var d,e,f={},g=0;if(m.isArray(b)){for(d=Ib(a),e=b.length;e>g;g++)f[b[g]]=m.css(a,b[g],!1,d);return f}return void 0!==c?m.style(a,b,c):m.css(a,b)},a,b,arguments.length>1)},show:function(){return Vb(this,!0)},hide:function(){return Vb(this)},toggle:function(a){return\"boolean\"==typeof a?a?this.show():this.hide():this.each(function(){U(this)?m(this).show():m(this).hide()})}});function Zb(a,b,c,d,e){return new Zb.prototype.init(a,b,c,d,e)\n}m.Tween=Zb,Zb.prototype={constructor:Zb,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||\"swing\",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(m.cssNumber[c]?\"\":\"px\")},cur:function(){var a=Zb.propHooks[this.prop];return a&&a.get?a.get(this):Zb.propHooks._default.get(this)},run:function(a){var b,c=Zb.propHooks[this.prop];return this.pos=b=this.options.duration?m.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Zb.propHooks._default.set(this),this}},Zb.prototype.init.prototype=Zb.prototype,Zb.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=m.css(a.elem,a.prop,\"\"),b&&\"auto\"!==b?b:0):a.elem[a.prop]},set:function(a){m.fx.step[a.prop]?m.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[m.cssProps[a.prop]]||m.cssHooks[a.prop])?m.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Zb.propHooks.scrollTop=Zb.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},m.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},m.fx=Zb.prototype.init,m.fx.step={};var $b,_b,ac=/^(?:toggle|show|hide)$/,bc=new RegExp(\"^(?:([+-])=|)(\"+S+\")([a-z%]*)$\",\"i\"),cc=/queueHooks$/,dc=[ic],ec={\"*\":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=bc.exec(b),f=e&&e[3]||(m.cssNumber[a]?\"\":\"px\"),g=(m.cssNumber[a]||\"px\"!==f&&+d)&&bc.exec(m.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||\".5\",g/=h,m.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function fc(){return setTimeout(function(){$b=void 0}),$b=m.now()}function gc(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=T[e],d[\"margin\"+c]=d[\"padding\"+c]=a;return b&&(d.opacity=d.width=a),d}function hc(a,b,c){for(var d,e=(ec[b]||[]).concat(ec[\"*\"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function ic(a,b,c){var d,e,f,g,h,i,j,l,n=this,o={},p=a.style,q=a.nodeType&&U(a),r=m._data(a,\"fxshow\");c.queue||(h=m._queueHooks(a,\"fx\"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,n.always(function(){n.always(function(){h.unqueued--,m.queue(a,\"fx\").length||h.empty.fire()})})),1===a.nodeType&&(\"height\"in b||\"width\"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=m.css(a,\"display\"),l=\"none\"===j?m._data(a,\"olddisplay\")||Fb(a.nodeName):j,\"inline\"===l&&\"none\"===m.css(a,\"float\")&&(k.inlineBlockNeedsLayout&&\"inline\"!==Fb(a.nodeName)?p.zoom=1:p.display=\"inline-block\")),c.overflow&&(p.overflow=\"hidden\",k.shrinkWrapBlocks()||n.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],ac.exec(e)){if(delete b[d],f=f||\"toggle\"===e,e===(q?\"hide\":\"show\")){if(\"show\"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||m.style(a,d)}else j=void 0;if(m.isEmptyObject(o))\"inline\"===(\"none\"===j?Fb(a.nodeName):j)&&(p.display=j);else{r?\"hidden\"in r&&(q=r.hidden):r=m._data(a,\"fxshow\",{}),f&&(r.hidden=!q),q?m(a).show():n.done(function(){m(a).hide()}),n.done(function(){var b;m._removeData(a,\"fxshow\");for(b in o)m.style(a,b,o[b])});for(d in o)g=hc(q?r[d]:0,d,n),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start=\"width\"===d||\"height\"===d?1:0))}}function jc(a,b){var c,d,e,f,g;for(c in a)if(d=m.camelCase(c),e=b[d],f=a[c],m.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=m.cssHooks[d],g&&\"expand\"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kc(a,b,c){var d,e,f=0,g=dc.length,h=m.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=$b||fc(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:m.extend({},b),opts:m.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:$b||fc(),duration:c.duration,tweens:[],createTween:function(b,c){var d=m.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jc(k,j.opts.specialEasing);g>f;f++)if(d=dc[f].call(j,a,k,j.opts))return d;return m.map(k,hc,j),m.isFunction(j.opts.start)&&j.opts.start.call(a,j),m.fx.timer(m.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}m.Animation=m.extend(kc,{tweener:function(a,b){m.isFunction(a)?(b=a,a=[\"*\"]):a=a.split(\" \");for(var c,d=0,e=a.length;e>d;d++)c=a[d],ec[c]=ec[c]||[],ec[c].unshift(b)},prefilter:function(a,b){b?dc.unshift(a):dc.push(a)}}),m.speed=function(a,b,c){var d=a&&\"object\"==typeof a?m.extend({},a):{complete:c||!c&&b||m.isFunction(a)&&a,duration:a,easing:c&&b||b&&!m.isFunction(b)&&b};return d.duration=m.fx.off?0:\"number\"==typeof d.duration?d.duration:d.duration in m.fx.speeds?m.fx.speeds[d.duration]:m.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue=\"fx\"),d.old=d.complete,d.complete=function(){m.isFunction(d.old)&&d.old.call(this),d.queue&&m.dequeue(this,d.queue)},d},m.fn.extend({fadeTo:function(a,b,c,d){return this.filter(U).css(\"opacity\",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=m.isEmptyObject(a),f=m.speed(b,c,d),g=function(){var b=kc(this,m.extend({},a),f);(e||m._data(this,\"finish\"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return\"string\"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||\"fx\",[]),this.each(function(){var b=!0,e=null!=a&&a+\"queueHooks\",f=m.timers,g=m._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&cc.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&m.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||\"fx\"),this.each(function(){var b,c=m._data(this),d=c[a+\"queue\"],e=c[a+\"queueHooks\"],f=m.timers,g=d?d.length:0;for(c.finish=!0,m.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),m.each([\"toggle\",\"show\",\"hide\"],function(a,b){var c=m.fn[b];m.fn[b]=function(a,d,e){return null==a||\"boolean\"==typeof a?c.apply(this,arguments):this.animate(gc(b,!0),a,d,e)}}),m.each({slideDown:gc(\"show\"),slideUp:gc(\"hide\"),slideToggle:gc(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(a,b){m.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),m.timers=[],m.fx.tick=function(){var a,b=m.timers,c=0;for($b=m.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||m.fx.stop(),$b=void 0},m.fx.timer=function(a){m.timers.push(a),a()?m.fx.start():m.timers.pop()},m.fx.interval=13,m.fx.start=function(){_b||(_b=setInterval(m.fx.tick,m.fx.interval))},m.fx.stop=function(){clearInterval(_b),_b=null},m.fx.speeds={slow:600,fast:200,_default:400},m.fn.delay=function(a,b){return a=m.fx?m.fx.speeds[a]||a:a,b=b||\"fx\",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a,b,c,d,e;b=y.createElement(\"div\"),b.setAttribute(\"className\",\"t\"),b.innerHTML=\"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\",d=b.getElementsByTagName(\"a\")[0],c=y.createElement(\"select\"),e=c.appendChild(y.createElement(\"option\")),a=b.getElementsByTagName(\"input\")[0],d.style.cssText=\"top:1px\",k.getSetAttribute=\"t\"!==b.className,k.style=/top/.test(d.getAttribute(\"style\")),k.hrefNormalized=\"/a\"===d.getAttribute(\"href\"),k.checkOn=!!a.value,k.optSelected=e.selected,k.enctype=!!y.createElement(\"form\").enctype,c.disabled=!0,k.optDisabled=!e.disabled,a=y.createElement(\"input\"),a.setAttribute(\"value\",\"\"),k.input=\"\"===a.getAttribute(\"value\"),a.value=\"t\",a.setAttribute(\"type\",\"radio\"),k.radioValue=\"t\"===a.value}();var lc=/\\r/g;m.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=m.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,m(this).val()):a,null==e?e=\"\":\"number\"==typeof e?e+=\"\":m.isArray(e)&&(e=m.map(e,function(a){return null==a?\"\":a+\"\"})),b=m.valHooks[this.type]||m.valHooks[this.nodeName.toLowerCase()],b&&\"set\"in b&&void 0!==b.set(this,e,\"value\")||(this.value=e))});if(e)return b=m.valHooks[e.type]||m.valHooks[e.nodeName.toLowerCase()],b&&\"get\"in b&&void 0!==(c=b.get(e,\"value\"))?c:(c=e.value,\"string\"==typeof c?c.replace(lc,\"\"):null==c?\"\":c)}}}),m.extend({valHooks:{option:{get:function(a){var b=m.find.attr(a,\"value\");return null!=b?b:m.trim(m.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f=\"select-one\"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute(\"disabled\"))||c.parentNode.disabled&&m.nodeName(c.parentNode,\"optgroup\"))){if(b=m(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=m.makeArray(b),g=e.length;while(g--)if(d=e[g],m.inArray(m.valHooks.option.get(d),f)>=0)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),m.each([\"radio\",\"checkbox\"],function(){m.valHooks[this]={set:function(a,b){return m.isArray(b)?a.checked=m.inArray(m(a).val(),b)>=0:void 0}},k.checkOn||(m.valHooks[this].get=function(a){return null===a.getAttribute(\"value\")?\"on\":a.value})});var mc,nc,oc=m.expr.attrHandle,pc=/^(?:checked|selected)$/i,qc=k.getSetAttribute,rc=k.input;m.fn.extend({attr:function(a,b){return V(this,m.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){m.removeAttr(this,a)})}}),m.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===K?m.prop(a,b,c):(1===f&&m.isXMLDoc(a)||(b=b.toLowerCase(),d=m.attrHooks[b]||(m.expr.match.bool.test(b)?nc:mc)),void 0===c?d&&\"get\"in d&&null!==(e=d.get(a,b))?e:(e=m.find.attr(a,b),null==e?void 0:e):null!==c?d&&\"set\"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+\"\"),c):void m.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=m.propFix[c]||c,m.expr.match.bool.test(c)?rc&&qc||!pc.test(c)?a[d]=!1:a[m.camelCase(\"default-\"+c)]=a[d]=!1:m.attr(a,c,\"\"),a.removeAttribute(qc?c:d)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&\"radio\"===b&&m.nodeName(a,\"input\")){var c=a.value;return a.setAttribute(\"type\",b),c&&(a.value=c),b}}}}}),nc={set:function(a,b,c){return b===!1?m.removeAttr(a,c):rc&&qc||!pc.test(c)?a.setAttribute(!qc&&m.propFix[c]||c,c):a[m.camelCase(\"default-\"+c)]=a[c]=!0,c}},m.each(m.expr.match.bool.source.match(/\\w+/g),function(a,b){var c=oc[b]||m.find.attr;oc[b]=rc&&qc||!pc.test(b)?function(a,b,d){var e,f;return d||(f=oc[b],oc[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,oc[b]=f),e}:function(a,b,c){return c?void 0:a[m.camelCase(\"default-\"+b)]?b.toLowerCase():null}}),rc&&qc||(m.attrHooks.value={set:function(a,b,c){return m.nodeName(a,\"input\")?void(a.defaultValue=b):mc&&mc.set(a,b,c)}}),qc||(mc={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+=\"\",\"value\"===c||b===a.getAttribute(c)?b:void 0}},oc.id=oc.name=oc.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&\"\"!==d.value?d.value:null},m.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:mc.set},m.attrHooks.contenteditable={set:function(a,b,c){mc.set(a,\"\"===b?!1:b,c)}},m.each([\"width\",\"height\"],function(a,b){m.attrHooks[b]={set:function(a,c){return\"\"===c?(a.setAttribute(b,\"auto\"),c):void 0}}})),k.style||(m.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+\"\"}});var sc=/^(?:input|select|textarea|button|object)$/i,tc=/^(?:a|area)$/i;m.fn.extend({prop:function(a,b){return V(this,m.prop,a,b,arguments.length>1)},removeProp:function(a){return a=m.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),m.extend({propFix:{\"for\":\"htmlFor\",\"class\":\"className\"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!m.isXMLDoc(a),f&&(b=m.propFix[b]||b,e=m.propHooks[b]),void 0!==c?e&&\"set\"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&\"get\"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=m.find.attr(a,\"tabindex\");return b?parseInt(b,10):sc.test(a.nodeName)||tc.test(a.nodeName)&&a.href?0:-1}}}}),k.hrefNormalized||m.each([\"href\",\"src\"],function(a,b){m.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),k.optSelected||(m.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}}),m.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){m.propFix[this.toLowerCase()]=this}),k.enctype||(m.propFix.enctype=\"encoding\");var uc=/[\\t\\r\\n\\f]/g;m.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=\"string\"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).addClass(a.call(this,b,this.className))});if(j)for(b=(a||\"\").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(\" \"+c.className+\" \").replace(uc,\" \"):\" \")){f=0;while(e=b[f++])d.indexOf(\" \"+e+\" \")<0&&(d+=e+\" \");g=m.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=0===arguments.length||\"string\"==typeof a&&a;if(m.isFunction(a))return this.each(function(b){m(this).removeClass(a.call(this,b,this.className))});if(j)for(b=(a||\"\").match(E)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(\" \"+c.className+\" \").replace(uc,\" \"):\"\")){f=0;while(e=b[f++])while(d.indexOf(\" \"+e+\" \")>=0)d=d.replace(\" \"+e+\" \",\" \");g=a?m.trim(d):\"\",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return\"boolean\"==typeof b&&\"string\"===c?b?this.addClass(a):this.removeClass(a):this.each(m.isFunction(a)?function(c){m(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if(\"string\"===c){var b,d=0,e=m(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===K||\"boolean\"===c)&&(this.className&&m._data(this,\"__className__\",this.className),this.className=this.className||a===!1?\"\":m._data(this,\"__className__\")||\"\")})},hasClass:function(a){for(var b=\" \"+a+\" \",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(\" \"+this[c].className+\" \").replace(uc,\" \").indexOf(b)>=0)return!0;return!1}}),m.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"),function(a,b){m.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),m.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,\"**\"):this.off(b,a||\"**\",c)}});var vc=m.now(),wc=/\\?/,xc=/(,)|(\\[|{)|(}|])|\"(?:[^\"\\\\\\r\\n]|\\\\[\"\\\\\\/bfnrt]|\\\\u[\\da-fA-F]{4})*\"\\s*:?|true|false|null|-?(?!0\\d)\\d+(?:\\.\\d+|)(?:[eE][+-]?\\d+|)/g;m.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+\"\");var c,d=null,e=m.trim(b+\"\");return e&&!m.trim(e.replace(xc,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,\"\")}))?Function(\"return \"+e)():m.error(\"Invalid JSON: \"+b)},m.parseXML=function(b){var c,d;if(!b||\"string\"!=typeof b)return null;try{a.DOMParser?(d=new DOMParser,c=d.parseFromString(b,\"text/xml\")):(c=new ActiveXObject(\"Microsoft.XMLDOM\"),c.async=\"false\",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName(\"parsererror\").length||m.error(\"Invalid XML: \"+b),c};var yc,zc,Ac=/#.*$/,Bc=/([?&])_=[^&]*/,Cc=/^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/gm,Dc=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Ec=/^(?:GET|HEAD)$/,Fc=/^\\/\\//,Gc=/^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,Hc={},Ic={},Jc=\"*/\".concat(\"*\");try{zc=location.href}catch(Kc){zc=y.createElement(\"a\"),zc.href=\"\",zc=zc.href}yc=Gc.exec(zc.toLowerCase())||[];function Lc(a){return function(b,c){\"string\"!=typeof b&&(c=b,b=\"*\");var d,e=0,f=b.toLowerCase().match(E)||[];if(m.isFunction(c))while(d=f[e++])\"+\"===d.charAt(0)?(d=d.slice(1)||\"*\",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Mc(a,b,c,d){var e={},f=a===Ic;function g(h){var i;return e[h]=!0,m.each(a[h]||[],function(a,h){var j=h(b,c,d);return\"string\"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e[\"*\"]&&g(\"*\")}function Nc(a,b){var c,d,e=m.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&m.extend(!0,a,c),a}function Oc(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while(\"*\"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader(\"Content-Type\"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+\" \"+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Pc(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if(\"*\"===f)f=i;else if(\"*\"!==i&&i!==f){if(g=j[i+\" \"+f]||j[\"* \"+f],!g)for(e in j)if(h=e.split(\" \"),h[1]===f&&(g=j[i+\" \"+h[0]]||j[\"* \"+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a[\"throws\"])b=g(b);else try{b=g(b)}catch(l){return{state:\"parsererror\",error:g?l:\"No conversion from \"+i+\" to \"+f}}}return{state:\"success\",data:b}}m.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:zc,type:\"GET\",isLocal:Dc.test(yc[1]),global:!0,processData:!0,async:!0,contentType:\"application/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":Jc,text:\"text/plain\",html:\"text/html\",xml:\"application/xml, text/xml\",json:\"application/json, text/javascript\"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":m.parseJSON,\"text xml\":m.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Nc(Nc(a,m.ajaxSettings),b):Nc(m.ajaxSettings,a)},ajaxPrefilter:Lc(Hc),ajaxTransport:Lc(Ic),ajax:function(a,b){\"object\"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=m.ajaxSetup({},b),l=k.context||k,n=k.context&&(l.nodeType||l.jquery)?m(l):m.event,o=m.Deferred(),p=m.Callbacks(\"once memory\"),q=k.statusCode||{},r={},s={},t=0,u=\"canceled\",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!j){j={};while(b=Cc.exec(f))j[b[1].toLowerCase()]=b[2]}b=j[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?f:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return i&&i.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||zc)+\"\").replace(Ac,\"\").replace(Fc,yc[1]+\"//\"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=m.trim(k.dataType||\"*\").toLowerCase().match(E)||[\"\"],null==k.crossDomain&&(c=Gc.exec(k.url.toLowerCase()),k.crossDomain=!(!c||c[1]===yc[1]&&c[2]===yc[2]&&(c[3]||(\"http:\"===c[1]?\"80\":\"443\"))===(yc[3]||(\"http:\"===yc[1]?\"80\":\"443\")))),k.data&&k.processData&&\"string\"!=typeof k.data&&(k.data=m.param(k.data,k.traditional)),Mc(Hc,k,b,v),2===t)return v;h=m.event&&k.global,h&&0===m.active++&&m.event.trigger(\"ajaxStart\"),k.type=k.type.toUpperCase(),k.hasContent=!Ec.test(k.type),e=k.url,k.hasContent||(k.data&&(e=k.url+=(wc.test(e)?\"&\":\"?\")+k.data,delete k.data),k.cache===!1&&(k.url=Bc.test(e)?e.replace(Bc,\"$1_=\"+vc++):e+(wc.test(e)?\"&\":\"?\")+\"_=\"+vc++)),k.ifModified&&(m.lastModified[e]&&v.setRequestHeader(\"If-Modified-Since\",m.lastModified[e]),m.etag[e]&&v.setRequestHeader(\"If-None-Match\",m.etag[e])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader(\"Content-Type\",k.contentType),v.setRequestHeader(\"Accept\",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+(\"*\"!==k.dataTypes[0]?\", \"+Jc+\"; q=0.01\":\"\"):k.accepts[\"*\"]);for(d in k.headers)v.setRequestHeader(d,k.headers[d]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u=\"abort\";for(d in{success:1,error:1,complete:1})v[d](k[d]);if(i=Mc(Ic,k,b,v)){v.readyState=1,h&&n.trigger(\"ajaxSend\",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort(\"timeout\")},k.timeout));try{t=1,i.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,\"No Transport\");function x(a,b,c,d){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),i=void 0,f=d||\"\",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,c&&(u=Oc(k,v,c)),u=Pc(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader(\"Last-Modified\"),w&&(m.lastModified[e]=w),w=v.getResponseHeader(\"etag\"),w&&(m.etag[e]=w)),204===a||\"HEAD\"===k.type?x=\"nocontent\":304===a?x=\"notmodified\":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x=\"error\",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+\"\",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,h&&n.trigger(j?\"ajaxSuccess\":\"ajaxError\",[v,k,j?r:s]),p.fireWith(l,[v,x]),h&&(n.trigger(\"ajaxComplete\",[v,k]),--m.active||m.event.trigger(\"ajaxStop\")))}return v},getJSON:function(a,b,c){return m.get(a,b,c,\"json\")},getScript:function(a,b){return m.get(a,void 0,b,\"script\")}}),m.each([\"get\",\"post\"],function(a,b){m[b]=function(a,c,d,e){return m.isFunction(c)&&(e=e||d,d=c,c=void 0),m.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),m._evalUrl=function(a){return m.ajax({url:a,type:\"GET\",dataType:\"script\",async:!1,global:!1,\"throws\":!0})},m.fn.extend({wrapAll:function(a){if(m.isFunction(a))return this.each(function(b){m(this).wrapAll(a.call(this,b))});if(this[0]){var b=m(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return this.each(m.isFunction(a)?function(b){m(this).wrapInner(a.call(this,b))}:function(){var b=m(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=m.isFunction(a);return this.each(function(c){m(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){m.nodeName(this,\"body\")||m(this).replaceWith(this.childNodes)}).end()}}),m.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0||!k.reliableHiddenOffsets()&&\"none\"===(a.style&&a.style.display||m.css(a,\"display\"))},m.expr.filters.visible=function(a){return!m.expr.filters.hidden(a)};var Qc=/%20/g,Rc=/\\[\\]$/,Sc=/\\r?\\n/g,Tc=/^(?:submit|button|image|reset|file)$/i,Uc=/^(?:input|select|textarea|keygen)/i;function Vc(a,b,c,d){var e;if(m.isArray(b))m.each(b,function(b,e){c||Rc.test(a)?d(a,e):Vc(a+\"[\"+(\"object\"==typeof e?b:\"\")+\"]\",e,c,d)});else if(c||\"object\"!==m.type(b))d(a,b);else for(e in b)Vc(a+\"[\"+e+\"]\",b[e],c,d)}m.param=function(a,b){var c,d=[],e=function(a,b){b=m.isFunction(b)?b():null==b?\"\":b,d[d.length]=encodeURIComponent(a)+\"=\"+encodeURIComponent(b)};if(void 0===b&&(b=m.ajaxSettings&&m.ajaxSettings.traditional),m.isArray(a)||a.jquery&&!m.isPlainObject(a))m.each(a,function(){e(this.name,this.value)});else for(c in a)Vc(c,a[c],b,e);return d.join(\"&\").replace(Qc,\"+\")},m.fn.extend({serialize:function(){return m.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=m.prop(this,\"elements\");return a?m.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!m(this).is(\":disabled\")&&Uc.test(this.nodeName)&&!Tc.test(a)&&(this.checked||!W.test(a))}).map(function(a,b){var c=m(this).val();return null==c?null:m.isArray(c)?m.map(c,function(a){return{name:b.name,value:a.replace(Sc,\"\\r\\n\")}}):{name:b.name,value:c.replace(Sc,\"\\r\\n\")}}).get()}}),m.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return!this.isLocal&&/^(get|post|head|put|delete|options)$/i.test(this.type)&&Zc()||$c()}:Zc;var Wc=0,Xc={},Yc=m.ajaxSettings.xhr();a.attachEvent&&a.attachEvent(\"onunload\",function(){for(var a in Xc)Xc[a](void 0,!0)}),k.cors=!!Yc&&\"withCredentials\"in Yc,Yc=k.ajax=!!Yc,Yc&&m.ajaxTransport(function(a){if(!a.crossDomain||k.cors){var b;return{send:function(c,d){var e,f=a.xhr(),g=++Wc;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c[\"X-Requested-With\"]||(c[\"X-Requested-With\"]=\"XMLHttpRequest\");for(e in c)void 0!==c[e]&&f.setRequestHeader(e,c[e]+\"\");f.send(a.hasContent&&a.data||null),b=function(c,e){var h,i,j;if(b&&(e||4===f.readyState))if(delete Xc[g],b=void 0,f.onreadystatechange=m.noop,e)4!==f.readyState&&f.abort();else{j={},h=f.status,\"string\"==typeof f.responseText&&(j.text=f.responseText);try{i=f.statusText}catch(k){i=\"\"}h||!a.isLocal||a.crossDomain?1223===h&&(h=204):h=j.text?200:404}j&&d(h,i,j,f.getAllResponseHeaders())},a.async?4===f.readyState?setTimeout(b):f.onreadystatechange=Xc[g]=b:b()},abort:function(){b&&b(void 0,!0)}}}});function Zc(){try{return new a.XMLHttpRequest}catch(b){}}function $c(){try{return new a.ActiveXObject(\"Microsoft.XMLHTTP\")}catch(b){}}m.ajaxSetup({accepts:{script:\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"},contents:{script:/(?:java|ecma)script/},converters:{\"text script\":function(a){return m.globalEval(a),a}}}),m.ajaxPrefilter(\"script\",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type=\"GET\",a.global=!1)}),m.ajaxTransport(\"script\",function(a){if(a.crossDomain){var b,c=y.head||m(\"head\")[0]||y.documentElement;return{send:function(d,e){b=y.createElement(\"script\"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||e(200,\"success\"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var _c=[],ad=/(=)\\?(?=&|$)|\\?\\?/;m.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var a=_c.pop()||m.expando+\"_\"+vc++;return this[a]=!0,a}}),m.ajaxPrefilter(\"json jsonp\",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(ad.test(b.url)?\"url\":\"string\"==typeof b.data&&!(b.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&ad.test(b.data)&&\"data\");return h||\"jsonp\"===b.dataTypes[0]?(e=b.jsonpCallback=m.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(ad,\"$1\"+e):b.jsonp!==!1&&(b.url+=(wc.test(b.url)?\"&\":\"?\")+b.jsonp+\"=\"+e),b.converters[\"script json\"]=function(){return g||m.error(e+\" was not called\"),g[0]},b.dataTypes[0]=\"json\",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,_c.push(e)),g&&m.isFunction(f)&&f(g[0]),g=f=void 0}),\"script\"):void 0}),m.parseHTML=function(a,b,c){if(!a||\"string\"!=typeof a)return null;\"boolean\"==typeof b&&(c=b,b=!1),b=b||y;var d=u.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=m.buildFragment([a],b,e),e&&e.length&&m(e).remove(),m.merge([],d.childNodes))};var bd=m.fn.load;m.fn.load=function(a,b,c){if(\"string\"!=typeof a&&bd)return bd.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(\" \");return h>=0&&(d=m.trim(a.slice(h,a.length)),a=a.slice(0,h)),m.isFunction(b)?(c=b,b=void 0):b&&\"object\"==typeof b&&(f=\"POST\"),g.length>0&&m.ajax({url:a,type:f,dataType:\"html\",data:b}).done(function(a){e=arguments,g.html(d?m(\"<div>\").append(m.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,e||[a.responseText,b,a])}),this},m.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(a,b){m.fn[b]=function(a){return this.on(b,a)}}),m.expr.filters.animated=function(a){return m.grep(m.timers,function(b){return a===b.elem}).length};var cd=a.document.documentElement;function dd(a){return m.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}m.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=m.css(a,\"position\"),l=m(a),n={};\"static\"===k&&(a.style.position=\"relative\"),h=l.offset(),f=m.css(a,\"top\"),i=m.css(a,\"left\"),j=(\"absolute\"===k||\"fixed\"===k)&&m.inArray(\"auto\",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),m.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(n.top=b.top-h.top+g),null!=b.left&&(n.left=b.left-h.left+e),\"using\"in b?b.using.call(a,n):l.css(n)}},m.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){m.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,m.contains(b,e)?(typeof e.getBoundingClientRect!==K&&(d=e.getBoundingClientRect()),c=dd(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return\"fixed\"===m.css(d,\"position\")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),m.nodeName(a[0],\"html\")||(c=a.offset()),c.top+=m.css(a[0],\"borderTopWidth\",!0),c.left+=m.css(a[0],\"borderLeftWidth\",!0)),{top:b.top-c.top-m.css(d,\"marginTop\",!0),left:b.left-c.left-m.css(d,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||cd;while(a&&!m.nodeName(a,\"html\")&&\"static\"===m.css(a,\"position\"))a=a.offsetParent;return a||cd})}}),m.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(a,b){var c=/Y/.test(b);m.fn[a]=function(d){return V(this,function(a,d,e){var f=dd(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?m(f).scrollLeft():e,c?e:m(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),m.each([\"top\",\"left\"],function(a,b){m.cssHooks[b]=Lb(k.pixelPosition,function(a,c){return c?(c=Jb(a,b),Hb.test(c)?m(a).position()[b]+\"px\":c):void 0})}),m.each({Height:\"height\",Width:\"width\"},function(a,b){m.each({padding:\"inner\"+a,content:b,\"\":\"outer\"+a},function(c,d){m.fn[d]=function(d,e){var f=arguments.length&&(c||\"boolean\"!=typeof d),g=c||(d===!0||e===!0?\"margin\":\"border\");return V(this,function(b,c,d){var e;return m.isWindow(b)?b.document.documentElement[\"client\"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body[\"scroll\"+a],e[\"scroll\"+a],b.body[\"offset\"+a],e[\"offset\"+a],e[\"client\"+a])):void 0===d?m.css(b,c,g):m.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),m.fn.size=function(){return this.length},m.fn.andSelf=m.fn.addBack,\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return m});var ed=a.jQuery,fd=a.$;return m.noConflict=function(b){return a.$===m&&(a.$=fd),b&&a.jQuery===m&&(a.jQuery=ed),m},typeof b===K&&(a.jQuery=a.$=m),m});\n"], "VFS_import": [".py", "import os\nfrom browser import doc\n\n\n\n\n\n\nVFS=dict(JSObject(__BRYTHON__.py_VFS))\nclass VFSModuleFinder:\n def __init__(self, path_entry):\n  print(\"in VFSModuleFinder\")\n  if path_entry.startswith('/libs') or path_entry.startswith('/Lib'):\n   self.path_entry=path_entry\n  else:\n   raise ImportError()\n   \n def __str__(self):\n  return '<%s for \"%s\">' % (self.__class__.__name__, self.path_entry)\n  \n def find_module(self, fullname, path=None):\n  path = path or self.path_entry\n  \n  for _ext in ['js', 'pyj', 'py']:\n   _filepath=os.path.join(self.path_entry, '%s.%s' % (fullname, _ext))\n   if _filepath in VFS:\n    print(\"module found at %s:%s\" % (_filepath, fullname))\n    return VFSModuleLoader(_filepath, fullname)\n    \n  print('module %s not found' % fullname)\n  raise ImportError()\n  return None\n  \nclass VFSModuleLoader:\n \"\"\n \n def __init__(self, filepath, name):\n  self._filepath=filepath\n  self._name=name\n  \n def get_source(self):\n  if self._filepath in VFS:\n   return JSObject(readFromVFS(self._filepath))\n   \n  raise ImportError('could not find source for %s' % fullname)\n  \n def is_package(self):\n  return '.' in self._name\n  \n def load_module(self):\n  if self._name in sys.modules:\n  \n   mod = sys.modules[self._name]\n   return mod\n   \n  _src=self.get_source()\n  if self._filepath.endswith('.js'):\n   mod=JSObject(import_js_module(_src, self._filepath, self._name))\n  elif self._filepath.endswith('.py'):\n   mod=JSObject(import_py_module(_src, self._filepath, self._name))\n  elif self._filepath.endswith('.pyj'):\n   mod=JSObject(import_pyj_module(_src, self._filepath, self._name))\n  else:\n   raise ImportError('Invalid Module: %s' % self._filepath)\n   \n   \n  mod.__file__ = self._filepath\n  mod.__name__ = self._name\n  mod.__path__ = os.path.abspath(self._filepath)\n  mod.__loader__ = self\n  mod.__package__ = '.'.join(self._name.split('.')[:-1])\n  \n  if self.is_package():\n   print('adding path for package')\n   \n   \n   mod.__path__ = [ self.path_entry ]\n  else:\n   print('imported as regular module')\n   \n  print('creating a new module object for \"%s\"' % self._name)\n  sys.modules.setdefault(self._name, mod)\n  JSObject(__BRYTHON__.imported)[self._name]=mod\n  \n  return mod\n  \nJSObject(__BRYTHON__.path_hooks.insert(0, VFSModuleFinder))\n"], "site-packages.pygame.version": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\n\nver = '1.8.0pre'\nvernum = 1,8,0\n"], "colorsys": [".py", "\"\"\n\n\n\n\n\n\n__all__ = [\"rgb_to_yiq\",\"yiq_to_rgb\",\"rgb_to_hls\",\"hls_to_rgb\",\n\"rgb_to_hsv\",\"hsv_to_rgb\"]\n\n\n\nONE_THIRD = 1.0/3.0\nONE_SIXTH = 1.0/6.0\nTWO_THIRD = 2.0/3.0\n\n\n\n\n\ndef rgb_to_yiq(r, g, b):\n y = 0.30*r + 0.59*g + 0.11*b\n i = 0.60*r - 0.28*g - 0.32*b\n q = 0.21*r - 0.52*g + 0.31*b\n return (y, i, q)\n \ndef yiq_to_rgb(y, i, q):\n r = y + 0.948262*i + 0.624013*q\n g = y - 0.276066*i - 0.639810*q\n b = y - 1.105450*i + 1.729860*q\n if r < 0.0:\n  r = 0.0\n if g < 0.0:\n  g = 0.0\n if b < 0.0:\n  b = 0.0\n if r > 1.0:\n  r = 1.0\n if g > 1.0:\n  g = 1.0\n if b > 1.0:\n  b = 1.0\n return (r, g, b)\n \n \n \n \n \n \n \ndef rgb_to_hls(r, g, b):\n maxc = max(r, g, b)\n minc = min(r, g, b)\n \n l = (minc+maxc)/2.0\n if minc == maxc:\n  return 0.0, l, 0.0\n if l <= 0.5:\n  s = (maxc-minc) / (maxc+minc)\n else:\n  s = (maxc-minc) / (2.0-maxc-minc)\n rc = (maxc-r) / (maxc-minc)\n gc = (maxc-g) / (maxc-minc)\n bc = (maxc-b) / (maxc-minc)\n if r == maxc:\n  h = bc-gc\n elif g == maxc:\n  h = 2.0+rc-bc\n else:\n  h = 4.0+gc-rc\n h = (h/6.0) % 1.0\n return h, l, s\n \ndef hls_to_rgb(h, l, s):\n if s == 0.0:\n  return l, l, l\n if l <= 0.5:\n  m2 = l * (1.0+s)\n else:\n  m2 = l+s-(l*s)\n m1 = 2.0*l - m2\n return (_v(m1, m2, h+ONE_THIRD), _v(m1, m2, h), _v(m1, m2, h-ONE_THIRD))\n \ndef _v(m1, m2, hue):\n hue = hue % 1.0\n if hue < ONE_SIXTH:\n  return m1 + (m2-m1)*hue*6.0\n if hue < 0.5:\n  return m2\n if hue < TWO_THIRD:\n  return m1 + (m2-m1)*(TWO_THIRD-hue)*6.0\n return m1\n \n \n \n \n \n \n \ndef rgb_to_hsv(r, g, b):\n maxc = max(r, g, b)\n minc = min(r, g, b)\n v = maxc\n if minc == maxc:\n  return 0.0, 0.0, v\n s = (maxc-minc) / maxc\n rc = (maxc-r) / (maxc-minc)\n gc = (maxc-g) / (maxc-minc)\n bc = (maxc-b) / (maxc-minc)\n if r == maxc:\n  h = bc-gc\n elif g == maxc:\n  h = 2.0+rc-bc\n else:\n  h = 4.0+gc-rc\n h = (h/6.0) % 1.0\n return h, s, v\n \ndef hsv_to_rgb(h, s, v):\n if s == 0.0:\n  return v, v, v\n i = int(h*6.0) \n f = (h*6.0) - i\n p = v*(1.0 - s)\n q = v*(1.0 - s*f)\n t = v*(1.0 - s*(1.0-f))\n i = i%6\n if i == 0:\n  return v, t, p\n if i == 1:\n  return q, v, p\n if i == 2:\n  return p, v, t\n if i == 3:\n  return p, q, v\n if i == 4:\n  return t, p, v\n if i == 5:\n  return v, p, q\n  \n"], "formatter": [".py", "\"\"\n\nimport sys\n\n\nAS_IS = None\n\n\nclass NullFormatter:\n \"\"\n \n def __init__(self, writer=None):\n  if writer is None:\n   writer = NullWriter()\n  self.writer = writer\n def end_paragraph(self, blankline): pass\n def add_line_break(self): pass\n def add_hor_rule(self, *args, **kw): pass\n def add_label_data(self, format, counter, blankline=None): pass\n def add_flowing_data(self, data): pass\n def add_literal_data(self, data): pass\n def flush_softspace(self): pass\n def push_alignment(self, align): pass\n def pop_alignment(self): pass\n def push_font(self, x): pass\n def pop_font(self): pass\n def push_margin(self, margin): pass\n def pop_margin(self): pass\n def set_spacing(self, spacing): pass\n def push_style(self, *styles): pass\n def pop_style(self, n=1): pass\n def assert_line_data(self, flag=1): pass\n \n \nclass AbstractFormatter:\n \"\"\n \n \n \n \n \n \n def __init__(self, writer):\n  self.writer = writer \n  self.align = None \n  self.align_stack = [] \n  self.font_stack = [] \n  self.margin_stack = [] \n  self.spacing = None \n  self.style_stack = [] \n  self.nospace = 1 \n  self.softspace = 0 \n  self.para_end = 1 \n  self.parskip = 0 \n  self.hard_break = 1 \n  self.have_label = 0\n  \n def end_paragraph(self, blankline):\n  if not self.hard_break:\n   self.writer.send_line_break()\n   self.have_label = 0\n  if self.parskip < blankline and not self.have_label:\n   self.writer.send_paragraph(blankline - self.parskip)\n   self.parskip = blankline\n   self.have_label = 0\n  self.hard_break = self.nospace = self.para_end = 1\n  self.softspace = 0\n  \n def add_line_break(self):\n  if not (self.hard_break or self.para_end):\n   self.writer.send_line_break()\n   self.have_label = self.parskip = 0\n  self.hard_break = self.nospace = 1\n  self.softspace = 0\n  \n def add_hor_rule(self, *args, **kw):\n  if not self.hard_break:\n   self.writer.send_line_break()\n  self.writer.send_hor_rule(*args, **kw)\n  self.hard_break = self.nospace = 1\n  self.have_label = self.para_end = self.softspace = self.parskip = 0\n  \n def add_label_data(self, format, counter, blankline = None):\n  if self.have_label or not self.hard_break:\n   self.writer.send_line_break()\n  if not self.para_end:\n   self.writer.send_paragraph((blankline and 1) or 0)\n  if isinstance(format, str):\n   self.writer.send_label_data(self.format_counter(format, counter))\n  else:\n   self.writer.send_label_data(format)\n  self.nospace = self.have_label = self.hard_break = self.para_end = 1\n  self.softspace = self.parskip = 0\n  \n def format_counter(self, format, counter):\n  label = ''\n  for c in format:\n   if c == '1':\n    label = label + ('%d' % counter)\n   elif c in 'aA':\n    if counter > 0:\n     label = label + self.format_letter(c, counter)\n   elif c in 'iI':\n    if counter > 0:\n     label = label + self.format_roman(c, counter)\n   else:\n    label = label + c\n  return label\n  \n def format_letter(self, case, counter):\n  label = ''\n  while counter > 0:\n   counter, x = divmod(counter-1, 26)\n   \n   \n   \n   s = chr(ord(case) + x)\n   label = s + label\n  return label\n  \n def format_roman(self, case, counter):\n  ones = ['i', 'x', 'c', 'm']\n  fives = ['v', 'l', 'd']\n  label, index = '', 0\n  \n  while counter > 0:\n   counter, x = divmod(counter, 10)\n   if x == 9:\n    label = ones[index] + ones[index+1] + label\n   elif x == 4:\n    label = ones[index] + fives[index] + label\n   else:\n    if x >= 5:\n     s = fives[index]\n     x = x-5\n    else:\n     s = ''\n    s = s + ones[index]*x\n    label = s + label\n   index = index + 1\n  if case == 'I':\n   return label.upper()\n  return label\n  \n def add_flowing_data(self, data):\n  if not data: return\n  prespace = data[:1].isspace()\n  postspace = data[-1:].isspace()\n  data = \" \".join(data.split())\n  if self.nospace and not data:\n   return\n  elif prespace or self.softspace:\n   if not data:\n    if not self.nospace:\n     self.softspace = 1\n     self.parskip = 0\n    return\n   if not self.nospace:\n    data = ' ' + data\n  self.hard_break = self.nospace = self.para_end = self.parskip = self.have_label = 0\n  self.softspace = postspace\n  self.writer.send_flowing_data(data)\n  \n def add_literal_data(self, data):\n  if not data: return\n  if self.softspace:\n   self.writer.send_flowing_data(\" \")\n  self.hard_break = data[-1:] == '\\n'\n  self.nospace = self.para_end = self.softspace = self.parskip = self.have_label = 0\n  self.writer.send_literal_data(data)\n  \n def flush_softspace(self):\n  if self.softspace:\n   self.hard_break = self.para_end = self.parskip = self.have_label = self.softspace = 0\n   self.nospace = 1\n   self.writer.send_flowing_data(' ')\n   \n def push_alignment(self, align):\n  if align and align != self.align:\n   self.writer.new_alignment(align)\n   self.align = align\n   self.align_stack.append(align)\n  else:\n   self.align_stack.append(self.align)\n   \n def pop_alignment(self):\n  if self.align_stack:\n   del self.align_stack[-1]\n  if self.align_stack:\n   self.align = align = self.align_stack[-1]\n   self.writer.new_alignment(align)\n  else:\n   self.align = None\n   self.writer.new_alignment(None)\n   \n def push_font(self, font):\n  size, i, b, tt = font\n  if self.softspace:\n   self.hard_break = self.para_end = self.softspace = 0\n   self.nospace = 1\n   self.writer.send_flowing_data(' ')\n  if self.font_stack:\n   csize, ci, cb, ctt = self.font_stack[-1]\n   if size is AS_IS: size = csize\n   if i is AS_IS: i = ci\n   if b is AS_IS: b = cb\n   if tt is AS_IS: tt = ctt\n  font = (size, i, b, tt)\n  self.font_stack.append(font)\n  self.writer.new_font(font)\n  \n def pop_font(self):\n  if self.font_stack:\n   del self.font_stack[-1]\n  if self.font_stack:\n   font = self.font_stack[-1]\n  else:\n   font = None\n  self.writer.new_font(font)\n  \n def push_margin(self, margin):\n  self.margin_stack.append(margin)\n  fstack = [m for m in self.margin_stack if m]\n  if not margin and fstack:\n   margin = fstack[-1]\n  self.writer.new_margin(margin, len(fstack))\n  \n def pop_margin(self):\n  if self.margin_stack:\n   del self.margin_stack[-1]\n  fstack = [m for m in self.margin_stack if m]\n  if fstack:\n   margin = fstack[-1]\n  else:\n   margin = None\n  self.writer.new_margin(margin, len(fstack))\n  \n def set_spacing(self, spacing):\n  self.spacing = spacing\n  self.writer.new_spacing(spacing)\n  \n def push_style(self, *styles):\n  if self.softspace:\n   self.hard_break = self.para_end = self.softspace = 0\n   self.nospace = 1\n   self.writer.send_flowing_data(' ')\n  for style in styles:\n   self.style_stack.append(style)\n  self.writer.new_styles(tuple(self.style_stack))\n  \n def pop_style(self, n=1):\n  del self.style_stack[-n:]\n  self.writer.new_styles(tuple(self.style_stack))\n  \n def assert_line_data(self, flag=1):\n  self.nospace = self.hard_break = not flag\n  self.para_end = self.parskip = self.have_label = 0\n  \n  \nclass NullWriter:\n \"\"\n def __init__(self): pass\n def flush(self): pass\n def new_alignment(self, align): pass\n def new_font(self, font): pass\n def new_margin(self, margin, level): pass\n def new_spacing(self, spacing): pass\n def new_styles(self, styles): pass\n def send_paragraph(self, blankline): pass\n def send_line_break(self): pass\n def send_hor_rule(self, *args, **kw): pass\n def send_label_data(self, data): pass\n def send_flowing_data(self, data): pass\n def send_literal_data(self, data): pass\n \n \nclass AbstractWriter(NullWriter):\n \"\"\n \n def new_alignment(self, align):\n  print(\"new_alignment(%r)\" % (align,))\n  \n def new_font(self, font):\n  print(\"new_font(%r)\" % (font,))\n  \n def new_margin(self, margin, level):\n  print(\"new_margin(%r, %d)\" % (margin, level))\n  \n def new_spacing(self, spacing):\n  print(\"new_spacing(%r)\" % (spacing,))\n  \n def new_styles(self, styles):\n  print(\"new_styles(%r)\" % (styles,))\n  \n def send_paragraph(self, blankline):\n  print(\"send_paragraph(%r)\" % (blankline,))\n  \n def send_line_break(self):\n  print(\"send_line_break()\")\n  \n def send_hor_rule(self, *args, **kw):\n  print(\"send_hor_rule()\")\n  \n def send_label_data(self, data):\n  print(\"send_label_data(%r)\" % (data,))\n  \n def send_flowing_data(self, data):\n  print(\"send_flowing_data(%r)\" % (data,))\n  \n def send_literal_data(self, data):\n  print(\"send_literal_data(%r)\" % (data,))\n  \n  \nclass DumbWriter(NullWriter):\n \"\"\n \n def __init__(self, file=None, maxcol=72):\n  self.file = file or sys.stdout\n  self.maxcol = maxcol\n  NullWriter.__init__(self)\n  self.reset()\n  \n def reset(self):\n  self.col = 0\n  self.atbreak = 0\n  \n def send_paragraph(self, blankline):\n  self.file.write('\\n'*blankline)\n  self.col = 0\n  self.atbreak = 0\n  \n def send_line_break(self):\n  self.file.write('\\n')\n  self.col = 0\n  self.atbreak = 0\n  \n def send_hor_rule(self, *args, **kw):\n  self.file.write('\\n')\n  self.file.write('-'*self.maxcol)\n  self.file.write('\\n')\n  self.col = 0\n  self.atbreak = 0\n  \n def send_literal_data(self, data):\n  self.file.write(data)\n  i = data.rfind('\\n')\n  if i >= 0:\n   self.col = 0\n   data = data[i+1:]\n  data = data.expandtabs()\n  self.col = self.col + len(data)\n  self.atbreak = 0\n  \n def send_flowing_data(self, data):\n  if not data: return\n  atbreak = self.atbreak or data[0].isspace()\n  col = self.col\n  maxcol = self.maxcol\n  write = self.file.write\n  for word in data.split():\n   if atbreak:\n    if col + len(word) >= maxcol:\n     write('\\n')\n     col = 0\n    else:\n     write(' ')\n     col = col + 1\n   write(word)\n   col = col + len(word)\n   atbreak = 1\n  self.col = col\n  self.atbreak = data[-1].isspace()\n  \n  \ndef test(file = None):\n w = DumbWriter()\n f = AbstractFormatter(w)\n if file is not None:\n  fp = open(file)\n elif sys.argv[1:]:\n  fp = open(sys.argv[1])\n else:\n  fp = sys.stdin\n for line in fp:\n  if line == '\\n':\n   f.end_paragraph(1)\n  else:\n   f.add_flowing_data(line)\n f.end_paragraph(0)\n \n \nif __name__ == '__main__':\n test()\n"], "math": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins\nvar $s=[]\nfor(var $b in _b_) $s.push('var ' + $b +'=_b_[\"'+$b+'\"]')\neval($s.join(';'))\n\n//for(var $py_builtin in _b_){eval(\"var \"+$py_builtin+\"=_b_[$py_builtin]\")}\n\nvar float_check=function(x) {\n    if (x.value !== undefined && isinstance(x, float)) return x.value\n    return x\n}\n\nvar isWholeNumber=function(x){return (x*10) % 10 == 0}\n\nvar isOdd=function(x) {return isWholeNumber(x) && 2*Math.floor(x/2) != x}\n\nvar isLargeNumber=function(x) {return x > Math.pow(2,32)}\n\n// Big number Library from jsfromhell.com\n// This library helps with producing \"correct\" results from \n// mathematic operations\n\n//+ Jonas Raoni Soares Silva\n//@ http://jsfromhell.com/classes/bignumber [rev. #4]\n\n\nvar BigNumber = function(n, p, r){\n\tvar o = this, i;\n\tif(n instanceof BigNumber){\n\t\tfor(i in {precision: 0, roundType: 0, _s: 0, _f: 0}) o[i] = n[i];\n\t\to._d = n._d.slice();\n\t\treturn;\n\t}\n\to.precision = isNaN(p = Math.abs(p)) ? BigNumber.defaultPrecision : p;\n\to.roundType = isNaN(r = Math.abs(r)) ? BigNumber.defaultRoundType : r;\n\to._s = (n += \"\").charAt(0) == \"-\";\n\to._f = ((n = n.replace(/[^\\d.]/g, \"\").split(\".\", 2))[0] = n[0].replace(/^0+/, \"\") || \"0\").length;\n\tfor(i = (n = o._d = (n.join(\"\") || \"0\").split(\"\")).length; i; n[--i] = +n[i]);\n\to.round();\n};\nwith({$: BigNumber, o: BigNumber.prototype}){\n\t$.ROUND_HALF_EVEN = ($.ROUND_HALF_DOWN = ($.ROUND_HALF_UP = ($.ROUND_FLOOR = ($.ROUND_CEIL = ($.ROUND_DOWN = ($.ROUND_UP = 0) + 1) + 1) + 1) + 1) + 1) + 1;\n\t$.defaultPrecision = 40;\n\t$.defaultRoundType = $.ROUND_HALF_UP;\n\to.add = function(n){\n\t\tif(this._s != (n = new BigNumber(n))._s)\n\t\t\treturn n._s ^= 1, this.subtract(n);\n\t\tvar o = new BigNumber(this), a = o._d, b = n._d, la = o._f,\n\t\tlb = n._f, n = Math.max(la, lb), i, r;\n\t\tla != lb && ((lb = la - lb) > 0 ? o._zeroes(b, lb, 1) : o._zeroes(a, -lb, 1));\n\t\ti = (la = a.length) == (lb = b.length) ? a.length : ((lb = la - lb) > 0 ? o._zeroes(b, lb) : o._zeroes(a, -lb)).length;\n\t\tfor(r = 0; i; r = (a[--i] = a[i] + b[i] + r) / 10 >>> 0, a[i] %= 10);\n\t\treturn r && ++n && a.unshift(r), o._f = n, o.round();\n\t};\n\to.subtract = function(n){\n\t\tif(this._s != (n = new BigNumber(n))._s)\n\t\t\treturn n._s ^= 1, this.add(n);\n\t\tvar o = new BigNumber(this), c = o.abs().compare(n.abs()) + 1, a = c ? o : n, b = c ? n : o, la = a._f, lb = b._f, d = la, i, j;\n\t\ta = a._d, b = b._d, la != lb && ((lb = la - lb) > 0 ? o._zeroes(b, lb, 1) : o._zeroes(a, -lb, 1));\n\t\tfor(i = (la = a.length) == (lb = b.length) ? a.length : ((lb = la - lb) > 0 ? o._zeroes(b, lb) : o._zeroes(a, -lb)).length; i;){\n\t\t\tif(a[--i] < b[i]){\n\t\t\t\tfor(j = i; j && !a[--j]; a[j] = 9);\n\t\t\t\t--a[j], a[i] += 10;\n\t\t\t}\n\t\t\tb[i] = a[i] - b[i];\n\t\t}\n\t\treturn c || (o._s ^= 1), o._f = d, o._d = b, o.round();\n\t};\n\to.multiply = function(n){\n\t\tvar o = new BigNumber(this), r = o._d.length >= (n = new BigNumber(n))._d.length, a = (r ? o : n)._d,\n\t\tb = (r ? n : o)._d, la = a.length, lb = b.length, x = new BigNumber, i, j, s;\n\t\tfor(i = lb; i; r && s.unshift(r), x.set(x.add(new BigNumber(s.join(\"\")))))\n\t\t\tfor(s = (new Array(lb - --i)).join(\"0\").split(\"\"), r = 0, j = la; j; r += a[--j] * b[i], s.unshift(r % 10), r = (r / 10) >>> 0);\n\t\treturn o._s = o._s != n._s, o._f = ((r = la + lb - o._f - n._f) >= (j = (o._d = x._d).length) ? this._zeroes(o._d, r - j + 1, 1).length : j) - r, o.round();\n\t};\n\to.divide = function(n){\n\t\tif((n = new BigNumber(n)) == \"0\")\n\t\t\tthrow new Error(\"Division by 0\");\n\t\telse if(this == \"0\")\n\t\t\treturn new BigNumber;\n\t\tvar o = new BigNumber(this), a = o._d, b = n._d, la = a.length - o._f,\n\t\tlb = b.length - n._f, r = new BigNumber, i = 0, j, s, l, f = 1, c = 0, e = 0;\n\t\tr._s = o._s != n._s, r.precision = Math.max(o.precision, n.precision),\n\t\tr._f = +r._d.pop(), la != lb && o._zeroes(la > lb ? b : a, Math.abs(la - lb));\n\t\tn._f = b.length, b = n, b._s = false, b = b.round();\n\t\tfor(n = new BigNumber; a[0] == \"0\"; a.shift());\n\t\tout:\n\t\tdo{\n\t\t\tfor(l = c = 0, n == \"0\" && (n._d = [], n._f = 0); i < a.length && n.compare(b) == -1; ++i){\n\t\t\t\t(l = i + 1 == a.length, (!f && ++c > 1 || (e = l && n == \"0\" && a[i] == \"0\")))\n\t\t\t\t&& (r._f == r._d.length && ++r._f, r._d.push(0));\n\t\t\t\t(a[i] == \"0\" && n == \"0\") || (n._d.push(a[i]), ++n._f);\n\t\t\t\tif(e)\n\t\t\t\t\tbreak out;\n\t\t\t\tif((l && n.compare(b) == -1 && (r._f == r._d.length && ++r._f, 1)) || (l = 0))\n\t\t\t\t\twhile(r._d.push(0), n._d.push(0), ++n._f, n.compare(b) == -1);\n\t\t\t}\n\t\t\tif(f = 0, n.compare(b) == -1 && !(l = 0))\n\t\t\t\twhile(l ? r._d.push(0) : l = 1, n._d.push(0), ++n._f, n.compare(b) == -1);\n\t\t\tfor(s = new BigNumber, j = 0; n.compare(y = s.add(b)) + 1 && ++j; s.set(y));\n\t\t\tn.set(n.subtract(s)), !l && r._f == r._d.length && ++r._f, r._d.push(j);\n\t\t}\n\t\twhile((i < a.length || n != \"0\") && (r._d.length - r._f) <= r.precision);\n\t\treturn r.round();\n\t};\n\to.mod = function(n){\n\t\treturn this.subtract(this.divide(n).intPart().multiply(n));\n\t};\n\to.pow = function(n){\n\t\tvar o = new BigNumber(this), i;\n\t\tif((n = (new BigNumber(n)).intPart()) == 0) return o.set(1);\n\t\tfor(i = Math.abs(n); --i; o.set(o.multiply(this)));\n\t\treturn n < 0 ? o.set((new BigNumber(1)).divide(o)) : o;\n\t};\n\to.set = function(n){\n\t\treturn this.constructor(n), this;\n\t};\n\to.compare = function(n){\n\t\tvar a = this, la = this._f, b = new BigNumber(n), lb = b._f, r = [-1, 1], i, l;\n\t\tif(a._s != b._s)\n\t\t\treturn a._s ? -1 : 1;\n\t\tif(la != lb)\n\t\t\treturn r[(la > lb) ^ a._s];\n\t\tfor(la = (a = a._d).length, lb = (b = b._d).length, i = -1, l = Math.min(la, lb); ++i < l;)\n\t\t\tif(a[i] != b[i])\n\t\t\t\treturn r[(a[i] > b[i]) ^ a._s];\n\t\treturn la != lb ? r[(la > lb) ^ a._s] : 0;\n\t};\n\to.negate = function(){\n\t\tvar n = new BigNumber(this); return n._s ^= 1, n;\n\t};\n\to.abs = function(){\n\t\tvar n = new BigNumber(this); return n._s = 0, n;\n\t};\n\to.intPart = function(){\n\t\treturn new BigNumber((this._s ? \"-\" : \"\") + (this._d.slice(0, this._f).join(\"\") || \"0\"));\n\t};\n\to.valueOf = o.toString = function(){\n\t\tvar o = this;\n\t\treturn (o._s ? \"-\" : \"\") + (o._d.slice(0, o._f).join(\"\") || \"0\") + (o._f != o._d.length ? \".\" + o._d.slice(o._f).join(\"\") : \"\");\n\t};\n\to._zeroes = function(n, l, t){\n\t\tvar s = [\"push\", \"unshift\"][t || 0];\n\t\tfor(++l; --l;  n[s](0));\n\t\treturn n;\n\t};\n\to.round = function(){\n\t\tif(\"_rounding\" in this) return this;\n\t\tvar $ = BigNumber, r = this.roundType, b = this._d, d, p, n, x;\n\t\tfor(this._rounding = true; this._f > 1 && !b[0]; --this._f, b.shift());\n\t\tfor(d = this._f, p = this.precision + d, n = b[p]; b.length > d && !b[b.length -1]; b.pop());\n\t\tx = (this._s ? \"-\" : \"\") + (p - d ? \"0.\" + this._zeroes([], p - d - 1).join(\"\") : \"\") + 1;\n\t\tif(b.length > p){\n\t\t\tn && (r == $.DOWN ? false : r == $.UP ? true : r == $.CEIL ? !this._s\n\t\t\t: r == $.FLOOR ? this._s : r == $.HALF_UP ? n >= 5 : r == $.HALF_DOWN ? n > 5\n\t\t\t: r == $.HALF_EVEN ? n >= 5 && b[p - 1] & 1 : false) && this.add(x);\n\t\t\tb.splice(p, b.length - p);\n\t\t}\n\t\treturn delete this._rounding, this;\n\t};\n}\n\nvar isNegZero=function(x) {return x===0 && Math.atan2(x,x) < 0}\n\nvar _mod = {\n    __getattr__ : function(attr){\n        var res = this[attr]\n        if(res===undefined){$raise('AttributeError','module math has no attribute '+attr)}\n        return res\n    },\n    acos: function(x) {return float(Math.acos(float_check(x)))},\n    acosh: function(x) { \n        if (_b_.$isinf(x)) return float('inf');\n        var y = float_check(x);\n        return float(Math.log(y + Math.sqrt(y*y-1)));\n    },\n    asin: function(x) {return float(Math.asin(float_check(x)))},\n    asinh: function(x) {\n        if (_b_.$isninf(x)) return float('-inf');\n        if (_b_.$isinf(x)) return float('inf');\n        var y = float_check(x);\n        return float(Math.log(y + Math.sqrt(y*y+1)))\n    },\n    atan: function(x) {\n        if (_b_.$isninf(x)) return float(-Math.PI/2);\n        if (_b_.$isinf(x)) return float(Math.PI/2);\n        return float(Math.atan(float_check(x)))},\n    atan2: function(y,x) {\n        return float(Math.atan2(float_check(y),float_check(x)))\n    },\n    atanh: function(x) { \n       var y=float_check(x);\n       if (y==0) return 0;\n       return float(0.5 * Math.log((1/y+1)/(1/y-1)));\n    },\n    ceil: function(x) {\n       try{return getattr(x,'__ceil__')()}catch(err){$B.$pop_exc()}\n\n       if (_b_.$isninf(x)) return float('-inf')\n       if (_b_.$isinf(x)) return float('inf')\n       if (isNaN(x)) return float('nan')\n\n       var y=float_check(x);\n       if (!isNaN(parseFloat(y)) && isFinite(y)) return int(Math.ceil(y));\n       \n       $raise('ValueError', 'object is not a number and does not contain __ceil__')\n    },\n    copysign: function(x,y) {\n        var x1=Math.abs(float_check(x))\n        var y1=float_check(y)\n        var sign=y1?y1<0?-1:1:1\n        if (isNegZero(y1)) sign=-1   // probably need to work on adding a check for -0\n        return float(x1 * sign)\n    },\n    cos : function(x){return float(Math.cos(float_check(x)))},\n    cosh: function(x){\n        if (_b_.$isinf(x)) return float('inf')\n        var y = float_check(x)\n        if (Math.cosh !== undefined) return float(Math.cosh(y))\n        return float((Math.pow(Math.E,y) + Math.pow(Math.E,-y))/2)\n    },\n    degrees: function(x){return float(float_check(x) * 180/Math.PI)},\n    e: float(Math.E),\n    erf: function(x) {\n        // inspired from \n        // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n        var y =float_check(x);\n        var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n        var ans = 1 - t * Math.exp( -y*y - 1.26551223 +\n                     t * ( 1.00002368 +\n                     t * ( 0.37409196 + \n                     t * ( 0.09678418 + \n                     t * (-0.18628806 + \n                     t * ( 0.27886807 + \n                     t * (-1.13520398 + \n                     t * ( 1.48851587 + \n                     t * (-0.82215223 + \n                     t * 0.17087277)))))))))\n        if (y >= 0.0) return ans\n\n        return -ans\n    },\n\n    erfc: function(x) {\n        // inspired from \n        // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n        var y = float_check(x);\n        var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n        var ans = 1 - t * Math.exp( -y*y - 1.26551223 +\n                     t * ( 1.00002368 +\n                     t * ( 0.37409196 + \n                     t * ( 0.09678418 + \n                     t * (-0.18628806 + \n                     t * ( 0.27886807 + \n                     t * (-1.13520398 + \n                     t * ( 1.48851587 + \n                     t * (-0.82215223 + \n                     t * 0.17087277)))))))))\n        if (y >= 0.0) return 1-ans\n        return 1+ans\n    },\n    exp: function(x){\n         if (_b_.$isninf(x)) {return float(0)}\n         if (_b_.$isinf(x)) {return float('inf')}\n         var _r=Math.exp(float_check(x))\n         if (_b_.$isinf(_r)) {throw OverflowError(\"math range error\")}\n         return float(_r)\n    },\n    expm1: function(x){return float(Math.exp(float_check(x))-1)},\n    //fabs: function(x){ return x>0?float(x):float(-x)},\n    fabs: function(x){return _b_.$fabs(x)}, //located in py_float.js\n    factorial: function(x) {\n         //using code from http://stackoverflow.com/questions/3959211/fast-factorial-function-in-javascript\n         var y=float_check(x);\n         var r=1\n         for (var i=2; i<=y; i++){r*=i}\n         return r\n    },\n    floor:function(x){return Math.floor(float_check(x))},\n    fmod:function(x,y){return float(float_check(x)%float_check(y))},\n    frexp: function(x){return _b_.tuple(_b_.$frexp(x))}, // located in py_float.js\n    //fsum:function(x){},\n    gamma: function(x){\n         //using code from http://stackoverflow.com/questions/3959211/fast-factorial-function-in-javascript\n         // Lanczos Approximation of the Gamma Function\n         // As described in Numerical Recipes in C (2nd ed. Cambridge University Press, 1992)\n         var y=float_check(x);\n         var z = y + 1;\n         var d1 = Math.sqrt(2 * Math.PI) / z;\n\n         var d2 = 1.000000000190015;\n         d2 +=  76.18009172947146 / (z+1);\n         d2 += -86.50532032941677 / (z+2);\n         d2 +=  24.01409824083091 / (z+3); \n         d2 += -1.231739572450155 / (z+4); \n         d2 +=  1.208650973866179E-3 / (z+5);\n         d2 += -5.395239384953E-6 / (z+6);\n\n         return d1 * d2 * Math.pow(z+5.5,z+0.5) * Math.exp(-(z+5.5));\n    },\n    hypot: function(x,y){\n       if (_b_.$isinf(x) || _b_.$isinf(y)) return float('inf')\n       var x1=float_check(x);\n       var y1=float_check(y);\n       return float(Math.sqrt(x1*x1 + y1*y1))},\n    isfinite:function(x) {return isFinite(float_check(x))},\n    isinf:function(x) {return _b_.$isinf(float_check(x))},\n    isnan:function(x) {return isNaN(float_check(x))},\n    ldexp:function(x,i) {return _b_.$ldexp(x,i)},   //located in py_float.js\n    lgamma:function(x) {\n         // see gamma function for sources\n         var y=float_check(x);\n         var z = y + 1;\n         var d1 = Math.sqrt(2 * Math.PI) / z;\n\n         var d2 = 1.000000000190015;\n         d2 +=  76.18009172947146 / (z+1);\n         d2 += -86.50532032941677 / (z+2);\n         d2 +=  24.01409824083091 / (z+3); \n         d2 += -1.231739572450155 / (z+4); \n         d2 +=  1.208650973866179E-3 / (z+5);\n         d2 += -5.395239384953E-6 / (z+6);\n\n         return float(Math.log(Math.abs(d1 * d2 * Math.pow(z+5.5,z+0.5) * Math.exp(-(z+5.5)))));\n    },\n    log: function(x, base) {\n         var x1=float_check(x);\n         if (base === undefined) return float(Math.log(x1));\n         return float(Math.log(x1)/Math.log(float_check(base)));\n    },\n    log1p: function(x) {return float(Math.log(1.0 + float_check(x)))},\n    log2: function(x) {\n        if (isNaN(x)) return float('nan')\n        if (_b_.$isninf(x)) throw ValueError('')\n        var x1=float_check(x)\n        if (x1 < 0.0) throw ValueError('')\n        //if (isLargeNumber(x1)) x1=new BigNumber(x1)         \n        return float(Math.log(x1)/Math.LN2)\n    },\n    log10: function(x) {return float(Math.log(float_check(x))/Math.LN10)},\n    modf:function(x) {\n       if (_b_.$isninf(x)) return _b_.tuple([0.0, float('-inf')])\n       if (_b_.$isinf(x)) return _b_.tuple([0.0, float('inf')])\n       if (isNaN(x)) return _b_.tuple([float('nan'), float('nan')])\n\n       var x1=float_check(x);\n       if (x1 > 0) {\n          var i=float(x1-Math.floor(x1))\n          return _b_.tuple([i, float(x1-i)])\n       }\n\n       var x2=Math.ceil(x1)\n       var i=float(x1-x2)\n       return _b_.tuple([i, float(x2)])\n    },\n    pi : float(Math.PI),\n    pow: function(x,y) {\n        var x1=float_check(x)\n        var y1=float_check(y)\n        if (y1 == 0) return float(1)        \n        if (x1 == 0 && y1 < 0) throw _b_.ValueError('')\n\n        if(isNaN(y1)) {if(x1==1) return float(1) \n                       return float('nan')\n        }\n        if (x1 == 0) return float(0)\n\n        if(_b_.$isninf(y)) {if(x1==1||x1==-1) {return float(1)}\n                       if(x1 < 1 && x1 > -1) return float('inf') \n                       return float(0)\n        }\n        if(_b_.$isinf(y)) {if(x1==1||x1==-1) {return float(1)} \n                      if(x1 < 1 && x1 > -1) return float(0) \n                      return float('inf')}\n\n        if(isNaN(x1)) return float('nan')\n        if(_b_.$isninf(x)) {\n            if (y1 > 0 && isOdd(y1)) return float('-inf')\n            if (y1 > 0) return float('inf')  // this is even or a float\n            if (y1 < 0) return float(0)\n            return float(1)\n        }\n\n        if(_b_.$isinf(x)) { \n            if (y1 > 0) return float('inf')\n            if (y1 < 0) return float(0)\n            return float(1)\n        }\n\n        var r\n        if (isLargeNumber(x1) || isLargeNumber(y1)) {\n           var x=new BigNumber(x1)\n           var y=new BigNumber(y1)\n           r=x.pow(y)\n        } else {\n           r=Math.pow(x1,y1)\n        }\n\n        if (isNaN(r)) return float('nan')\n        if (_b_.$isninf(r)) return float('-inf')\n        if (_b_.$isinf(r)) return float('inf')\n\n        return r\n    },\n    radians: function(x){return float(float_check(x) * Math.PI/180)},\n    sin : function(x){return float(Math.sin(float_check(x)))},\n    sinh: function(x) { \n        //if (_b_.$isinf(x)) return float('inf');\n        var y = float_check(x)\n        if (Math.sinh !== undefined) { return float(Math.sinh(y))}\n        return float((Math.pow(Math.E,y) - Math.pow(Math.E,-y))/2)\n    },\n    sqrt : function(x){\n      var y = float_check(x)\n      if (y < 0) { throw ValueError(\"math range error\")}\n      if (_b_.$isinf(y)) return float('inf')\n      var _r=Math.sqrt(y)\n      if (_b_.$isinf(_r)) {throw OverflowError(\"math range error\")}\n      return float(_r)\n    },\n    tan: function(x) {\n        var y = float_check(x)\n        return float(Math.tan(y))\n    },\n    tanh: function(x) {\n        var y = float_check(x)\n        if (Math.tanh !== undefined) return float(Math.tanh(y))\n        return float((Math.pow(Math.E,y) - Math.pow(Math.E,-y))/\n                     (Math.pow(Math.E,y) + Math.pow(Math.E,-y)))       \n    },\n    trunc: function(x) {\n       try{return getattr(x,'__trunc__')()}catch(err){$B.$pop_exc()}\n       var x1=float_check(x);\n       if (!isNaN(parseFloat(x1)) && isFinite(x1)) {\n          if (Math.trunc !== undefined) { return int(Math.trunc(x1))}\n          if (x1 > 0) {return int(Math.floor(x1))}\n          return int(Math.ceil(x1))  // x1 < 0\n       }\n       $raise('ValueError', 'object is not a number and does not contain __trunc__')\n    }\n}\n\nfor(var $attr in _mod){\n    if(typeof _mod[$attr]==='function'){\n        _mod[$attr].__repr__=(function(func){\n            return function(){return '<built-in function '+func+'>'}})($attr)\n        _mod[$attr].__str__=(function(func){\n            return function(){return '<built-in function '+func+'>'}})($attr)\n    }\n}\n\nreturn _mod\n\n})(__BRYTHON__)\n"], "site-packages.pygame.sprite": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport pygame\nfrom pygame.rect import Rect\nfrom pygame.time import get_ticks\nfrom operator import truth\n\n\n\n\ncallable = lambda obj: hasattr(obj, '__call__')\n\n\ntry:\n from pygame.mask import from_surface\nexcept:\n pass\n \n \nclass Sprite(object):\n \"\"\n \n def __init__(self, *groups):\n  self.__g = {} \n  if groups:\n   self.add(*groups)\n   \n def add(self, *groups):\n  \"\"\n  has = self.__g.__contains__\n  for group in groups:\n   if hasattr(group, '_spritegroup'):\n    if not has(group):\n     group.add_internal(self)\n     self.add_internal(group)\n   else:\n    self.add(*group)\n    \n def remove(self, *groups):\n  \"\"\n  has = self.__g.__contains__\n  for group in groups:\n   if hasattr(group, '_spritegroup'):\n    if has(group):\n     group.remove_internal(self)\n     self.remove_internal(group)\n   else:\n    self.remove(*group)\n    \n def add_internal(self, group):\n  self.__g[group] = 0\n  \n def remove_internal(self, group):\n  del self.__g[group]\n  \n def update(self, *args):\n  \"\"\n  pass\n  \n def kill(self):\n  \"\"\n  for c in self.__g:\n   c.remove_internal(self)\n  self.__g.clear()\n  \n def groups(self):\n  \"\"\n  return list(self.__g)\n  \n def alive(self):\n  \"\"\n  return truth(self.__g)\n  \n def __repr__(self):\n  return \"<%s sprite(in %d groups)>\" % (self.__class__.__name__, len(self.__g))\n  \n  \nclass DirtySprite(Sprite):\n \"\"\n \n def __init__(self, *groups):\n \n  self.dirty = 1\n  self.blendmode = 0 \n  \n  self._visible = 1\n  self._layer = 0 \n  self.source_rect = None\n  Sprite.__init__(self, *groups)\n  \n def _set_visible(self, val):\n  \"\"\n  self._visible = val\n  if self.dirty < 2:\n   self.dirty = 1\n   \n def _get_visible(self):\n  \"\"\n  return self._visible\n  \n visible = property(lambda self: self._get_visible(),\n lambda self, value: self._set_visible(value),\n doc=\"you can make this sprite disappear without \"\n \"removing it from the group,\\n\"\n \"assign 0 for invisible and 1 for visible\")\n \n def __repr__(self):\n  return \"<%s DirtySprite(in %d groups)>\" % (self.__class__.__name__, len(self.groups()))\n  \n  \nclass AbstractGroup(object):\n \"\"\n \n \n _spritegroup = True\n \n def __init__(self):\n  self.spritedict = {}\n  self.lostsprites = []\n  \n def sprites(self):\n  \"\"\n  return list(self.spritedict)\n  \n def add_internal(self, sprite):\n  self.spritedict[sprite] = 0\n  \n def remove_internal(self, sprite):\n  r = self.spritedict[sprite]\n  if r:\n   self.lostsprites.append(r)\n  del self.spritedict[sprite]\n  \n def has_internal(self, sprite):\n  return sprite in self.spritedict\n  \n def copy(self):\n  \"\"\n  return self.__class__(self.sprites())\n  \n def __iter__(self):\n  return iter(self.sprites())\n  \n def __contains__(self, sprite):\n  return self.has(sprite)\n  \n def add(self, *sprites):\n  \"\"\n  for sprite in sprites:\n  \n  \n  \n   if isinstance(sprite, Sprite):\n    if not self.has_internal(sprite):\n     self.add_internal(sprite)\n     sprite.add_internal(self)\n   else:\n    try:\n    \n    \n     self.add(*sprite)\n    except (TypeError, AttributeError):\n    \n    \n    \n    \n     if hasattr(sprite, '_spritegroup'):\n      for spr in sprite.sprites():\n       if not self.has_internal(spr):\n        self.add_internal(spr)\n        spr.add_internal(self)\n     elif not self.has_internal(sprite):\n      self.add_internal(sprite)\n      sprite.add_internal(self)\n      \n def remove(self, *sprites):\n  \"\"\n  \n  \n  \n  \n  \n  \n  for sprite in sprites:\n   if isinstance(sprite, Sprite):\n    if self.has_internal(sprite):\n     self.remove_internal(sprite)\n     sprite.remove_internal(self)\n   else:\n    try:\n     self.remove(*sprite)\n    except (TypeError, AttributeError):\n     if hasattr(sprite, '_spritegroup'):\n      for spr in sprite.sprites():\n       if self.has_internal(spr):\n        self.remove_internal(spr)\n        spr.remove_internal(self)\n     elif self.has_internal(sprite):\n      self.remove_internal(sprite)\n      sprite.remove_internal(self)\n      \n def has(self, *sprites):\n  \"\"\n  return_value = False\n  \n  for sprite in sprites:\n   if isinstance(sprite, Sprite):\n   \n    if self.has_internal(sprite):\n     return_value = True\n    else:\n     return False\n   else:\n    try:\n     if self.has(*sprite):\n      return_value = True\n     else:\n      return False\n    except (TypeError, AttributeError):\n     if hasattr(sprite, '_spritegroup'):\n      for spr in sprite.sprites():\n       if self.has_internal(spr):\n        return_value = True\n       else:\n        return False\n     else:\n      if self.has_internal(sprite):\n       return_value = True\n      else:\n       return False\n       \n  return return_value\n  \n def update(self, *args):\n  \"\"\n  for s in self.sprites():\n   s.update(*args)\n   \n def draw(self, surface):\n  \"\"\n  \n  sprites = self.sprites()\n  surface_blit = surface.blit\n  for spr in sprites:\n  \n  \n   self.spritedict[spr] = surface_blit(spr.image, spr.rect)\n  self.lostsprites = []\n  \n def clear(self, surface, bgd):\n  \"\"\n  if callable(bgd):\n   for r in self.lostsprites:\n    bgd(surface, r)\n   for r in self.spritedict.values():\n    if r:\n     bgd(surface, r)\n  else:\n   surface_blit = surface.blit\n   for r in self.lostsprites:\n    surface_blit(bgd, r, r)\n   for r in self.spritedict.values():\n    if r:\n     surface_blit(bgd, r, r)\n     \n def empty(self):\n  \"\"\n  for s in self.sprites():\n   self.remove_internal(s)\n   s.remove_internal(self)\n   \n def __nonzero__(self):\n  return truth(self.sprites())\n  \n def __len__(self):\n  \"\"\n  return len(self.sprites())\n  \n def __repr__(self):\n  return \"<%s(%d sprites)>\" % (self.__class__.__name__, len(self))\n  \nclass Group(AbstractGroup):\n \"\"\n def __init__(self, *sprites):\n  AbstractGroup.__init__(self)\n  self.add(*sprites)\n  \nRenderPlain = Group\nRenderClear = Group\n\nclass RenderUpdates(Group):\n \"\"\n def draw(self, surface):\n  spritedict = self.spritedict\n  surface_blit = surface.blit\n  dirty = self.lostsprites\n  self.lostsprites = []\n  dirty_append = dirty.append\n  for s in self.sprites():\n   r = spritedict[s]\n   newrect = surface_blit(s.image, s.rect)\n   if r:\n    if newrect.colliderect(r):\n     dirty_append(newrect.union(r))\n    else:\n     dirty_append(newrect)\n     dirty_append(r)\n   else:\n    dirty_append(newrect)\n   spritedict[s] = newrect\n  return dirty\n  \nclass OrderedUpdates(RenderUpdates):\n \"\"\n def __init__(self, *sprites):\n  self._spritelist = []\n  RenderUpdates.__init__(self, *sprites)\n  \n def sprites(self):\n  return list(self._spritelist)\n  \n def add_internal(self, sprite):\n  RenderUpdates.add_internal(self, sprite)\n  self._spritelist.append(sprite)\n  \n def remove_internal(self, sprite):\n  RenderUpdates.remove_internal(self, sprite)\n  self._spritelist.remove(sprite)\n  \n  \nclass LayeredUpdates(AbstractGroup):\n \"\"\n \n _init_rect = Rect(0, 0, 0, 0)\n \n def __init__(self, *sprites, **kwargs):\n  \"\"\n  self._spritelayers = {}\n  self._spritelist = []\n  AbstractGroup.__init__(self)\n  self._default_layer = kwargs.get('default_layer', 0)\n  \n  self.add(*sprites, **kwargs)\n  \n def add_internal(self, sprite, layer=None):\n  \"\"\n  self.spritedict[sprite] = self._init_rect\n  \n  if layer is None:\n   try:\n    layer = sprite._layer\n   except AttributeError:\n    layer = sprite._layer = self._default_layer\n  elif hasattr(sprite, '_layer'):\n   sprite._layer = layer\n   \n  sprites = self._spritelist \n  sprites_layers = self._spritelayers\n  sprites_layers[sprite] = layer\n  \n  \n  \n  leng = len(sprites)\n  low = mid = 0\n  high = leng - 1\n  while low <= high:\n   mid = low + (high - low) // 2\n   if sprites_layers[sprites[mid]] <= layer:\n    low = mid + 1\n   else:\n    high = mid - 1\n    \n  while mid < leng and sprites_layers[sprites[mid]] <= layer:\n   mid += 1\n  sprites.insert(mid, sprite)\n  \n def add(self, *sprites, **kwargs):\n  \"\"\n  \n  if not sprites:\n   return\n  if 'layer' in kwargs:\n   layer = kwargs['layer']\n  else:\n   layer = None\n  for sprite in sprites:\n  \n  \n  \n   if isinstance(sprite, Sprite):\n    if not self.has_internal(sprite):\n     self.add_internal(sprite, layer)\n     sprite.add_internal(self)\n   else:\n    try:\n    \n    \n     self.add(*sprite, **kwargs)\n    except (TypeError, AttributeError):\n    \n    \n    \n    \n     if hasattr(sprite, '_spritegroup'):\n      for spr in sprite.sprites():\n       if not self.has_internal(spr):\n        self.add_internal(spr, layer)\n        spr.add_internal(self)\n     elif not self.has_internal(sprite):\n      self.add_internal(sprite, layer)\n      sprite.add_internal(self)\n      \n def remove_internal(self, sprite):\n  \"\"\n  self._spritelist.remove(sprite)\n  \n  r = self.spritedict[sprite]\n  if r is not self._init_rect:\n   self.lostsprites.append(r) \n  if hasattr(sprite, 'rect'):\n   self.lostsprites.append(sprite.rect) \n   \n  del self.spritedict[sprite]\n  del self._spritelayers[sprite]\n  \n def sprites(self):\n  \"\"\n  return list(self._spritelist)\n  \n def draw(self, surface):\n  \"\"\n  spritedict = self.spritedict\n  surface_blit = surface.blit\n  dirty = self.lostsprites\n  self.lostsprites = []\n  dirty_append = dirty.append\n  init_rect = self._init_rect\n  for spr in self.sprites():\n   rec = spritedict[spr]\n   newrect = surface_blit(spr.image, spr.rect)\n   if rec is init_rect:\n    dirty_append(newrect)\n   else:\n    if newrect.colliderect(rec):\n     dirty_append(newrect.union(rec))\n    else:\n     dirty_append(newrect)\n     dirty_append(rec)\n   spritedict[spr] = newrect\n  return dirty\n  \n def get_sprites_at(self, pos):\n  \"\"\n  _sprites = self._spritelist\n  rect = Rect(pos, (0, 0))\n  colliding_idx = rect.collidelistall(_sprites)\n  colliding = [_sprites[i] for i in colliding_idx]\n  return colliding\n  \n def get_sprite(self, idx):\n  \"\"\n  return self._spritelist[idx]\n  \n def remove_sprites_of_layer(self, layer_nr):\n  \"\"\n  sprites = self.get_sprites_from_layer(layer_nr)\n  self.remove(*sprites)\n  return sprites\n  \n  \n def layers(self):\n  \"\"\n  return sorted(set(self._spritelayers.values()))\n  \n def change_layer(self, sprite, new_layer):\n  \"\"\n  sprites = self._spritelist \n  sprites_layers = self._spritelayers \n  \n  sprites.remove(sprite)\n  sprites_layers.pop(sprite)\n  \n  \n  \n  leng = len(sprites)\n  low = mid = 0\n  high = leng - 1\n  while low <= high:\n   mid = low + (high - low) // 2\n   if sprites_layers[sprites[mid]] <= new_layer:\n    low = mid + 1\n   else:\n    high = mid - 1\n    \n  while mid < leng and sprites_layers[sprites[mid]] <= new_layer:\n   mid += 1\n  sprites.insert(mid, sprite)\n  if hasattr(sprite, 'layer'):\n   sprite.layer = new_layer\n   \n   \n  sprites_layers[sprite] = new_layer\n  \n def get_layer_of_sprite(self, sprite):\n  \"\"\n  return self._spritelayers.get(sprite, self._default_layer)\n  \n def get_top_layer(self):\n  \"\"\n  return self._spritelayers[self._spritelist[-1]]\n  \n def get_bottom_layer(self):\n  \"\"\n  return self._spritelayers[self._spritelist[0]]\n  \n def move_to_front(self, sprite):\n  \"\"\n  self.change_layer(sprite, self.get_top_layer())\n  \n def move_to_back(self, sprite):\n  \"\"\n  self.change_layer(sprite, self.get_bottom_layer() - 1)\n  \n def get_top_sprite(self):\n  \"\"\n  return self._spritelist[-1]\n  \n def get_sprites_from_layer(self, layer):\n  \"\"\n  sprites = []\n  sprites_append = sprites.append\n  sprite_layers = self._spritelayers\n  for spr in self._spritelist:\n   if sprite_layers[spr] == layer:\n    sprites_append(spr)\n   elif sprite_layers[spr] > layer:\n   \n    break\n  return sprites\n  \n def switch_layer(self, layer1_nr, layer2_nr):\n  \"\"\n  sprites1 = self.remove_sprites_of_layer(layer1_nr)\n  for spr in self.get_sprites_from_layer(layer2_nr):\n   self.change_layer(spr, layer1_nr)\n  self.add(layer=layer2_nr, *sprites1)\n  \n  \nclass LayeredDirty(LayeredUpdates):\n \"\"\n \n def __init__(self, *sprites, **kwargs):\n  \"\"\n  LayeredUpdates.__init__(self, *sprites, **kwargs)\n  self._clip = None\n  \n  self._use_update = False\n  \n  self._time_threshold = 1000.0 / 80.0 \n  \n  self._bgd = None\n  for key, val in kwargs.items():\n   if key in ['_use_update', '_time_threshold', '_default_layer']:\n    if hasattr(self, key):\n     setattr(self, key, val)\n     \n def add_internal(self, sprite, layer=None):\n  \"\"\n  \n  if not hasattr(sprite, 'dirty'):\n   raise AttributeError()\n  if not hasattr(sprite, 'visible'):\n   raise AttributeError()\n  if not hasattr(sprite, 'blendmode'):\n   raise AttributeError()\n   \n  if not isinstance(sprite, DirtySprite):\n   raise TypeError()\n   \n  if sprite.dirty == 0: \n   sprite.dirty = 1\n   \n  LayeredUpdates.add_internal(self, sprite, layer)\n  \n def draw(self, surface, bgd=None):\n  \"\"\n  \n  _orig_clip = surface.get_clip()\n  _clip = self._clip\n  if _clip is None:\n   _clip = _orig_clip\n   \n  _surf = surface\n  _sprites = self._spritelist\n  _old_rect = self.spritedict\n  _update = self.lostsprites\n  _update_append = _update.append\n  _ret = None\n  _surf_blit = _surf.blit\n  _rect = Rect\n  if bgd is not None:\n   self._bgd = bgd\n  _bgd = self._bgd\n  init_rect = self._init_rect\n  \n  _surf.set_clip(_clip)\n  \n  \n  start_time = get_ticks()\n  if self._use_update: \n  \n  \n   for spr in _sprites:\n    if 0 < spr.dirty:\n    \n     if spr.source_rect:\n      _union_rect = _rect(spr.rect.topleft,\n      spr.source_rect.size)\n     else:\n      _union_rect = _rect(spr.rect)\n      \n     _union_rect_collidelist = _union_rect.collidelist\n     _union_rect_union_ip = _union_rect.union_ip\n     i = _union_rect_collidelist(_update)\n     while -1 < i:\n      _union_rect_union_ip(_update[i])\n      del _update[i]\n      i = _union_rect_collidelist(_update)\n     _update_append(_union_rect.clip(_clip))\n     \n     if _old_rect[spr] is not init_rect:\n      _union_rect = _rect(_old_rect[spr])\n      _union_rect_collidelist = _union_rect.collidelist\n      _union_rect_union_ip = _union_rect.union_ip\n      i = _union_rect_collidelist(_update)\n      while -1 < i:\n       _union_rect_union_ip(_update[i])\n       del _update[i]\n       i = _union_rect_collidelist(_update)\n      _update_append(_union_rect.clip(_clip))\n      \n      \n      \n      \n   if _bgd is not None:\n    for rec in _update:\n     _surf_blit(_bgd, rec, rec)\n     \n     \n   for spr in _sprites:\n    if 1 > spr.dirty:\n     if spr._visible:\n     \n      _spr_rect = spr.rect\n      if spr.source_rect is not None:\n       _spr_rect = Rect(spr.rect.topleft,\n       spr.source_rect.size)\n      _spr_rect_clip = _spr_rect.clip\n      for idx in _spr_rect.collidelistall(_update):\n      \n       clip = _spr_rect_clip(_update[idx])\n       _surf_blit(spr.image,\n       clip,\n       (clip[0] - _spr_rect[0],\n       clip[1] - _spr_rect[1],\n       clip[2],\n       clip[3]),\n       spr.blendmode)\n    else: \n     if spr._visible:\n      _old_rect[spr] = _surf_blit(spr.image,\n      spr.rect,\n      spr.source_rect,\n      spr.blendmode)\n     if spr.dirty == 1:\n      spr.dirty = 0\n   _ret = list(_update)\n  else: \n   if _bgd is not None:\n    _surf_blit(_bgd, (0, 0))\n   for spr in _sprites:\n    if spr._visible:\n     _old_rect[spr] = _surf_blit(spr.image,\n     spr.rect,\n     spr.source_rect,\n     spr.blendmode)\n   _ret = [_rect(_clip)] \n   \n   \n   \n   \n  end_time = get_ticks()\n  if end_time-start_time > self._time_threshold:\n   self._use_update = False\n  else:\n   self._use_update = True\n   \n   \n   \n   \n   \n  _update[:] = []\n  \n  \n  \n  _surf.set_clip(_orig_clip)\n  return _ret\n  \n def clear(self, surface, bgd):\n  \"\"\n  self._bgd = bgd\n  \n def repaint_rect(self, screen_rect):\n  \"\"\n  if self._clip:\n   self.lostsprites.append(screen_rect.clip(self._clip))\n  else:\n   self.lostsprites.append(Rect(screen_rect))\n   \n def set_clip(self, screen_rect=None):\n  \"\"\n  if screen_rect is None:\n   self._clip = pygame.display.get_surface().get_rect()\n  else:\n   self._clip = screen_rect\n  self._use_update = False\n  \n def get_clip(self):\n  \"\"\n  return self._clip\n  \n def change_layer(self, sprite, new_layer):\n  \"\"\n  LayeredUpdates.change_layer(self, sprite, new_layer)\n  if sprite.dirty == 0:\n   sprite.dirty = 1\n   \n def set_timing_treshold(self, time_ms):\n  \"\"\n  self._time_threshold = time_ms\n  \n  \nclass GroupSingle(AbstractGroup):\n \"\"\n \n def __init__(self, sprite=None):\n  AbstractGroup.__init__(self)\n  self.__sprite = None\n  if sprite is not None:\n   self.add(sprite)\n   \n def copy(self):\n  return GroupSingle(self.__sprite)\n  \n def sprites(self):\n  if self.__sprite is not None:\n   return [self.__sprite]\n  else:\n   return []\n   \n def add_internal(self, sprite):\n  if self.__sprite is not None:\n   self.__sprite.remove_internal(self)\n   self.remove_internal(self.__sprite)\n  self.__sprite = sprite\n  \n def __nonzero__(self):\n  return self.__sprite is not None\n  \n def _get_sprite(self):\n  return self.__sprite\n  \n def _set_sprite(self, sprite):\n  self.add_internal(sprite)\n  sprite.add_internal(self)\n  return sprite\n  \n sprite = property(_get_sprite,\n _set_sprite,\n None,\n \"The sprite contained in this group\")\n \n def remove_internal(self, sprite):\n  if sprite is self.__sprite:\n   self.__sprite = None\n  if sprite in self.spritedict:\n   AbstractGroup.remove_internal(self, sprite)\n   \n def has_internal(self, sprite):\n  return self.__sprite is sprite\n  \n  \n def __contains__(self, sprite):\n  return self.__sprite is sprite\n  \n  \n  \ndef collide_rect(left, right):\n \"\"\n return left.rect.colliderect(right.rect)\n \nclass collide_rect_ratio:\n \"\"\n \n def __init__(self, ratio):\n  \"\"\n  self.ratio = ratio\n  \n def __call__(self, left, right):\n  \"\"\n  \n  ratio = self.ratio\n  \n  leftrect = left.rect\n  width = leftrect.width\n  height = leftrect.height\n  leftrect = leftrect.inflate(width * ratio - width,\n  height * ratio - height)\n  \n  rightrect = right.rect\n  width = rightrect.width\n  height = rightrect.height\n  rightrect = rightrect.inflate(width * ratio - width,\n  height * ratio - height)\n  \n  return leftrect.colliderect(rightrect)\n  \ndef collide_circle(left, right):\n \"\"\n \n xdistance = left.rect.centerx - right.rect.centerx\n ydistance = left.rect.centery - right.rect.centery\n distancesquared = xdistance ** 2 + ydistance ** 2\n \n if hasattr(left, 'radius'):\n  leftradius = left.radius\n else:\n  leftrect = left.rect\n  \n  \n  leftradius = 0.5 * ((leftrect.width ** 2 + leftrect.height ** 2) ** 0.5)\n  \n  setattr(left, 'radius', leftradius)\n  \n if hasattr(right, 'radius'):\n  rightradius = right.radius\n else:\n  rightrect = right.rect\n  \n  \n  rightradius = 0.5 * ((rightrect.width ** 2 + rightrect.height ** 2) ** 0.5)\n  \n  setattr(right, 'radius', rightradius)\n return distancesquared <= (leftradius + rightradius) ** 2\n \nclass collide_circle_ratio(object):\n \"\"\n \n def __init__(self, ratio):\n  \"\"\n  self.ratio = ratio\n  \n  \n def __call__(self, left, right):\n  \"\"\n  \n  ratio = self.ratio\n  xdistance = left.rect.centerx - right.rect.centerx\n  ydistance = left.rect.centery - right.rect.centery\n  distancesquared = xdistance ** 2 + ydistance ** 2\n  \n  if hasattr(left, \"radius\"):\n   leftradius = left.radius * ratio\n  else:\n   leftrect = left.rect\n   leftradius = ratio * 0.5 * ((leftrect.width ** 2 + leftrect.height ** 2) ** 0.5)\n   \n   setattr(left, 'radius', leftradius)\n   \n  if hasattr(right, \"radius\"):\n   rightradius = right.radius * ratio\n  else:\n   rightrect = right.rect\n   rightradius = ratio * 0.5 * ((rightrect.width ** 2 + rightrect.height ** 2) ** 0.5)\n   \n   setattr(right, 'radius', rightradius)\n   \n  return distancesquared <= (leftradius + rightradius) ** 2\n  \ndef collide_mask(left, right):\n \"\"\n xoffset = right.rect[0] - left.rect[0]\n yoffset = right.rect[1] - left.rect[1]\n try:\n  leftmask = left.mask\n except AttributeError:\n  leftmask = from_surface(left.image)\n try:\n  rightmask = right.mask\n except AttributeError:\n  rightmask = from_surface(right.image)\n return leftmask.overlap(rightmask, (xoffset, yoffset))\n \ndef spritecollide(sprite, group, dokill, collided=None):\n \"\"\n if dokill:\n \n  crashed = []\n  append = crashed.append\n  \n  if collided:\n   for s in group.sprites():\n    if collided(sprite, s):\n     s.kill()\n     append(s)\n  else:\n   spritecollide = sprite.rect.colliderect\n   for s in group.sprites():\n    if spritecollide(s.rect):\n     s.kill()\n     append(s)\n     \n  return crashed\n  \n elif collided:\n  return [s for s in group if collided(sprite, s)]\n else:\n  spritecollide = sprite.rect.colliderect\n  return [s for s in group if spritecollide(s.rect)]\n  \n  \ndef groupcollide(groupa, groupb, dokilla, dokillb, collided=None):\n \"\"\n crashed = {}\n SC = spritecollide\n if dokilla:\n  for s in groupa.sprites():\n   c = SC(s, groupb, dokillb, collided)\n   if c:\n    crashed[s] = c\n    s.kill()\n else:\n  for s in groupa:\n   c = SC(s, groupb, dokillb, collided)\n   if c:\n    crashed[s] = c\n return crashed\n \ndef spritecollideany(sprite, group, collided=None):\n \"\"\n if collided:\n  for s in group:\n   if collided(sprite, s):\n    return s\n else:\n \n  spritecollide = sprite.rect.colliderect\n  for s in group:\n   if spritecollide(s.rect):\n    return s\n return None\n"], "javascript": [".js", "var $module=(function($B) {\n  return {\n    JSObject: $B.JSObject,\n    JSConstructor: $B.JSConstructor,\n    console: $B.JSObject(window.console),\n    load:function(script_url, names){\n        // Load and eval() the Javascript file at script_url\n        // Set the names in array \"names\" in the Javacript global namespace\n        var file_obj = $B.builtins.open(script_url)\n        var content = $B.builtins.getattr(file_obj, 'read')()\n        eval(content)\n        if(names!==undefined){\n            if(!Array.isArray(names)){\n                throw $B.builtins.TypeError(\"argument 'names' should be a list, not '\"+$B.get_class(names).__name__)\n            }else{\n                for(var i=0;i<names.length;i++){\n                    try{window[names[i]]=eval(names[i])}\n                    catch(err){throw $B.builtins.NameError(\"name '\"+names[i]+\"' not found in script \"+script_url)}\n                }\n            }\n        }\n    },\n    py2js: function(src){return $B.py2js(src).to_js()},\n    pyobj2jsobj:function(obj){ return $B.pyobj2jsobj(obj)},\n    jsobj2pyobj:function(obj){ return $B.jsobj2pyobj(obj)}\n  }\n})(__BRYTHON__)\n"], "multiprocessing.pool": [".py", "\n\n\n\n\n\n\n\n\n__all__ = ['Pool']\n\n\n\n\n\nimport threading\nimport queue\nimport itertools\nimport collections\nimport time\n\nfrom multiprocessing import Process, cpu_count, TimeoutError\nfrom multiprocessing.util import Finalize, debug\n\n\n\n\n\nRUN = 0\nCLOSE = 1\nTERMINATE = 2\n\n\n\n\n\njob_counter = itertools.count()\n\ndef mapstar(args):\n return list(map(*args))\n \ndef starmapstar(args):\n return list(itertools.starmap(args[0], args[1]))\n \n \n \n \n \nclass MaybeEncodingError(Exception):\n \"\"\n \n def __init__(self, exc, value):\n  self.exc = repr(exc)\n  self.value = repr(value)\n  super(MaybeEncodingError, self).__init__(self.exc, self.value)\n  \n def __str__(self):\n  return \"Error sending result: '%s'. Reason: '%s'\" % (self.value,\n  self.exc)\n  \n def __repr__(self):\n  return \"<MaybeEncodingError: %s>\" % str(self)\n  \n  \ndef worker(inqueue, outqueue, initializer=None, initargs=(), maxtasks=None):\n assert maxtasks is None or (type(maxtasks) == int and maxtasks > 0)\n put = outqueue.put\n get = inqueue.get\n if hasattr(inqueue, '_writer'):\n  inqueue._writer.close()\n  outqueue._reader.close()\n  \n if initializer is not None:\n  initializer(*initargs)\n  \n completed = 0\n while maxtasks is None or (maxtasks and completed < maxtasks):\n  try:\n   task = get()\n  except (EOFError, IOError):\n   debug('worker got EOFError or IOError -- exiting')\n   break\n   \n  if task is None:\n   debug('worker got sentinel -- exiting')\n   break\n   \n  job, i, func, args, kwds = task\n  try:\n   result = (True, func(*args, **kwds))\n  except Exception as e:\n   result = (False, e)\n  try:\n   put((job, i, result))\n  except Exception as e:\n   wrapped = MaybeEncodingError(e, result[1])\n   debug(\"Possible encoding error while sending result: %s\" % (\n   wrapped))\n   put((job, i, (False, wrapped)))\n  completed += 1\n debug('worker exiting after %d tasks' % completed)\n \n \n \n \n \nclass Pool(object):\n \"\"\n Process = Process\n \n def __init__(self, processes=None, initializer=None, initargs=(),\n maxtasksperchild=None):\n  self._setup_queues()\n  self._taskqueue = queue.Queue()\n  self._cache = {}\n  self._state = RUN\n  self._maxtasksperchild = maxtasksperchild\n  self._initializer = initializer\n  self._initargs = initargs\n  \n  if processes is None:\n   try:\n    processes = cpu_count()\n   except NotImplementedError:\n    processes = 1\n  if processes < 1:\n   raise ValueError(\"Number of processes must be at least 1\")\n   \n  if initializer is not None and not callable(initializer):\n   raise TypeError('initializer must be a callable')\n   \n  self._processes = processes\n  self._pool = []\n  self._repopulate_pool()\n  \n  self._worker_handler = threading.Thread(\n  target=Pool._handle_workers,\n  args=(self, )\n  )\n  self._worker_handler.daemon = True\n  self._worker_handler._state = RUN\n  self._worker_handler.start()\n  \n  \n  self._task_handler = threading.Thread(\n  target=Pool._handle_tasks,\n  args=(self._taskqueue, self._quick_put, self._outqueue, self._pool)\n  )\n  self._task_handler.daemon = True\n  self._task_handler._state = RUN\n  self._task_handler.start()\n  \n  self._result_handler = threading.Thread(\n  target=Pool._handle_results,\n  args=(self._outqueue, self._quick_get, self._cache)\n  )\n  self._result_handler.daemon = True\n  self._result_handler._state = RUN\n  self._result_handler.start()\n  \n  self._terminate = Finalize(\n  self, self._terminate_pool,\n  args=(self._taskqueue, self._inqueue, self._outqueue, self._pool,\n  self._worker_handler, self._task_handler,\n  self._result_handler, self._cache),\n  exitpriority=15\n  )\n  \n def _join_exited_workers(self):\n  \"\"\n  cleaned = False\n  for i in reversed(range(len(self._pool))):\n   worker = self._pool[i]\n   if worker.exitcode is not None:\n   \n    debug('cleaning up worker %d' % i)\n    worker.join()\n    cleaned = True\n    del self._pool[i]\n  return cleaned\n  \n def _repopulate_pool(self):\n  \"\"\n  for i in range(self._processes - len(self._pool)):\n   w = self.Process(target=worker,\n   args=(self._inqueue, self._outqueue,\n   self._initializer,\n   self._initargs, self._maxtasksperchild)\n   )\n   self._pool.append(w)\n   w.name = w.name.replace('Process', 'PoolWorker')\n   w.daemon = True\n   w.start()\n   debug('added worker')\n   \n def _maintain_pool(self):\n  \"\"\n  if self._join_exited_workers():\n   self._repopulate_pool()\n   \n def _setup_queues(self):\n  from .queues import SimpleQueue\n  self._inqueue = SimpleQueue()\n  self._outqueue = SimpleQueue()\n  self._quick_put = self._inqueue._writer.send\n  self._quick_get = self._outqueue._reader.recv\n  \n def apply(self, func, args=(), kwds={}):\n  \"\"\n  assert self._state == RUN\n  return self.apply_async(func, args, kwds).get()\n  \n def map(self, func, iterable, chunksize=None):\n  \"\"\n  return self._map_async(func, iterable, mapstar, chunksize).get()\n  \n def starmap(self, func, iterable, chunksize=None):\n  \"\"\n  return self._map_async(func, iterable, starmapstar, chunksize).get()\n  \n def starmap_async(self, func, iterable, chunksize=None, callback=None,\n error_callback=None):\n  \"\"\n  return self._map_async(func, iterable, starmapstar, chunksize,\n  callback, error_callback)\n  \n def imap(self, func, iterable, chunksize=1):\n  \"\"\n  if self._state != RUN:\n   raise ValueError(\"Pool not running\")\n  if chunksize == 1:\n   result = IMapIterator(self._cache)\n   self._taskqueue.put((((result._job, i, func, (x,), {})\n   for i, x in enumerate(iterable)), result._set_length))\n   return result\n  else:\n   assert chunksize > 1\n   task_batches = Pool._get_tasks(func, iterable, chunksize)\n   result = IMapIterator(self._cache)\n   self._taskqueue.put((((result._job, i, mapstar, (x,), {})\n   for i, x in enumerate(task_batches)), result._set_length))\n   return (item for chunk in result for item in chunk)\n   \n def imap_unordered(self, func, iterable, chunksize=1):\n  \"\"\n  if self._state != RUN:\n   raise ValueError(\"Pool not running\")\n  if chunksize == 1:\n   result = IMapUnorderedIterator(self._cache)\n   self._taskqueue.put((((result._job, i, func, (x,), {})\n   for i, x in enumerate(iterable)), result._set_length))\n   return result\n  else:\n   assert chunksize > 1\n   task_batches = Pool._get_tasks(func, iterable, chunksize)\n   result = IMapUnorderedIterator(self._cache)\n   self._taskqueue.put((((result._job, i, mapstar, (x,), {})\n   for i, x in enumerate(task_batches)), result._set_length))\n   return (item for chunk in result for item in chunk)\n   \n def apply_async(self, func, args=(), kwds={}, callback=None,\n error_callback=None):\n  \"\"\n  if self._state != RUN:\n   raise ValueError(\"Pool not running\")\n  result = ApplyResult(self._cache, callback, error_callback)\n  self._taskqueue.put(([(result._job, None, func, args, kwds)], None))\n  return result\n  \n def map_async(self, func, iterable, chunksize=None, callback=None,\n error_callback=None):\n  \"\"\n  return self._map_async(func, iterable, mapstar, chunksize, callback,\n  error_callback)\n  \n def _map_async(self, func, iterable, mapper, chunksize=None, callback=None,\n error_callback=None):\n  \"\"\n  if self._state != RUN:\n   raise ValueError(\"Pool not running\")\n  if not hasattr(iterable, '__len__'):\n   iterable = list(iterable)\n   \n  if chunksize is None:\n   chunksize, extra = divmod(len(iterable), len(self._pool) * 4)\n   if extra:\n    chunksize += 1\n  if len(iterable) == 0:\n   chunksize = 0\n   \n  task_batches = Pool._get_tasks(func, iterable, chunksize)\n  result = MapResult(self._cache, chunksize, len(iterable), callback,\n  error_callback=error_callback)\n  self._taskqueue.put((((result._job, i, mapper, (x,), {})\n  for i, x in enumerate(task_batches)), None))\n  return result\n  \n @staticmethod\n def _handle_workers(pool):\n  thread = threading.current_thread()\n  \n  \n  \n  while thread._state == RUN or (pool._cache and thread._state != TERMINATE):\n   pool._maintain_pool()\n   time.sleep(0.1)\n   \n  pool._taskqueue.put(None)\n  debug('worker handler exiting')\n  \n @staticmethod\n def _handle_tasks(taskqueue, put, outqueue, pool):\n  thread = threading.current_thread()\n  \n  for taskseq, set_length in iter(taskqueue.get, None):\n   i = -1\n   for i, task in enumerate(taskseq):\n    if thread._state:\n     debug('task handler found thread._state != RUN')\n     break\n    try:\n     put(task)\n    except IOError:\n     debug('could not put task on queue')\n     break\n   else:\n    if set_length:\n     debug('doing set_length()')\n     set_length(i+1)\n    continue\n   break\n  else:\n   debug('task handler got sentinel')\n   \n   \n  try:\n  \n   debug('task handler sending sentinel to result handler')\n   outqueue.put(None)\n   \n   \n   debug('task handler sending sentinel to workers')\n   for p in pool:\n    put(None)\n  except IOError:\n   debug('task handler got IOError when sending sentinels')\n   \n  debug('task handler exiting')\n  \n @staticmethod\n def _handle_results(outqueue, get, cache):\n  thread = threading.current_thread()\n  \n  while 1:\n   try:\n    task = get()\n   except (IOError, EOFError):\n    debug('result handler got EOFError/IOError -- exiting')\n    return\n    \n   if thread._state:\n    assert thread._state == TERMINATE\n    debug('result handler found thread._state=TERMINATE')\n    break\n    \n   if task is None:\n    debug('result handler got sentinel')\n    break\n    \n   job, i, obj = task\n   try:\n    cache[job]._set(i, obj)\n   except KeyError:\n    pass\n    \n  while cache and thread._state != TERMINATE:\n   try:\n    task = get()\n   except (IOError, EOFError):\n    debug('result handler got EOFError/IOError -- exiting')\n    return\n    \n   if task is None:\n    debug('result handler ignoring extra sentinel')\n    continue\n   job, i, obj = task\n   try:\n    cache[job]._set(i, obj)\n   except KeyError:\n    pass\n    \n  if hasattr(outqueue, '_reader'):\n   debug('ensuring that outqueue is not full')\n   \n   \n   \n   try:\n    for i in range(10):\n     if not outqueue._reader.poll():\n      break\n     get()\n   except (IOError, EOFError):\n    pass\n    \n  debug('result handler exiting: len(cache)=%s, thread._state=%s',\n  len(cache), thread._state)\n  \n @staticmethod\n def _get_tasks(func, it, size):\n  it = iter(it)\n  while 1:\n   x = tuple(itertools.islice(it, size))\n   if not x:\n    return\n   yield (func, x)\n   \n def __reduce__(self):\n  raise NotImplementedError(\n  'pool objects cannot be passed between processes or pickled'\n  )\n  \n def close(self):\n  debug('closing pool')\n  if self._state == RUN:\n   self._state = CLOSE\n   self._worker_handler._state = CLOSE\n   \n def terminate(self):\n  debug('terminating pool')\n  self._state = TERMINATE\n  self._worker_handler._state = TERMINATE\n  self._terminate()\n  \n def join(self):\n  debug('joining pool')\n  assert self._state in (CLOSE, TERMINATE)\n  self._worker_handler.join()\n  self._task_handler.join()\n  self._result_handler.join()\n  for p in self._pool:\n   p.join()\n   \n @staticmethod\n def _help_stuff_finish(inqueue, task_handler, size):\n \n  debug('removing tasks from inqueue until task handler finished')\n  inqueue._rlock.acquire()\n  while task_handler.is_alive() and inqueue._reader.poll():\n   inqueue._reader.recv()\n   time.sleep(0)\n   \n @classmethod\n def _terminate_pool(cls, taskqueue, inqueue, outqueue, pool,\n worker_handler, task_handler, result_handler, cache):\n \n  debug('finalizing pool')\n  \n  worker_handler._state = TERMINATE\n  task_handler._state = TERMINATE\n  \n  debug('helping task handler/workers to finish')\n  cls._help_stuff_finish(inqueue, task_handler, len(pool))\n  \n  assert result_handler.is_alive() or len(cache) == 0\n  \n  result_handler._state = TERMINATE\n  outqueue.put(None) \n  \n  \n  \n  debug('joining worker handler')\n  if threading.current_thread() is not worker_handler:\n   worker_handler.join()\n   \n   \n  if pool and hasattr(pool[0], 'terminate'):\n   debug('terminating workers')\n   for p in pool:\n    if p.exitcode is None:\n     p.terminate()\n     \n  debug('joining task handler')\n  if threading.current_thread() is not task_handler:\n   task_handler.join()\n   \n  debug('joining result handler')\n  if threading.current_thread() is not result_handler:\n   result_handler.join()\n   \n  if pool and hasattr(pool[0], 'terminate'):\n   debug('joining pool workers')\n   for p in pool:\n    if p.is_alive():\n    \n     debug('cleaning up worker %d' % p.pid)\n     p.join()\n     \n def __enter__(self):\n  return self\n  \n def __exit__(self, exc_type, exc_val, exc_tb):\n  self.terminate()\n  \n  \n  \n  \n  \nclass ApplyResult(object):\n\n def __init__(self, cache, callback, error_callback):\n  self._event = threading.Event()\n  self._job = next(job_counter)\n  self._cache = cache\n  self._callback = callback\n  self._error_callback = error_callback\n  cache[self._job] = self\n  \n def ready(self):\n  return self._event.is_set()\n  \n def successful(self):\n  assert self.ready()\n  return self._success\n  \n def wait(self, timeout=None):\n  self._event.wait(timeout)\n  \n def get(self, timeout=None):\n  self.wait(timeout)\n  if not self.ready():\n   raise TimeoutError\n  if self._success:\n   return self._value\n  else:\n   raise self._value\n   \n def _set(self, i, obj):\n  self._success, self._value = obj\n  if self._callback and self._success:\n   self._callback(self._value)\n  if self._error_callback and not self._success:\n   self._error_callback(self._value)\n  self._event.set()\n  del self._cache[self._job]\n  \nAsyncResult = ApplyResult \n\n\n\n\n\nclass MapResult(ApplyResult):\n\n def __init__(self, cache, chunksize, length, callback, error_callback):\n  ApplyResult.__init__(self, cache, callback,\n  error_callback=error_callback)\n  self._success = True\n  self._value = [None] * length\n  self._chunksize = chunksize\n  if chunksize <= 0:\n   self._number_left = 0\n   self._event.set()\n   del cache[self._job]\n  else:\n   self._number_left = length//chunksize + bool(length % chunksize)\n   \n def _set(self, i, success_result):\n  success, result = success_result\n  if success:\n   self._value[i*self._chunksize:(i+1)*self._chunksize] = result\n   self._number_left -= 1\n   if self._number_left == 0:\n    if self._callback:\n     self._callback(self._value)\n    del self._cache[self._job]\n    self._event.set()\n  else:\n   self._success = False\n   self._value = result\n   if self._error_callback:\n    self._error_callback(self._value)\n   del self._cache[self._job]\n   self._event.set()\n   \n   \n   \n   \n   \nclass IMapIterator(object):\n\n def __init__(self, cache):\n  self._cond = threading.Condition(threading.Lock())\n  self._job = next(job_counter)\n  self._cache = cache\n  self._items = collections.deque()\n  self._index = 0\n  self._length = None\n  self._unsorted = {}\n  cache[self._job] = self\n  \n def __iter__(self):\n  return self\n  \n def next(self, timeout=None):\n  self._cond.acquire()\n  try:\n   try:\n    item = self._items.popleft()\n   except IndexError:\n    if self._index == self._length:\n     raise StopIteration\n    self._cond.wait(timeout)\n    try:\n     item = self._items.popleft()\n    except IndexError:\n     if self._index == self._length:\n      raise StopIteration\n     raise TimeoutError\n  finally:\n   self._cond.release()\n   \n  success, value = item\n  if success:\n   return value\n  raise value\n  \n __next__ = next \n \n def _set(self, i, obj):\n  self._cond.acquire()\n  try:\n   if self._index == i:\n    self._items.append(obj)\n    self._index += 1\n    while self._index in self._unsorted:\n     obj = self._unsorted.pop(self._index)\n     self._items.append(obj)\n     self._index += 1\n    self._cond.notify()\n   else:\n    self._unsorted[i] = obj\n    \n   if self._index == self._length:\n    del self._cache[self._job]\n  finally:\n   self._cond.release()\n   \n def _set_length(self, length):\n  self._cond.acquire()\n  try:\n   self._length = length\n   if self._index == self._length:\n    self._cond.notify()\n    del self._cache[self._job]\n  finally:\n   self._cond.release()\n   \n   \n   \n   \n   \nclass IMapUnorderedIterator(IMapIterator):\n\n def _set(self, i, obj):\n  self._cond.acquire()\n  try:\n   self._items.append(obj)\n   self._index += 1\n   self._cond.notify()\n   if self._index == self._length:\n    del self._cache[self._job]\n  finally:\n   self._cond.release()\n   \n   \n   \n   \n   \nclass ThreadPool(Pool):\n\n from .dummy import Process\n \n def __init__(self, processes=None, initializer=None, initargs=()):\n  Pool.__init__(self, processes, initializer, initargs)\n  \n def _setup_queues(self):\n  self._inqueue = queue.Queue()\n  self._outqueue = queue.Queue()\n  self._quick_put = self._inqueue.put\n  self._quick_get = self._outqueue.get\n  \n @staticmethod\n def _help_stuff_finish(inqueue, task_handler, size):\n \n  inqueue.not_empty.acquire()\n  try:\n   inqueue.queue.clear()\n   inqueue.queue.extend([None] * size)\n   inqueue.not_empty.notify_all()\n  finally:\n   inqueue.not_empty.release()\n"], "ui.widget": [".py", "import random\nfrom browser import doc\n\ndef getMousePosition(e):\n if e is None:\n  e=win.event\n  \n if e.pageX or e.pageY:\n  return {'x': e.pageX, 'y': e.pageY}\n  \n if e.clientX or e.clientY:\n  _posx=e.clientX + doc.body.scrollLeft + doc.documentElement.scrollLeft;\n  _posy=e.clientY + doc.body.scrollTop + doc.documentElement.scrollTop;\n  return {'x': _posx, 'y': _posy}\n  \n return {'x': 0, 'y': 0}\n \nclass Widget:\n def __init__(self, element, type, id=None):\n  self._element=element\n  \n  if id is None:\n   self._element.id='%s_%s' % (type, int(100000*random.random()))\n  else:\n   self._element.id=id\n   \n def get_id(self):\n  return self._element.id\n  \n def attach(self, element_id):\n  \"\"\n  \n  \n  doc[element_id] <= self._element\n  \n def show(self):\n  self._element.display='block'\n  \n def hide(self):\n  self._element.display='none'\n  \nclass DraggableWidget(Widget):\n def __init__(self, element, type, id=None):\n  Widget.__init__(self, element, type, id)\n  \n  def drag(e):\n   self._element.style.top='%spx' % (e.clientY - self._deltaY)\n   self._element.style.left='%spx' % (e.clientX - self._deltaX)\n   \n  def mouseDown(e):\n   self._element.style.position='absolute'\n   self._deltaX=e.clientX - self._element.offsetLeft\n   self._deltaY=e.clientY - self._element.offsetTop\n   doc.bind('mousemove', drag)\n   \n  def mouseUp(e):\n   doc.unbind('mousemove')\n   \n  self._element.bind('mousedown', mouseDown)\n  self._element.bind('mouseup', mouseUp)\n"], "crypto_js.rollups.sha512": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(a,m){var r={},f=r.lib={},g=function(){},l=f.Base={extend:function(a){g.prototype=this;var b=new g;a&&b.mixIn(a);b.hasOwnProperty(\"init\")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\np=f.WordArray=l.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=m?b:4*a.length},toString:function(a){return(a||q).stringify(this)},concat:function(a){var b=this.words,d=a.words,c=this.sigBytes;a=a.sigBytes;this.clamp();if(c%4)for(var j=0;j<a;j++)b[c+j>>>2]|=(d[j>>>2]>>>24-8*(j%4)&255)<<24-8*((c+j)%4);else if(65535<d.length)for(j=0;j<a;j+=4)b[c+j>>>2]=d[j>>>2];else b.push.apply(b,d);this.sigBytes+=a;return this},clamp:function(){var n=this.words,b=this.sigBytes;n[b>>>2]&=4294967295<<\n32-8*(b%4);n.length=a.ceil(b/4)},clone:function(){var a=l.clone.call(this);a.words=this.words.slice(0);return a},random:function(n){for(var b=[],d=0;d<n;d+=4)b.push(4294967296*a.random()|0);return new p.init(b,n)}}),y=r.enc={},q=y.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++){var j=b[c>>>2]>>>24-8*(c%4)&255;d.push((j>>>4).toString(16));d.push((j&15).toString(16))}return d.join(\"\")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c+=2)d[c>>>3]|=parseInt(a.substr(c,\n2),16)<<24-4*(c%8);return new p.init(d,b/2)}},G=y.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++)d.push(String.fromCharCode(b[c>>>2]>>>24-8*(c%4)&255));return d.join(\"\")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c++)d[c>>>2]|=(a.charCodeAt(c)&255)<<24-8*(c%4);return new p.init(d,b)}},fa=y.Utf8={stringify:function(a){try{return decodeURIComponent(escape(G.stringify(a)))}catch(b){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return G.parse(unescape(encodeURIComponent(a)))}},\nh=f.BufferedBlockAlgorithm=l.extend({reset:function(){this._data=new p.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=fa.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(n){var b=this._data,d=b.words,c=b.sigBytes,j=this.blockSize,l=c/(4*j),l=n?a.ceil(l):a.max((l|0)-this._minBufferSize,0);n=l*j;c=a.min(4*n,c);if(n){for(var h=0;h<n;h+=j)this._doProcessBlock(d,h);h=d.splice(0,n);b.sigBytes-=c}return new p.init(h,c)},clone:function(){var a=l.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});f.Hasher=h.extend({cfg:l.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){h.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new ga.HMAC.init(a,\nd)).finalize(b)}}});var ga=r.algo={};return r}(Math);\n(function(a){var m=CryptoJS,r=m.lib,f=r.Base,g=r.WordArray,m=m.x64={};m.Word=f.extend({init:function(a,p){this.high=a;this.low=p}});m.WordArray=f.extend({init:function(l,p){l=this.words=l||[];this.sigBytes=p!=a?p:8*l.length},toX32:function(){for(var a=this.words,p=a.length,f=[],q=0;q<p;q++){var G=a[q];f.push(G.high);f.push(G.low)}return g.create(f,this.sigBytes)},clone:function(){for(var a=f.clone.call(this),p=a.words=this.words.slice(0),g=p.length,q=0;q<g;q++)p[q]=p[q].clone();return a}})})();\n(function(){function a(){return g.create.apply(g,arguments)}for(var m=CryptoJS,r=m.lib.Hasher,f=m.x64,g=f.Word,l=f.WordArray,f=m.algo,p=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),\na(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,\n2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),\na(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,\n3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],y=[],q=0;80>q;q++)y[q]=a();f=f.SHA512=r.extend({_doReset:function(){this._hash=new l.init([new g.init(1779033703,4089235720),new g.init(3144134277,2227873595),new g.init(1013904242,4271175723),new g.init(2773480762,1595750129),new g.init(1359893119,2917565137),new g.init(2600822924,725511199),new g.init(528734635,4215389547),new g.init(1541459225,327033209)])},_doProcessBlock:function(a,f){for(var h=this._hash.words,\ng=h[0],n=h[1],b=h[2],d=h[3],c=h[4],j=h[5],l=h[6],h=h[7],q=g.high,m=g.low,r=n.high,N=n.low,Z=b.high,O=b.low,$=d.high,P=d.low,aa=c.high,Q=c.low,ba=j.high,R=j.low,ca=l.high,S=l.low,da=h.high,T=h.low,v=q,s=m,H=r,E=N,I=Z,F=O,W=$,J=P,w=aa,t=Q,U=ba,K=R,V=ca,L=S,X=da,M=T,x=0;80>x;x++){var B=y[x];if(16>x)var u=B.high=a[f+2*x]|0,e=B.low=a[f+2*x+1]|0;else{var u=y[x-15],e=u.high,z=u.low,u=(e>>>1|z<<31)^(e>>>8|z<<24)^e>>>7,z=(z>>>1|e<<31)^(z>>>8|e<<24)^(z>>>7|e<<25),D=y[x-2],e=D.high,k=D.low,D=(e>>>19|k<<13)^\n(e<<3|k>>>29)^e>>>6,k=(k>>>19|e<<13)^(k<<3|e>>>29)^(k>>>6|e<<26),e=y[x-7],Y=e.high,C=y[x-16],A=C.high,C=C.low,e=z+e.low,u=u+Y+(e>>>0<z>>>0?1:0),e=e+k,u=u+D+(e>>>0<k>>>0?1:0),e=e+C,u=u+A+(e>>>0<C>>>0?1:0);B.high=u;B.low=e}var Y=w&U^~w&V,C=t&K^~t&L,B=v&H^v&I^H&I,ha=s&E^s&F^E&F,z=(v>>>28|s<<4)^(v<<30|s>>>2)^(v<<25|s>>>7),D=(s>>>28|v<<4)^(s<<30|v>>>2)^(s<<25|v>>>7),k=p[x],ia=k.high,ea=k.low,k=M+((t>>>14|w<<18)^(t>>>18|w<<14)^(t<<23|w>>>9)),A=X+((w>>>14|t<<18)^(w>>>18|t<<14)^(w<<23|t>>>9))+(k>>>0<M>>>\n0?1:0),k=k+C,A=A+Y+(k>>>0<C>>>0?1:0),k=k+ea,A=A+ia+(k>>>0<ea>>>0?1:0),k=k+e,A=A+u+(k>>>0<e>>>0?1:0),e=D+ha,B=z+B+(e>>>0<D>>>0?1:0),X=V,M=L,V=U,L=K,U=w,K=t,t=J+k|0,w=W+A+(t>>>0<J>>>0?1:0)|0,W=I,J=F,I=H,F=E,H=v,E=s,s=k+e|0,v=A+B+(s>>>0<k>>>0?1:0)|0}m=g.low=m+s;g.high=q+v+(m>>>0<s>>>0?1:0);N=n.low=N+E;n.high=r+H+(N>>>0<E>>>0?1:0);O=b.low=O+F;b.high=Z+I+(O>>>0<F>>>0?1:0);P=d.low=P+J;d.high=$+W+(P>>>0<J>>>0?1:0);Q=c.low=Q+t;c.high=aa+w+(Q>>>0<t>>>0?1:0);R=j.low=R+K;j.high=ba+U+(R>>>0<K>>>0?1:0);S=l.low=\nS+L;l.high=ca+V+(S>>>0<L>>>0?1:0);T=h.low=T+M;h.high=da+X+(T>>>0<M>>>0?1:0)},_doFinalize:function(){var a=this._data,f=a.words,h=8*this._nDataBytes,g=8*a.sigBytes;f[g>>>5]|=128<<24-g%32;f[(g+128>>>10<<5)+30]=Math.floor(h/4294967296);f[(g+128>>>10<<5)+31]=h;a.sigBytes=4*f.length;this._process();return this._hash.toX32()},clone:function(){var a=r.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});m.SHA512=r._createHelper(f);m.HmacSHA512=r._createHmacHelper(f)})();\n"], "inspect": [".py", "\"\"\n\n\n\n__author__ = ('Ka-Ping Yee <ping@lfw.org>',\n'Yury Selivanov <yselivanov@sprymix.com>')\n\nimport imp\nimport importlib.machinery\nimport itertools\nimport linecache\nimport os\nimport re\nimport sys\nimport tokenize\nimport types\nimport warnings\nimport functools\nimport builtins\nfrom operator import attrgetter\nfrom collections import namedtuple, OrderedDict\n\n\n\n\ntry:\n from dis import COMPILER_FLAG_NAMES as _flag_names\nexcept ImportError:\n CO_OPTIMIZED, CO_NEWLOCALS = 0x1, 0x2\n CO_VARARGS, CO_VARKEYWORDS = 0x4, 0x8\n CO_NESTED, CO_GENERATOR, CO_NOFREE = 0x10, 0x20, 0x40\nelse:\n mod_dict = globals()\n for k, v in _flag_names.items():\n  mod_dict[\"CO_\" + v] = k\n  \n  \nTPFLAGS_IS_ABSTRACT = 1 << 20\n\n\ndef ismodule(object):\n \"\"\n return isinstance(object, types.ModuleType)\n \ndef isclass(object):\n \"\"\n return isinstance(object, type)\n \ndef ismethod(object):\n \"\"\n return isinstance(object, types.MethodType)\n \ndef ismethoddescriptor(object):\n \"\"\n if isclass(object) or ismethod(object) or isfunction(object):\n \n  return False\n tp = type(object)\n return hasattr(tp, \"__get__\") and not hasattr(tp, \"__set__\")\n \ndef isdatadescriptor(object):\n \"\"\n if isclass(object) or ismethod(object) or isfunction(object):\n \n  return False\n tp = type(object)\n return hasattr(tp, \"__set__\") and hasattr(tp, \"__get__\")\n \nif hasattr(types, 'MemberDescriptorType'):\n\n def ismemberdescriptor(object):\n  \"\"\n  return isinstance(object, types.MemberDescriptorType)\nelse:\n\n def ismemberdescriptor(object):\n  \"\"\n  return False\n  \nif hasattr(types, 'GetSetDescriptorType'):\n\n def isgetsetdescriptor(object):\n  \"\"\n  return isinstance(object, types.GetSetDescriptorType)\nelse:\n\n def isgetsetdescriptor(object):\n  \"\"\n  return False\n  \ndef isfunction(object):\n \"\"\n return isinstance(object, types.FunctionType)\n \ndef isgeneratorfunction(object):\n \"\"\n return bool((isfunction(object) or ismethod(object)) and\n object.__code__.co_flags & CO_GENERATOR)\n \ndef isgenerator(object):\n \"\"\n return isinstance(object, types.GeneratorType)\n \ndef istraceback(object):\n \"\"\n return isinstance(object, types.TracebackType)\n \ndef isframe(object):\n \"\"\n return isinstance(object, types.FrameType)\n \ndef iscode(object):\n \"\"\n return isinstance(object, types.CodeType)\n \ndef isbuiltin(object):\n \"\"\n return isinstance(object, types.BuiltinFunctionType)\n \ndef isroutine(object):\n \"\"\n return (isbuiltin(object)\n or isfunction(object)\n or ismethod(object)\n or ismethoddescriptor(object))\n \ndef isabstract(object):\n \"\"\n return bool(isinstance(object, type) and object.__flags__ & TPFLAGS_IS_ABSTRACT)\n \ndef getmembers(object, predicate=None):\n \"\"\n if isclass(object):\n  mro = (object,) + getmro(object)\n else:\n  mro = ()\n results = []\n for key in dir(object):\n \n \n  for base in mro:\n   if key in base.__dict__:\n    value = base.__dict__[key]\n    break\n  else:\n   try:\n    value = getattr(object, key)\n   except AttributeError:\n    continue\n  if not predicate or predicate(value):\n   results.append((key, value))\n results.sort()\n return results\n \nAttribute = namedtuple('Attribute', 'name kind defining_class object')\n\ndef classify_class_attrs(cls):\n \"\"\n \n mro = getmro(cls)\n names = dir(cls)\n result = []\n for name in names:\n \n \n \n \n \n \n  homecls = None\n  for base in (cls,) + mro:\n   if name in base.__dict__:\n    obj = base.__dict__[name]\n    homecls = base\n    break\n  else:\n   obj = getattr(cls, name)\n   homecls = getattr(obj, \"__objclass__\", homecls)\n   \n   \n  if isinstance(obj, staticmethod):\n   kind = \"static method\"\n  elif isinstance(obj, classmethod):\n   kind = \"class method\"\n  elif isinstance(obj, property):\n   kind = \"property\"\n  elif ismethoddescriptor(obj):\n   kind = \"method\"\n  elif isdatadescriptor(obj):\n   kind = \"data\"\n  else:\n   obj_via_getattr = getattr(cls, name)\n   if (isfunction(obj_via_getattr) or\n   ismethoddescriptor(obj_via_getattr)):\n    kind = \"method\"\n   else:\n    kind = \"data\"\n   obj = obj_via_getattr\n   \n  result.append(Attribute(name, kind, homecls, obj))\n  \n return result\n \n \n \ndef getmro(cls):\n \"\"\n return cls.__mro__\n \n \ndef indentsize(line):\n \"\"\n expline = line.expandtabs()\n return len(expline) - len(expline.lstrip())\n \ndef getdoc(object):\n \"\"\n try:\n  doc = object.__doc__\n except AttributeError:\n  return None\n if not isinstance(doc, str):\n  return None\n return cleandoc(doc)\n \ndef cleandoc(doc):\n \"\"\n try:\n  lines = doc.expandtabs().split('\\n')\n except UnicodeError:\n  return None\n else:\n \n  margin = sys.maxsize\n  for line in lines[1:]:\n   content = len(line.lstrip())\n   if content:\n    indent = len(line) - content\n    margin = min(margin, indent)\n    \n  if lines:\n   lines[0] = lines[0].lstrip()\n  if margin < sys.maxsize:\n   for i in range(1, len(lines)): lines[i] = lines[i][margin:]\n   \n  while lines and not lines[-1]:\n   lines.pop()\n  while lines and not lines[0]:\n   lines.pop(0)\n  return '\\n'.join(lines)\n  \ndef getfile(object):\n \"\"\n if ismodule(object):\n  if hasattr(object, '__file__'):\n   return object.__file__\n  raise TypeError('{!r} is a built-in module'.format(object))\n if isclass(object):\n  object = sys.modules.get(object.__module__)\n  if hasattr(object, '__file__'):\n   return object.__file__\n  raise TypeError('{!r} is a built-in class'.format(object))\n if ismethod(object):\n  object = object.__func__\n if isfunction(object):\n  object = object.__code__\n if istraceback(object):\n  object = object.tb_frame\n if isframe(object):\n  object = object.f_code\n if iscode(object):\n  return object.co_filename\n raise TypeError('{!r} is not a module, class, method, '\n 'function, traceback, frame, or code object'.format(object))\n \nModuleInfo = namedtuple('ModuleInfo', 'name suffix mode module_type')\n\ndef getmoduleinfo(path):\n \"\"\n warnings.warn('inspect.getmoduleinfo() is deprecated', DeprecationWarning,\n 2)\n filename = os.path.basename(path)\n suffixes = [(-len(suffix), suffix, mode, mtype)\n for suffix, mode, mtype in imp.get_suffixes()]\n suffixes.sort() \n for neglen, suffix, mode, mtype in suffixes:\n  if filename[neglen:] == suffix:\n   return ModuleInfo(filename[:neglen], suffix, mode, mtype)\n   \ndef getmodulename(path):\n \"\"\n fname = os.path.basename(path)\n \n suffixes = [(-len(suffix), suffix)\n for suffix in importlib.machinery.all_suffixes()]\n suffixes.sort() \n for neglen, suffix in suffixes:\n  if fname.endswith(suffix):\n   return fname[:neglen]\n return None\n \ndef getsourcefile(object):\n \"\"\n filename = getfile(object)\n all_bytecode_suffixes = importlib.machinery.DEBUG_BYTECODE_SUFFIXES[:]\n all_bytecode_suffixes += importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES[:]\n if any(filename.endswith(s) for s in all_bytecode_suffixes):\n  filename = (os.path.splitext(filename)[0] +\n  importlib.machinery.SOURCE_SUFFIXES[0])\n elif any(filename.endswith(s) for s in\n importlib.machinery.EXTENSION_SUFFIXES):\n  return None\n if os.path.exists(filename):\n  return filename\n  \n if hasattr(getmodule(object, filename), '__loader__'):\n  return filename\n  \n if filename in linecache.cache:\n  return filename\n  \ndef getabsfile(object, _filename=None):\n \"\"\n if _filename is None:\n  _filename = getsourcefile(object) or getfile(object)\n return os.path.normcase(os.path.abspath(_filename))\n \nmodulesbyfile = {}\n_filesbymodname = {}\n\ndef getmodule(object, _filename=None):\n \"\"\n if ismodule(object):\n  return object\n if hasattr(object, '__module__'):\n  return sys.modules.get(object.__module__)\n  \n if _filename is not None and _filename in modulesbyfile:\n  return sys.modules.get(modulesbyfile[_filename])\n  \n try:\n  file = getabsfile(object, _filename)\n except TypeError:\n  return None\n if file in modulesbyfile:\n  return sys.modules.get(modulesbyfile[file])\n  \n  \n for modname, module in list(sys.modules.items()):\n  if ismodule(module) and hasattr(module, '__file__'):\n   f = module.__file__\n   if f == _filesbymodname.get(modname, None):\n   \n    continue\n   _filesbymodname[modname] = f\n   f = getabsfile(module)\n   \n   modulesbyfile[f] = modulesbyfile[\n   os.path.realpath(f)] = module.__name__\n if file in modulesbyfile:\n  return sys.modules.get(modulesbyfile[file])\n  \n main = sys.modules['__main__']\n if not hasattr(object, '__name__'):\n  return None\n if hasattr(main, object.__name__):\n  mainobject = getattr(main, object.__name__)\n  if mainobject is object:\n   return main\n   \n builtin = sys.modules['builtins']\n if hasattr(builtin, object.__name__):\n  builtinobject = getattr(builtin, object.__name__)\n  if builtinobject is object:\n   return builtin\n   \ndef findsource(object):\n \"\"\n \n file = getfile(object)\n sourcefile = getsourcefile(object)\n if not sourcefile and file[:1] + file[-1:] != '<>':\n  raise IOError('source code not available')\n file = sourcefile if sourcefile else file\n \n module = getmodule(object, file)\n if module:\n  lines = linecache.getlines(file, module.__dict__)\n else:\n  lines = linecache.getlines(file)\n if not lines:\n  raise IOError('could not get source code')\n  \n if ismodule(object):\n  return lines, 0\n  \n if isclass(object):\n  name = object.__name__\n  pat = re.compile(r'^(\\s*)class\\s*' + name + r'\\b')\n  \n  \n  \n  candidates = []\n  for i in range(len(lines)):\n   match = pat.match(lines[i])\n   if match:\n   \n    if lines[i][0] == 'c':\n     return lines, i\n     \n    candidates.append((match.group(1), i))\n  if candidates:\n  \n  \n   candidates.sort()\n   return lines, candidates[0][1]\n  else:\n   raise IOError('could not find class definition')\n   \n if ismethod(object):\n  object = object.__func__\n if isfunction(object):\n  object = object.__code__\n if istraceback(object):\n  object = object.tb_frame\n if isframe(object):\n  object = object.f_code\n if iscode(object):\n  if not hasattr(object, 'co_firstlineno'):\n   raise IOError('could not find function definition')\n  lnum = object.co_firstlineno - 1\n  pat = re.compile(r'^(\\s*def\\s)|(.*(?<!\\w)lambda(:|\\s))|^(\\s*@)')\n  while lnum > 0:\n   if pat.match(lines[lnum]): break\n   lnum = lnum - 1\n  return lines, lnum\n raise IOError('could not find code object')\n \ndef getcomments(object):\n \"\"\n try:\n  lines, lnum = findsource(object)\n except (IOError, TypeError):\n  return None\n  \n if ismodule(object):\n \n  start = 0\n  if lines and lines[0][:2] == '#!': start = 1\n  while start < len(lines) and lines[start].strip() in ('', '#'):\n   start = start + 1\n  if start < len(lines) and lines[start][:1] == '#':\n   comments = []\n   end = start\n   while end < len(lines) and lines[end][:1] == '#':\n    comments.append(lines[end].expandtabs())\n    end = end + 1\n   return ''.join(comments)\n   \n   \n elif lnum > 0:\n  indent = indentsize(lines[lnum])\n  end = lnum - 1\n  if end >= 0 and lines[end].lstrip()[:1] == '#' and indentsize(lines[end]) == indent:\n   comments = [lines[end].expandtabs().lstrip()]\n   if end > 0:\n    end = end - 1\n    comment = lines[end].expandtabs().lstrip()\n    while comment[:1] == '#' and indentsize(lines[end]) == indent:\n     comments[:0] = [comment]\n     end = end - 1\n     if end < 0: break\n     comment = lines[end].expandtabs().lstrip()\n   while comments and comments[0].strip() == '#':\n    comments[:1] = []\n   while comments and comments[-1].strip() == '#':\n    comments[-1:] = []\n   return ''.join(comments)\n   \nclass EndOfBlock(Exception): pass\n\nclass BlockFinder:\n \"\"\n def __init__(self):\n  self.indent = 0\n  self.islambda = False\n  self.started = False\n  self.passline = False\n  self.last = 1\n  \n def tokeneater(self, type, token, srowcol, erowcol, line):\n  if not self.started:\n  \n   if token in (\"def\", \"class\", \"lambda\"):\n    if token == \"lambda\":\n     self.islambda = True\n    self.started = True\n   self.passline = True \n  elif type == tokenize.NEWLINE:\n   self.passline = False \n   self.last = srowcol[0]\n   if self.islambda: \n    raise EndOfBlock\n  elif self.passline:\n   pass\n  elif type == tokenize.INDENT:\n   self.indent = self.indent + 1\n   self.passline = True\n  elif type == tokenize.DEDENT:\n   self.indent = self.indent - 1\n   \n   \n   \n   if self.indent <= 0:\n    raise EndOfBlock\n  elif self.indent == 0 and type not in (tokenize.COMMENT, tokenize.NL):\n  \n  \n   raise EndOfBlock\n   \ndef getblock(lines):\n \"\"\n blockfinder = BlockFinder()\n try:\n  tokens = tokenize.generate_tokens(iter(lines).__next__)\n  for _token in tokens:\n   blockfinder.tokeneater(*_token)\n except (EndOfBlock, IndentationError):\n  pass\n return lines[:blockfinder.last]\n \ndef getsourcelines(object):\n \"\"\n lines, lnum = findsource(object)\n \n if ismodule(object): return lines, 0\n else: return getblock(lines[lnum:]), lnum + 1\n \ndef getsource(object):\n \"\"\n lines, lnum = getsourcelines(object)\n return ''.join(lines)\n \n \ndef walktree(classes, children, parent):\n \"\"\n results = []\n classes.sort(key=attrgetter('__module__', '__name__'))\n for c in classes:\n  results.append((c, c.__bases__))\n  if c in children:\n   results.append(walktree(children[c], children, c))\n return results\n \ndef getclasstree(classes, unique=False):\n \"\"\n children = {}\n roots = []\n for c in classes:\n  if c.__bases__:\n   for parent in c.__bases__:\n    if not parent in children:\n     children[parent] = []\n    if c not in children[parent]:\n     children[parent].append(c)\n    if unique and parent in classes: break\n  elif c not in roots:\n   roots.append(c)\n for parent in children:\n  if parent not in classes:\n   roots.append(parent)\n return walktree(roots, children, None)\n \n \nArguments = namedtuple('Arguments', 'args, varargs, varkw')\n\ndef getargs(co):\n \"\"\n args, varargs, kwonlyargs, varkw = _getfullargs(co)\n return Arguments(args + kwonlyargs, varargs, varkw)\n \ndef _getfullargs(co):\n \"\"\n \n if not iscode(co):\n  raise TypeError('{!r} is not a code object'.format(co))\n  \n nargs = co.co_argcount\n names = co.co_varnames\n nkwargs = co.co_kwonlyargcount\n args = list(names[:nargs])\n kwonlyargs = list(names[nargs:nargs+nkwargs])\n step = 0\n \n nargs += nkwargs\n varargs = None\n if co.co_flags & CO_VARARGS:\n  varargs = co.co_varnames[nargs]\n  nargs = nargs + 1\n varkw = None\n if co.co_flags & CO_VARKEYWORDS:\n  varkw = co.co_varnames[nargs]\n return args, varargs, kwonlyargs, varkw\n \n \nArgSpec = namedtuple('ArgSpec', 'args varargs keywords defaults')\n\ndef getargspec(func):\n \"\"\n \n args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = getfullargspec(func)\n if kwonlyargs or ann:\n  raise ValueError(\"Function has keyword-only arguments or annotations\"\n  \", use getfullargspec() API which can support them\")\n return ArgSpec(args, varargs, varkw, defaults)\n \nFullArgSpec = namedtuple('FullArgSpec',\n'args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations')\n\ndef getfullargspec(func):\n \"\"\n \n if ismethod(func):\n  func = func.__func__\n if not isfunction(func):\n  raise TypeError('{!r} is not a Python function'.format(func))\n args, varargs, kwonlyargs, varkw = _getfullargs(func.__code__)\n return FullArgSpec(args, varargs, varkw, func.__defaults__,\n kwonlyargs, func.__kwdefaults__, func.__annotations__)\n \nArgInfo = namedtuple('ArgInfo', 'args varargs keywords locals')\n\ndef getargvalues(frame):\n \"\"\n args, varargs, varkw = getargs(frame.f_code)\n return ArgInfo(args, varargs, varkw, frame.f_locals)\n \ndef formatannotation(annotation, base_module=None):\n if isinstance(annotation, type):\n  if annotation.__module__ in ('builtins', base_module):\n   return annotation.__name__\n  return annotation.__module__+'.'+annotation.__name__\n return repr(annotation)\n \ndef formatannotationrelativeto(object):\n module = getattr(object, '__module__', None)\n def _formatannotation(annotation):\n  return formatannotation(annotation, module)\n return _formatannotation\n \n \ndef formatargspec(args, varargs=None, varkw=None, defaults=None,\nkwonlyargs=(), kwonlydefaults={}, annotations={},\nformatarg=str,\nformatvarargs=lambda name: '*' + name,\nformatvarkw=lambda name: '**' + name,\nformatvalue=lambda value: '=' + repr(value),\nformatreturns=lambda text: ' -> ' + text,\nformatannotation=formatannotation):\n \"\"\n def formatargandannotation(arg):\n  result = formatarg(arg)\n  if arg in annotations:\n   result += ': ' + formatannotation(annotations[arg])\n  return result\n specs = []\n if defaults:\n  firstdefault = len(args) - len(defaults)\n for i, arg in enumerate(args):\n  spec = formatargandannotation(arg)\n  if defaults and i >= firstdefault:\n   spec = spec + formatvalue(defaults[i - firstdefault])\n  specs.append(spec)\n if varargs is not None:\n  specs.append(formatvarargs(formatargandannotation(varargs)))\n else:\n  if kwonlyargs:\n   specs.append('*')\n if kwonlyargs:\n  for kwonlyarg in kwonlyargs:\n   spec = formatargandannotation(kwonlyarg)\n   if kwonlydefaults and kwonlyarg in kwonlydefaults:\n    spec += formatvalue(kwonlydefaults[kwonlyarg])\n   specs.append(spec)\n if varkw is not None:\n  specs.append(formatvarkw(formatargandannotation(varkw)))\n result = '(' + ', '.join(specs) + ')'\n if 'return' in annotations:\n  result += formatreturns(formatannotation(annotations['return']))\n return result\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \ndef _missing_arguments(f_name, argnames, pos, values):\n names = [repr(name) for name in argnames if name not in values]\n missing = len(names)\n if missing == 1:\n  s = names[0]\n elif missing == 2:\n  s = \"{} and {}\".format(*names)\n else:\n  tail = \", {} and {}\".format(names[-2:])\n  del names[-2:]\n  s = \", \".join(names) + tail\n raise TypeError(\"%s() missing %i required %s argument%s: %s\" %\n (f_name, missing,\n \"positional\" if pos else \"keyword-only\",\n \"\" if missing == 1 else \"s\", s))\n \ndef _too_many(f_name, args, kwonly, varargs, defcount, given, values):\n atleast = len(args) - defcount\n kwonly_given = len([arg for arg in kwonly if arg in values])\n if varargs:\n  plural = atleast != 1\n  sig = \"at least %d\" % (atleast,)\n elif defcount:\n  plural = True\n  sig = \"from %d to %d\" % (atleast, len(args))\n else:\n  plural = len(args) != 1\n  sig = str(len(args))\n kwonly_sig = \"\"\n if kwonly_given:\n  msg = \" positional argument%s (and %d keyword-only argument%s)\"\n  kwonly_sig = (msg % (\"s\" if given != 1 else \"\", kwonly_given,\n  \"s\" if kwonly_given != 1 else \"\"))\n raise TypeError(\"%s() takes %s positional argument%s but %d%s %s given\" %\n (f_name, sig, \"s\" if plural else \"\", given, kwonly_sig,\n \"was\" if given == 1 and not kwonly_given else \"were\"))\n \ndef getcallargs(func, *positional, **named):\n \"\"\n spec = getfullargspec(func)\n args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, ann = spec\n f_name = func.__name__\n arg2value = {}\n \n \n if ismethod(func) and func.__self__ is not None:\n \n  positional = (func.__self__,) + positional\n num_pos = len(positional)\n num_args = len(args)\n num_defaults = len(defaults) if defaults else 0\n \n n = min(num_pos, num_args)\n for i in range(n):\n  arg2value[args[i]] = positional[i]\n if varargs:\n  arg2value[varargs] = tuple(positional[n:])\n possible_kwargs = set(args + kwonlyargs)\n if varkw:\n  arg2value[varkw] = {}\n for kw, value in named.items():\n  if kw not in possible_kwargs:\n   if not varkw:\n    raise TypeError(\"%s() got an unexpected keyword argument %r\" %\n    (f_name, kw))\n   arg2value[varkw][kw] = value\n   continue\n  if kw in arg2value:\n   raise TypeError(\"%s() got multiple values for argument %r\" %\n   (f_name, kw))\n  arg2value[kw] = value\n if num_pos > num_args and not varargs:\n  _too_many(f_name, args, kwonlyargs, varargs, num_defaults,\n  num_pos, arg2value)\n if num_pos < num_args:\n  req = args[:num_args - num_defaults]\n  for arg in req:\n   if arg not in arg2value:\n    _missing_arguments(f_name, req, True, arg2value)\n  for i, arg in enumerate(args[num_args - num_defaults:]):\n   if arg not in arg2value:\n    arg2value[arg] = defaults[i]\n missing = 0\n for kwarg in kwonlyargs:\n  if kwarg not in arg2value:\n   if kwarg in kwonlydefaults:\n    arg2value[kwarg] = kwonlydefaults[kwarg]\n   else:\n    missing += 1\n if missing:\n  _missing_arguments(f_name, kwonlyargs, False, arg2value)\n return arg2value\n \nClosureVars = namedtuple('ClosureVars', 'nonlocals globals builtins unbound')\n\ndef getclosurevars(func):\n \"\"\n \n if ismethod(func):\n  func = func.__func__\n  \n if not isfunction(func):\n  raise TypeError(\"'{!r}' is not a Python function\".format(func))\n  \n code = func.__code__\n \n \n if func.__closure__ is None:\n  nonlocal_vars = {}\n else:\n  nonlocal_vars = {\n  var : cell.cell_contents\n  for var, cell in zip(code.co_freevars, func.__closure__)\n  }\n  \n  \n  \n global_ns = func.__globals__\n builtin_ns = global_ns.get(\"__builtins__\", builtins.__dict__)\n if ismodule(builtin_ns):\n  builtin_ns = builtin_ns.__dict__\n global_vars = {}\n builtin_vars = {}\n unbound_names = set()\n for name in code.co_names:\n  if name in (\"None\", \"True\", \"False\"):\n  \n  \n   continue\n  try:\n   global_vars[name] = global_ns[name]\n  except KeyError:\n   try:\n    builtin_vars[name] = builtin_ns[name]\n   except KeyError:\n    unbound_names.add(name)\n    \n return ClosureVars(nonlocal_vars, global_vars,\n builtin_vars, unbound_names)\n \n \n \nTraceback = namedtuple('Traceback', 'filename lineno function code_context index')\n\ndef getframeinfo(frame, context=1):\n \"\"\n if istraceback(frame):\n  lineno = frame.tb_lineno\n  frame = frame.tb_frame\n else:\n  lineno = frame.f_lineno\n if not isframe(frame):\n  raise TypeError('{!r} is not a frame or traceback object'.format(frame))\n  \n filename = getsourcefile(frame) or getfile(frame)\n if context > 0:\n  start = lineno - 1 - context//2\n  try:\n   lines, lnum = findsource(frame)\n  except IOError:\n   lines = index = None\n  else:\n   start = max(start, 1)\n   start = max(0, min(start, len(lines) - context))\n   lines = lines[start:start+context]\n   index = lineno - 1 - start\n else:\n  lines = index = None\n  \n return Traceback(filename, lineno, frame.f_code.co_name, lines, index)\n \ndef getlineno(frame):\n \"\"\n \n return frame.f_lineno\n \ndef getouterframes(frame, context=1):\n \"\"\n framelist = []\n while frame:\n  framelist.append((frame,) + getframeinfo(frame, context))\n  frame = frame.f_back\n return framelist\n \ndef getinnerframes(tb, context=1):\n \"\"\n framelist = []\n while tb:\n  framelist.append((tb.tb_frame,) + getframeinfo(tb, context))\n  tb = tb.tb_next\n return framelist\n \ndef currentframe():\n \"\"\n return sys._getframe(1) if hasattr(sys, \"_getframe\") else None\n \ndef stack(context=1):\n \"\"\n return getouterframes(sys._getframe(1), context)\n \ndef trace(context=1):\n \"\"\n return getinnerframes(sys.exc_info()[2], context)\n \n \n \n \n_sentinel = object()\n\ndef _static_getmro(klass):\n return type.__dict__['__mro__'].__get__(klass)\n \ndef _check_instance(obj, attr):\n instance_dict = {}\n try:\n  instance_dict = object.__getattribute__(obj, \"__dict__\")\n except AttributeError:\n  pass\n return dict.get(instance_dict, attr, _sentinel)\n \n \ndef _check_class(klass, attr):\n for entry in _static_getmro(klass):\n  if _shadowed_dict(type(entry)) is _sentinel:\n   try:\n    return entry.__dict__[attr]\n   except KeyError:\n    pass\n return _sentinel\n \ndef _is_type(obj):\n try:\n  _static_getmro(obj)\n except TypeError:\n  return False\n return True\n \ndef _shadowed_dict(klass):\n dict_attr = type.__dict__[\"__dict__\"]\n for entry in _static_getmro(klass):\n  try:\n   class_dict = dict_attr.__get__(entry)[\"__dict__\"]\n  except KeyError:\n   pass\n  else:\n   if not (type(class_dict) is types.GetSetDescriptorType and\n   class_dict.__name__ == \"__dict__\" and\n   class_dict.__objclass__ is entry):\n    return class_dict\n return _sentinel\n \ndef getattr_static(obj, attr, default=_sentinel):\n \"\"\n instance_result = _sentinel\n if not _is_type(obj):\n  klass = type(obj)\n  dict_attr = _shadowed_dict(klass)\n  if (dict_attr is _sentinel or\n  type(dict_attr) is types.MemberDescriptorType):\n   instance_result = _check_instance(obj, attr)\n else:\n  klass = obj\n  \n klass_result = _check_class(klass, attr)\n \n if instance_result is not _sentinel and klass_result is not _sentinel:\n  if (_check_class(type(klass_result), '__get__') is not _sentinel and\n  _check_class(type(klass_result), '__set__') is not _sentinel):\n   return klass_result\n   \n if instance_result is not _sentinel:\n  return instance_result\n if klass_result is not _sentinel:\n  return klass_result\n  \n if obj is klass:\n \n  for entry in _static_getmro(type(klass)):\n   if _shadowed_dict(type(entry)) is _sentinel:\n    try:\n     return entry.__dict__[attr]\n    except KeyError:\n     pass\n if default is not _sentinel:\n  return default\n raise AttributeError(attr)\n \n \n \n \nGEN_CREATED = 'GEN_CREATED'\nGEN_RUNNING = 'GEN_RUNNING'\nGEN_SUSPENDED = 'GEN_SUSPENDED'\nGEN_CLOSED = 'GEN_CLOSED'\n\ndef getgeneratorstate(generator):\n \"\"\n if generator.gi_running:\n  return GEN_RUNNING\n if generator.gi_frame is None:\n  return GEN_CLOSED\n if generator.gi_frame.f_lasti == -1:\n  return GEN_CREATED\n return GEN_SUSPENDED\n \n \ndef getgeneratorlocals(generator):\n \"\"\n \n if not isgenerator(generator):\n  raise TypeError(\"'{!r}' is not a Python generator\".format(generator))\n  \n frame = getattr(generator, \"gi_frame\", None)\n if frame is not None:\n  return generator.gi_frame.f_locals\n else:\n  return {}\n  \n  \n  \n  \n  \n  \n_WrapperDescriptor = type(type.__call__)\n_MethodWrapper = type(all.__call__)\n\n_NonUserDefinedCallables = (_WrapperDescriptor,\n_MethodWrapper,\ntypes.BuiltinFunctionType)\n\n\ndef _get_user_defined_method(cls, method_name):\n try:\n  meth = getattr(cls, method_name)\n except AttributeError:\n  return\n else:\n  if not isinstance(meth, _NonUserDefinedCallables):\n  \n  \n   return meth\n   \n   \ndef signature(obj):\n \"\"\n \n if not callable(obj):\n  raise TypeError('{!r} is not a callable object'.format(obj))\n  \n if isinstance(obj, types.MethodType):\n \n \n  sig = signature(obj.__func__)\n  return sig.replace(parameters=tuple(sig.parameters.values())[1:])\n  \n try:\n  sig = obj.__signature__\n except AttributeError:\n  pass\n else:\n  if sig is not None:\n   return sig\n   \n try:\n \n  wrapped = obj.__wrapped__\n except AttributeError:\n  pass\n else:\n  return signature(wrapped)\n  \n if isinstance(obj, types.FunctionType):\n  return Signature.from_function(obj)\n  \n if isinstance(obj, functools.partial):\n  sig = signature(obj.func)\n  \n  new_params = OrderedDict(sig.parameters.items())\n  \n  partial_args = obj.args or ()\n  partial_keywords = obj.keywords or {}\n  try:\n   ba = sig.bind_partial(*partial_args, **partial_keywords)\n  except TypeError as ex:\n   msg = 'partial object {!r} has incorrect arguments'.format(obj)\n   raise ValueError(msg) from ex\n   \n  for arg_name, arg_value in ba.arguments.items():\n   param = new_params[arg_name]\n   if arg_name in partial_keywords:\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n    new_params[arg_name] = param.replace(default=arg_value,\n    _partial_kwarg=True)\n    \n   elif (param.kind not in (_VAR_KEYWORD, _VAR_POSITIONAL) and\n   not param._partial_kwarg):\n    new_params.pop(arg_name)\n    \n  return sig.replace(parameters=new_params.values())\n  \n sig = None\n if isinstance(obj, type):\n \n \n \n \n  call = _get_user_defined_method(type(obj), '__call__')\n  if call is not None:\n   sig = signature(call)\n  else:\n  \n   new = _get_user_defined_method(obj, '__new__')\n   if new is not None:\n    sig = signature(new)\n   else:\n   \n    init = _get_user_defined_method(obj, '__init__')\n    if init is not None:\n     sig = signature(init)\n elif not isinstance(obj, _NonUserDefinedCallables):\n \n \n \n \n  call = _get_user_defined_method(type(obj), '__call__')\n  if call is not None:\n   sig = signature(call)\n   \n if sig is not None:\n \n \n  return sig.replace(parameters=tuple(sig.parameters.values())[1:])\n  \n if isinstance(obj, types.BuiltinFunctionType):\n \n  msg = 'no signature found for builtin function {!r}'.format(obj)\n  raise ValueError(msg)\n  \n raise ValueError('callable {!r} is not supported by signature'.format(obj))\n \n \nclass _void:\n \"\"\n \n \nclass _empty:\n pass\n \n \nclass _ParameterKind(int):\n def __new__(self, *args, name):\n  obj = int.__new__(self, *args)\n  obj._name = name\n  return obj\n  \n def __str__(self):\n  return self._name\n  \n def __repr__(self):\n  return '<_ParameterKind: {!r}>'.format(self._name)\n  \n  \n_POSITIONAL_ONLY = _ParameterKind(0, name='POSITIONAL_ONLY')\n_POSITIONAL_OR_KEYWORD = _ParameterKind(1, name='POSITIONAL_OR_KEYWORD')\n_VAR_POSITIONAL = _ParameterKind(2, name='VAR_POSITIONAL')\n_KEYWORD_ONLY = _ParameterKind(3, name='KEYWORD_ONLY')\n_VAR_KEYWORD = _ParameterKind(4, name='VAR_KEYWORD')\n\n\nclass Parameter:\n \"\"\n \n __slots__ = ('_name', '_kind', '_default', '_annotation', '_partial_kwarg')\n \n POSITIONAL_ONLY = _POSITIONAL_ONLY\n POSITIONAL_OR_KEYWORD = _POSITIONAL_OR_KEYWORD\n VAR_POSITIONAL = _VAR_POSITIONAL\n KEYWORD_ONLY = _KEYWORD_ONLY\n VAR_KEYWORD = _VAR_KEYWORD\n \n empty = _empty\n \n def __init__(self, name, kind, *, default=_empty, annotation=_empty,\n _partial_kwarg=False):\n \n  if kind not in (_POSITIONAL_ONLY, _POSITIONAL_OR_KEYWORD,\n  _VAR_POSITIONAL, _KEYWORD_ONLY, _VAR_KEYWORD):\n   raise ValueError(\"invalid value for 'Parameter.kind' attribute\")\n  self._kind = kind\n  \n  if default is not _empty:\n   if kind in (_VAR_POSITIONAL, _VAR_KEYWORD):\n    msg = '{} parameters cannot have default values'.format(kind)\n    raise ValueError(msg)\n  self._default = default\n  self._annotation = annotation\n  \n  if name is None:\n   if kind != _POSITIONAL_ONLY:\n    raise ValueError(\"None is not a valid name for a \"\n    \"non-positional-only parameter\")\n   self._name = name\n  else:\n   name = str(name)\n   if kind != _POSITIONAL_ONLY and not name.isidentifier():\n    msg = '{!r} is not a valid parameter name'.format(name)\n    raise ValueError(msg)\n   self._name = name\n   \n  self._partial_kwarg = _partial_kwarg\n  \n @property\n def name(self):\n  return self._name\n  \n @property\n def default(self):\n  return self._default\n  \n @property\n def annotation(self):\n  return self._annotation\n  \n @property\n def kind(self):\n  return self._kind\n  \n def replace(self, *, name=_void, kind=_void, annotation=_void,\n default=_void, _partial_kwarg=_void):\n  \"\"\n  \n  if name is _void:\n   name = self._name\n   \n  if kind is _void:\n   kind = self._kind\n   \n  if annotation is _void:\n   annotation = self._annotation\n   \n  if default is _void:\n   default = self._default\n   \n  if _partial_kwarg is _void:\n   _partial_kwarg = self._partial_kwarg\n   \n  return type(self)(name, kind, default=default, annotation=annotation,\n  _partial_kwarg=_partial_kwarg)\n  \n def __str__(self):\n  kind = self.kind\n  \n  formatted = self._name\n  if kind == _POSITIONAL_ONLY:\n   if formatted is None:\n    formatted = ''\n   formatted = '<{}>'.format(formatted)\n   \n   \n  if self._annotation is not _empty:\n   formatted = '{}:{}'.format(formatted,\n   formatannotation(self._annotation))\n   \n  if self._default is not _empty:\n   formatted = '{}={}'.format(formatted, repr(self._default))\n   \n  if kind == _VAR_POSITIONAL:\n   formatted = '*' + formatted\n  elif kind == _VAR_KEYWORD:\n   formatted = '**' + formatted\n   \n  return formatted\n  \n def __repr__(self):\n  return '<{} at {:#x} {!r}>'.format(self.__class__.__name__,\n  id(self), self.name)\n  \n def __eq__(self, other):\n  return (issubclass(other.__class__, Parameter) and\n  self._name == other._name and\n  self._kind == other._kind and\n  self._default == other._default and\n  self._annotation == other._annotation)\n  \n def __ne__(self, other):\n  return not self.__eq__(other)\n  \n  \nclass BoundArguments:\n \"\"\n \n def __init__(self, signature, arguments):\n  self.arguments = arguments\n  self._signature = signature\n  \n @property\n def signature(self):\n  return self._signature\n  \n @property\n def args(self):\n  args = []\n  for param_name, param in self._signature.parameters.items():\n   if (param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY) or\n   param._partial_kwarg):\n   \n   \n   \n   \n    break\n    \n   try:\n    arg = self.arguments[param_name]\n   except KeyError:\n   \n   \n    break\n   else:\n    if param.kind == _VAR_POSITIONAL:\n    \n     args.extend(arg)\n    else:\n    \n     args.append(arg)\n     \n  return tuple(args)\n  \n @property\n def kwargs(self):\n  kwargs = {}\n  kwargs_started = False\n  for param_name, param in self._signature.parameters.items():\n   if not kwargs_started:\n    if (param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY) or\n    param._partial_kwarg):\n     kwargs_started = True\n    else:\n     if param_name not in self.arguments:\n      kwargs_started = True\n      continue\n      \n   if not kwargs_started:\n    continue\n    \n   try:\n    arg = self.arguments[param_name]\n   except KeyError:\n    pass\n   else:\n    if param.kind == _VAR_KEYWORD:\n    \n     kwargs.update(arg)\n    else:\n    \n     kwargs[param_name] = arg\n     \n  return kwargs\n  \n def __eq__(self, other):\n  return (issubclass(other.__class__, BoundArguments) and\n  self.signature == other.signature and\n  self.arguments == other.arguments)\n  \n def __ne__(self, other):\n  return not self.__eq__(other)\n  \n  \nclass Signature:\n \"\"\n \n __slots__ = ('_return_annotation', '_parameters')\n \n _parameter_cls = Parameter\n _bound_arguments_cls = BoundArguments\n \n empty = _empty\n \n def __init__(self, parameters=None, *, return_annotation=_empty,\n __validate_parameters__=True):\n  \"\"\n  \n  if parameters is None:\n   params = OrderedDict()\n  else:\n   if __validate_parameters__:\n    params = OrderedDict()\n    top_kind = _POSITIONAL_ONLY\n    \n    for idx, param in enumerate(parameters):\n     kind = param.kind\n     if kind < top_kind:\n      msg = 'wrong parameter order: {} before {}'\n      msg = msg.format(top_kind, param.kind)\n      raise ValueError(msg)\n     else:\n      top_kind = kind\n      \n     name = param.name\n     if name is None:\n      name = str(idx)\n      param = param.replace(name=name)\n      \n     if name in params:\n      msg = 'duplicate parameter name: {!r}'.format(name)\n      raise ValueError(msg)\n     params[name] = param\n   else:\n    params = OrderedDict(((param.name, param)\n    for param in parameters))\n    \n  self._parameters = types.MappingProxyType(params)\n  self._return_annotation = return_annotation\n  \n @classmethod\n def from_function(cls, func):\n  \"\"\n  \n  if not isinstance(func, types.FunctionType):\n   raise TypeError('{!r} is not a Python function'.format(func))\n   \n  Parameter = cls._parameter_cls\n  \n  \n  func_code = func.__code__\n  pos_count = func_code.co_argcount\n  arg_names = func_code.co_varnames\n  positional = tuple(arg_names[:pos_count])\n  keyword_only_count = func_code.co_kwonlyargcount\n  keyword_only = arg_names[pos_count:(pos_count + keyword_only_count)]\n  annotations = func.__annotations__\n  defaults = func.__defaults__\n  kwdefaults = func.__kwdefaults__\n  \n  if defaults:\n   pos_default_count = len(defaults)\n  else:\n   pos_default_count = 0\n   \n  parameters = []\n  \n  \n  non_default_count = pos_count - pos_default_count\n  for name in positional[:non_default_count]:\n   annotation = annotations.get(name, _empty)\n   parameters.append(Parameter(name, annotation=annotation,\n   kind=_POSITIONAL_OR_KEYWORD))\n   \n   \n  for offset, name in enumerate(positional[non_default_count:]):\n   annotation = annotations.get(name, _empty)\n   parameters.append(Parameter(name, annotation=annotation,\n   kind=_POSITIONAL_OR_KEYWORD,\n   default=defaults[offset]))\n   \n   \n  if func_code.co_flags & 0x04:\n   name = arg_names[pos_count + keyword_only_count]\n   annotation = annotations.get(name, _empty)\n   parameters.append(Parameter(name, annotation=annotation,\n   kind=_VAR_POSITIONAL))\n   \n   \n  for name in keyword_only:\n   default = _empty\n   if kwdefaults is not None:\n    default = kwdefaults.get(name, _empty)\n    \n   annotation = annotations.get(name, _empty)\n   parameters.append(Parameter(name, annotation=annotation,\n   kind=_KEYWORD_ONLY,\n   default=default))\n   \n  if func_code.co_flags & 0x08:\n   index = pos_count + keyword_only_count\n   if func_code.co_flags & 0x04:\n    index += 1\n    \n   name = arg_names[index]\n   annotation = annotations.get(name, _empty)\n   parameters.append(Parameter(name, annotation=annotation,\n   kind=_VAR_KEYWORD))\n   \n  return cls(parameters,\n  return_annotation=annotations.get('return', _empty),\n  __validate_parameters__=False)\n  \n @property\n def parameters(self):\n  return self._parameters\n  \n @property\n def return_annotation(self):\n  return self._return_annotation\n  \n def replace(self, *, parameters=_void, return_annotation=_void):\n  \"\"\n  \n  if parameters is _void:\n   parameters = self.parameters.values()\n   \n  if return_annotation is _void:\n   return_annotation = self._return_annotation\n   \n  return type(self)(parameters,\n  return_annotation=return_annotation)\n  \n def __eq__(self, other):\n  if (not issubclass(type(other), Signature) or\n  self.return_annotation != other.return_annotation or\n  len(self.parameters) != len(other.parameters)):\n   return False\n   \n  other_positions = {param: idx\n  for idx, param in enumerate(other.parameters.keys())}\n  \n  for idx, (param_name, param) in enumerate(self.parameters.items()):\n   if param.kind == _KEYWORD_ONLY:\n    try:\n     other_param = other.parameters[param_name]\n    except KeyError:\n     return False\n    else:\n     if param != other_param:\n      return False\n   else:\n    try:\n     other_idx = other_positions[param_name]\n    except KeyError:\n     return False\n    else:\n     if (idx != other_idx or\n     param != other.parameters[param_name]):\n      return False\n      \n  return True\n  \n def __ne__(self, other):\n  return not self.__eq__(other)\n  \n def _bind(self, args, kwargs, *, partial=False):\n  \"\"\n  \n  arguments = OrderedDict()\n  \n  parameters = iter(self.parameters.values())\n  parameters_ex = ()\n  arg_vals = iter(args)\n  \n  if partial:\n  \n  \n  \n   for param_name, param in self.parameters.items():\n    if (param._partial_kwarg and param_name not in kwargs):\n    \n     kwargs[param_name] = param.default\n     \n  while True:\n  \n  \n   try:\n    arg_val = next(arg_vals)\n   except StopIteration:\n   \n    try:\n     param = next(parameters)\n    except StopIteration:\n    \n    \n     break\n    else:\n     if param.kind == _VAR_POSITIONAL:\n     \n     \n      break\n     elif param.name in kwargs:\n      if param.kind == _POSITIONAL_ONLY:\n       msg = '{arg!r} parameter is positional only, ' 'but was passed as a keyword'\n       msg = msg.format(arg=param.name)\n       raise TypeError(msg) from None\n      parameters_ex = (param,)\n      break\n     elif (param.kind == _VAR_KEYWORD or\n     param.default is not _empty):\n     \n     \n     \n      parameters_ex = (param,)\n      break\n     else:\n      if partial:\n       parameters_ex = (param,)\n       break\n      else:\n       msg = '{arg!r} parameter lacking default value'\n       msg = msg.format(arg=param.name)\n       raise TypeError(msg) from None\n   else:\n   \n    try:\n     param = next(parameters)\n    except StopIteration:\n     raise TypeError('too many positional arguments') from None\n    else:\n     if param.kind in (_VAR_KEYWORD, _KEYWORD_ONLY):\n     \n     \n      raise TypeError('too many positional arguments')\n      \n     if param.kind == _VAR_POSITIONAL:\n     \n     \n     \n      values = [arg_val]\n      values.extend(arg_vals)\n      arguments[param.name] = tuple(values)\n      break\n      \n     if param.name in kwargs:\n      raise TypeError('multiple values for argument '\n      '{arg!r}'.format(arg=param.name))\n      \n     arguments[param.name] = arg_val\n     \n     \n     \n  kwargs_param = None\n  for param in itertools.chain(parameters_ex, parameters):\n   if param.kind == _POSITIONAL_ONLY:\n   \n   \n   \n    raise TypeError('{arg!r} parameter is positional only, '\n    'but was passed as a keyword'. format(arg=param.name))\n    \n   if param.kind == _VAR_KEYWORD:\n   \n    kwargs_param = param\n    continue\n    \n   param_name = param.name\n   try:\n    arg_val = kwargs.pop(param_name)\n   except KeyError:\n   \n   \n   \n   \n    if (not partial and param.kind != _VAR_POSITIONAL and\n    param.default is _empty):\n     raise TypeError('{arg!r} parameter lacking default value'. format(arg=param_name)) from None\n     \n   else:\n    arguments[param_name] = arg_val\n    \n  if kwargs:\n   if kwargs_param is not None:\n   \n    arguments[kwargs_param.name] = kwargs\n   else:\n    raise TypeError('too many keyword arguments')\n    \n  return self._bound_arguments_cls(self, arguments)\n  \n def bind(__bind_self, *args, **kwargs):\n  \"\"\n  return __bind_self._bind(args, kwargs)\n  \n def bind_partial(__bind_self, *args, **kwargs):\n  \"\"\n  return __bind_self._bind(args, kwargs, partial=True)\n  \n def __str__(self):\n  result = []\n  render_kw_only_separator = True\n  for idx, param in enumerate(self.parameters.values()):\n   formatted = str(param)\n   \n   kind = param.kind\n   if kind == _VAR_POSITIONAL:\n   \n   \n    render_kw_only_separator = False\n   elif kind == _KEYWORD_ONLY and render_kw_only_separator:\n   \n   \n   \n    result.append('*')\n    \n    \n    render_kw_only_separator = False\n    \n   result.append(formatted)\n   \n  rendered = '({})'.format(', '.join(result))\n  \n  if self.return_annotation is not _empty:\n   anno = formatannotation(self.return_annotation)\n   rendered += ' -> {}'.format(anno)\n   \n  return rendered\n"], "browser.markdown": [".py", "\n\ntry:\n import _jsre as re\nexcept:\n import re\n \nimport random\nimport time\n\nletters = 'abcdefghijklmnopqrstuvwxyz'\nletters += letters.upper()+'0123456789'\n\nclass URL:\n def __init__(self,src):\n  elts = src.split(maxsplit=1)\n  self.href = elts[0]\n  self.alt = ''\n  if len(elts)==2:\n   alt = elts[1]\n   if alt[0]=='\"' and alt[-1]=='\"':self.alt=alt[1:-1]\n   elif alt[0]==\"'\" and alt[-1]==\"'\":self.alt=alt[1:-1]\n   elif alt[0]==\"(\" and alt[-1]==\")\":self.alt=alt[1:-1]\n   \nclass CodeBlock:\n def __init__(self,line):\n  self.lines = [line]\n  if line.startswith(\"```\") and len(line)>3:\n   self.info = line[3:]\n  else:\n   self.info = None\n   \n def to_html(self):\n  if self.lines[0].startswith(\"`\"):\n   self.lines.pop(0)\n  res = escape('\\n'.join(self.lines))\n  res = unmark(res)\n  _class = self.info or \"marked\"\n  res = '<pre class=\"%s\">%s</pre>\\n' %(_class, res)\n  return res,[]\n  \nclass HtmlBlock:\n\n def __init__(self, src):\n  self.src = src\n  \n def to_html(self):\n  return self.src\n  \nclass Marked:\n def __init__(self, line=''):\n  self.line = line\n  self.children = []\n  \n def to_html(self):\n  return apply_markdown(self.line)\n  \n  \nrefs = {}\nref_pattern = r\"^\\[(.*)\\]:\\s+(.*)\"\n\ndef mark(src):\n\n global refs\n t0 = time.time()\n refs = {}\n \n \n \n \n \n \n \n \n src = src.replace('\\r\\n','\\n')\n \n \n src = re.sub(r'(.*?)\\n=+\\n', '\\n# \\\\1\\n', src)\n src = re.sub(r'(.*?)\\n-+\\n', '\\n## \\\\1\\n', src) \n \n lines = src.split('\\n')+['']\n \n i = bq = 0\n ul = ol = 0\n \n while i<len(lines):\n \n \n  if lines[i].startswith('>'):\n   nb = 1\n   while nb<len(lines[i]) and lines[i][nb]=='>':\n    nb += 1\n   lines[i] = lines[i][nb:]\n   if nb>bq:\n    lines.insert(i,'<blockquote>'*(nb-bq))\n    i += 1\n    bq = nb\n   elif nb<bq:\n    lines.insert(i,'</blockquote>'*(bq-nb))\n    i += 1\n    bq = nb\n  elif bq>0:\n   lines.insert(i,'</blockquote>'*bq)\n   i += 1\n   bq = 0\n   \n   \n  if lines[i].strip() and lines[i].lstrip()[0] in '-+*' and len(lines[i].lstrip())>1 and lines[i].lstrip()[1]==' ' and (i==0 or ul or not lines[i-1].strip()):\n  \n   nb = 1+len(lines[i])-len(lines[i].lstrip())\n   lines[i] = '<li>'+lines[i][nb:]\n   if nb>ul:\n    lines.insert(i,'<ul>'*(nb-ul))\n    i += 1\n   elif nb<ul:\n    lines.insert(i,'</ul>'*(ul-nb))\n    i += 1\n   ul = nb\n  elif ul and not lines[i].strip():\n   if i<len(lines)-1 and lines[i+1].strip() and not lines[i+1].startswith(' '):\n    nline = lines[i+1].lstrip()\n    if nline[0] in '-+*' and len(nline)>1 and nline[1]==' ':\n     pass\n    else:\n     lines.insert(i,'</ul>'*ul)\n     i += 1\n     ul = 0\n     \n     \n  mo = re.search(r'^(\\d+\\.)',lines[i])\n  if mo:\n   if not ol:\n    lines.insert(i,'<ol>')\n    i += 1\n   lines[i] = '<li>'+lines[i][len(mo.groups()[0]):]\n   ol = 1\n  elif ol and not lines[i].strip() and i<len(lines)-1 and not lines[i+1].startswith(' ') and not re.search(r'^(\\d+\\.)',lines[i+1]):\n   lines.insert(i,'</ol>')\n   i += 1\n   ol = 0\n   \n  i += 1\n  \n if ul:\n  lines.append('</ul>'*ul)\n if ol:\n  lines.append('</ol>'*ol)\n if bq:\n  lines.append('</blockquote>'*bq)\n  \n t1 = time.time()\n \n sections = []\n scripts = []\n section = Marked()\n \n i = 0\n while i<len(lines):\n  line = lines[i]\n  if line.strip() and line.startswith('    '):\n   if isinstance(section,Marked) and section.line:\n    sections.append(section)\n   section = CodeBlock(line[4:])\n   j = i+1\n   while j<len(lines) and lines[j].startswith('    '):\n    section.lines.append(lines[j][4:])\n    j += 1\n   sections.append(section)\n   section = Marked()\n   i = j \n   continue\n   \n  elif line.strip() and line.startswith(\"```\"):\n  \n   if isinstance(section,Marked) and section.line:\n    sections.append(section)\n   section = CodeBlock(line)\n   j = i+1\n   while j<len(lines) and not lines[j].startswith(\"```\"):\n    section.lines.append(lines[j])\n    j += 1\n   sections.append(section)\n   section = Marked()\n   i = j+1\n   continue\n   \n  elif line.lower().startswith('<script'):\n   if isinstance(section,Marked) and section.line:\n    sections.append(section)\n    section = Marked()\n   j = i+1\n   while j<len(lines):\n    if lines[j].lower().startswith('</script>'):\n     scripts.append('\\n'.join(lines[i+1:j]))\n     for k in range(i,j+1):\n      lines[k] = ''\n     break\n    j += 1\n   i = j\n   continue\n   \n   \n  elif line.startswith('#'):\n   level = 1\n   line = lines[i]\n   while level<len(line) and line[level]=='#' and level<=6:\n    level += 1\n   if not line[level+1:].strip():\n    if level==1:\n     i += 1\n     continue\n    else:\n     lines[i] = '<H%s>%s</H%s>\\n' %(level-1,'#',level-1)\n   else:\n    lines[i] = '<H%s>%s</H%s>\\n' %(level,line[level+1:],level)\n    \n  else:\n   mo = re.search(ref_pattern,line)\n   if mo is not None:\n    if isinstance(section,Marked) and section.line:\n     sections.append(section)\n     section = Marked()\n    key = mo.groups()[0]\n    value = URL(mo.groups()[1])\n    refs[key.lower()] = value\n   else:\n    if not line.strip():\n     line = '<p></p>'\n    if section.line:\n     section.line += '\\n'\n    section.line += line\n    \n   i += 1\n t2 = time.time()\n \n if isinstance(section,Marked) and section.line:\n  sections.append(section)\n  \n res = ''\n for section in sections:\n  mk,_scripts = section.to_html()\n  res += mk\n  scripts += _scripts\n  \n return res,scripts\n \ndef escape(czone):\n czone = czone.replace('&','&amp;')\n czone = czone.replace('<','&lt;')\n czone = czone.replace('>','&gt;')\n czone = czone.replace('_','&#95;')\n czone = czone.replace('*','&#42;')\n return czone\n \ndef s_escape(mo):\n\n czone = mo.string[mo.start():mo.end()]\n return escape(czone)\n \ndef unmark(code_zone):\n\n code_zone = code_zone.replace('_','&#95;')\n return code_zone\n \ndef s_unmark(mo):\n\n code_zone = mo.string[mo.start():mo.end()]\n code_zone = code_zone.replace('_','&#95;')\n return code_zone\n \ndef apply_markdown(src):\n\n scripts = []\n key = None\n \n t0 = time.time()\n i = 0\n while i<len(src):\n  if src[i]=='[':\n   start_a = i+1\n   while True:\n    end_a = src.find(']',i)\n    if end_a == -1:\n     break\n    if src[end_a-1]=='\\\\':\n     i = end_a+1\n    else:\n     break\n   if end_a>-1 and src[start_a:end_a].find('\\n')==-1:\n    link = src[start_a:end_a]\n    rest = src[end_a+1:].lstrip()\n    if rest and rest[0]=='(':\n     j = 0\n     while True:\n      end_href = rest.find(')',j)\n      if end_href == -1:\n       break\n      if rest[end_href-1]=='\\\\':\n       j = end_href+1\n      else:\n       break\n     if end_href>-1 and rest[:end_href].find('\\n')==-1:\n      tag = '<a href=\"'+rest[1:end_href]+'\">'+link+'</a>'\n      src = src[:start_a-1]+tag+rest[end_href+1:]\n      i = start_a+len(tag)\n    elif rest and rest[0]=='[':\n     j = 0\n     while True:\n      end_key = rest.find(']',j)\n      if end_key == -1:\n       break\n      if rest[end_key-1]=='\\\\':\n       j = end_key+1\n      else:\n       break\n     if end_key>-1 and rest[:end_key].find('\\n')==-1:\n      if not key:\n       key = link\n      if key.lower() not in refs:\n       raise KeyError('unknown reference %s' %key)\n      url = refs[key.lower()]\n      tag = '<a href=\"'+url+'\">'+link+'</a>'\n      src = src[:start_a-1]+tag+rest[end_key+1:]\n      i = start_a+len(tag)\n      \n  i += 1\n  \n t1 = time.time()\n \n \n \n \n \n rstr = ''.join(random.choice(letters) for i in range(16))\n \n i = 0\n state = None\n start = -1\n data = ''\n tags = []\n while i<len(src):\n  if src[i]=='<':\n   j = i+1\n   while j<len(src):\n    if src[j]=='\"' or src[j]==\"'\":\n     if state==src[j] and src[j-1]!='\\\\':\n      state = None\n      j = start+len(data)+1\n      data = ''\n     elif state==None:\n      state = src[j]\n      start = j\n     else:\n      data += src[j]\n    elif src[j]=='>' and state is None:\n     tags.append(src[i:j+1])\n     src = src[:i]+rstr+src[j+1:]\n     i += len(rstr)\n     break\n    elif state=='\"' or state==\"'\":\n     data += src[j]\n    elif src[j]=='\\n':\n    \n    \n     src = src[:i]+'&lt;'+src[i+1:]\n     j=i+4\n     break\n    j += 1\n  elif src[i]=='`' and i>0 and src[i-1]!='\\\\':\n  \n   j = i+1\n   while j<len(src):\n    if src[j]=='`' and src[j-1]!='\\\\':\n     break\n    j += 1\n   i = j\n  i += 1 \n  \n t2 = time.time()\n \n \n \n code_pattern = r'\\`(.*?)\\`'\n src = re.sub(code_pattern,s_escape,src)\n \n \n src = src.replace(r'\\\\`','&#96;')\n src = src.replace(r'\\_','&#95;')\n src = src.replace(r'\\*','&#42;')\n \n \n strong_patterns = [('STRONG',r'\\*\\*(.*?)\\*\\*'),('B',r'__(.*?)__')]\n for tag,strong_pattern in strong_patterns:\n  src = re.sub(strong_pattern,r'<%s>\\1</%s>' %(tag,tag),src)\n  \n em_patterns = [('EM',r'\\*(.*?)\\*'),('I',r'\\_(.*?)\\_')]\n for tag,em_pattern in em_patterns:\n  src = re.sub(em_pattern,r'<%s>\\1</%s>' %(tag,tag),src)\n  \n  \n code_pattern = r'\\`(.*?)\\`'\n src = re.sub(code_pattern,r'<code>\\1</code>',src)\n \n \n while True:\n  pos = src.rfind(rstr)\n  if pos==-1:\n   break\n  repl = tags.pop()\n  src = src[:pos]+repl+src[pos+len(rstr):]\n  \n src = '<p>'+src+'</p>'\n \n t3 = time.time()\n \n \n return src,scripts\n"], "xml": [".py", "\"\"\n\n\n__all__ = [\"dom\", \"parsers\", \"sax\", \"etree\"]\n", 1], "_testcapi": [".py", "\nCHAR_MAX = 127\n\nCHAR_MIN = -128\n\nDBL_MAX = 1.7976931348623157e+308\n\nDBL_MIN = 2.2250738585072014e-308\n\nFLT_MAX = 3.4028234663852886e+38\n\nFLT_MIN = 1.1754943508222875e-38\n\nINT_MAX = 2147483647\n\nINT_MIN = -2147483648\n\nLLONG_MAX = 9223372036854775807\n\nLLONG_MIN = -9223372036854775808\n\nLONG_MAX = 2147483647\n\nLONG_MIN = -2147483648\n\nPY_SSIZE_T_MAX = 2147483647\n\nPY_SSIZE_T_MIN = -2147483648\n\nSHRT_MAX = 32767\n\nSHRT_MIN = -32768\n\nSIZEOF_PYGC_HEAD = 16\n\nUCHAR_MAX = 255\n\nUINT_MAX = 4294967295\n\nULLONG_MAX = 18446744073709551615\n\nULONG_MAX = 4294967295\n\nUSHRT_MAX = 65535\n\n__loader__ = \"<_frozen_importlib.ExtensionFileLoader object at 0x00C98DD0>\"\n\ndef _pending_threadfunc(*args,**kw):\n pass\n \nclass _test_structmembersType(object):\n pass\n \ndef _test_thread_state(*args,**kw):\n pass\n \ndef argparsing(*args,**kw):\n pass\n \ndef code_newempty(*args,**kw):\n pass\n \ndef codec_incrementaldecoder(*args,**kw):\n pass\n \ndef codec_incrementalencoder(*args,**kw):\n pass\n \ndef crash_no_current_thread(*args,**kw):\n pass\n \nclass error(Exception):\n pass\n \ndef exception_print(*args,**kw):\n pass\n \ndef getargs_B(*args,**kw):\n pass\n \ndef getargs_H(*args,**kw):\n pass\n \ndef getargs_I(*args,**kw):\n pass\n \ndef getargs_K(*args,**kw):\n pass\n \ndef getargs_L(*args,**kw):\n pass\n \ndef getargs_Z(*args,**kw):\n pass\n \ndef getargs_Z_hash(*args,**kw):\n pass\n \ndef getargs_b(*args,**kw):\n pass\n \ndef getargs_c(*args,**kw):\n pass\n \ndef getargs_h(*args,**kw):\n pass\n \ndef getargs_i(*args,**kw):\n pass\n \ndef getargs_k(*args,**kw):\n pass\n \ndef getargs_keyword_only(*args,**kw):\n pass\n \ndef getargs_keywords(*args,**kw):\n pass\n \ndef getargs_l(*args,**kw):\n pass\n \ndef getargs_n(*args,**kw):\n pass\n \ndef getargs_p(*args,**kw):\n pass\n \ndef getargs_s(*args,**kw):\n pass\n \ndef getargs_s_hash(*args,**kw):\n pass\n \ndef getargs_s_star(*args,**kw):\n pass\n \ndef getargs_tuple(*args,**kw):\n pass\n \ndef getargs_u(*args,**kw):\n pass\n \ndef getargs_u_hash(*args,**kw):\n pass\n \ndef getargs_w_star(*args,**kw):\n pass\n \ndef getargs_y(*args,**kw):\n pass\n \ndef getargs_y_hash(*args,**kw):\n pass\n \ndef getargs_y_star(*args,**kw):\n pass\n \ndef getargs_z(*args,**kw):\n pass\n \ndef getargs_z_hash(*args,**kw):\n pass\n \ndef getargs_z_star(*args,**kw):\n pass\n \nclass instancemethod(object):\n pass\n \ndef make_exception_with_doc(*args,**kw):\n pass\n \ndef make_memoryview_from_NULL_pointer(*args,**kw):\n pass\n \ndef parse_tuple_and_keywords(*args,**kw):\n pass\n \ndef pytime_object_to_time_t(*args,**kw):\n pass\n \ndef pytime_object_to_timespec(*args,**kw):\n pass\n \ndef pytime_object_to_timeval(*args,**kw):\n pass\n \ndef raise_exception(*args,**kw):\n pass\n \ndef raise_memoryerror(*args,**kw):\n pass\n \ndef run_in_subinterp(*args,**kw):\n pass\n \ndef set_exc_info(*args,**kw):\n pass\n \ndef test_L_code(*args,**kw):\n pass\n \ndef test_Z_code(*args,**kw):\n pass\n \ndef test_capsule(*args,**kw):\n pass\n \ndef test_config(*args,**kw):\n pass\n \ndef test_datetime_capi(*args,**kw):\n pass\n \ndef test_dict_iteration(*args,**kw):\n pass\n \ndef test_empty_argparse(*args,**kw):\n pass\n \ndef test_k_code(*args,**kw):\n pass\n \ndef test_lazy_hash_inheritance(*args,**kw):\n pass\n \ndef test_list_api(*args,**kw):\n pass\n \ndef test_long_and_overflow(*args,**kw):\n pass\n \ndef test_long_api(*args,**kw):\n pass\n \ndef test_long_as_double(*args,**kw):\n pass\n \ndef test_long_as_size_t(*args,**kw):\n pass\n \ndef test_long_long_and_overflow(*args,**kw):\n pass\n \ndef test_long_numbits(*args,**kw):\n pass\n \ndef test_longlong_api(*args,**kw):\n pass\n \ndef test_null_strings(*args,**kw):\n pass\n \ndef test_s_code(*args,**kw):\n pass\n \ndef test_string_from_format(*args,**kw):\n pass\n \ndef test_string_to_double(*args,**kw):\n pass\n \ndef test_u_code(*args,**kw):\n pass\n \ndef test_unicode_compare_with_ascii(*args,**kw):\n pass\n \ndef test_widechar(*args,**kw):\n pass\n \ndef test_with_docstring(*args,**kw):\n \"\"\n pass\n \ndef traceback_print(*args,**kw):\n pass\n \ndef unicode_aswidechar(*args,**kw):\n pass\n \ndef unicode_aswidecharstring(*args,**kw):\n pass\n \ndef unicode_encodedecimal(*args,**kw):\n pass\n \ndef unicode_transformdecimaltoascii(*args,**kw):\n pass\n"], "codecs": [".py", "\"\"\n\nimport builtins, sys\n\n\n\ntry:\n from _codecs import *\nexcept ImportError as why:\n raise SystemError('Failed to load the builtin codecs: %s' % why)\n \n__all__ = [\"register\", \"lookup\", \"open\", \"EncodedFile\", \"BOM\", \"BOM_BE\",\n\"BOM_LE\", \"BOM32_BE\", \"BOM32_LE\", \"BOM64_BE\", \"BOM64_LE\",\n\"BOM_UTF8\", \"BOM_UTF16\", \"BOM_UTF16_LE\", \"BOM_UTF16_BE\",\n\"BOM_UTF32\", \"BOM_UTF32_LE\", \"BOM_UTF32_BE\",\n\"strict_errors\", \"ignore_errors\", \"replace_errors\",\n\"xmlcharrefreplace_errors\",\n\"register_error\", \"lookup_error\"]\n\n\n\n\n\n\n\n\n\n\nBOM_UTF8 = b'\\xef\\xbb\\xbf'\n\n\nBOM_LE = BOM_UTF16_LE = b'\\xff\\xfe'\n\n\nBOM_BE = BOM_UTF16_BE = b'\\xfe\\xff'\n\n\nBOM_UTF32_LE = b'\\xff\\xfe\\x00\\x00'\n\n\nBOM_UTF32_BE = b'\\x00\\x00\\xfe\\xff'\n\nif sys.byteorder == 'little':\n\n\n BOM = BOM_UTF16 = BOM_UTF16_LE\n \n \n BOM_UTF32 = BOM_UTF32_LE\n \nelse:\n\n\n BOM = BOM_UTF16 = BOM_UTF16_BE\n \n \n BOM_UTF32 = BOM_UTF32_BE\n \n \nBOM32_LE = BOM_UTF16_LE\nBOM32_BE = BOM_UTF16_BE\nBOM64_LE = BOM_UTF32_LE\nBOM64_BE = BOM_UTF32_BE\n\n\n\n\nclass CodecInfo(tuple):\n\n def __new__(cls, encode, decode, streamreader=None, streamwriter=None,\n incrementalencoder=None, incrementaldecoder=None, name=None):\n  self = tuple.__new__(cls, (encode, decode, streamreader, streamwriter))\n  self.name = name\n  self.encode = encode\n  self.decode = decode\n  self.incrementalencoder = incrementalencoder\n  self.incrementaldecoder = incrementaldecoder\n  self.streamwriter = streamwriter\n  self.streamreader = streamreader\n  return self\n  \n def __repr__(self):\n  return \"<%s.%s object for encoding %s at 0x%x>\" % (self.__class__.__module__, self.__class__.__name__,\n  self.name, id(self))\n  \nclass Codec:\n\n \"\"\n def encode(self, input, errors='strict'):\n \n  \"\"\n  raise NotImplementedError\n  \n def decode(self, input, errors='strict'):\n \n  \"\"\n  raise NotImplementedError\n  \nclass IncrementalEncoder(object):\n \"\"\n def __init__(self, errors='strict'):\n  \"\"\n  self.errors = errors\n  self.buffer = \"\"\n  \n def encode(self, input, final=False):\n  \"\"\n  raise NotImplementedError\n  \n def reset(self):\n  \"\"\n  \n def getstate(self):\n  \"\"\n  return 0\n  \n def setstate(self, state):\n  \"\"\n  \nclass BufferedIncrementalEncoder(IncrementalEncoder):\n \"\"\n def __init__(self, errors='strict'):\n  IncrementalEncoder.__init__(self, errors)\n  \n  self.buffer = \"\"\n  \n def _buffer_encode(self, input, errors, final):\n \n \n  raise NotImplementedError\n  \n def encode(self, input, final=False):\n \n  data = self.buffer + input\n  (result, consumed) = self._buffer_encode(data, self.errors, final)\n  \n  self.buffer = data[consumed:]\n  return result\n  \n def reset(self):\n  IncrementalEncoder.reset(self)\n  self.buffer = \"\"\n  \n def getstate(self):\n  return self.buffer or 0\n  \n def setstate(self, state):\n  self.buffer = state or \"\"\n  \nclass IncrementalDecoder(object):\n \"\"\n def __init__(self, errors='strict'):\n  \"\"\n  self.errors = errors\n  \n def decode(self, input, final=False):\n  \"\"\n  raise NotImplementedError\n  \n def reset(self):\n  \"\"\n  \n def getstate(self):\n  \"\"\n  return (b\"\", 0)\n  \n def setstate(self, state):\n  \"\"\n  \nclass BufferedIncrementalDecoder(IncrementalDecoder):\n \"\"\n def __init__(self, errors='strict'):\n  IncrementalDecoder.__init__(self, errors)\n  \n  self.buffer = b\"\"\n  \n def _buffer_decode(self, input, errors, final):\n \n \n  raise NotImplementedError\n  \n def decode(self, input, final=False):\n \n  data = self.buffer + input\n  (result, consumed) = self._buffer_decode(data, self.errors, final)\n  \n  self.buffer = data[consumed:]\n  return result\n  \n def reset(self):\n  IncrementalDecoder.reset(self)\n  self.buffer = b\"\"\n  \n def getstate(self):\n \n  return (self.buffer, 0)\n  \n def setstate(self, state):\n \n  self.buffer = state[0]\n  \n  \n  \n  \n  \n  \n  \n  \nclass StreamWriter(Codec):\n\n def __init__(self, stream, errors='strict'):\n \n  \"\"\n  self.stream = stream\n  self.errors = errors\n  \n def write(self, object):\n \n  \"\"\n  data, consumed = self.encode(object, self.errors)\n  self.stream.write(data)\n  \n def writelines(self, list):\n \n  \"\"\n  self.write(''.join(list))\n  \n def reset(self):\n \n  \"\"\n  pass\n  \n def seek(self, offset, whence=0):\n  self.stream.seek(offset, whence)\n  if whence == 0 and offset == 0:\n   self.reset()\n   \n def __getattr__(self, name,\n getattr=getattr):\n \n  \"\"\n  return getattr(self.stream, name)\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self, type, value, tb):\n  self.stream.close()\n  \n  \n  \nclass StreamReader(Codec):\n\n charbuffertype = str\n \n def __init__(self, stream, errors='strict'):\n \n  \"\"\n  self.stream = stream\n  self.errors = errors\n  self.bytebuffer = b\"\"\n  self._empty_charbuffer = self.charbuffertype()\n  self.charbuffer = self._empty_charbuffer\n  self.linebuffer = None\n  \n def decode(self, input, errors='strict'):\n  raise NotImplementedError\n  \n def read(self, size=-1, chars=-1, firstline=False):\n \n  \"\"\n  \n  if self.linebuffer:\n   self.charbuffer = self._empty_charbuffer.join(self.linebuffer)\n   self.linebuffer = None\n   \n   \n  while True:\n  \n   if chars < 0:\n    if size < 0:\n     if self.charbuffer:\n      break\n    elif len(self.charbuffer) >= size:\n     break\n   else:\n    if len(self.charbuffer) >= chars:\n     break\n     \n   if size < 0:\n    newdata = self.stream.read()\n   else:\n    newdata = self.stream.read(size)\n    \n   data = self.bytebuffer + newdata\n   try:\n    newchars, decodedbytes = self.decode(data, self.errors)\n   except UnicodeDecodeError as exc:\n    if firstline:\n     newchars, decodedbytes = self.decode(data[:exc.start], self.errors)\n     lines = newchars.splitlines(keepends=True)\n     if len(lines)<=1:\n      raise\n    else:\n     raise\n     \n   self.bytebuffer = data[decodedbytes:]\n   \n   self.charbuffer += newchars\n   \n   if not newdata:\n    break\n  if chars < 0:\n  \n   result = self.charbuffer\n   self.charbuffer = self._empty_charbuffer\n  else:\n  \n   result = self.charbuffer[:chars]\n   self.charbuffer = self.charbuffer[chars:]\n  return result\n  \n def readline(self, size=None, keepends=True):\n \n  \"\"\n  \n  \n  if self.linebuffer:\n   line = self.linebuffer[0]\n   del self.linebuffer[0]\n   if len(self.linebuffer) == 1:\n   \n   \n    self.charbuffer = self.linebuffer[0]\n    self.linebuffer = None\n   if not keepends:\n    line = line.splitlines(keepends=False)[0]\n   return line\n   \n  readsize = size or 72\n  line = self._empty_charbuffer\n  \n  while True:\n   data = self.read(readsize, firstline=True)\n   if data:\n   \n   \n   \n    if (isinstance(data, str) and data.endswith(\"\\r\")) or (isinstance(data, bytes) and data.endswith(b\"\\r\")):\n     data += self.read(size=1, chars=1)\n     \n   line += data\n   lines = line.splitlines(keepends=True)\n   if lines:\n    if len(lines) > 1:\n    \n    \n     line = lines[0]\n     del lines[0]\n     if len(lines) > 1:\n     \n      lines[-1] += self.charbuffer\n      self.linebuffer = lines\n      self.charbuffer = None\n     else:\n     \n      self.charbuffer = lines[0] + self.charbuffer\n     if not keepends:\n      line = line.splitlines(keepends=False)[0]\n     break\n    line0withend = lines[0]\n    line0withoutend = lines[0].splitlines(keepends=False)[0]\n    if line0withend != line0withoutend: \n    \n     self.charbuffer = self._empty_charbuffer.join(lines[1:]) + self.charbuffer\n     if keepends:\n      line = line0withend\n     else:\n      line = line0withoutend\n     break\n     \n   if not data or size is not None:\n    if line and not keepends:\n     line = line.splitlines(keepends=False)[0]\n    break\n   if readsize < 8000:\n    readsize *= 2\n  return line\n  \n def readlines(self, sizehint=None, keepends=True):\n \n  \"\"\n  data = self.read()\n  return data.splitlines(keepends)\n  \n def reset(self):\n \n  \"\"\n  self.bytebuffer = b\"\"\n  self.charbuffer = self._empty_charbuffer\n  self.linebuffer = None\n  \n def seek(self, offset, whence=0):\n  \"\"\n  self.stream.seek(offset, whence)\n  self.reset()\n  \n def __next__(self):\n \n  \"\"\n  line = self.readline()\n  if line:\n   return line\n  raise StopIteration\n  \n def __iter__(self):\n  return self\n  \n def __getattr__(self, name,\n getattr=getattr):\n \n  \"\"\n  return getattr(self.stream, name)\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self, type, value, tb):\n  self.stream.close()\n  \n  \n  \nclass StreamReaderWriter:\n\n \"\"\n \n encoding = 'unknown'\n \n def __init__(self, stream, Reader, Writer, errors='strict'):\n \n  \"\"\n  self.stream = stream\n  self.reader = Reader(stream, errors)\n  self.writer = Writer(stream, errors)\n  self.errors = errors\n  \n def read(self, size=-1):\n \n  return self.reader.read(size)\n  \n def readline(self, size=None):\n \n  return self.reader.readline(size)\n  \n def readlines(self, sizehint=None):\n \n  return self.reader.readlines(sizehint)\n  \n def __next__(self):\n \n  \"\"\n  return next(self.reader)\n  \n def __iter__(self):\n  return self\n  \n def write(self, data):\n \n  return self.writer.write(data)\n  \n def writelines(self, list):\n \n  return self.writer.writelines(list)\n  \n def reset(self):\n \n  self.reader.reset()\n  self.writer.reset()\n  \n def seek(self, offset, whence=0):\n  self.stream.seek(offset, whence)\n  self.reader.reset()\n  if whence == 0 and offset == 0:\n   self.writer.reset()\n   \n def __getattr__(self, name,\n getattr=getattr):\n \n  \"\"\n  return getattr(self.stream, name)\n  \n  \n  \n def __enter__(self):\n  return self\n  \n def __exit__(self, type, value, tb):\n  self.stream.close()\n  \n  \n  \nclass StreamRecoder:\n\n \"\"\n \n data_encoding = 'unknown'\n file_encoding = 'unknown'\n \n def __init__(self, stream, encode, decode, Reader, Writer,\n errors='strict'):\n \n  \"\"\n  self.stream = stream\n  self.encode = encode\n  self.decode = decode\n  self.reader = Reader(stream, errors)\n  self.writer = Writer(stream, errors)\n  self.errors = errors\n  \n def read(self, size=-1):\n \n  data = self.reader.read(size)\n  data, bytesencoded = self.encode(data, self.errors)\n  return data\n  \n def readline(self, size=None):\n \n  if size is None:\n   data = self.reader.readline()\n  else:\n   data = self.reader.readline(size)\n  data, bytesencoded = self.encode(data, self.errors)\n  return data\n  \n def readlines(self, sizehint=None):\n \n  data = self.reader.read()\n  data, bytesencoded = self.encode(data, self.errors)\n  return data.splitlines(keepends=True)\n  \n def __next__(self):\n \n  \"\"\n  data = next(self.reader)\n  data, bytesencoded = self.encode(data, self.errors)\n  return data\n  \n def __iter__(self):\n  return self\n  \n def write(self, data):\n \n  data, bytesdecoded = self.decode(data, self.errors)\n  return self.writer.write(data)\n  \n def writelines(self, list):\n \n  data = ''.join(list)\n  data, bytesdecoded = self.decode(data, self.errors)\n  return self.writer.write(data)\n  \n def reset(self):\n \n  self.reader.reset()\n  self.writer.reset()\n  \n def __getattr__(self, name,\n getattr=getattr):\n \n  \"\"\n  return getattr(self.stream, name)\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self, type, value, tb):\n  self.stream.close()\n  \n  \n  \ndef open(filename, mode='rb', encoding=None, errors='strict', buffering=1):\n\n \"\"\n if encoding is not None and 'b' not in mode:\n \n  mode = mode + 'b'\n file = builtins.open(filename, mode, buffering)\n if encoding is None:\n  return file\n info = lookup(encoding)\n srw = StreamReaderWriter(file, info.streamreader, info.streamwriter, errors)\n \n srw.encoding = encoding\n return srw\n \ndef EncodedFile(file, data_encoding, file_encoding=None, errors='strict'):\n\n \"\"\n if file_encoding is None:\n  file_encoding = data_encoding\n data_info = lookup(data_encoding)\n file_info = lookup(file_encoding)\n sr = StreamRecoder(file, data_info.encode, data_info.decode,\n file_info.streamreader, file_info.streamwriter, errors)\n \n sr.data_encoding = data_encoding\n sr.file_encoding = file_encoding\n return sr\n \n \n \ndef getencoder(encoding):\n\n \"\"\n return lookup(encoding).encode\n \ndef getdecoder(encoding):\n\n \"\"\n return lookup(encoding).decode\n \ndef getincrementalencoder(encoding):\n\n \"\"\n encoder = lookup(encoding).incrementalencoder\n if encoder is None:\n  raise LookupError(encoding)\n return encoder\n \ndef getincrementaldecoder(encoding):\n\n \"\"\n decoder = lookup(encoding).incrementaldecoder\n if decoder is None:\n  raise LookupError(encoding)\n return decoder\n \ndef getreader(encoding):\n\n \"\"\n return lookup(encoding).streamreader\n \ndef getwriter(encoding):\n\n \"\"\n return lookup(encoding).streamwriter\n \ndef iterencode(iterator, encoding, errors='strict', **kwargs):\n \"\"\n encoder = getincrementalencoder(encoding)(errors, **kwargs)\n for input in iterator:\n  output = encoder.encode(input)\n  if output:\n   yield output\n output = encoder.encode(\"\", True)\n if output:\n  yield output\n  \ndef iterdecode(iterator, encoding, errors='strict', **kwargs):\n \"\"\n decoder = getincrementaldecoder(encoding)(errors, **kwargs)\n for input in iterator:\n  output = decoder.decode(input)\n  if output:\n   yield output\n output = decoder.decode(b\"\", True)\n if output:\n  yield output\n  \n  \n  \ndef make_identity_dict(rng):\n\n \"\"\n return {i:i for i in rng}\n \ndef make_encoding_map(decoding_map):\n\n \"\"\n m = {}\n for k,v in decoding_map.items():\n  if not v in m:\n   m[v] = k\n  else:\n   m[v] = None\n return m\n \n \n \ntry:\n strict_errors = lookup_error(\"strict\")\n ignore_errors = lookup_error(\"ignore\")\n replace_errors = lookup_error(\"replace\")\n xmlcharrefreplace_errors = lookup_error(\"xmlcharrefreplace\")\n backslashreplace_errors = lookup_error(\"backslashreplace\")\nexcept LookupError:\n\n strict_errors = None\n ignore_errors = None\n replace_errors = None\n xmlcharrefreplace_errors = None\n backslashreplace_errors = None\n \n \n \n_false = 0\nif _false:\n import encodings\n \n \n \nif __name__ == '__main__':\n\n\n sys.stdout = EncodedFile(sys.stdout, 'latin-1', 'utf-8')\n \n \n sys.stdin = EncodedFile(sys.stdin, 'utf-8', 'latin-1')\n"], "xml.dom.domreg": [".py", "\"\"\n\n\n\n\n\nwell_known_implementations = {\n'minidom':'xml.dom.minidom',\n'4DOM': 'xml.dom.DOMImplementation',\n}\n\n\n\n\nregistered = {}\n\ndef registerDOMImplementation(name, factory):\n \"\"\n \n registered[name] = factory\n \ndef _good_enough(dom, features):\n \"\"\n for f,v in features:\n  if not dom.hasFeature(f,v):\n   return 0\n return 1\n \ndef getDOMImplementation(name=None, features=()):\n \"\"\n \n import os\n creator = None\n mod = well_known_implementations.get(name)\n if mod:\n  mod = __import__(mod, {}, {}, ['getDOMImplementation'])\n  return mod.getDOMImplementation()\n elif name:\n  return registered[name]()\n elif \"PYTHON_DOM\" in os.environ:\n  return getDOMImplementation(name = os.environ[\"PYTHON_DOM\"])\n  \n  \n  \n if isinstance(features, str):\n  features = _parse_feature_string(features)\n for creator in registered.values():\n  dom = creator()\n  if _good_enough(dom, features):\n   return dom\n   \n for creator in well_known_implementations.keys():\n  try:\n   dom = getDOMImplementation(name = creator)\n  except Exception: \n   continue\n  if _good_enough(dom, features):\n   return dom\n   \n raise ImportError(\"no suitable DOM implementation found\")\n \ndef _parse_feature_string(s):\n features = []\n parts = s.split()\n i = 0\n length = len(parts)\n while i < length:\n  feature = parts[i]\n  if feature[0] in \"0123456789\":\n   raise ValueError(\"bad feature name: %r\" % (feature,))\n  i = i + 1\n  version = None\n  if i < length:\n   v = parts[i]\n   if v[0] in \"0123456789\":\n    i = i + 1\n    version = v\n  features.append((feature, version))\n return tuple(features)\n"], "browser.ajax": [".py", "from _ajax import *"], "long_int1.decimal.min": [".js", "/*! decimal.js v4.0.1 https://github.com/MikeMcl/decimal.js/LICENCE */\n(function(n){\"use strict\";function l(n){for(var t,e,f=1,r=n.length,u=n[0]+\"\";f<r;f++){for(t=n[f]+\"\",e=i-t.length;e--;)t=\"0\"+t;u+=t}for(r=u.length;u.charCodeAt(--r)===48;);return u.slice(0,r+1||1)}function g(n,t,r,u){for(var s,c,f,o=1,e=n[0];e>=10;e/=10,o++);return e=t-o,e<0?(e+=i,s=0):(s=Math.ceil((e+1)/i),e%=i),o=h(10,i-e),f=n[s]%o|0,u==null?e<3?(e==0?f=f/100|0:e==1&&(f=f/10|0),c=r<4&&f==99999||r>3&&f==49999||f==5e4||f==0):c=(r<4&&f+1==o||r>3&&f+1==o/2)&&(n[s+1]/o/100|0)==h(10,e-2)-1||(f==o/2||f==0)&&(n[s+1]/o/100|0)==0:e<4?(e==0?f=f/1e3|0:e==1?f=f/100|0:e==2&&(f=f/10|0),c=(u||r<4)&&f==9999||!u&&r>3&&f==4999):c=((u||r<4)&&f+1==o||!u&&r>3&&f+1==o/2)&&(n[s+1]/o/1e3|0)==h(10,e-3)-1,c}function k(n,t,i){var r=n.constructor;return t==null||((c=t<0||t>8)||t!==0&&(r.errors?parseInt:parseFloat)(t)!=t)&&!f(r,\"rounding mode\",t,i,0)?r.rounding:t|0}function d(n,t,i,r){var u=n.constructor;return!(c=t<(r||0)||t>=et+1)&&(t===0||(u.errors?parseInt:parseFloat)(t)==t)||f(u,\"argument\",t,i,0)}function rt(n,t){var c,v,k,a,i,f,o,y=0,d=0,p=0,u=n.constructor,w=u.ONE,nt=u.rounding,b=u.precision;if(!n.c||!n.c[0]||n.e>17)return new u(n.c?n.c[0]?n.s<0?0:1/0:w:n.s?n.s<0?0:n:NaN);for(t==null?(e=!1,i=b):i=t,o=new u(.03125);n.e>-2;)n=n.times(o),p+=5;for(v=Math.log(h(2,p))/Math.LN10*2+5|0,i+=v,c=a=f=new u(w),u.precision=i;;){if(a=r(a.times(n),i,1),c=c.times(++d),o=f.plus(s(a,c,i,1)),l(o.c).slice(0,i)===l(f.c).slice(0,i)){for(k=p;k--;)f=r(f.times(f),i,1);if(t==null)if(y<3&&g(f.c,i-v,nt,y))u.precision=i+=10,c=a=o=new u(w),d=0,y++;else return r(f,u.precision=b,nt,e=!0);else return u.precision=b,f}f=o}}function nt(n,t,i,u){var f,o,s=n.constructor,e=(n=new s(n)).e;if(t==null?i=0:(r(n,++t,i),i=u?t:t+n.e-e),e=n.e,f=l(n.c),u==1||u==2&&(t<=e||e<=s.toExpNeg)){for(;f.length<i;f+=\"0\");f.length>1&&(f=f.charAt(0)+\".\"+f.slice(1));f+=(e<0?\"e\":\"e+\")+e}else{if(u=f.length,e<0){for(o=i-u;++e;f=\"0\"+f);f=\"0.\"+f}else if(++e>u){for(o=i-e,e-=u;e--;f+=\"0\");o>0&&(f+=\".\")}else o=i-u,e<u?f=f.slice(0,e)+\".\"+f.slice(e):o>0&&(f+=\".\");if(o>0)for(;o--;f+=\"0\");}return n.s<0&&n.c[0]?\"-\"+f:f}function ot(n){var t=n.length-1,r=t*i+1;if(t=n[t]){for(;t%10==0;t/=10,r--);for(t=n[0];t>=10;t/=10,r++);}return r}function f(n,t,i,r,f){if(n.errors){var e=new Error((r||[\"new Decimal\",\"cmp\",\"div\",\"eq\",\"gt\",\"gte\",\"lt\",\"lte\",\"minus\",\"mod\",\"plus\",\"times\",\"toFraction\",\"pow\",\"random\",\"log\",\"sqrt\",\"toNearest\",\"divToInt\"][u?u<0?-u:u:1/u<0?1:0])+\"() \"+([\"number type has more than 15 significant digits\",\"LN10 out of digits\"][t]||t+([c?\" out of range\":\" not an integer\",\" not a boolean or binary digit\"][f]||\"\"))+\": \"+i);e.name=\"Decimal Error\";c=u=0;throw e;}}function st(n,t,i){var r=new n(n.ONE);for(e=!1;;){if(i&1&&(r=r.times(t)),i>>=1,!i)break;t=t.times(t)}return e=!0,r}function p(n,t){var c,a,d,w,b,et,u,h,nt,rt,ut,ot=1,tt=10,i=n,v=i.c,o=i.constructor,it=o.ONE,ft=o.rounding,k=o.precision;if(i.s<0||!v||!v[0]||!i.e&&v[0]==1&&v.length==1)return new o(v&&!v[0]?-1/0:i.s!=1?NaN:v?0:i);if(t==null?(e=!1,u=k):u=t,o.precision=u+=tt,c=l(v),a=c.charAt(0),Math.abs(w=i.e)<15e14){while(a<7&&a!=1||a==1&&c.charAt(1)>3)i=i.times(n),c=l(i.c),a=c.charAt(0),ot++;w=i.e;a>1?(i=new o(\"0.\"+c),w++):i=new o(a+\".\"+c.slice(1))}else return i=new o(a+\".\"+c.slice(1)),u+2>y.length&&f(o,1,u+2,\"ln\"),i=p(i,u-tt).plus(new o(y.slice(0,u+2)).times(w+\"\")),o.precision=k,t==null?r(i,k,ft,e=!0):i;for(rt=i,h=b=i=s(i.minus(it),i.plus(it),u,1),ut=r(i.times(i),u,1),d=3;;){if(b=r(b.times(ut),u,1),nt=h.plus(s(b,new o(d),u,1)),l(nt.c).slice(0,u)===l(h.c).slice(0,u))if(h=h.times(2),w!==0&&(u+2>y.length&&f(o,1,u+2,\"ln\"),h=h.plus(new o(y.slice(0,u+2)).times(w+\"\"))),h=s(h,new o(ot),u,1),t==null)if(g(h.c,u-tt,ft,et))o.precision=u+=tt,nt=b=i=s(rt.minus(it),rt.plus(it),u,1),ut=r(i.times(i),u,1),d=et=1;else return r(h,o.precision=k,ft,e=!0);else return o.precision=k,h;h=nt;d+=2}}function r(n,t,r,u){var y,c,s,l,p,w,f,a,b=n.constructor;n:if(t!=null){if(!(f=n.c))return n;for(y=1,l=f[0];l>=10;l/=10,y++);if(c=t-y,c<0)c+=i,s=t,p=f[a=0],w=p/h(10,y-s-1)%10|0;else if(a=Math.ceil((c+1)/i),a>=f.length)if(u){for(;f.length<=a;f.push(0));p=w=0;y=1;c%=i;s=c-i+1}else break n;else{for(p=l=f[a],y=1;l>=10;l/=10,y++);c%=i;s=c-i+y;w=s<0?0:o(p/h(10,y-s-1)%10)}if(u=u||t<0||f[a+1]!=null||(s<0?p:p%h(10,y-s-1)),u=r<4?(w||u)&&(r==0||r==(n.s<0?3:2)):w>5||w==5&&(r==4||u||r==6&&(c>0?s>0?p/h(10,y-s):0:f[a-1])%10&1||r==(n.s<0?8:7)),t<1||!f[0])return f.length=0,u?(t-=n.e+1,f[0]=h(10,t%i),n.e=-t||0):f[0]=n.e=0,n;if(c==0?(f.length=a,l=1,a--):(f.length=a+1,l=h(10,i-c),f[a]=s>0?(p/h(10,y-s)%h(10,s)|0)*l:0),u)for(;;)if(a==0){for(c=1,s=f[0];s>=10;s/=10,c++);for(s=f[0]+=l,l=1;s>=10;s/=10,l++);c!=l&&(n.e++,f[0]==v&&(f[0]=1));break}else{if(f[a]+=l,f[a]!=v)break;f[a--]=0;l=1}for(c=f.length;f[--c]===0;f.pop());}return e&&(n.e>b.maxE?n.c=n.e=null:n.e<b.minE&&(n.c=[n.e=0])),n}var tt,w,ut,a=n.crypto,e=!0,u=0,o=Math.floor,h=Math.pow,c,ft=Object.prototype.toString,v=1e7,i=7,it=\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\",t={},b=9e15,et=1e9,ht=3e3,y=\"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\",s;if(t.absoluteValue=t.abs=function(){var n=new this.constructor(this);return n.s<0&&(n.s=1),r(n)},t.ceil=function(){return r(new this.constructor(this),this.e+1,2)},t.comparedTo=t.cmp=function(n,t){var r,c=this,f=c.c,s=(u=-u,n=new c.constructor(n,t),n.c),i=c.s,h=n.s,e=c.e,o=n.e;if(!i||!h)return null;if(r=f&&!f[0],t=s&&!s[0],r||t)return r?t?0:-h:i;if(i!=h)return i;if(r=i<0,!f||!s)return e==o?0:!f^r?1:-1;if(e!=o)return e>o^r?1:-1;for(i=-1,h=(e=f.length)<(o=s.length)?e:o;++i<h;)if(f[i]!=s[i])return f[i]>s[i]^r?1:-1;return e==o?0:e>o^r?1:-1},t.decimalPlaces=t.dp=function(){var r,n,t=null;if(r=this.c){if(t=((n=r.length-1)-o(this.e/i))*i,n=r[n])for(;n%10==0;n/=10,t--);t<0&&(t=0)}return t},t.dividedBy=t.div=function(n,t){return u=2,s(this,new this.constructor(n,t))},t.dividedToIntegerBy=t.divToInt=function(n,t){var f=this,i=f.constructor;return u=18,r(s(f,new i(n,t),0,1,1),i.precision,i.rounding)},t.equals=t.eq=function(n,t){return u=3,this.cmp(n,t)===0},t.exponential=t.exp=function(){return rt(this)},t.floor=function(){return r(new this.constructor(this),this.e+1,3)},t.greaterThan=t.gt=function(n,t){return u=4,this.cmp(n,t)>0},t.greaterThanOrEqualTo=t.gte=function(n,t){return u=5,t=this.cmp(n,t),t==1||t===0},t.isFinite=function(){return!!this.c},t.isInteger=t.isInt=function(){return!!this.c&&o(this.e/i)>this.c.length-2},t.isNaN=function(){return!this.s},t.isNegative=t.isNeg=function(){return this.s<0},t.isZero=function(){return!!this.c&&this.c[0]==0},t.lessThan=t.lt=function(n,t){return u=6,this.cmp(n,t)<0},t.lessThanOrEqualTo=t.lte=function(n,t){return u=7,t=this.cmp(n,t),t==-1||t===0},t.logarithm=t.log=function(n,t){var k,i,b,o,it,d,h,a,v,w=this,c=w.constructor,nt=c.precision,tt=c.rounding;if(n==null)n=new c(10),k=!0;else{if(u=15,n=new c(n,t),i=n.c,n.s<0||!i||!i[0]||!n.e&&i[0]==1&&i.length==1)return new c(NaN);k=n.eq(10)}if(i=w.c,w.s<0||!i||!i[0]||!w.e&&i[0]==1&&i.length==1)return new c(i&&!i[0]?-1/0:w.s!=1?NaN:i?0:1/0);if(it=k&&(o=i[0],i.length>1||o!=1&&o!=10&&o!=100&&o!=1e3&&o!=1e4&&o!=1e5&&o!=1e6),e=!1,h=nt+5,a=h+10,d=p(w,h),k?(a>y.length&&f(c,1,a,\"log\"),b=new c(y.slice(0,a))):b=p(n,h),v=s(d,b,h,1),g(v.c,o=nt,tt))do if(h+=10,d=p(w,h),k?(a=h+10,a>y.length&&f(c,1,a,\"log\"),b=new c(y.slice(0,a))):b=p(n,h),v=s(d,b,h,1),!it){+l(v.c).slice(o+1,o+15)+1==1e14&&(v=r(v,nt+1,0));break}while(g(v.c,o+=10,tt));return e=!0,r(v,nt,tt)},t.minus=function(n,t){var a,c,p,k,l=this,w=l.constructor,h=l.s;if(u=8,n=new w(n,t),t=n.s,!h||!t)return new w(NaN);if(h!=t)return n.s=-t,l.plus(n);var f=l.c,s=n.c,b=o(n.e/i),y=o(l.e/i),g=w.precision,d=w.rounding;if(!y||!b){if(!f||!s)return f?(n.s=-t,n):new w(s?l:NaN);if(!f[0]||!s[0])return l=s[0]?(n.s=-t,n):new w(f[0]?l:d==3?-0:0),e?r(l,g,d):l}if(f=f.slice(),c=f.length,h=y-b){for((k=h<0)?(h=-h,a=f,c=s.length):(b=y,a=s),(y=Math.ceil(g/i))>c&&(c=y),h>(c+=2)&&(h=c,a.length=1),a.reverse(),t=h;t--;a.push(0));a.reverse()}else for((k=c<(p=s.length))&&(p=c),h=t=0;t<p;t++)if(f[t]!=s[t]){k=f[t]<s[t];break}if(k&&(a=f,f=s,s=a,n.s=-n.s),(t=-((p=f.length)-s.length))>0)for(;t--;f[p++]=0);for(y=v-1,t=s.length;t>h;){if(f[--t]<s[t]){for(c=t;c&&!f[--c];f[c]=y);--f[c];f[t]+=v}f[t]-=s[t]}for(;f[--p]==0;f.pop());for(;f[0]==0;f.shift(),--b);for(f[0]||(f=[b=0],n.s=d==3?-1:1),n.c=f,h=1,t=f[0];t>=10;t/=10,h++);return n.e=h+b*i-1,e?r(n,g,d):n},t.modulo=t.mod=function(n,t){var h,f,i=this,o=i.constructor,c=o.modulo;return(u=9,n=new o(n,t),t=n.s,h=!i.c||!t||n.c&&!n.c[0],h||!n.c||i.c&&!i.c[0])?h?new o(NaN):r(new o(i),o.precision,o.rounding):(e=!1,c==9?(n.s=1,f=s(i,n,0,3,1),n.s=t,f.s*=t):f=s(i,n,0,c,1),f=f.times(n),e=!0,i.minus(f))},t.naturalLogarithm=t.ln=function(){return p(this)},t.negated=t.neg=function(){var n=new this.constructor(this);return n.s=-n.s||null,r(n)},t.plus=function(n,t){var l,c=this,y=c.constructor,f=c.s;if(u=10,n=new y(n,t),t=n.s,!f||!t)return new y(NaN);if(f!=t)return n.s=-t,c.minus(n);var s=c.c,h=n.c,p=o(n.e/i),a=o(c.e/i),w=y.precision,b=y.rounding;if(!a||!p){if(!s||!h)return new y(f/0);if(!s[0]||!h[0])return c=h[0]?n:new y(s[0]?c:f*0),e?r(c,w,b):c}if(s=s.slice(),f=a-p){for(f<0?(f=-f,l=s,t=h.length):(p=a,l=h,t=s.length),(a=Math.ceil(w/i))>t&&(t=a),f>++t&&(f=t,l.length=1),l.reverse();f--;l.push(0));l.reverse()}for(s.length-h.length<0&&(l=h,h=s,s=l),f=h.length,t=0,a=v;f;s[f]%=a)t=(s[--f]=s[f]+h[f]+t)/a|0;for(t&&(s.unshift(t),++p),f=s.length;s[--f]==0;s.pop());for(n.c=s,f=1,t=s[0];t>=10;t/=10,f++);return n.e=f+p*i-1,e?r(n,w,b):n},t.precision=t.sd=function(n){var t=null,i=this;return n!=t&&n!==!!n&&n!==1&&n!==0&&f(i.constructor,\"argument\",n,\"precision\",1),i.c&&(t=ot(i.c),n&&i.e+1>t&&(t=i.e+1)),t},t.round=function(){var n=this,t=n.constructor;return r(new t(n),n.e+1,t.rounding)},t.squareRoot=t.sqrt=function(){var p,n,c,i,y,h,f=this,a=f.c,u=f.s,t=f.e,v=f.constructor,w=new v(.5);if(u!==1||!a||!a[0])return new v(!u||u<0&&(!a||a[0])?NaN:a?f:1/0);for(e=!1,u=Math.sqrt(+f),u==0||u==1/0?(n=l(a),(n.length+t)%2==0&&(n+=\"0\"),u=Math.sqrt(n),t=o((t+1)/2)-(t<0||t%2),u==1/0?n=\"1e\"+t:(n=u.toExponential(),n=n.slice(0,n.indexOf(\"e\")+1)+t),i=new v(n)):i=new v(u.toString()),c=(t=v.precision)+3;;)if(h=i,i=w.times(h.plus(s(f,h,c+2,1))),l(h.c).slice(0,c)===(n=l(i.c)).slice(0,c))if(n=n.slice(c-3,c+1),n!=\"9999\"&&(y||n!=\"4999\")){+n&&(+n.slice(1)||n.charAt(0)!=\"5\")||(r(i,t+1,1),p=!i.times(i).eq(f));break}else{if(!y&&(r(h,t+1,0),h.times(h).eq(f))){i=h;break}c+=4;y=1}return e=!0,r(i,t,v.rounding,p)},t.times=function(n,t){var f,w,y=this,p=y.constructor,c=y.c,l=(u=11,n=new p(n,t),n.c),a=o(y.e/i),s=o(n.e/i),h=y.s;if(t=n.s,n.s=h==t?1:-1,!a&&(!c||!c[0])||!s&&(!l||!l[0]))return new p(!h||!t||c&&!c[0]&&!l||l&&!l[0]&&!c?NaN:!c||!l?n.s/0:n.s*0);for(w=a+s,h=c.length,t=l.length,h<t&&(f=c,c=l,l=f,s=h,h=t,t=s),s=h+t,f=[];s--;f.push(0));for(a=t-1;a>-1;a--){for(t=0,s=h+a;s>a;)t=f[s]+l[a]*c[s-a-1]+t,f[s--]=t%v|0,t=t/v|0;f[s]=(f[s]+t)%v|0}for(t?++w:f[0]||f.shift(),s=f.length;!f[--s];f.pop());for(n.c=f,h=1,t=f[0];t>=10;t/=10,h++);return n.e=h+w*i-1,e?r(n,p.precision,p.rounding):n},t.toDecimalPlaces=t.toDP=function(n,t){var i=this;return i=new i.constructor(i),n==null||!d(i,n,\"toDP\")?i:r(i,(n|0)+i.e+1,k(i,t,\"toDP\"))},t.toExponential=function(n,t){var i=this;return i.c?nt(i,n!=null&&d(i,n,\"toExponential\")?n|0:null,n!=null&&k(i,t,\"toExponential\"),1):i.toString()},t.toFixed=function(n,t){var i,r=this,u=r.constructor,f=u.toExpNeg,e=u.toExpPos;return n!=null&&(n=d(r,n,i=\"toFixed\")?r.e+(n|0):null,t=k(r,t,i)),u.toExpNeg=-(u.toExpPos=1/0),n!=null&&r.c?(i=nt(r,n,t),r.s<0&&r.c&&(r.c[0]?i.indexOf(\"-\")<0&&(i=\"-\"+i):i=i.replace(\"-\",\"\"))):i=r.toString(),u.toExpNeg=f,u.toExpPos=e,i},t.toFormat=function(n,t){var o=this;if(!o.c)return o.toString();var r,l=o.s<0,f=o.constructor.format,a=f.groupSeparator,u=+f.groupSize,e=+f.secondaryGroupSize,v=o.toFixed(n,t).split(\".\"),i=v[0],c=v[1],s=l?i.slice(1):i,h=s.length;if(e&&(h-=(r=u,u=e,e=r)),u>0&&h>0){for(r=h%u||u,i=s.substr(0,r);r<h;r+=u)i+=a+s.substr(r,u);e>0&&(i+=a+s.slice(r));l&&(i=\"-\"+i)}return c?i+f.decimalSeparator+((e=+f.fractionGroupSize)?c.replace(new RegExp(\"\\\\d{\"+e+\"}\\\\B\",\"g\"),\"$&\"+f.fractionGroupSeparator):c):i},t.toFraction=function(n){var v,r,d,it,a,y,g,nt,b=this,t=b.constructor,p=v=new t(t.ONE),w=y=new t(0),tt=b.c,k=new t(w);if(!tt)return b.toString();for(d=k.e=ot(tt)-b.e-1,k.c[0]=h(10,(g=d%i)<0?i+g:g),(n==null||(!(u=12,a=new t(n)).s||(c=a.cmp(p)<0||!a.c)||t.errors&&o(a.e/i)<a.c.length-1)&&!f(t,\"max denominator\",n,\"toFraction\",0)||(n=a).cmp(k)>0)&&(n=d>0?k:p),e=!1,a=new t(l(tt)),g=t.precision,t.precision=d=tt.length*i*2;;){if(nt=s(a,k,0,1,1),r=v.plus(nt.times(w)),r.cmp(n)==1)break;v=w;w=r;p=y.plus(nt.times(r=p));y=r;k=a.minus(nt.times(r=k));a=r}return r=s(n.minus(v),w,0,1,1),y=y.plus(r.times(p)),v=v.plus(r.times(w)),y.s=p.s=b.s,it=s(p,w,d,1).minus(b).abs().cmp(s(y,v,d,1).minus(b).abs())<1?[p+\"\",w+\"\"]:[y+\"\",v+\"\"],e=!0,t.precision=g,it},t.toNearest=function(n,t){var i=this,f=i.constructor;return i=new f(i),n==null?(n=new f(f.ONE),t=f.rounding):(u=17,n=new f(n),t=k(i,t,\"toNearest\")),n.c?i.c&&(n.c[0]?(e=!1,i=s(i,n,0,t<4?[4,5,7,8][t]:t,1).times(n),e=!0,r(i)):i.c=[i.e=0]):i.s&&(n.s&&(n.s=i.s),i=n),i},t.toNumber=function(){var n=this;return+n||(n.s?0*n.s:NaN)},t.toPower=t.pow=function(n,t){var nt,a,b,s,f=this,c=f.constructor,y=f.s,w=+(u=13,n=new c(n,t)),k=w<0?-w:w,v=c.precision,d=c.rounding;if(!f.c||!n.c||(b=!f.c[0])||!n.c[0])return new c(h(b?y*0:+f,w));if(f=new c(f),nt=f.c.length,!f.e&&f.c[0]==f.s&&nt==1)return f;if(t=n.c.length-1,n.e||n.c[0]!=n.s||t)if(a=o(n.e/i),b=a>=t,!b&&y<0)s=new c(NaN);else{if(b&&nt*i*k<ht){if(s=st(c,f,k),n.s<0)return c.ONE.div(s)}else{if(y=y<0&&n.c[Math.max(a,t)]&1?-1:1,t=h(+f,w),a=t==0||!isFinite(t)?o(w*(Math.log(\"0.\"+l(f.c))/Math.LN10+f.e+1)):new c(t+\"\").e,a>c.maxE+1||a<c.minE-1)return new c(a>0?y/0:0);e=!1;c.rounding=f.s=1;k=Math.min(12,(a+\"\").length);s=rt(n.times(p(f,v+k)),v);s=r(s,v+5,1);g(s.c,v,d)&&(a=v+10,s=r(rt(n.times(p(f,a+k)),a),a+5,1),+l(s.c).slice(v+1,v+15)+1==1e14&&(s=r(s,v+1,0)));s.s=y;e=!0;c.rounding=d}s=r(s,v,d)}else s=r(f,v,d);return s},t.toPrecision=function(n,t){var i=this;return n!=null&&d(i,n,\"toPrecision\",1)&&i.c?nt(i,--n|0,k(i,t,\"toPrecision\"),2):i.toString()},t.toSignificantDigits=t.toSD=function(n,t){var i=this,u=i.constructor;return i=new u(i),n==null||!d(i,n,\"toSD\",1)?r(i,u.precision,u.rounding):r(i,n|0,k(i,t,\"toSD\"))},t.toString=function(n){var e,t,o,r=this,u=r.constructor,i=r.e;if(i===null)t=r.s?\"Infinity\":\"NaN\";else{if(n===e&&(i<=u.toExpNeg||i>=u.toExpPos))return nt(r,null,u.rounding,1);if(t=l(r.c),i<0){for(;++i;t=\"0\"+t);t=\"0.\"+t}else if(o=t.length,i>0)if(++i>o)for(i-=o;i--;t+=\"0\");else i<o&&(t=t.slice(0,i)+\".\"+t.slice(i));else if(e=t.charAt(0),o>1)t=e+\".\"+t.slice(1);else if(e==\"0\")return e;if(n!=null)if((c=!(n>=2&&n<65))||n!=(n|0)&&u.errors)f(u,\"base\",n,\"toString\",0);else if(t=tt(u,t,n|0,10,r.s),t==\"0\")return t}return r.s<0?\"-\"+t:t},t.truncated=t.trunc=function(){return r(new this.constructor(this),this.e+1,1)},t.valueOf=t.toJSON=function(){return this.toString()},tt=function(){function n(n,t,i){for(var u,r=[0],f,e=0,o=n.length;e<o;){for(f=r.length;f--;r[f]*=t);for(r[u=0]+=it.indexOf(n.charAt(e++));u<r.length;u++)r[u]>i-1&&(r[u+1]==null&&(r[u+1]=0),r[u+1]+=r[u]/i|0,r[u]%=i)}return r.reverse()}return function(t,i,r,u,f){var h,a,p,c,e,y,o=i.indexOf(\".\"),l=t.precision,v=t.rounding;for(u<37&&(i=i.toLowerCase()),o>=0&&(i=i.replace(\".\",\"\"),y=new t(u),c=st(t,y,i.length-o),y.c=n(c.toFixed(),10,r),y.e=y.c.length),e=n(i,u,r),h=a=e.length;e[--a]==0;e.pop());if(!e[0])return\"0\";if(o<0?h--:(c.c=e,c.e=h,c.s=f,c=s(c,y,l,v,0,r),e=c.c,p=c.r,h=c.e),o=e[l],a=r/2,p=p||e[l+1]!=null,v<4?(o!=null||p)&&(v==0||v==(c.s<0?3:2)):o>a||o==a&&(v==4||p||v==6&&e[l-1]&1||v==(c.s<0?8:7)))for(e.length=l,--r;++e[--l]>r;)e[l]=0,l||(++h,e.unshift(1));else e.length=l;for(a=e.length;!e[--a];);for(o=0,i=\"\";o<=a;i+=it.charAt(e[o++]));if(h<0){for(;++h;i=\"0\"+i);i=\"0.\"+i}else if(o=i.length,++h>o)for(h-=o;h--;i+=\"0\");else h<o&&(i=i.slice(0,h)+\".\"+i.slice(h));return i}}(),s=function(){function n(n,t,i){var u,r=0,f=n.length;for(n=n.slice();f--;)u=n[f]*t+r,n[f]=u%i|0,r=u/i|0;return r&&n.unshift(r),n}function t(n,t,i,r){var u,f;if(i!=r)f=i>r?1:-1;else for(u=f=0;u<i;u++)if(n[u]!=t[u]){f=n[u]>t[u]?1:-1;break}return f}function u(n,t,i,r){for(var u=0;i--;)n[i]-=u,u=n[i]<t[i]?1:0,n[i]=u*r+n[i]-t[i];for(;!n[0]&&n.length>1;n.shift());}return function(f,e,s,h,c,l){var nt,et,w,rt,ot,y,tt,ft,it,ut,p,b,ht,vt,ct,st,yt,g,lt,at=f.constructor,d=f.s==e.s?1:-1,k=f.c,a=e.c;if(!k||!k[0]||!a||!a[0])return new at(!f.s||!e.s||(k?a&&k[0]==a[0]:!a)?NaN:k&&k[0]==0||!a?d*0:d/0);for(l?(rt=1,et=f.e-e.e):(l=v,rt=i,et=o(f.e/rt)-o(e.e/rt)),g=a.length,st=k.length,it=new at(d),ut=it.c=[],w=0;a[w]==(k[w]||0);w++);if(a[w]>(k[w]||0)&&et--,s==null?(d=s=at.precision,h=at.rounding):d=c?s+(f.e-e.e)+1:s,d<0)ut.push(1),ot=!0;else{if(d=d/rt+2|0,w=0,g==1){for(y=0,a=a[0],d++;(w<st||y)&&d--;w++)vt=y*l+(k[w]||0),ut[w]=vt/a|0,y=vt%a|0;ot=y||w<st}else{for(y=l/(a[0]+1)|0,y>1&&(a=n(a,y,l),k=n(k,y,l),g=a.length,st=k.length),ct=g,p=k.slice(0,g),b=p.length;b<g;p[b++]=0);lt=a.slice();lt.unshift(0);yt=a[0];a[1]>=l/2&&yt++;do y=0,nt=t(a,p,g,b),nt<0?(ht=p[0],g!=b&&(ht=ht*l+(p[1]||0)),y=ht/yt|0,y>1?(y>=l&&(y=l-1),tt=n(a,y,l),ft=tt.length,b=p.length,nt=t(tt,p,ft,b),nt==1&&(y--,u(tt,g<ft?lt:a,ft,l))):(y==0&&(nt=y=1),tt=a.slice()),ft=tt.length,ft<b&&tt.unshift(0),u(p,tt,b,l),nt==-1&&(b=p.length,nt=t(a,p,g,b),nt<1&&(y++,u(p,g<b?lt:a,b,l))),b=p.length):nt===0&&(y++,p=[0]),ut[w++]=y,nt&&p[0]?p[b++]=k[ct]||0:(p=[k[ct]],b=1);while((ct++<st||p[0]!=null)&&d--);ot=p[0]!=null}ut[0]||ut.shift()}if(rt==1)it.e=et,it.r=+ot;else{for(w=1,d=ut[0];d>=10;d/=10,w++);it.e=w+et*rt-1;r(it,c?s+it.e+1:s,h,ot)}return it}}(),w=function(){function l(n){var i,e,t,r=this,s=\"config\",h=r.errors?parseInt:parseFloat;return n==e||typeof n!=\"object\"&&!f(r,\"object expected\",n,s)?r:((t=n[i=\"precision\"])!=e&&((c=t<1||t>et)||h(t)!=t?f(r,i,t,s,0):r[i]=t|0),(t=n[i=\"rounding\"])!=e&&((c=t<0||t>8)||h(t)!=t?f(r,i,t,s,0):r[i]=t|0),(t=n[i=\"toExpNeg\"])!=e&&((c=t<-b||t>0)||h(t)!=t?f(r,i,t,s,0):r[i]=o(t)),(t=n[i=\"toExpPos\"])!=e&&((c=t<0||t>b)||h(t)!=t?f(r,i,t,s,0):r[i]=o(t)),(t=n[i=\"minE\"])!=e&&((c=t<-b||t>0)||h(t)!=t?f(r,i,t,s,0):r[i]=o(t)),(t=n[i=\"maxE\"])!=e&&((c=t<0||t>b)||h(t)!=t?f(r,i,t,s,0):r[i]=o(t)),(t=n[i=\"errors\"])!=e&&(t===!!t||t===1||t===0?(c=u=0,r[i]=!!t):f(r,i,t,s,1)),(t=n[i=\"crypto\"])!=e&&(t===!!t||t===1||t===0?r[i]=!!(t&&a&&typeof a==\"object\"):f(r,i,t,s,1)),(t=n[i=\"modulo\"])!=e&&((c=t<0||t>9)||h(t)!=t?f(r,i,t,s,0):r[i]=t|0),(n=n[i=\"format\"])!=e&&(typeof n==\"object\"?r[i]=n:f(r,\"format object expected\",n,s)),r)}function v(n){return new this(n).exp()}function y(n){return new this(n).ln()}function p(n,t){return new this(n).log(t)}function n(n,t,i){var r,u,f=0;for(ft.call(t[0])==\"[object Array]\"&&(t=t[0]),r=new n(t[0]);++f<t.length;)if(u=new n(t[f]),u.s)r[i](u)&&(r=u);else{r=u;break}return r}function w(){return n(this,arguments,\"lt\")}function k(){return n(this,arguments,\"gt\")}function nt(n,t){return new this(n).pow(t)}function rt(n){var o,r,u,t=0,e=[],s=this,c=new s(s.ONE);if(n!=null&&d(c,n,\"random\")?n|=0:n=s.precision,r=Math.ceil(n/i),s.crypto)if(a&&a.getRandomValues)for(o=a.getRandomValues(new Uint32Array(r));t<r;)u=o[t],u>=429e7?o[t]=a.getRandomValues(new Uint32Array(1))[0]:e[t++]=u%1e7;else if(a&&a.randomBytes){for(o=a.randomBytes(r*=4);t<r;)u=o[t]+(o[t+1]<<8)+(o[t+2]<<16)+((o[t+3]&127)<<24),u>=214e7?a.randomBytes(4).copy(o,t):(e.push(u%1e7),t+=4);t=r/4}else f(s,\"crypto unavailable\",a,\"random\");if(!t)for(;t<r;)e[t++]=Math.random()*1e7|0;for(r=e[--t],n%=i,r&&n&&(u=h(10,i-n),e[t]=(r/u|0)*u);e[t]===0;t--)e.pop();if(t<0)e=[r=0];else{for(r=-1;e[0]===0;)e.shift(),r-=i;for(t=1,u=e[0];u>=10;)u/=10,t++;t<i&&(r-=i-t)}return c.e=r,c.c=e,c}function ut(n){return new this(n).sqrt()}function s(n){function i(n,t){var e=this;if(!(e instanceof i))return f(i,\"Decimal called without new\",n),new i(n,t);if(e.constructor=i,n instanceof i){if(t==null)return u=0,e.s=n.s,e.e=n.e,e.c=(n=n.c)?n.slice():n,e;if(t==10)return r(new i(n),i.precision,i.rounding);n+=\"\"}return g(i,e,n,t)}return i.precision=20,i.rounding=4,i.modulo=1,i.toExpNeg=-7,i.toExpPos=21,i.minE=-b,i.maxE=b,i.errors=!0,i.crypto=!1,i.format={decimalSeparator:\".\",groupSeparator:\",\",groupSize:3,secondaryGroupSize:0,fractionGroupSeparator:\"\u00a0\",fractionGroupSize:0},i.prototype=t,i.ONE=new i(1),i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.EUCLID=9,i.config=l,i.constructor=s,i.exp=v,i.ln=y,i.log=p,i.max=w,i.min=k,i.pow=nt,i.sqrt=ut,i.random=rt,n!=null&&i.config(n),i}var g=function(){var n=/^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,t=String.prototype.trim||function(){return this.replace(/^\\s+|\\s+$/g,\"\")};return function(o,s,h,l){var b,v,a,y,p,w;if(typeof h!=\"string\"&&(h=(y=typeof h==\"number\"||ft.call(h)==\"[object Number]\")&&h===0&&1/h<0?\"-0\":h+\"\"),p=h,l==null&&n.test(h))s.s=h.charCodeAt(0)===45?(h=h.slice(1),-1):1;else{if(l==10)return r(new o(h),o.precision,o.rounding);if(h=t.call(h).replace(/^\\+(?!-)/,\"\"),s.s=h.charCodeAt(0)===45?(h=h.replace(/^-(?!-)/,\"\"),-1):1,l!=null?l!=(l|0)&&o.errors||(c=!(l>=2&&l<65))?(f(o,\"base\",l,0,0),w=n.test(h)):(b=\"[\"+it.slice(0,l=l|0)+\"]+\",h=h.replace(/\\.$/,\"\").replace(/^\\./,\"0.\"),(w=new RegExp(\"^\"+b+\"(?:\\\\.\"+b+\")?$\",l<37?\"i\":\"\").test(h))?(y&&(h.replace(/^0\\.0*|\\./,\"\").length>15&&f(o,0,p),y=!y),h=tt(o,h,10,l,s.s)):h!=\"Infinity\"&&h!=\"NaN\"&&(f(o,\"not a base \"+l+\" number\",p),h=\"NaN\")):w=n.test(h),!w)return s.c=s.e=null,h!=\"Infinity\"&&(h!=\"NaN\"&&f(o,\"not a number\",p),s.s=null),u=0,s}for((v=h.indexOf(\".\"))>-1&&(h=h.replace(\".\",\"\")),(a=h.search(/e/i))>0?(v<0&&(v=a),v+=+h.slice(a+1),h=h.substring(0,a)):v<0&&(v=h.length),a=0;h.charCodeAt(a)===48;a++);for(l=h.length;h.charCodeAt(--l)===48;);if(h=h.slice(a,l+1),h){if(l=h.length,y&&l>15&&f(o,0,p),s.e=v=v-a-1,s.c=[],a=(v+1)%i,v<0&&(a+=i),a<l){for(a&&s.c.push(+h.slice(0,a)),l-=i;a<l;)s.c.push(+h.slice(a,a+=i));h=h.slice(a);a=i-h.length}else a-=l;for(;a--;h+=\"0\");s.c.push(+h);e&&(s.e>o.maxE?s.c=s.e=null:s.e<o.minE&&(s.c=[s.e=0]))}else s.c=[s.e=0];return u=0,s}}();return s()}(),typeof define==\"function\"&&define.amd)define(function(){return w});else if(typeof module!=\"undefined\"&&module.exports){if(module.exports=w,!a)try{a=require(\"crypto\")}catch(ct){}}else ut=n.Decimal,w.noConflict=function(){return n.Decimal=ut,w},n.Decimal=w})(this)"], "http.cookies": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\n\n\n\n\nimport re\nimport string\n\n__all__ = [\"CookieError\", \"BaseCookie\", \"SimpleCookie\"]\n\n_nulljoin = ''.join\n_semispacejoin = '; '.join\n_spacejoin = ' '.join\n\n\n\n\nclass CookieError(Exception):\n pass\n \n \n \n \n \n \n \n \n \n \n \n \n \n_LegalChars = string.ascii_letters + string.digits + \"!#$%&'*+-.^_`|~:\"\n_Translator = {\n'\\000' : '\\\\000', '\\001' : '\\\\001', '\\002' : '\\\\002',\n'\\003' : '\\\\003', '\\004' : '\\\\004', '\\005' : '\\\\005',\n'\\006' : '\\\\006', '\\007' : '\\\\007', '\\010' : '\\\\010',\n'\\011' : '\\\\011', '\\012' : '\\\\012', '\\013' : '\\\\013',\n'\\014' : '\\\\014', '\\015' : '\\\\015', '\\016' : '\\\\016',\n'\\017' : '\\\\017', '\\020' : '\\\\020', '\\021' : '\\\\021',\n'\\022' : '\\\\022', '\\023' : '\\\\023', '\\024' : '\\\\024',\n'\\025' : '\\\\025', '\\026' : '\\\\026', '\\027' : '\\\\027',\n'\\030' : '\\\\030', '\\031' : '\\\\031', '\\032' : '\\\\032',\n'\\033' : '\\\\033', '\\034' : '\\\\034', '\\035' : '\\\\035',\n'\\036' : '\\\\036', '\\037' : '\\\\037',\n\n\n\n\n',' : '\\\\054', ';' : '\\\\073',\n\n'\"' : '\\\\\"', '\\\\' : '\\\\\\\\',\n\n'\\177' : '\\\\177', '\\200' : '\\\\200', '\\201' : '\\\\201',\n'\\202' : '\\\\202', '\\203' : '\\\\203', '\\204' : '\\\\204',\n'\\205' : '\\\\205', '\\206' : '\\\\206', '\\207' : '\\\\207',\n'\\210' : '\\\\210', '\\211' : '\\\\211', '\\212' : '\\\\212',\n'\\213' : '\\\\213', '\\214' : '\\\\214', '\\215' : '\\\\215',\n'\\216' : '\\\\216', '\\217' : '\\\\217', '\\220' : '\\\\220',\n'\\221' : '\\\\221', '\\222' : '\\\\222', '\\223' : '\\\\223',\n'\\224' : '\\\\224', '\\225' : '\\\\225', '\\226' : '\\\\226',\n'\\227' : '\\\\227', '\\230' : '\\\\230', '\\231' : '\\\\231',\n'\\232' : '\\\\232', '\\233' : '\\\\233', '\\234' : '\\\\234',\n'\\235' : '\\\\235', '\\236' : '\\\\236', '\\237' : '\\\\237',\n'\\240' : '\\\\240', '\\241' : '\\\\241', '\\242' : '\\\\242',\n'\\243' : '\\\\243', '\\244' : '\\\\244', '\\245' : '\\\\245',\n'\\246' : '\\\\246', '\\247' : '\\\\247', '\\250' : '\\\\250',\n'\\251' : '\\\\251', '\\252' : '\\\\252', '\\253' : '\\\\253',\n'\\254' : '\\\\254', '\\255' : '\\\\255', '\\256' : '\\\\256',\n'\\257' : '\\\\257', '\\260' : '\\\\260', '\\261' : '\\\\261',\n'\\262' : '\\\\262', '\\263' : '\\\\263', '\\264' : '\\\\264',\n'\\265' : '\\\\265', '\\266' : '\\\\266', '\\267' : '\\\\267',\n'\\270' : '\\\\270', '\\271' : '\\\\271', '\\272' : '\\\\272',\n'\\273' : '\\\\273', '\\274' : '\\\\274', '\\275' : '\\\\275',\n'\\276' : '\\\\276', '\\277' : '\\\\277', '\\300' : '\\\\300',\n'\\301' : '\\\\301', '\\302' : '\\\\302', '\\303' : '\\\\303',\n'\\304' : '\\\\304', '\\305' : '\\\\305', '\\306' : '\\\\306',\n'\\307' : '\\\\307', '\\310' : '\\\\310', '\\311' : '\\\\311',\n'\\312' : '\\\\312', '\\313' : '\\\\313', '\\314' : '\\\\314',\n'\\315' : '\\\\315', '\\316' : '\\\\316', '\\317' : '\\\\317',\n'\\320' : '\\\\320', '\\321' : '\\\\321', '\\322' : '\\\\322',\n'\\323' : '\\\\323', '\\324' : '\\\\324', '\\325' : '\\\\325',\n'\\326' : '\\\\326', '\\327' : '\\\\327', '\\330' : '\\\\330',\n'\\331' : '\\\\331', '\\332' : '\\\\332', '\\333' : '\\\\333',\n'\\334' : '\\\\334', '\\335' : '\\\\335', '\\336' : '\\\\336',\n'\\337' : '\\\\337', '\\340' : '\\\\340', '\\341' : '\\\\341',\n'\\342' : '\\\\342', '\\343' : '\\\\343', '\\344' : '\\\\344',\n'\\345' : '\\\\345', '\\346' : '\\\\346', '\\347' : '\\\\347',\n'\\350' : '\\\\350', '\\351' : '\\\\351', '\\352' : '\\\\352',\n'\\353' : '\\\\353', '\\354' : '\\\\354', '\\355' : '\\\\355',\n'\\356' : '\\\\356', '\\357' : '\\\\357', '\\360' : '\\\\360',\n'\\361' : '\\\\361', '\\362' : '\\\\362', '\\363' : '\\\\363',\n'\\364' : '\\\\364', '\\365' : '\\\\365', '\\366' : '\\\\366',\n'\\367' : '\\\\367', '\\370' : '\\\\370', '\\371' : '\\\\371',\n'\\372' : '\\\\372', '\\373' : '\\\\373', '\\374' : '\\\\374',\n'\\375' : '\\\\375', '\\376' : '\\\\376', '\\377' : '\\\\377'\n}\n\ndef _quote(str, LegalChars=_LegalChars):\n \"\"\n if all(c in LegalChars for c in str):\n  return str\n else:\n  return '\"' + _nulljoin(_Translator.get(s, s) for s in str) + '\"'\n  \n  \n_OctalPatt = re.compile(r\"\\\\[0-3][0-7][0-7]\")\n_QuotePatt = re.compile(r\"[\\\\].\")\n\ndef _unquote(str):\n\n\n if len(str) < 2:\n  return str\n if str[0] != '\"' or str[-1] != '\"':\n  return str\n  \n  \n  \n  \n  \n str = str[1:-1]\n \n \n \n \n \n i = 0\n n = len(str)\n res = []\n while 0 <= i < n:\n  o_match = _OctalPatt.search(str, i)\n  q_match = _QuotePatt.search(str, i)\n  if not o_match and not q_match: \n   res.append(str[i:])\n   break\n   \n  j = k = -1\n  if o_match:\n   j = o_match.start(0)\n  if q_match:\n   k = q_match.start(0)\n  if q_match and (not o_match or k < j): \n   res.append(str[i:k])\n   res.append(str[k+1])\n   i = k + 2\n  else: \n   res.append(str[i:j])\n   res.append(chr(int(str[j+1:j+4], 8)))\n   i = j + 4\n return _nulljoin(res)\n \n \n \n \n \n \n \n \n_weekdayname = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n\n_monthname = [None,\n'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\ndef _getdate(future=0, weekdayname=_weekdayname, monthname=_monthname):\n from time import gmtime, time\n now = time()\n year, month, day, hh, mm, ss, wd, y, z = gmtime(now + future)\n return \"%s, %02d %3s %4d %02d:%02d:%02d GMT\" % (weekdayname[wd], day, monthname[month], year, hh, mm, ss)\n \n \nclass Morsel(dict):\n \"\"\n \n \n \n \n \n \n \n \n \n \n \n \n \n _reserved = {\n \"expires\" : \"expires\",\n \"path\" : \"Path\",\n \"comment\" : \"Comment\",\n \"domain\" : \"Domain\",\n \"max-age\" : \"Max-Age\",\n \"secure\" : \"secure\",\n \"httponly\" : \"httponly\",\n \"version\" : \"Version\",\n }\n \n _flags = {'secure', 'httponly'}\n \n def __init__(self):\n \n  self.key = self.value = self.coded_value = None\n  \n  \n  for key in self._reserved:\n   dict.__setitem__(self, key, \"\")\n   \n def __setitem__(self, K, V):\n  K = K.lower()\n  if not K in self._reserved:\n   raise CookieError(\"Invalid Attribute %s\" % K)\n  dict.__setitem__(self, K, V)\n  \n def isReservedKey(self, K):\n  return K.lower() in self._reserved\n  \n def set(self, key, val, coded_val, LegalChars=_LegalChars):\n \n \n  if key.lower() in self._reserved:\n   raise CookieError(\"Attempt to set a reserved key: %s\" % key)\n  if any(c not in LegalChars for c in key):\n   raise CookieError(\"Illegal key value: %s\" % key)\n   \n   \n  self.key = key\n  self.value = val\n  self.coded_value = coded_val\n  \n def output(self, attrs=None, header=\"Set-Cookie:\"):\n  return \"%s %s\" % (header, self.OutputString(attrs))\n  \n __str__ = output\n \n def __repr__(self):\n  return '<%s: %s=%s>' % (self.__class__.__name__,\n  self.key, repr(self.value))\n  \n def js_output(self, attrs=None):\n \n  return \"\"\"\n        <script type=\"text/javascript\">\n        <!-- begin hiding\n        document.cookie = \\\"%s\\\";\n        // end hiding -->\n        </script>\n        \"\"\"  % (self.OutputString(attrs).replace('\"', r'\\\"'))\n  \n def OutputString(self, attrs=None):\n \n \n  result = []\n  append = result.append\n  \n  \n  append(\"%s=%s\" % (self.key, self.coded_value))\n  \n  \n  if attrs is None:\n   attrs = self._reserved\n  items = sorted(self.items())\n  for key, value in items:\n   if value == \"\":\n    continue\n   if key not in attrs:\n    continue\n   if key == \"expires\" and isinstance(value, int):\n    append(\"%s=%s\" % (self._reserved[key], _getdate(value)))\n   elif key == \"max-age\" and isinstance(value, int):\n    append(\"%s=%d\" % (self._reserved[key], value))\n   elif key == \"secure\":\n    append(str(self._reserved[key]))\n   elif key == \"httponly\":\n    append(str(self._reserved[key]))\n   else:\n    append(\"%s=%s\" % (self._reserved[key], value))\n    \n    \n  return _semispacejoin(result)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n_LegalCharsPatt = r\"[\\w\\d!#%&'~_`><@,:/\\$\\*\\+\\-\\.\\^\\|\\)\\(\\?\\}\\{\\=]\"\n_CookiePattern = re.compile(r\"\"\"\n    (?x)                           # This is a verbose pattern\n    (?P<key>                       # Start of group 'key'\n    \"\"\"+ _LegalCharsPatt + r\"\"\"+?   # Any word of at least one letter\n    )                              # End of group 'key'\n    (                              # Optional group: there may not be a value.\n    \\s*=\\s*                          # Equal Sign\n    (?P<val>                         # Start of group 'val'\n    \"(?:[^\\\\\"]|\\\\.)*\"                  # Any doublequoted string\n    |                                  # or\n    \\w{3},\\s[\\w\\d\\s-]{9,11}\\s[\\d:]{8}\\sGMT  # Special case for \"expires\" attr\n    |                                  # or\n    \"\"\"+ _LegalCharsPatt + r\"\"\"*      # Any word or empty string\n    )                                # End of group 'val'\n    )?                             # End of optional value group\n    \\s*                            # Any number of spaces.\n    (\\s+|;|$)                      # Ending either at space, semicolon, or EOS.\n    \"\"\", re.ASCII) \n\n\n\n\n\nclass BaseCookie(dict):\n \"\"\n \n def value_decode(self, val):\n  \"\"\n  return val, val\n  \n def value_encode(self, val):\n  \"\"\n  strval = str(val)\n  return strval, strval\n  \n def __init__(self, input=None):\n  if input:\n   self.load(input)\n   \n def __set(self, key, real_value, coded_value):\n  \"\"\n  M = self.get(key, Morsel())\n  M.set(key, real_value, coded_value)\n  dict.__setitem__(self, key, M)\n  \n def __setitem__(self, key, value):\n  \"\"\n  rval, cval = self.value_encode(value)\n  self.__set(key, rval, cval)\n  \n def output(self, attrs=None, header=\"Set-Cookie:\", sep=\"\\015\\012\"):\n  \"\"\n  result = []\n  items = sorted(self.items())\n  for key, value in items:\n   result.append(value.output(attrs, header))\n  return sep.join(result)\n  \n __str__ = output\n \n def __repr__(self):\n  l = []\n  items = sorted(self.items())\n  for key, value in items:\n   l.append('%s=%s' % (key, repr(value.value)))\n  return '<%s: %s>' % (self.__class__.__name__, _spacejoin(l))\n  \n def js_output(self, attrs=None):\n  \"\"\n  result = []\n  items = sorted(self.items())\n  for key, value in items:\n   result.append(value.js_output(attrs))\n  return _nulljoin(result)\n  \n def load(self, rawdata):\n  \"\"\n  if isinstance(rawdata, str):\n   self.__parse_string(rawdata)\n  else:\n  \n   for key, value in rawdata.items():\n    self[key] = value\n  return\n  \n def __parse_string(self, str, patt=_CookiePattern):\n  i = 0 \n  n = len(str) \n  M = None \n  \n  while 0 <= i < n:\n  \n   match = patt.search(str, i)\n   if not match:\n   \n    break\n    \n   key, value = match.group(\"key\"), match.group(\"val\")\n   i = match.end(0)\n   \n   \n   if key[0] == \"$\":\n   \n   \n   \n    if M:\n     M[key[1:]] = value\n   elif key.lower() in Morsel._reserved:\n    if M:\n     if value is None:\n      if key.lower() in Morsel._flags:\n       M[key] = True\n     else:\n      M[key] = _unquote(value)\n   elif value is not None:\n    rval, cval = self.value_decode(value)\n    self.__set(key, rval, cval)\n    M = self[key]\n    \n    \nclass SimpleCookie(BaseCookie):\n \"\"\n def value_decode(self, val):\n  return _unquote(val), val\n  \n def value_encode(self, val):\n  strval = str(val)\n  return strval, _quote(strval)\n"], "importlib": [".py", "\"\"\n__all__ = ['__import__', 'import_module', 'invalidate_caches']\n\n\n\n\n\n\n\n\n\nimport _imp \nimport sys\n\nfrom . import machinery \n\ntry:\n import _frozen_importlib as _bootstrap\nexcept ImportError:\n from . import _bootstrap\n _bootstrap._setup(sys, _imp)\nelse:\n\n\n _bootstrap.__name__ = 'importlib._bootstrap'\n _bootstrap.__package__ = 'importlib'\n _bootstrap.__file__ = __file__.replace('__init__.py', '_bootstrap.py')\n sys.modules['importlib._bootstrap'] = _bootstrap\n \n \n_w_long = _bootstrap._w_long\n_r_long = _bootstrap._r_long\n\n\n\n\n\n\nfrom ._bootstrap import __import__\n\n\ndef invalidate_caches():\n \"\"\n for finder in sys.meta_path:\n  if hasattr(finder, 'invalidate_caches'):\n   finder.invalidate_caches()\n   \n   \ndef find_loader(name, path=None):\n \"\"\n try:\n  loader = sys.modules[name].__loader__\n  if loader is None:\n   raise ValueError('{}.__loader__ is None'.format(name))\n  else:\n   return loader\n except KeyError:\n  pass\n return _bootstrap._find_module(name, path)\n \n \ndef import_module(name, package=None):\n \"\"\n level = 0\n if name.startswith('.'):\n  if not package:\n   raise TypeError(\"relative imports require the 'package' argument\")\n  for character in name:\n   if character != '.':\n    break\n   level += 1\n return _bootstrap._gcd_import(name[level:], package, level)\n \n \n \nimport basehook\nsys.meta_path.append(basehook.BaseHook())\n", 1], "_functools": [".py", "def partial(func, *args, **keywords):\n def newfunc(*fargs, **fkeywords):\n  newkeywords = keywords.copy()\n  newkeywords.update(fkeywords)\n  return func(*(args + fargs), **newkeywords)\n newfunc.func = func\n newfunc.args = args\n newfunc.keywords = keywords\n return newfunc\n \ndef reduce(func,iterable,initializer=None):\n args = iter(iterable)\n if initializer is not None:\n  res = initializer\n else:\n  res = next(args)\n while True:\n  try:\n   res = func(res,next(args))\n  except StopIteration:\n   return res\n"], "logging": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\n\nimport sys, os, time, io, traceback, warnings, weakref\nfrom string import Template\n\n__all__ = ['BASIC_FORMAT', 'BufferingFormatter', 'CRITICAL', 'DEBUG', 'ERROR',\n'FATAL', 'FileHandler', 'Filter', 'Formatter', 'Handler', 'INFO',\n'LogRecord', 'Logger', 'LoggerAdapter', 'NOTSET', 'NullHandler',\n'StreamHandler', 'WARN', 'WARNING', 'addLevelName', 'basicConfig',\n'captureWarnings', 'critical', 'debug', 'disable', 'error',\n'exception', 'fatal', 'getLevelName', 'getLogger', 'getLoggerClass',\n'info', 'log', 'makeLogRecord', 'setLoggerClass', 'warn', 'warning',\n'getLogRecordFactory', 'setLogRecordFactory', 'lastResort']\n\ntry:\n import threading\nexcept ImportError: \n threading = None\n \n__author__ = \"Vinay Sajip <vinay_sajip@red-dove.com>\"\n__status__ = \"production\"\n__version__ = \"0.5.1.2\"\n__date__ = \"07 February 2010\"\n\n\n\n\n\n\n\n\n\nif hasattr(sys, 'frozen'): \n _srcfile = \"logging%s__init__%s\" % (os.sep, __file__[-4:])\nelse:\n _srcfile = __file__\n_srcfile = os.path.normcase(_srcfile)\n\n\nif hasattr(sys, '_getframe'):\n currentframe = lambda: sys._getframe(3)\nelse: \n def currentframe():\n  \"\"\n  try:\n   raise Exception\n  except:\n   return sys.exc_info()[2].tb_frame.f_back\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n_startTime = time.time()\n\n\n\n\n\nraiseExceptions = True\n\n\n\n\nlogThreads = True\n\n\n\n\nlogMultiprocessing = True\n\n\n\n\nlogProcesses = True\n\n\n\n\n\n\n\n\n\n\n\n\nCRITICAL = 50\nFATAL = CRITICAL\nERROR = 40\nWARNING = 30\nWARN = WARNING\nINFO = 20\nDEBUG = 10\nNOTSET = 0\n\n_levelNames = {\nCRITICAL : 'CRITICAL',\nERROR : 'ERROR',\nWARNING : 'WARNING',\nINFO : 'INFO',\nDEBUG : 'DEBUG',\nNOTSET : 'NOTSET',\n'CRITICAL' : CRITICAL,\n'ERROR' : ERROR,\n'WARN' : WARNING,\n'WARNING' : WARNING,\n'INFO' : INFO,\n'DEBUG' : DEBUG,\n'NOTSET' : NOTSET,\n}\n\ndef getLevelName(level):\n \"\"\n return _levelNames.get(level, (\"Level %s\" % level))\n \ndef addLevelName(level, levelName):\n \"\"\n _acquireLock()\n try: \n  _levelNames[level] = levelName\n  _levelNames[levelName] = level\n finally:\n  _releaseLock()\n  \ndef _checkLevel(level):\n if isinstance(level, int):\n  rv = level\n elif str(level) == level:\n  if level not in _levelNames:\n   raise ValueError(\"Unknown level: %r\" % level)\n  rv = _levelNames[level]\n else:\n  raise TypeError(\"Level not an integer or a valid string: %r\" % level)\n return rv\n \n \n \n \n \n \n \n \n \n \n \n \n \nif threading:\n _lock = threading.RLock()\nelse: \n _lock = None\n \n \ndef _acquireLock():\n \"\"\n if _lock:\n  _lock.acquire()\n  \ndef _releaseLock():\n \"\"\n if _lock:\n  _lock.release()\n  \n  \n  \n  \n  \nclass LogRecord(object):\n \"\"\n def __init__(self, name, level, pathname, lineno,\n msg, args, exc_info, func=None, sinfo=None, **kwargs):\n  \"\"\n  ct = time.time()\n  self.name = name\n  self.msg = msg\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if args and len(args) == 1 and isinstance(args[0], dict) and args[0]:\n   args = args[0]\n  self.args = args\n  self.levelname = getLevelName(level)\n  self.levelno = level\n  self.pathname = pathname\n  try:\n   self.filename = os.path.basename(pathname)\n   self.module = os.path.splitext(self.filename)[0]\n  except (TypeError, ValueError, AttributeError):\n   self.filename = pathname\n   self.module = \"Unknown module\"\n  self.exc_info = exc_info\n  self.exc_text = None \n  self.stack_info = sinfo\n  self.lineno = lineno\n  self.funcName = func\n  self.created = ct\n  self.msecs = (ct - int(ct)) * 1000\n  self.relativeCreated = (self.created - _startTime) * 1000\n  if logThreads and threading:\n   self.thread = threading.get_ident()\n   self.threadName = threading.current_thread().name\n  else: \n   self.thread = None\n   self.threadName = None\n  if not logMultiprocessing: \n   self.processName = None\n  else:\n   self.processName = 'MainProcess'\n   mp = sys.modules.get('multiprocessing')\n   if mp is not None:\n   \n   \n   \n   \n    try:\n     self.processName = mp.current_process().name\n    except Exception: \n     pass\n  if logProcesses and hasattr(os, 'getpid'):\n   self.process = os.getpid()\n  else:\n   self.process = None\n   \n def __str__(self):\n  return '<LogRecord: %s, %s, %s, %s, \"%s\">'%(self.name, self.levelno,\n  self.pathname, self.lineno, self.msg)\n  \n def getMessage(self):\n  \"\"\n  msg = str(self.msg)\n  if self.args:\n   msg = msg % self.args\n  return msg\n  \n  \n  \n  \n_logRecordFactory = LogRecord\n\ndef setLogRecordFactory(factory):\n \"\"\n global _logRecordFactory\n _logRecordFactory = factory\n \ndef getLogRecordFactory():\n \"\"\n \n return _logRecordFactory\n \ndef makeLogRecord(dict):\n \"\"\n rv = _logRecordFactory(None, None, \"\", 0, \"\", (), None, None)\n rv.__dict__.update(dict)\n return rv\n \n \n \n \n \nclass PercentStyle(object):\n\n default_format = '%(message)s'\n asctime_format = '%(asctime)s'\n asctime_search = '%(asctime)'\n \n def __init__(self, fmt):\n  self._fmt = fmt or self.default_format\n  \n def usesTime(self):\n  return self._fmt.find(self.asctime_search) >= 0\n  \n def format(self, record):\n  return self._fmt % record.__dict__\n  \nclass StrFormatStyle(PercentStyle):\n default_format = '{message}'\n asctime_format = '{asctime}'\n asctime_search = '{asctime'\n \n def format(self, record):\n  return self._fmt.format(**record.__dict__)\n  \n  \nclass StringTemplateStyle(PercentStyle):\n default_format = '${message}'\n asctime_format = '${asctime}'\n asctime_search = '${asctime}'\n \n def __init__(self, fmt):\n  self._fmt = fmt or self.default_format\n  self._tpl = Template(self._fmt)\n  \n def usesTime(self):\n  fmt = self._fmt\n  return fmt.find('$asctime') >= 0 or fmt.find(self.asctime_format) >= 0\n  \n def format(self, record):\n  return self._tpl.substitute(**record.__dict__)\n  \n_STYLES = {\n'%': PercentStyle,\n'{': StrFormatStyle,\n'$': StringTemplateStyle\n}\n\nclass Formatter(object):\n \"\"\n \n converter = time.localtime\n \n def __init__(self, fmt=None, datefmt=None, style='%'):\n  \"\"\n  if style not in _STYLES:\n   raise ValueError('Style must be one of: %s' % ','.join(\n   _STYLES.keys()))\n  self._style = _STYLES[style](fmt)\n  self._fmt = self._style._fmt\n  self.datefmt = datefmt\n  \n default_time_format = '%Y-%m-%d %H:%M:%S'\n default_msec_format = '%s,%03d'\n \n def formatTime(self, record, datefmt=None):\n  \"\"\n  ct = self.converter(record.created)\n  if datefmt:\n   s = time.strftime(datefmt, ct)\n  else:\n   t = time.strftime(self.default_time_format, ct)\n   s = self.default_msec_format % (t, record.msecs)\n  return s\n  \n def formatException(self, ei):\n  \"\"\n  sio = io.StringIO()\n  tb = ei[2]\n  \n  \n  \n  traceback.print_exception(ei[0], ei[1], tb, None, sio)\n  s = sio.getvalue()\n  sio.close()\n  if s[-1:] == \"\\n\":\n   s = s[:-1]\n  return s\n  \n def usesTime(self):\n  \"\"\n  return self._style.usesTime()\n  \n def formatMessage(self, record):\n  return self._style.format(record)\n  \n def formatStack(self, stack_info):\n  \"\"\n  return stack_info\n  \n def format(self, record):\n  \"\"\n  record.message = record.getMessage()\n  if self.usesTime():\n   record.asctime = self.formatTime(record, self.datefmt)\n  s = self.formatMessage(record)\n  if record.exc_info:\n  \n  \n   if not record.exc_text:\n    record.exc_text = self.formatException(record.exc_info)\n  if record.exc_text:\n   if s[-1:] != \"\\n\":\n    s = s + \"\\n\"\n   s = s + record.exc_text\n  if record.stack_info:\n   if s[-1:] != \"\\n\":\n    s = s + \"\\n\"\n   s = s + self.formatStack(record.stack_info)\n  return s\n  \n  \n  \n  \n_defaultFormatter = Formatter()\n\nclass BufferingFormatter(object):\n \"\"\n def __init__(self, linefmt=None):\n  \"\"\n  if linefmt:\n   self.linefmt = linefmt\n  else:\n   self.linefmt = _defaultFormatter\n   \n def formatHeader(self, records):\n  \"\"\n  return \"\"\n  \n def formatFooter(self, records):\n  \"\"\n  return \"\"\n  \n def format(self, records):\n  \"\"\n  rv = \"\"\n  if len(records) > 0:\n   rv = rv + self.formatHeader(records)\n   for record in records:\n    rv = rv + self.linefmt.format(record)\n   rv = rv + self.formatFooter(records)\n  return rv\n  \n  \n  \n  \n  \nclass Filter(object):\n \"\"\n def __init__(self, name=''):\n  \"\"\n  self.name = name\n  self.nlen = len(name)\n  \n def filter(self, record):\n  \"\"\n  if self.nlen == 0:\n   return True\n  elif self.name == record.name:\n   return True\n  elif record.name.find(self.name, 0, self.nlen) != 0:\n   return False\n  return (record.name[self.nlen] == \".\")\n  \nclass Filterer(object):\n \"\"\n def __init__(self):\n  \"\"\n  self.filters = []\n  \n def addFilter(self, filter):\n  \"\"\n  if not (filter in self.filters):\n   self.filters.append(filter)\n   \n def removeFilter(self, filter):\n  \"\"\n  if filter in self.filters:\n   self.filters.remove(filter)\n   \n def filter(self, record):\n  \"\"\n  rv = True\n  for f in self.filters:\n   if hasattr(f, 'filter'):\n    result = f.filter(record)\n   else:\n    result = f(record) \n   if not result:\n    rv = False\n    break\n  return rv\n  \n  \n  \n  \n  \n_handlers = weakref.WeakValueDictionary() \n_handlerList = [] \n\ndef _removeHandlerRef(wr):\n \"\"\n \n \n \n if (_acquireLock is not None and _handlerList is not None and\n _releaseLock is not None):\n  _acquireLock()\n  try:\n   if wr in _handlerList:\n    _handlerList.remove(wr)\n  finally:\n   _releaseLock()\n   \ndef _addHandlerRef(handler):\n \"\"\n _acquireLock()\n try:\n  _handlerList.append(weakref.ref(handler, _removeHandlerRef))\n finally:\n  _releaseLock()\n  \nclass Handler(Filterer):\n \"\"\n def __init__(self, level=NOTSET):\n  \"\"\n  Filterer.__init__(self)\n  self._name = None\n  self.level = _checkLevel(level)\n  self.formatter = None\n  \n  _addHandlerRef(self)\n  self.createLock()\n  \n def get_name(self):\n  return self._name\n  \n def set_name(self, name):\n  _acquireLock()\n  try:\n   if self._name in _handlers:\n    del _handlers[self._name]\n   self._name = name\n   if name:\n    _handlers[name] = self\n  finally:\n   _releaseLock()\n   \n name = property(get_name, set_name)\n \n def createLock(self):\n  \"\"\n  if threading:\n   self.lock = threading.RLock()\n  else: \n   self.lock = None\n   \n def acquire(self):\n  \"\"\n  if self.lock:\n   self.lock.acquire()\n   \n def release(self):\n  \"\"\n  if self.lock:\n   self.lock.release()\n   \n def setLevel(self, level):\n  \"\"\n  self.level = _checkLevel(level)\n  \n def format(self, record):\n  \"\"\n  if self.formatter:\n   fmt = self.formatter\n  else:\n   fmt = _defaultFormatter\n  return fmt.format(record)\n  \n def emit(self, record):\n  \"\"\n  raise NotImplementedError('emit must be implemented '\n  'by Handler subclasses')\n  \n def handle(self, record):\n  \"\"\n  rv = self.filter(record)\n  if rv:\n   self.acquire()\n   try:\n    self.emit(record)\n   finally:\n    self.release()\n  return rv\n  \n def setFormatter(self, fmt):\n  \"\"\n  self.formatter = fmt\n  \n def flush(self):\n  \"\"\n  pass\n  \n def close(self):\n  \"\"\n  \n  _acquireLock()\n  try: \n   if self._name and self._name in _handlers:\n    del _handlers[self._name]\n  finally:\n   _releaseLock()\n   \n def handleError(self, record):\n  \"\"\n  if raiseExceptions and sys.stderr: \n   ei = sys.exc_info()\n   try:\n    traceback.print_exception(ei[0], ei[1], ei[2],\n    None, sys.stderr)\n    sys.stderr.write('Logged from file %s, line %s\\n' % (\n    record.filename, record.lineno))\n   except IOError: \n    pass \n   finally:\n    del ei\n    \nclass StreamHandler(Handler):\n \"\"\n \n terminator = '\\n'\n \n def __init__(self, stream=None):\n  \"\"\n  Handler.__init__(self)\n  if stream is None:\n   stream = sys.stderr\n  self.stream = stream\n  \n def flush(self):\n  \"\"\n  self.acquire()\n  try:\n   if self.stream and hasattr(self.stream, \"flush\"):\n    self.stream.flush()\n  finally:\n   self.release()\n   \n def emit(self, record):\n  \"\"\n  try:\n   msg = self.format(record)\n   stream = self.stream\n   stream.write(msg)\n   stream.write(self.terminator)\n   self.flush()\n  except (KeyboardInterrupt, SystemExit): \n   raise\n  except:\n   self.handleError(record)\n   \nclass FileHandler(StreamHandler):\n \"\"\n def __init__(self, filename, mode='a', encoding=None, delay=False):\n  \"\"\n  \n  \n  self.baseFilename = os.path.abspath(filename)\n  self.mode = mode\n  self.encoding = encoding\n  self.delay = delay\n  if delay:\n  \n  \n   Handler.__init__(self)\n   self.stream = None\n  else:\n   StreamHandler.__init__(self, self._open())\n   \n def close(self):\n  \"\"\n  self.acquire()\n  try:\n   if self.stream:\n    self.flush()\n    if hasattr(self.stream, \"close\"):\n     self.stream.close()\n    StreamHandler.close(self)\n    self.stream = None\n  finally:\n   self.release()\n   \n def _open(self):\n  \"\"\n  return open(self.baseFilename, self.mode, encoding=self.encoding)\n  \n def emit(self, record):\n  \"\"\n  if self.stream is None:\n   self.stream = self._open()\n  StreamHandler.emit(self, record)\n  \nclass _StderrHandler(StreamHandler):\n \"\"\n def __init__(self, level=NOTSET):\n  \"\"\n  Handler.__init__(self, level)\n  \n @property\n def stream(self):\n  return sys.stderr\n  \n  \n_defaultLastResort = _StderrHandler(WARNING)\nlastResort = _defaultLastResort\n\n\n\n\n\nclass PlaceHolder(object):\n \"\"\n def __init__(self, alogger):\n  \"\"\n  self.loggerMap = { alogger : None }\n  \n def append(self, alogger):\n  \"\"\n  if alogger not in self.loggerMap:\n   self.loggerMap[alogger] = None\n   \n   \n   \n   \n_loggerClass = None\n\ndef setLoggerClass(klass):\n \"\"\n if klass != Logger:\n  if not issubclass(klass, Logger):\n   raise TypeError(\"logger not derived from logging.Logger: \"\n   + klass.__name__)\n global _loggerClass\n _loggerClass = klass\n \ndef getLoggerClass():\n \"\"\n \n return _loggerClass\n \nclass Manager(object):\n \"\"\n def __init__(self, rootnode):\n  \"\"\n  self.root = rootnode\n  self.disable = 0\n  self.emittedNoHandlerWarning = False\n  self.loggerDict = {}\n  self.loggerClass = None\n  self.logRecordFactory = None\n  \n def getLogger(self, name):\n  \"\"\n  rv = None\n  if not isinstance(name, str):\n   raise TypeError('A logger name must be a string')\n  _acquireLock()\n  try:\n   if name in self.loggerDict:\n    rv = self.loggerDict[name]\n    if isinstance(rv, PlaceHolder):\n     ph = rv\n     rv = (self.loggerClass or _loggerClass)(name)\n     rv.manager = self\n     self.loggerDict[name] = rv\n     self._fixupChildren(ph, rv)\n     self._fixupParents(rv)\n   else:\n    rv = (self.loggerClass or _loggerClass)(name)\n    rv.manager = self\n    self.loggerDict[name] = rv\n    self._fixupParents(rv)\n  finally:\n   _releaseLock()\n  return rv\n  \n def setLoggerClass(self, klass):\n  \"\"\n  if klass != Logger:\n   if not issubclass(klass, Logger):\n    raise TypeError(\"logger not derived from logging.Logger: \"\n    + klass.__name__)\n  self.loggerClass = klass\n  \n def setLogRecordFactory(self, factory):\n  \"\"\n  self.logRecordFactory = factory\n  \n def _fixupParents(self, alogger):\n  \"\"\n  name = alogger.name\n  i = name.rfind(\".\")\n  rv = None\n  while (i > 0) and not rv:\n   substr = name[:i]\n   if substr not in self.loggerDict:\n    self.loggerDict[substr] = PlaceHolder(alogger)\n   else:\n    obj = self.loggerDict[substr]\n    if isinstance(obj, Logger):\n     rv = obj\n    else:\n     assert isinstance(obj, PlaceHolder)\n     obj.append(alogger)\n   i = name.rfind(\".\", 0, i - 1)\n  if not rv:\n   rv = self.root\n  alogger.parent = rv\n  \n def _fixupChildren(self, ph, alogger):\n  \"\"\n  name = alogger.name\n  namelen = len(name)\n  for c in ph.loggerMap.keys():\n  \n   if c.parent.name[:namelen] != name:\n    alogger.parent = c.parent\n    c.parent = alogger\n    \n    \n    \n    \n    \nclass Logger(Filterer):\n \"\"\n def __init__(self, name, level=NOTSET):\n  \"\"\n  Filterer.__init__(self)\n  self.name = name\n  self.level = _checkLevel(level)\n  self.parent = None\n  self.propagate = True\n  self.handlers = []\n  self.disabled = False\n  \n def setLevel(self, level):\n  \"\"\n  self.level = _checkLevel(level)\n  \n def debug(self, msg, *args, **kwargs):\n  \"\"\n  if self.isEnabledFor(DEBUG):\n   self._log(DEBUG, msg, args, **kwargs)\n   \n def info(self, msg, *args, **kwargs):\n  \"\"\n  if self.isEnabledFor(INFO):\n   self._log(INFO, msg, args, **kwargs)\n   \n def warning(self, msg, *args, **kwargs):\n  \"\"\n  if self.isEnabledFor(WARNING):\n   self._log(WARNING, msg, args, **kwargs)\n   \n def warn(self, msg, *args, **kwargs):\n  warnings.warn(\"The 'warn' method is deprecated, \"\n  \"use 'warning' instead\", DeprecationWarning, 2)\n  self.warning(msg, *args, **kwargs)\n  \n def error(self, msg, *args, **kwargs):\n  \"\"\n  if self.isEnabledFor(ERROR):\n   self._log(ERROR, msg, args, **kwargs)\n   \n def exception(self, msg, *args, **kwargs):\n  \"\"\n  kwargs['exc_info'] = True\n  self.error(msg, *args, **kwargs)\n  \n def critical(self, msg, *args, **kwargs):\n  \"\"\n  if self.isEnabledFor(CRITICAL):\n   self._log(CRITICAL, msg, args, **kwargs)\n   \n fatal = critical\n \n def log(self, level, msg, *args, **kwargs):\n  \"\"\n  if not isinstance(level, int):\n   if raiseExceptions:\n    raise TypeError(\"level must be an integer\")\n   else:\n    return\n  if self.isEnabledFor(level):\n   self._log(level, msg, args, **kwargs)\n   \n def findCaller(self, stack_info=False):\n  \"\"\n  f = currentframe()\n  \n  \n  if f is not None:\n   f = f.f_back\n  rv = \"(unknown file)\", 0, \"(unknown function)\", None\n  while hasattr(f, \"f_code\"):\n   co = f.f_code\n   filename = os.path.normcase(co.co_filename)\n   if filename == _srcfile:\n    f = f.f_back\n    continue\n   sinfo = None\n   if stack_info:\n    sio = io.StringIO()\n    sio.write('Stack (most recent call last):\\n')\n    traceback.print_stack(f, file=sio)\n    sinfo = sio.getvalue()\n    if sinfo[-1] == '\\n':\n     sinfo = sinfo[:-1]\n    sio.close()\n   rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)\n   break\n  return rv\n  \n def makeRecord(self, name, level, fn, lno, msg, args, exc_info,\n func=None, extra=None, sinfo=None):\n  \"\"\n  rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,\n  sinfo)\n  if extra is not None:\n   for key in extra:\n    if (key in [\"message\", \"asctime\"]) or (key in rv.__dict__):\n     raise KeyError(\"Attempt to overwrite %r in LogRecord\" % key)\n    rv.__dict__[key] = extra[key]\n  return rv\n  \n def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False):\n  \"\"\n  sinfo = None\n  if _srcfile:\n  \n  \n  \n   try:\n    fn, lno, func, sinfo = self.findCaller(stack_info)\n   except ValueError: \n    fn, lno, func = \"(unknown file)\", 0, \"(unknown function)\"\n  else: \n   fn, lno, func = \"(unknown file)\", 0, \"(unknown function)\"\n  if exc_info:\n   if not isinstance(exc_info, tuple):\n    exc_info = sys.exc_info()\n  record = self.makeRecord(self.name, level, fn, lno, msg, args,\n  exc_info, func, extra, sinfo)\n  self.handle(record)\n  \n def handle(self, record):\n  \"\"\n  if (not self.disabled) and self.filter(record):\n   self.callHandlers(record)\n   \n def addHandler(self, hdlr):\n  \"\"\n  _acquireLock()\n  try:\n   if not (hdlr in self.handlers):\n    self.handlers.append(hdlr)\n  finally:\n   _releaseLock()\n   \n def removeHandler(self, hdlr):\n  \"\"\n  _acquireLock()\n  try:\n   if hdlr in self.handlers:\n    self.handlers.remove(hdlr)\n  finally:\n   _releaseLock()\n   \n def hasHandlers(self):\n  \"\"\n  c = self\n  rv = False\n  while c:\n   if c.handlers:\n    rv = True\n    break\n   if not c.propagate:\n    break\n   else:\n    c = c.parent\n  return rv\n  \n def callHandlers(self, record):\n  \"\"\n  c = self\n  found = 0\n  while c:\n   for hdlr in c.handlers:\n    found = found + 1\n    if record.levelno >= hdlr.level:\n     hdlr.handle(record)\n   if not c.propagate:\n    c = None \n   else:\n    c = c.parent\n  if (found == 0):\n   if lastResort:\n    if record.levelno >= lastResort.level:\n     lastResort.handle(record)\n   elif raiseExceptions and not self.manager.emittedNoHandlerWarning:\n    sys.stderr.write(\"No handlers could be found for logger\"\n    \" \\\"%s\\\"\\n\" % self.name)\n    self.manager.emittedNoHandlerWarning = True\n    \n def getEffectiveLevel(self):\n  \"\"\n  logger = self\n  while logger:\n   if logger.level:\n    return logger.level\n   logger = logger.parent\n  return NOTSET\n  \n def isEnabledFor(self, level):\n  \"\"\n  if self.manager.disable >= level:\n   return False\n  return level >= self.getEffectiveLevel()\n  \n def getChild(self, suffix):\n  \"\"\n  if self.root is not self:\n   suffix = '.'.join((self.name, suffix))\n  return self.manager.getLogger(suffix)\n  \nclass RootLogger(Logger):\n \"\"\n def __init__(self, level):\n  \"\"\n  Logger.__init__(self, \"root\", level)\n  \n_loggerClass = Logger\n\nclass LoggerAdapter(object):\n \"\"\n \n def __init__(self, logger, extra):\n  \"\"\n  self.logger = logger\n  self.extra = extra\n  \n def process(self, msg, kwargs):\n  \"\"\n  kwargs[\"extra\"] = self.extra\n  return msg, kwargs\n  \n  \n  \n  \n def debug(self, msg, *args, **kwargs):\n  \"\"\n  self.log(DEBUG, msg, *args, **kwargs)\n  \n def info(self, msg, *args, **kwargs):\n  \"\"\n  self.log(INFO, msg, *args, **kwargs)\n  \n def warning(self, msg, *args, **kwargs):\n  \"\"\n  self.log(WARNING, msg, *args, **kwargs)\n  \n def warn(self, msg, *args, **kwargs):\n  warnings.warn(\"The 'warn' method is deprecated, \"\n  \"use 'warning' instead\", DeprecationWarning, 2)\n  self.warning(msg, *args, **kwargs)\n  \n def error(self, msg, *args, **kwargs):\n  \"\"\n  self.log(ERROR, msg, *args, **kwargs)\n  \n def exception(self, msg, *args, **kwargs):\n  \"\"\n  kwargs[\"exc_info\"] = True\n  self.log(ERROR, msg, *args, **kwargs)\n  \n def critical(self, msg, *args, **kwargs):\n  \"\"\n  self.log(CRITICAL, msg, *args, **kwargs)\n  \n def log(self, level, msg, *args, **kwargs):\n  \"\"\n  if self.isEnabledFor(level):\n   msg, kwargs = self.process(msg, kwargs)\n   self.logger._log(level, msg, args, **kwargs)\n   \n def isEnabledFor(self, level):\n  \"\"\n  if self.logger.manager.disable >= level:\n   return False\n  return level >= self.getEffectiveLevel()\n  \n def setLevel(self, level):\n  \"\"\n  self.logger.setLevel(level)\n  \n def getEffectiveLevel(self):\n  \"\"\n  return self.logger.getEffectiveLevel()\n  \n def hasHandlers(self):\n  \"\"\n  return self.logger.hasHandlers()\n  \nroot = RootLogger(WARNING)\nLogger.root = root\nLogger.manager = Manager(Logger.root)\n\n\n\n\n\nBASIC_FORMAT = \"%(levelname)s:%(name)s:%(message)s\"\n\ndef basicConfig(**kwargs):\n \"\"\n \n \n _acquireLock()\n try:\n  if len(root.handlers) == 0:\n   handlers = kwargs.get(\"handlers\")\n   if handlers is None:\n    if \"stream\" in kwargs and \"filename\" in kwargs:\n     raise ValueError(\"'stream' and 'filename' should not be \"\n     \"specified together\")\n   else:\n    if \"stream\" in kwargs or \"filename\" in kwargs:\n     raise ValueError(\"'stream' or 'filename' should not be \"\n     \"specified together with 'handlers'\")\n   if handlers is None:\n    filename = kwargs.get(\"filename\")\n    if filename:\n     mode = kwargs.get(\"filemode\", 'a')\n     h = FileHandler(filename, mode)\n    else:\n     stream = kwargs.get(\"stream\")\n     h = StreamHandler(stream)\n    handlers = [h]\n   fs = kwargs.get(\"format\", BASIC_FORMAT)\n   dfs = kwargs.get(\"datefmt\", None)\n   style = kwargs.get(\"style\", '%')\n   fmt = Formatter(fs, dfs, style)\n   for h in handlers:\n    if h.formatter is None:\n     h.setFormatter(fmt)\n    root.addHandler(h)\n   level = kwargs.get(\"level\")\n   if level is not None:\n    root.setLevel(level)\n finally:\n  _releaseLock()\n  \n  \n  \n  \n  \n  \ndef getLogger(name=None):\n \"\"\n if name:\n  return Logger.manager.getLogger(name)\n else:\n  return root\n  \ndef critical(msg, *args, **kwargs):\n \"\"\n if len(root.handlers) == 0:\n  basicConfig()\n root.critical(msg, *args, **kwargs)\n \nfatal = critical\n\ndef error(msg, *args, **kwargs):\n \"\"\n if len(root.handlers) == 0:\n  basicConfig()\n root.error(msg, *args, **kwargs)\n \ndef exception(msg, *args, **kwargs):\n \"\"\n kwargs['exc_info'] = True\n error(msg, *args, **kwargs)\n \ndef warning(msg, *args, **kwargs):\n \"\"\n if len(root.handlers) == 0:\n  basicConfig()\n root.warning(msg, *args, **kwargs)\n \ndef warn(msg, *args, **kwargs):\n warnings.warn(\"The 'warn' function is deprecated, \"\n \"use 'warning' instead\", DeprecationWarning, 2)\n warning(msg, *args, **kwargs)\n \ndef info(msg, *args, **kwargs):\n \"\"\n if len(root.handlers) == 0:\n  basicConfig()\n root.info(msg, *args, **kwargs)\n \ndef debug(msg, *args, **kwargs):\n \"\"\n if len(root.handlers) == 0:\n  basicConfig()\n root.debug(msg, *args, **kwargs)\n \ndef log(level, msg, *args, **kwargs):\n \"\"\n if len(root.handlers) == 0:\n  basicConfig()\n root.log(level, msg, *args, **kwargs)\n \ndef disable(level):\n \"\"\n root.manager.disable = level\n \ndef shutdown(handlerList=_handlerList):\n \"\"\n for wr in reversed(handlerList[:]):\n \n \n  try:\n   h = wr()\n   if h:\n    try:\n     h.acquire()\n     h.flush()\n     h.close()\n    except (IOError, ValueError):\n    \n    \n    \n    \n     pass\n    finally:\n     h.release()\n  except:\n   if raiseExceptions:\n    raise\n    \n    \n    \nimport atexit\natexit.register(shutdown)\n\n\n\nclass NullHandler(Handler):\n \"\"\n def handle(self, record):\n  \"\"\n  \n def emit(self, record):\n  \"\"\n  \n def createLock(self):\n  self.lock = None\n  \n  \n  \n_warnings_showwarning = None\n\ndef _showwarning(message, category, filename, lineno, file=None, line=None):\n \"\"\n if file is not None:\n  if _warnings_showwarning is not None:\n   _warnings_showwarning(message, category, filename, lineno, file, line)\n else:\n  s = warnings.formatwarning(message, category, filename, lineno, line)\n  logger = getLogger(\"py.warnings\")\n  if not logger.handlers:\n   logger.addHandler(NullHandler())\n  logger.warning(\"%s\", s)\n  \ndef captureWarnings(capture):\n \"\"\n global _warnings_showwarning\n if capture:\n  if _warnings_showwarning is None:\n   _warnings_showwarning = warnings.showwarning\n   warnings.showwarning = _showwarning\n else:\n  if _warnings_showwarning is not None:\n   warnings.showwarning = _warnings_showwarning\n   _warnings_showwarning = None\n", 1], "socket": [".py", "\n\n\n\"\"\n\nimport _socket\nfrom _socket import *\n\nimport os, sys, io\n\ntry:\n import errno\nexcept ImportError:\n errno = None\nEBADF = getattr(errno, 'EBADF', 9)\nEAGAIN = getattr(errno, 'EAGAIN', 11)\nEWOULDBLOCK = getattr(errno, 'EWOULDBLOCK', 11)\n\n__all__ = [\"getfqdn\", \"create_connection\"]\n__all__.extend(os._get_exports_list(_socket))\n\n\n_realsocket = socket\n\n\nif sys.platform.lower().startswith(\"win\"):\n errorTab = {}\n errorTab[10004] = \"The operation was interrupted.\"\n errorTab[10009] = \"A bad file handle was passed.\"\n errorTab[10013] = \"Permission denied.\"\n errorTab[10014] = \"A fault occurred on the network??\" \n errorTab[10022] = \"An invalid operation was attempted.\"\n errorTab[10035] = \"The socket operation would block\"\n errorTab[10036] = \"A blocking operation is already in progress.\"\n errorTab[10048] = \"The network address is in use.\"\n errorTab[10054] = \"The connection has been reset.\"\n errorTab[10058] = \"The network has been shut down.\"\n errorTab[10060] = \"The operation timed out.\"\n errorTab[10061] = \"Connection refused.\"\n errorTab[10063] = \"The name is too long.\"\n errorTab[10064] = \"The host is down.\"\n errorTab[10065] = \"The host is unreachable.\"\n __all__.append(\"errorTab\")\n \n \nclass socket(_socket.socket):\n\n \"\"\n \n __slots__ = [\"__weakref__\", \"_io_refs\", \"_closed\"]\n \n def __init__(self, family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None):\n  _socket.socket.__init__(self, family, type, proto, fileno)\n  self._io_refs = 0\n  self._closed = False\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self, *args):\n  if not self._closed:\n   self.close()\n   \n def __repr__(self):\n  \"\"\n  s = _socket.socket.__repr__(self)\n  if s.startswith(\"<socket object\"):\n   s = \"<%s.%s%s%s\" % (self.__class__.__module__,\n   self.__class__.__name__,\n   getattr(self, '_closed', False) and \" [closed] \" or \"\",\n   s[7:])\n  return s\n  \n def __getstate__(self):\n  raise TypeError(\"Cannot serialize socket object\")\n  \n def dup(self):\n  \"\"\n  fd = dup(self.fileno())\n  sock = self.__class__(self.family, self.type, self.proto, fileno=fd)\n  sock.settimeout(self.gettimeout())\n  return sock\n  \n def accept(self):\n  \"\"\n  fd, addr = self._accept()\n  sock = socket(self.family, self.type, self.proto, fileno=fd)\n  \n  \n  \n  if getdefaulttimeout() is None and self.gettimeout():\n   sock.setblocking(True)\n  return sock, addr\n  \n def makefile(self, mode=\"r\", buffering=None, *,\n encoding=None, errors=None, newline=None):\n  \"\"\n  for c in mode:\n   if c not in {\"r\", \"w\", \"b\"}:\n    raise ValueError(\"invalid mode %r (only r, w, b allowed)\")\n  writing = \"w\" in mode\n  reading = \"r\" in mode or not writing\n  assert reading or writing\n  binary = \"b\" in mode\n  rawmode = \"\"\n  if reading:\n   rawmode += \"r\"\n  if writing:\n   rawmode += \"w\"\n  raw = SocketIO(self, rawmode)\n  self._io_refs += 1\n  if buffering is None:\n   buffering = -1\n  if buffering < 0:\n   buffering = io.DEFAULT_BUFFER_SIZE\n  if buffering == 0:\n   if not binary:\n    raise ValueError(\"unbuffered streams must be binary\")\n   return raw\n  if reading and writing:\n   buffer = io.BufferedRWPair(raw, raw, buffering)\n  elif reading:\n   buffer = io.BufferedReader(raw, buffering)\n  else:\n   assert writing\n   buffer = io.BufferedWriter(raw, buffering)\n  if binary:\n   return buffer\n  text = io.TextIOWrapper(buffer, encoding, errors, newline)\n  text.mode = mode\n  return text\n  \n def _decref_socketios(self):\n  if self._io_refs > 0:\n   self._io_refs -= 1\n  if self._closed:\n   self.close()\n   \n def _real_close(self, _ss=_socket.socket):\n \n  _ss.close(self)\n  \n def close(self):\n \n  self._closed = True\n  if self._io_refs <= 0:\n   self._real_close()\n   \n def detach(self):\n  \"\"\n  self._closed = True\n  return super().detach()\n  \ndef fromfd(fd, family, type, proto=0):\n \"\"\n nfd = dup(fd)\n return socket(family, type, proto, nfd)\n \nif hasattr(_socket.socket, \"share\"):\n def fromshare(info):\n  \"\"\n  return socket(0, 0, 0, info)\n  \nif hasattr(_socket, \"socketpair\"):\n\n def socketpair(family=None, type=SOCK_STREAM, proto=0):\n  \"\"\n  if family is None:\n   try:\n    family = AF_UNIX\n   except NameError:\n    family = AF_INET\n  a, b = _socket.socketpair(family, type, proto)\n  a = socket(family, type, proto, a.detach())\n  b = socket(family, type, proto, b.detach())\n  return a, b\n  \n  \n_blocking_errnos = { EAGAIN, EWOULDBLOCK }\n\nclass SocketIO(io.RawIOBase):\n\n \"\"\n \n \n \n \n \n \n \n \n \n \n def __init__(self, sock, mode):\n  if mode not in (\"r\", \"w\", \"rw\", \"rb\", \"wb\", \"rwb\"):\n   raise ValueError(\"invalid mode: %r\" % mode)\n  io.RawIOBase.__init__(self)\n  self._sock = sock\n  if \"b\" not in mode:\n   mode += \"b\"\n  self._mode = mode\n  self._reading = \"r\" in mode\n  self._writing = \"w\" in mode\n  self._timeout_occurred = False\n  \n def readinto(self, b):\n  \"\"\n  self._checkClosed()\n  self._checkReadable()\n  if self._timeout_occurred:\n   raise IOError(\"cannot read from timed out object\")\n  while True:\n   try:\n    return self._sock.recv_into(b)\n   except timeout:\n    self._timeout_occurred = True\n    raise\n   except InterruptedError:\n    continue\n   except error as e:\n    if e.args[0] in _blocking_errnos:\n     return None\n    raise\n    \n def write(self, b):\n  \"\"\n  self._checkClosed()\n  self._checkWritable()\n  try:\n   return self._sock.send(b)\n  except error as e:\n  \n   if e.args[0] in _blocking_errnos:\n    return None\n   raise\n   \n def readable(self):\n  \"\"\n  if self.closed:\n   raise ValueError(\"I/O operation on closed socket.\")\n  return self._reading\n  \n def writable(self):\n  \"\"\n  if self.closed:\n   raise ValueError(\"I/O operation on closed socket.\")\n  return self._writing\n  \n def seekable(self):\n  \"\"\n  if self.closed:\n   raise ValueError(\"I/O operation on closed socket.\")\n  return super().seekable()\n  \n def fileno(self):\n  \"\"\n  self._checkClosed()\n  return self._sock.fileno()\n  \n @property\n def name(self):\n  if not self.closed:\n   return self.fileno()\n  else:\n   return -1\n   \n @property\n def mode(self):\n  return self._mode\n  \n def close(self):\n  \"\"\n  if self.closed:\n   return\n  io.RawIOBase.close(self)\n  self._sock._decref_socketios()\n  self._sock = None\n  \n  \ndef getfqdn(name=''):\n \"\"\n name = name.strip()\n if not name or name == '0.0.0.0':\n  name = gethostname()\n try:\n  hostname, aliases, ipaddrs = gethostbyaddr(name)\n except error:\n  pass\n else:\n  aliases.insert(0, hostname)\n  for name in aliases:\n   if '.' in name:\n    break\n  else:\n   name = hostname\n return name\n \n \n_GLOBAL_DEFAULT_TIMEOUT = object()\n\ndef create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\nsource_address=None):\n \"\"\n \n host, port = address\n err = None\n for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n  af, socktype, proto, canonname, sa = res\n  sock = None\n  try:\n   sock = socket(af, socktype, proto)\n   if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n    sock.settimeout(timeout)\n   if source_address:\n    sock.bind(source_address)\n   sock.connect(sa)\n   return sock\n   \n  except error as _:\n   err = _\n   if sock is not None:\n    sock.close()\n    \n if err is not None:\n  raise err\n else:\n  raise error(\"getaddrinfo returns an empty list\")\n"], "xml.etree": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", 1], "traceback": [".py", "import sys\ndef print_exc(file=sys.stderr):\n exc = __BRYTHON__.exception_stack[-1]\n file.write(exc.info)\n file.write('\\n'+exc.__name__)\n if exc.message:\n  file.write(': '+exc.message)\n file.write('\\n')\n \ndef format_exc(limit=None,chain=True):\n exc = __BRYTHON__.exception_stack[-1]\n res = exc.info+'\\n'+exc.__name__\n if exc.message:\n  res += ': '+exc.message\n return res+'\\n'\n \ndef format_exception(_type, value, tb, limit=None, chain=True):\n return ['%s\\n' %_type,'%s\\n' %value] \n"], "long_int": [".js", "/*\nModule to manipulate long integers\n*/\n\nvar $module=(function($B){\n\neval($B.InjectBuiltins())\n\nvar $LongIntDict = {__class__:$B.$type,__name__:'LongInt'}\n\nfunction add_pos(v1, v2){\n    // Add two positive numbers\n    // v1, v2 : strings\n    // Return an instance of LongInt\n\n    var res = '', carry = 0, iself=v1.length, sv=0\n    for(var i=v2.length-1;i>=0;i--){\n        iself--\n        if(iself<0){sv=0}else{sv=parseInt(v1.charAt(iself))}\n        x = (carry+sv+parseInt(v2.charAt(i))).toString()\n        if(x.length==2){res=x.charAt(1)+res;carry=parseInt(x.charAt(0))}\n        else{res=x+res;carry=0}\n    }\n    while(iself>0){\n        iself--\n        x = (carry+parseInt(v1.charAt(iself))).toString()\n        if(x.length==2){res=x.charAt(1)+res;carry=parseInt(x.charAt(0))}\n        else{res=x+res;carry=0}\n    }\n    if(carry){res=carry+res}        \n    return {__class__:$LongIntDict, value:res, pos:true}\n}\n\nfunction check_shift(shift){\n    // Check the argument of >> and <<\n    if(!isinstance(shift, LongInt)){\n        throw TypeError(\"shift must be LongInt, not '\"+\n            $B.get_class(shift).__name__+\"'\")\n    }\n    if(!shift.pos){throw ValueError(\"negative shift count\")}\n}\n\nfunction clone(obj){\n    // Used for traces\n    var obj1 = {}\n    for(var attr in obj){obj1[attr]=obj[attr]}\n    return obj1\n}\n\nfunction comp_pos(v1, v2){\n    // Compare two positive numbers\n    if(v1.length>v2.length){return 1}\n    else if(v1.length<v2.length){return -1}\n    else{\n        if(v1>v2){return 1}\n        else if(v1<v2){return -1}\n    }\n    return 0\n}\n\nfunction divmod_pos(v1, v2){\n    // v1, v2 : strings, represent 2 positive integers A and B\n    // Return [a, b] where a and b are instances of LongInt\n    // a = A // B, b = A % B\n    var v1_init = v1, quotient, mod\n    if(comp_pos(v1, v2)==-1){ // a < b\n        quotient='0'\n        mod = LongInt(v1)\n    }else if(v2==v1){ // a = b\n        quotient = '1';\n        mod = LongInt('0')\n    }else{\n        var quotient = '', v1_init = v1\n        // mv2 maps integers i from 2 to 9 to i*v2\n        var mv2 = {}\n        // Javascript \"safe integer\" with the 15 first digits in v2,\n        // used in the algorithm to test candidate values\n        var jsv2 = parseInt(v2.substr(0,15))\n\n        // Division algorithm\n        while(comp_pos(v1,v2)>-1){\n            // At each step in the division, v1 is split into substrings\n            // \"left\" is the left part, with the same length as v2\n            // \"rest\" is the rest of v1 after \"left\"\n            // The algorithm finds the one-digit integer \"candidate\" such\n            // that 0 <= left - candidate*v2 < v2\n            // It stops when left < v2\n            var left = v1.substr(0, v2.length)\n            if(left<v2){\n                if(left.length<v2.length){\n                    if(quotient==''){quotient='0'}\n                    // v1 is lesser than v2 : division is finished\n                    break\n                }\n                else{\n                    left+=v1.charAt(v2.length)\n                }\n            }\n            var rest = v1.substr(left.length)\n            // use JS division to test an approximate result\n            jsleft = parseInt(left.substr(0,15))\n            var candidate = Math.floor(jsleft/jsv2).toString()\n            if(mv2[candidate]===undefined){\n                mv2[candidate] = mul_pos(v2, candidate).value\n            }\n            if(comp_pos(left, mv2[candidate])==-1){\n                // If left < candidate * v2, use candidate-1\n                candidate--\n                if(mv2[candidate]===undefined){\n                    mv2[candidate] = mul_pos(v2, candidate).value\n                }\n            }\n            // Add candidate to the quotient\n            quotient += candidate\n            // New value for left : left - v2*candidate\n            left = sub_pos(left, mv2[candidate]).value\n            // New value for v1\n            v1 = left+rest\n        }\n        // Modulo is A - (A//B)*B\n        mod = sub_pos(v1_init, mul_pos(quotient, v2).value)\n    }\n    return [LongInt(quotient), mod]\n}\n\nfunction mul_pos(v1, v2){\n    // Multiply positive numbers v1 by v2\n    // Make v2 smaller than v1\n    if(v1.length<v2.length){var a=v1; v1=v2 ; v2=a}\n    if(v2=='0'){return LongInt('0')}\n    var cols = {}, i=v2.length, j\n    \n    // Built the object \"cols\", indexed by integers from 1 to nb1+nb2-2\n    // where nb1 and nb2 are the number of digits in v1 and v2.\n    // cols[n] is the sum of v1[i]*v2[j] for i+j = n\n    \n    while(i--){\n        var car = v2.charAt(i)\n        if(car==\"0\"){\n            j = v1.length\n            while(j--){\n                if(cols[i+j]===undefined){cols[i+j]=0}\n            }        \n        }else if(car==\"1\"){\n            j = v1.length\n            while(j--){\n                var z = parseInt(v1.charAt(j))\n                if(cols[i+j]===undefined){cols[i+j]=z}\n                else{cols[i+j] += z}\n            }\n        }else{\n            var x = parseInt(car), j = v1.length, y, z\n            while(j--){\n                y = x * parseInt(v1.charAt(j))\n                if(cols[i+j]===undefined){cols[i+j]=y}\n                else{cols[i+j] += y}\n            }\n        }\n    }\n\n    // Transform cols so that cols[x] is a one-digit integers\n    i = v1.length+v2.length-1\n    while(i--){\n        var col = cols[i].toString()\n        if(col.length>1){\n            // If the value in cols[i] has more than one digit, only keep the\n            // last one and report the others at the right index\n            // For instance if cols[i] = 123, keep 3 in cols[i], add 2 to\n            // cols[i-1] and 1 to cols[i-2]\n            cols[i] = parseInt(col.charAt(col.length-1))\n            j = col.length\n            while(j-->1){\n                var report = parseInt(col.charAt(j-1))\n                var pos = i-col.length+j\n                if(cols[pos]===undefined){cols[pos]=report}\n                else{cols[pos] += report}\n            }\n        }\n    }\n\n    // Find minimum index in cols\n    // The previous loop may have introduced negative indices\n    var imin\n    for(var attr in cols){\n        i = parseInt(attr)\n        if(imin===undefined){imin=i}\n        else if(i<imin){imin=i}\n    }\n\n    // Result is the concatenation of digits in cols\n    var res = ''\n    for(var i=imin;i<=v1.length+v2.length-2;i++){res+=cols[i].toString()}\n    return LongInt(res)\n}\n\nfunction sub_pos(v1, v2){\n    // Substraction of positive numbers with v1>=v2\n\n    var res = '', carry = 0, i1=v1.length, sv=0\n    \n    // For all digits in v2, starting by the rightmost, substract it from\n    // the matching digit in v1\n    // This is the equivalent of the manual operation :\n    //    12345678\n    //   -   98765\n    //\n    // We begin by the rightmost operation : 8-5 (3, no carry),\n    // then 7-6 (1, no carry)\n    // then 6-7 (9, carry 1) and so on\n    for(var i=v2.length-1;i>=0;i--){\n        i1--\n        sv = parseInt(v1.charAt(i1))\n        x = (sv-carry-parseInt(v2.charAt(i)))\n        if(x<0){res=(10+x)+res;carry=1}\n        else{res=x+res;carry=0}\n    }\n    \n    // If there are remaining digits in v1, substract the carry, if any\n    while(i1>0){\n        i1--\n        x = (parseInt(v1.charAt(i1))-carry)\n        if(x<0){res=(10+x)+res;carry=1}\n        else{res=x+res;carry=0}\n    }\n\n    // Remove leading zeros and return the result\n    while(res.charAt(0)=='0' && res.length>1){res=res.substr(1)}\n    return {__class__:$LongIntDict, value:res, pos:true}\n}\n\n// Special methods to implement operations on instances of LongInt\n\n$LongIntDict.__abs__ = function(self){\n    return {__class__:$LongIntDict, value: self.value, pos:true}\n}\n\n$LongIntDict.__add__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str(other))\n    // Addition of \"self\" and \"other\"\n    // If both have the same sign (+ or -) we add their absolute values\n    // If they have different sign we use the substraction of their\n    // absolute values\n    var res\n    if(self.pos&&other.pos){  // self > 0, other > 0\n        return add_pos(self.value, other.value)\n    }else if(!self.pos&&!other.pos){ // self < 0, other < 0\n        res = add_pos(self.value, other.value)\n        res.pos = false\n        return res\n    }else if(self.pos && !other.pos){ // self > 0, other < 0\n        switch (comp_pos(self.value, other.value)){\n            case 1:\n                res = sub_pos(self.value, other.value)\n                break\n            case 0:\n                res = {__class__:$LongIntDict, value:0, pos:true}\n                break\n            case -1:\n                res = sub_pos(other.value, self.value)\n                res.pos = false\n                break\n        }\n        return res\n    }else{ // self < 0, other > 0\n        switch(comp_pos(self.value, other.value)){\n            case 1:\n                res = sub_pos(self.value, other.value)\n                res.pos = false\n                break\n            case 0:\n                res = {__class__:$LongIntDict, value:0, pos:true}\n                break\n            case -1:\n                res = sub_pos(other.value, self.value)\n                break\n        }\n        return res\n    }\n}\n\n$LongIntDict.__and__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str(other))\n    // Bitwise \"and\" : build the binary representation of self and other\n    var v1 = $LongIntDict.__index__(self)\n    var v2 = $LongIntDict.__index__(other)\n    // apply \"and\" on zeros and ones\n    if(v1.length<v2.length){var temp=v2;v2=v1;v1=temp}\n    var start = v1.length-v2.length\n    var res = ''\n    for(var i=0;i<v2.length;i++){\n        if(v1.charAt(start+i)=='1' && v2.charAt(i)=='1'){res += '1'}\n        else{res += '0'}\n    }\n    // Return the LongInt instance represented by res in base 2\n    return LongInt(res, 2)\n}\n\n$LongIntDict.__divmod__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str(other))\n\n    var dm = divmod_pos(self.value, other.value)\n    if(self.pos!==other.pos){\n        if(dm[0].value!='0'){dm[0].pos = false}\n        if(dm[1].value!='0'){\n            // If self and other have different signs and self is not a multiple\n            // of other, round to the previous integer\n            dm[0] = $LongIntDict.__sub__(dm[0], LongInt('1'))\n            dm[1] = $LongIntDict.__add__(dm[1], LongInt('1'))\n        }\n    }\n    return dm    \n}\n\n$LongIntDict.__eq__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str(other))\n    return self.value==other.value && self.pos==other.pos\n}\n\n$LongIntDict.__floordiv__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str(other))\n    return $LongIntDict.__divmod__(self, other)[0]\n}\n\n$LongIntDict.__ge__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str(other))\n    if(self.value.length>other.value.length){return true}\n    else if(self.value.length<other.value.length){return false}\n    else{return self.value >= other.value}\n}\n\n$LongIntDict.__gt__ = function(self, other){\n    return !$LongIntDict.__le__(self, other)\n}\n\n$LongIntDict.__index__ = function(self){\n    // Used by bin()\n    // returns a string with the binary value of self\n    // The algorithm computes the result of the floor division of self by 2\n    \n    // XXX to do : negative integers\n    \n    var res = '', pos=self.value.length,\n        temp = self.value, d\n    while(true){\n        d = divmod_pos(temp, '2')\n        res = d[1].value + res\n        temp = d[0].value\n        if(temp=='0'){break}\n    }\n    return res\n}\n\n$LongIntDict.__le__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str(other))\n    if(self.value.length>other.value.length){return false}\n    else if(self.value.length<other.value.length){return true}\n    else{return self.value <= other.value}\n}\n\n$LongIntDict.__lt__ = function(self, other){\n    return !$LongIntDict.__ge__(self, other)\n}\n\n$LongIntDict.__lshift__ = function(self, shift){\n    check_shift(shift)\n    var res = self.value\n    while(true){\n        var x, carry=0, res1=''\n        for(var i=res.length-1;i>=0;i--){\n            x = (carry+parseInt(res.charAt(i))*2).toString()\n            if(x.length==2){res1=x.charAt(1)+res1;carry=parseInt(x.charAt(0))}\n            else{res1=x+res1;carry=0}\n        }\n        if(carry){res1=carry+res1}\n        res=res1\n        shift = sub_pos(shift.value, '1')\n        if(shift.value=='0'){break}\n    }\n    return {__class__:$LongIntDict, value:res, pos:self.pos}\n}\n\n$LongIntDict.__mod__ = function(self, other){\n    return $LongIntDict.__divmod__(self, other)[1]\n}\n\n$LongIntDict.__mro__ = [$LongIntDict, _b_.object.$dict]\n\n$LongIntDict.__mul__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str(other))\n    var res = mul_pos(self.value, other.value)\n    if(self.pos==other.pos){return res}\n    res.pos = false\n    return res\n}\n\n$LongIntDict.__neg__ = function(obj){\n    return {__class__:$LongIntDict, value:obj.value, pos:!obj.pos}\n}\n\n$LongIntDict.__or__ = function(self, other){\n    var v1 = $LongIntDict.__index__(self)\n    var v2 = $LongIntDict.__index__(other)\n    if(v1.length<v2.length){var temp=v2;v2=v1;v1=temp}\n    var start = v1.length-v2.length\n    var res = v1.substr(0, start)\n    for(var i=0;i<v2.length;i++){\n        if(v1.charAt(start+i)=='1' || v2.charAt(i)=='1'){res += '1'}\n        else{res += '0'}\n    }\n    return LongInt(res, 2)\n}\n\n\n$LongIntDict.__pow__ = function(self, power){\n    if (typeof power == \"number\") {\n        power=LongInt(_b_.str(power))\n    }else if(!isinstance(power, LongInt)){\n        var msg = \"power must be a LongDict, not '\"\n        throw TypeError(msg+$B.get_class(power).__name__+\"'\")\n    }\n    if(!power.pos){\n        if(self.value=='1'){return self}\n        // For all other integers, x**-n is 0\n        return LongInt('0')\n    }else if(power.value=='0'){\n        return LongInt('1')\n    }\n    var res = {__class__:$LongIntDict, value:self.value, pos:self.pos}\n    var pow = power.value\n    while(true){\n        pow = sub_pos(pow, '1').value\n        if(pow == '0'){break}\n        res = $LongIntDict.__mul__(res, self)\n    }\n    return res    \n}\n\n$LongIntDict.__rshift__ = function(self, shift){\n    check_shift(shift)\n    var res = self.value\n    while(true){\n        res = divmod_pos(res, '2')[0].value\n        if(res.value=='0'){break}\n        shift = sub_pos(shift.value, '1')\n        if(shift.value=='0'){break}\n    }\n    return {__class__:$LongIntDict, value:res, pos:self.pos}\n}\n\n$LongIntDict.__str__ = $LongIntDict.__repr__ = function(self){\n    var res = \"LongInt('\"\n    if(!self.pos){res += '-'}\n    return res+self.value+\"')\"\n}\n\n$LongIntDict.__sub__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str(other))\n    var res\n    if(self.pos && other.pos){\n        switch(comp_pos(self.value, other.value)){\n            case 1:\n                res = sub_pos(self.value, other.value)\n                break\n            case 0:\n                res = {__class__:$LongIntDict, value:'0', pos:true}\n                break\n            case -1:\n                res = sub_pos(other.value, self.value)\n                res.pos = false\n                break\n        }\n        return res\n    }else if(!self.pos && !other.pos){\n        switch(comp_pos(self.value, other.value)){\n            case 1:\n                res = sub_pos(self.value, other.value)\n                res.pos = false\n                break\n            case 0:\n                res = {__class__:$LongIntDict, value:'0', pos:true}\n                break\n            case -1:\n                res = sub_pos(other.value, self.value)\n                break\n        }\n        return res\n    }else if(self.pos && !other.pos){\n        return add_pos(self.value, other.value)\n    }else{\n        res = add_pos(self.value, other.value)\n        res.pos = false\n        return res\n    }\n}\n\n$LongIntDict.__xor__ = function(self, other){\n    var v1 = $LongIntDict.__index__(self)\n    var v2 = $LongIntDict.__index__(other)\n    if(v1.length<v2.length){var temp=v2;v2=v1;v1=temp}\n    var start = v1.length-v2.length\n    var res = v1.substr(0, start)\n    for(var i=0;i<v2.length;i++){\n        if(v1.charAt(start+i)=='1' && v2.charAt(i)=='0'){res += '1'}\n        else if(v1.charAt(start+i)=='0' && v2.charAt(i)=='1'){res += '1'}\n        else{res += '0'}\n    }\n    return LongInt(res, 2)\n}\n\nfunction digits(base){\n    // Return an object where keys are all the digits valid in specified base\n    // and value is \"true\"\n    // Used to test if the string passed as first argument to LongInt is valid\n    var is_digits = {}\n    // Number from 0 to base, or from 0 to 9 if base > 10\n    for(var i=0;i<base;i++){\n        if(i==10){break}\n        is_digits[i]=true\n    }\n    if(base>10){\n        // Additional letters\n        // For instance in base 16, add \"abcdefABCDEF\" as keys\n        for(var i=0;i<base-10;i++){\n            is_digits[String.fromCharCode(65+i)]=true\n            is_digits[String.fromCharCode(97+i)]=true\n        }\n    }\n    return is_digits\n}\n\nfunction LongInt(value, base){\n    if(arguments.length>2){\n        throw _b_.TypeError(\"LongInt takes at most 2 arguments (\"+\n            arguments.length+\" given)\")\n    }\n    // base defaults to 10\n    if(base===undefined){base = 10}\n    else if(!isinstance(base, int)){\n        throw TypeError(\"'\"+$B.get_class(base).__name__+\"' object cannot be interpreted as an integer\")\n    }\n    if(base<0 || base==1 || base>36){\n        throw ValueError(\"LongInt() base must be >= 2 and <= 36\")\n    }\n    if(!typeof value=='string'){\n        throw ValueError(\"argument of long_int must be a string, not \"+\n            $B.get_class(value).__name__)\n    }\n    var has_prefix = false, pos = true, start = 0\n    // Strip leading and trailing whitespaces\n    while(value.charAt(0)==' ' && value.length){value = value.substr(1)}\n    while(value.charAt(value.length-1)==' ' && value.length){\n        value = value.substr(0, value.length-1)\n    }\n    // Check if string starts with + or -\n    if(value.charAt(0)=='+'){has_prefix=true}\n    else if(value.charAt(0)=='-'){has_prefix=true;pos=false}\n    if(has_prefix){\n        // Remove prefix\n        if(value.length==1){\n            // \"+\" or \"-\" alone are not valid arguments\n            throw ValueError('LongInt argument is not a valid number')            \n        }else{value=value.substr(1)}\n    }\n    // Ignore leading zeros\n    while(start<value.length-1 && value.charAt(start)=='0'){start++}\n    value = value.substr(start)\n\n    // Check if all characters in value are valid in the base\n    var is_digits = digits(base)\n    for(var i=0;i<value.length;i++){\n        if(!is_digits[value.charAt(i)]){\n            throw ValueError('LongInt argument is not a valid number')\n        }\n    }\n    if(base!=10){\n        // Conversion to base 10\n        var coef = '1', v10 = LongInt('0'),\n            pos = value.length, digit_base10\n        while(pos--){\n            digit_base10 = parseInt(value.charAt(pos), base).toString()\n            digit_by_coef = mul_pos(coef, digit_base10).value\n            v10 = add_pos(v10.value, digit_by_coef)\n            coef = mul_pos(coef, base.toString()).value\n        }\n        return v10\n    }\n    return {__class__:$LongIntDict, value:value, pos:pos}\n}\n\nLongInt.__class__ = $B.$factory\nLongInt.$dict = $LongIntDict\n$LongIntDict.$factory = LongInt\n\nreturn {LongInt:LongInt}\n\n})(__BRYTHON__)\n"], "multiprocessing": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__version__ = '0.70a1'\n\n__all__ = [\n'Process', 'current_process', 'active_children', 'freeze_support',\n'Manager', 'Pipe', 'cpu_count', 'log_to_stderr', 'get_logger',\n'allow_connection_pickling', 'BufferTooShort', 'TimeoutError',\n'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Condition',\n'Event', 'Barrier', 'Queue', 'SimpleQueue', 'JoinableQueue', 'Pool',\n'Value', 'Array', 'RawValue', 'RawArray', 'SUBDEBUG', 'SUBWARNING',\n]\n\n__author__ = 'R. Oudkerk (r.m.oudkerk@gmail.com)'\n\n\n\n\n\nimport os\nimport sys\n\nfrom multiprocessing.process import Process, current_process, active_children\nfrom multiprocessing.util import SUBDEBUG, SUBWARNING\n\n\n\n\n\nclass ProcessError(Exception):\n pass\n \nclass BufferTooShort(ProcessError):\n pass\n \nclass TimeoutError(ProcessError):\n pass\n \nclass AuthenticationError(ProcessError):\n pass\n \nimport _multiprocessing\n\n\n\n\n\ndef Manager():\n \"\"\n from multiprocessing.managers import SyncManager\n m = SyncManager()\n m.start()\n return m\n \n \n \n \n \n \n \n \n \ndef cpu_count():\n \"\"\n if sys.platform == 'win32':\n  try:\n   num = int(os.environ['NUMBER_OF_PROCESSORS'])\n  except (ValueError, KeyError):\n   num = 0\n elif 'bsd' in sys.platform or sys.platform == 'darwin':\n  comm = '/sbin/sysctl -n hw.ncpu'\n  if sys.platform == 'darwin':\n   comm = '/usr' + comm\n  try:\n   with os.popen(comm) as p:\n    num = int(p.read())\n  except ValueError:\n   num = 0\n else:\n  try:\n   num = os.sysconf('SC_NPROCESSORS_ONLN')\n  except (ValueError, OSError, AttributeError):\n   num = 0\n   \n if num >= 1:\n  return num\n else:\n  raise NotImplementedError('cannot determine number of cpus')\n  \ndef freeze_support():\n \"\"\n if sys.platform == 'win32' and getattr(sys, 'frozen', False):\n  from multiprocessing.forking import freeze_support\n  freeze_support()\n  \ndef get_logger():\n \"\"\n from multiprocessing.util import get_logger\n return get_logger()\n \ndef log_to_stderr(level=None):\n \"\"\n from multiprocessing.util import log_to_stderr\n return log_to_stderr(level)\n \n \n \n \n \n \n \n \n \n \n \n \n \n \ndef Lock():\n \"\"\n from multiprocessing.synchronize import Lock\n return Lock()\n \ndef RLock():\n \"\"\n from multiprocessing.synchronize import RLock\n return RLock()\n \ndef Condition(lock=None):\n \"\"\n from multiprocessing.synchronize import Condition\n return Condition(lock)\n \ndef Semaphore(value=1):\n \"\"\n from multiprocessing.synchronize import Semaphore\n return Semaphore(value)\n \ndef BoundedSemaphore(value=1):\n \"\"\n from multiprocessing.synchronize import BoundedSemaphore\n return BoundedSemaphore(value)\n \ndef Event():\n \"\"\n from multiprocessing.synchronize import Event\n return Event()\n \ndef Barrier(parties, action=None, timeout=None):\n \"\"\n from multiprocessing.synchronize import Barrier\n return Barrier(parties, action, timeout)\n \ndef Queue(maxsize=0):\n \"\"\n from multiprocessing.queues import Queue\n return Queue(maxsize)\n \ndef JoinableQueue(maxsize=0):\n \"\"\n from multiprocessing.queues import JoinableQueue\n return JoinableQueue(maxsize)\n \ndef SimpleQueue():\n \"\"\n from multiprocessing.queues import SimpleQueue\n return SimpleQueue()\n \ndef Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None):\n \"\"\n from multiprocessing.pool import Pool\n return Pool(processes, initializer, initargs, maxtasksperchild)\n \ndef RawValue(typecode_or_type, *args):\n \"\"\n from multiprocessing.sharedctypes import RawValue\n return RawValue(typecode_or_type, *args)\n \ndef RawArray(typecode_or_type, size_or_initializer):\n \"\"\n from multiprocessing.sharedctypes import RawArray\n return RawArray(typecode_or_type, size_or_initializer)\n \ndef Value(typecode_or_type, *args, lock=True):\n \"\"\n from multiprocessing.sharedctypes import Value\n return Value(typecode_or_type, *args, lock=lock)\n \ndef Array(typecode_or_type, size_or_initializer, *, lock=True):\n \"\"\n from multiprocessing.sharedctypes import Array\n return Array(typecode_or_type, size_or_initializer, lock=lock)\n \n \n \n \n \nif sys.platform == 'win32':\n\n def set_executable(executable):\n  \"\"\n  from multiprocessing.forking import set_executable\n  set_executable(executable)\n  \n __all__ += ['set_executable']\n", 1], "queue": [".py", "\"\"\n\ntry:\n import threading\nexcept ImportError:\n import dummy_threading as threading\nfrom collections import deque\nfrom heapq import heappush, heappop\ntry:\n from time import monotonic as time\nexcept ImportError:\n from time import time\n \n__all__ = ['Empty', 'Full', 'Queue', 'PriorityQueue', 'LifoQueue']\n\nclass Empty(Exception):\n \"\"\n pass\n \nclass Full(Exception):\n \"\"\n pass\n \nclass Queue:\n \"\"\n \n def __init__(self, maxsize=0):\n  self.maxsize = maxsize\n  self._init(maxsize)\n  \n  \n  \n  \n  \n  self.mutex = threading.Lock()\n  \n  \n  \n  self.not_empty = threading.Condition(self.mutex)\n  \n  \n  \n  self.not_full = threading.Condition(self.mutex)\n  \n  \n  \n  self.all_tasks_done = threading.Condition(self.mutex)\n  self.unfinished_tasks = 0\n  \n def task_done(self):\n  \"\"\n  with self.all_tasks_done:\n   unfinished = self.unfinished_tasks - 1\n   if unfinished <= 0:\n    if unfinished < 0:\n     raise ValueError('task_done() called too many times')\n    self.all_tasks_done.notify_all()\n   self.unfinished_tasks = unfinished\n   \n def join(self):\n  \"\"\n  with self.all_tasks_done:\n   while self.unfinished_tasks:\n    self.all_tasks_done.wait()\n    \n def qsize(self):\n  \"\"\n  with self.mutex:\n   return self._qsize()\n   \n def empty(self):\n  \"\"\n  with self.mutex:\n   return not self._qsize()\n   \n def full(self):\n  \"\"\n  with self.mutex:\n   return 0 < self.maxsize <= self._qsize()\n   \n def put(self, item, block=True, timeout=None):\n  \"\"\n  with self.not_full:\n   if self.maxsize > 0:\n    if not block:\n     if self._qsize() >= self.maxsize:\n      raise Full\n    elif timeout is None:\n     while self._qsize() >= self.maxsize:\n      self.not_full.wait()\n    elif timeout < 0:\n     raise ValueError(\"'timeout' must be a non-negative number\")\n    else:\n     endtime = time() + timeout\n     while self._qsize() >= self.maxsize:\n      remaining = endtime - time()\n      if remaining <= 0.0:\n       raise Full\n      self.not_full.wait(remaining)\n   self._put(item)\n   self.unfinished_tasks += 1\n   self.not_empty.notify()\n   \n def get(self, block=True, timeout=None):\n  \"\"\n  with self.not_empty:\n   if not block:\n    if not self._qsize():\n     raise Empty\n   elif timeout is None:\n    while not self._qsize():\n     self.not_empty.wait()\n   elif timeout < 0:\n    raise ValueError(\"'timeout' must be a non-negative number\")\n   else:\n    endtime = time() + timeout\n    while not self._qsize():\n     remaining = endtime - time()\n     if remaining <= 0.0:\n      raise Empty\n     self.not_empty.wait(remaining)\n   item = self._get()\n   self.not_full.notify()\n   return item\n   \n def put_nowait(self, item):\n  \"\"\n  return self.put(item, block=False)\n  \n def get_nowait(self):\n  \"\"\n  return self.get(block=False)\n  \n  \n  \n  \n  \n  \n def _init(self, maxsize):\n  self.queue = deque()\n  \n def _qsize(self):\n  return len(self.queue)\n  \n  \n def _put(self, item):\n  self.queue.append(item)\n  \n  \n def _get(self):\n  return self.queue.popleft()\n  \n  \nclass PriorityQueue(Queue):\n \"\"\n \n def _init(self, maxsize):\n  self.queue = []\n  \n def _qsize(self):\n  return len(self.queue)\n  \n def _put(self, item):\n  heappush(self.queue, item)\n  \n def _get(self):\n  return heappop(self.queue)\n  \n  \nclass LifoQueue(Queue):\n \"\"\n \n def _init(self, maxsize):\n  self.queue = []\n  \n def _qsize(self):\n  return len(self.queue)\n  \n def _put(self, item):\n  self.queue.append(item)\n  \n def _get(self):\n  return self.queue.pop()\n"], "site-packages.turtle": [".py", "import math\n\nfrom javascript import console\nfrom browser import document, html\nimport _svg\n\n_CFG = {\"width\" : 0.5, \n\"height\" : 0.75,\n\"canvwidth\" : 400,\n\"canvheight\": 300,\n\"leftright\": None,\n\"topbottom\": None,\n\"mode\": \"standard\", \n\"colormode\": 1.0,\n\"delay\": 10,\n\"undobuffersize\": 1000, \n\"shape\": \"classic\",\n\"pencolor\" : \"black\",\n\"fillcolor\" : \"black\",\n\"resizemode\" : \"noresize\",\n\"visible\" : True,\n\"language\": \"english\", \n\"exampleturtle\": \"turtle\",\n\"examplescreen\": \"screen\",\n\"title\": \"Python Turtle Graphics\",\n\"using_IDLE\": False\n}\n\n\nclass Vec2D(tuple):\n \"\"\n def __new__(cls, x, y):\n  return tuple.__new__(cls, (x, y))\n def __add__(self, other):\n  return Vec2D(self[0]+other[0], self[1]+other[1])\n def __mul__(self, other):\n  if isinstance(other, Vec2D):\n   return self[0]*other[0]+ self[1]*other[1]\n  return Vec2D(self[0]*other, self[1]*other)\n def __rmul__(self, other):\n  if isinstance(other, int) or isinstance(other, float):\n   return Vec2D(self[0]*other, self[1]*other)\n def __sub__(self, other):\n  return Vec2D(self[0]-other[0], self[1]-other[1])\n def __neg__(self):\n  return Vec2D(-self[0], -self[1])\n def __abs__(self):\n  return (self[0]**2 + self[1]**2)**0.5\n def rotate(self, angle):\n  \"\"\n  perp = Vec2D(-self[1], self[0])\n  angle = angle * math.pi / 180.0\n  c, s = math.cos(angle), math.sin(angle)\n  return Vec2D(self[0]*c+perp[0]*s, self[1]*c+perp[1]*s)\n def __getnewargs__(self):\n  return (self[0], self[1])\n def __repr__(self):\n  return \"(%.2f,%.2f)\" % self\n  \n  \n  \n  \n  \n  \n  \nclass _Root:\n \"\"\n \n def setupcanvas(self, width, height, cwidth, cheight):\n  self._svg=_svg.svg(Id=\"mycanvas\", width=cwidth, height=cheight)\n  self._canvas=_svg.g(transform=\"translate(%d,%d)\" % (cwidth//2, cheight//2))\n  self._svg <= self._canvas\n  \n def end(self):\n  def set_svg():\n  \n   document['container'].html=document['container'].html\n   \n   \n  if \"mycanvas\" not in document:\n   document[\"container\"] <= self._svg\n   from browser import timer\n   \n   timer.set_timeout(set_svg, 1) \n   \n def _getcanvas(self):\n  return self._canvas\n  \n def win_width(self):\n  return self._canvas.width\n  \n def win_height(self):\n  return self._canvas.height\n  \nclass TurtleScreenBase:\n \"\"\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n def __init__(self, cv):\n  self.cv = cv\n  \n  self._previous_turtle_attributes={}\n  self._draw_pos=0\n  \n  self.canvwidth = cv.width\n  self.canvheight = cv.height\n  self.xscale = self.yscale = 1.0\n  \n def _createpoly(self):\n  \"\"\n  \n  pass\n  \n def _drawpoly(self, polyitem, coordlist, fill=None,\n outline=None, width=None, top=False):\n  \"\"\n  \n  pass\n  \n def _drawline(self, lineitem, coordlist=None,\n fill=None, width=None, top=False):\n  \"\"\n  \n  \n  \n  \n  \n  if coordlist is not None:\n   _x0, _y0=coordlist[0]\n   _x1, _y1=coordlist[1]\n   \n   _dist=math.sqrt( (_x0-_x1)*(_x0-_x1) + (_y0-_y1)*(_y0-_y1) )\n   \n   _dur=\"%4.2fs\" % (0.01*_dist)\n   if _dur == '0.00s':\n    _dur='0.1s'\n    \n    \n   self._draw_pos+=1\n   \n   _shape=[\"%s,%s\" % (_x, _y) for _x,_y in lineitem.get_shapepoly()]\n   \n   if 0:\n   \n    if lineitem in self._previous_turtle_attributes:\n     _previous=self._previous_turtle_attributes[lineitem]\n     if _previous.heading() != lineitem.heading():\n     \n     \n      _rotate=_previous.heading()\n      _turtle=_svg.polygon(points=\" \".join(_shape),\n      transform=\"rotate(%s)\" % (_rotate-90),\n      style={'stroke': fill, 'fill': fill, \n      'stroke-width': width, 'display': 'none'})\n      \n      \n      _turtle <= _svg.animateTransform(\n      Id=\"animateLine%s\" % self._draw_pos,\n      attributeName=\"transform\",\n      type=\"rotate\",\n      attributeType=\"XML\",\n      From=_rotate - 90,\n      to=lineitem.heading() -90,\n      dur=_dur,\n      begin=\"animateLine%s.end\" % (self._draw_pos-1))\n      \n      _turtle <= _svg.set(attributeName=\"display\", \n      attributeType=\"CSS\", to=\"block\",\n      begin=\"animateLine%s.begin\" % self._draw_pos,\n      end=\"animateLine%s.end\" % self._draw_pos)\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      self._draw_pos+=1\n      self._canvas <= _turtle\n      \n      \n   _line= _svg.line(x1=_x0*self.xscale, y1=_y0*self.yscale,\n   x2=_x0*self.xscale, y2=_y0*self.yscale,\n   style={'stroke': fill, 'stroke-width': width})\n   \n   _an1=_svg.animate(Id=\"animateLine%s\" % self._draw_pos,\n   attributeName=\"x2\", attributeType=\"XML\",\n   From=_x0*self.xscale, to=_x1*self.xscale,\n   dur=_dur, fill='freeze')\n   \n   _an2=_svg.animate(attributeName=\"y2\", attributeType=\"XML\",\n   begin=\"animateLine%s.begin\" % self._draw_pos,\n   From=_y0*self.xscale, to=_y1*self.xscale,\n   dur=_dur, fill='freeze')\n   \n   \n   if lineitem.isvisible():\n    _turtle=_svg.polygon(points=\" \".join(_shape),\n    transform=\"rotate(%s)\" % (lineitem.heading() - 90),\n    style={'stroke': fill, 'fill': fill, \n    'stroke-width': width, 'display': 'none'})\n    \n    _turtle <= _svg.animateMotion(From=\"%s,%s\" % (_x0*self.xscale, _y0*self.yscale),\n    to=\"%s,%s\" % (_x1*self.xscale, _y1*self.yscale),\n    dur=_dur, begin=\"animateLine%s.begin\" % self._draw_pos)\n    \n    _turtle <= _svg.set(attributeName=\"display\", attributeType=\"CSS\",\n    to=\"block\", \n    begin=\"animateLine%s.begin\" % self._draw_pos,\n    end=\"animateLine%s.end\" % self._draw_pos)\n    \n    self._canvas <= _turtle\n    \n   self._previous_turtle_attributes[lineitem]=lineitem\n   \n   if self._draw_pos == 1:\n    _an1.setAttribute('begin', \"0s\")\n   else:\n    _an1.setAttribute('begin', \"animateLine%s.end\" % (self._draw_pos-1))\n    \n   _line <= _an1\n   _line <= _an2\n   \n   self._canvas <= _line\n   \n def _delete(self, item):\n  \"\"\n  pass\n  \n def _update(self):\n  \"\"\n  pass\n  \n def _delay(self, delay):\n  \"\"\n  pass\n  \n def _iscolorstring(self, color):\n  \"\"\n  return True \n  \n  \n  \n  \n  \n  \n  \n  \n def _bgcolor(self, color=None):\n  \"\"\n  if color is not None:\n   self.cv.style.backgroundColor=color\n  else:\n   return self.cv.style.backgroundColor\n   \n def _write(self, pos, txt, align, font, pencolor):\n  \"\"\n  \n  self._draw_pos+=1\n  _text= _svg.text(txt, x=pos[0], y=pos[1], fill=pencolor,\n  style={'display': 'none'})\n  _text <= _svg.animate(Id=\"animateLine%s\" % self._draw_pos,\n  attributeName=\"display\", attributeType=\"CSS\",\n  From=\"block\", to=\"block\", dur=\"1s\", fill='freeze',\n  begin=\"animateLine%s.end\" % (self._draw_pos-1))\n  \n  self._canvas <= _text\n  return Vec2D(pos[0]+50, pos[1]+50) \n  \n  \n  \n  \n def _createimage(self, image):\n  \"\"\n  pass\n  \n def _drawimage(self, item, pos, image):\n  \"\"\n  pass\n  \n def _setbgpic(self, item, image):\n  \"\"\n  pass\n  \n def _type(self, item):\n  \"\"\n  pass\n  \n  \n def _resize(self, canvwidth=None, canvheight=None, bg=None):\n  \"\"\n  self.cv.style.width=canvwidth\n  self.cv.style.height=canvheight\n  if bg is not None:\n   self.cv.style.backgroundColor=bg\n   \n def _window_size(self):\n  \"\"\n  \n  return self.cv.width, self.cv.height\n  \n def mainloop(self):\n  \"\"\n  pass\n  \n def textinput(self, title, prompt):\n  \"\"\n  pass\n  \n def numinput(self, title, prompt, default=None, minval=None, maxval=None):\n  \"\"\n  pass\n  \n  \n  \n  \n  \n  \nclass Terminator (Exception):\n \"\"\n pass\n \nclass TurtleGraphicsError(Exception):\n \"\"\n pass\n \nclass Shape:\n \"\"\n def __init__(self, type_, data=None):\n  self._type = type_\n  if type_ == \"polygon\":\n   if isinstance(data, list):\n    data = tuple(data)\n  elif type_ == \"image\":\n   if isinstance(data, str):\n    if data.lower().endswith(\".gif\") and isfile(data):\n     data = TurtleScreen._image(data)\n     \n  elif type_ == \"compound\":\n   data = []\n  else:\n   raise TurtleGraphicsError(\"There is no shape type %s\" % type_)\n  self._data = data\n  \n def addcomponent(self, poly, fill, outline=None):\n  \"\"\n  if self._type != \"compound\":\n   raise TurtleGraphicsError(\"Cannot add component to %s Shape\"\n   % self._type)\n  if outline is None:\n   outline = fill\n  self._data.append([poly, fill, outline])\n  \n  \nclass TurtleScreen(TurtleScreenBase):\n \"\"\n _RUNNING = True\n \n def __init__(self, cv, mode=_CFG[\"mode\"],\n colormode=_CFG[\"colormode\"], delay=_CFG[\"delay\"]):\n  self._shapes = {\n  \"arrow\" : Shape(\"polygon\", ((-10,0), (10,0), (0,10))),\n  \"turtle\" : Shape(\"polygon\", ((0,16), (-2,14), (-1,10), (-4,7),\n  (-7,9), (-9,8), (-6,5), (-7,1), (-5,-3), (-8,-6),\n  (-6,-8), (-4,-5), (0,-7), (4,-5), (6,-8), (8,-6),\n  (5,-3), (7,1), (6,5), (9,8), (7,9), (4,7), (1,10),\n  (2,14))),\n  \"circle\" : Shape(\"polygon\", ((10,0), (9.51,3.09), (8.09,5.88),\n  (5.88,8.09), (3.09,9.51), (0,10), (-3.09,9.51),\n  (-5.88,8.09), (-8.09,5.88), (-9.51,3.09), (-10,0),\n  (-9.51,-3.09), (-8.09,-5.88), (-5.88,-8.09),\n  (-3.09,-9.51), (-0.00,-10.00), (3.09,-9.51),\n  (5.88,-8.09), (8.09,-5.88), (9.51,-3.09))),\n  \"square\" : Shape(\"polygon\", ((10,-10), (10,10), (-10,10),\n  (-10,-10))),\n  \"triangle\" : Shape(\"polygon\", ((10,-5.77), (0,11.55),\n  (-10,-5.77))),\n  \"classic\": Shape(\"polygon\", ((0,0),(-5,-9),(0,-7),(5,-9))),\n  \"blank\" : Shape(\"image\", None) \n  }\n  \n  self._bgpics = {\"nopic\" : \"\"}\n  \n  TurtleScreenBase.__init__(self, cv)\n  self._mode = mode\n  self._delayvalue = delay\n  self._colormode = _CFG[\"colormode\"]\n  self._keys = []\n  self.clear()\n  \n def clear(self):\n  \"\"\n  self._delayvalue = _CFG[\"delay\"]\n  self._colormode = _CFG[\"colormode\"]\n  self._delete(\"all\")\n  self._bgpic = self._createimage(\"\")\n  self._bgpicname = \"nopic\"\n  self._tracing = 1\n  self._updatecounter = 0\n  self._turtles = []\n  self.bgcolor(\"white\")\n  \n  \n  \n  \n  \n  \n  Turtle._pen = None\n  \n def mode(self, mode=None):\n  \"\"\n  if mode is None:\n   return self._mode\n  mode = mode.lower()\n  if mode not in [\"standard\", \"logo\", \"world\"]:\n   raise TurtleGraphicsError(\"No turtle-graphics-mode %s\" % mode)\n  self._mode = mode\n  if mode in [\"standard\", \"logo\"]:\n   self._setscrollregion(-self.canvwidth//2, -self.canvheight//2,\n   self.canvwidth//2, self.canvheight//2)\n   self.xscale = self.yscale = 1.0\n  self.reset()\n  \n def setworldcoordinates(self, llx, lly, urx, ury):\n  \"\"\n  if self.mode() != \"world\":\n   self.mode(\"world\")\n  xspan = float(urx - llx)\n  yspan = float(ury - lly)\n  wx, wy = self._window_size()\n  self.screensize(wx-20, wy-20)\n  oldxscale, oldyscale = self.xscale, self.yscale\n  self.xscale = self.canvwidth / xspan\n  self.yscale = self.canvheight / yspan\n  srx1 = llx * self.xscale\n  sry1 = -ury * self.yscale\n  srx2 = self.canvwidth + srx1\n  sry2 = self.canvheight + sry1\n  self._setscrollregion(srx1, sry1, srx2, sry2)\n  self._rescale(self.xscale/oldxscale, self.yscale/oldyscale)\n  \n  \n def register_shape(self, name, shape=None):\n  \"\"\n  if shape is None:\n  \n   if name.lower().endswith(\".gif\"):\n    shape = Shape(\"image\", self._image(name))\n   else:\n    raise TurtleGraphicsError(\"Bad arguments for register_shape.\\n\"\n    + \"Use  help(register_shape)\" )\n  elif isinstance(shape, tuple):\n   shape = Shape(\"polygon\", shape)\n   \n  self._shapes[name] = shape\n  \n def _colorstr(self, color):\n  \"\"\n  if len(color) == 1:\n   color = color[0]\n  if isinstance(color, str):\n   if self._iscolorstring(color) or color == \"\":\n    return color\n   else:\n    raise TurtleGraphicsError(\"bad color string: %s\" % str(color))\n  try:\n   r, g, b = color\n  except:\n   raise TurtleGraphicsError(\"bad color arguments: %s\" % str(color))\n  if self._colormode == 1.0:\n   r, g, b = [round(255.0*x) for x in (r, g, b)]\n  if not ((0 <= r <= 255) and (0 <= g <= 255) and (0 <= b <= 255)):\n   raise TurtleGraphicsError(\"bad color sequence: %s\" % str(color))\n  return \"#%02x%02x%02x\" % (r, g, b)\n  \n def _color(self, cstr):\n  if not cstr.startswith(\"#\"):\n   return cstr\n  if len(cstr) == 7:\n   cl = [int(cstr[i:i+2], 16) for i in (1, 3, 5)]\n  elif len(cstr) == 4:\n   cl = [16*int(cstr[h], 16) for h in cstr[1:]]\n  else:\n   raise TurtleGraphicsError(\"bad colorstring: %s\" % cstr)\n  return tuple([c * self._colormode/255 for c in cl])\n  \n def colormode(self, cmode=None):\n  \"\"\n  if cmode is None:\n   return self._colormode\n  if cmode == 1.0:\n   self._colormode = float(cmode)\n  elif cmode == 255:\n   self._colormode = int(cmode)\n   \n def reset(self):\n  \"\"\n  for turtle in self._turtles:\n   turtle._setmode(self._mode)\n   turtle.reset()\n   \n def turtles(self):\n  \"\"\n  return self._turtles\n  \n def bgcolor(self, *args):\n  \"\"\n  if args:\n   color = self._colorstr(args)\n  else:\n   color = None\n  color = self._bgcolor(color)\n  if color is not None:\n   color = self._color(color)\n  return color\n  \n def tracer(self, n=None, delay=None):\n  \"\"\n  if n is None:\n   return self._tracing\n  self._tracing = int(n)\n  self._updatecounter = 0\n  if delay is not None:\n   self._delayvalue = int(delay)\n  if self._tracing:\n   self.update()\n   \n def delay(self, delay=None):\n  \"\"\n  if delay is None:\n   return self._delayvalue\n  self._delayvalue = int(delay)\n  \n def _incrementudc(self):\n  \"\"\n  if not TurtleScreen._RUNNING:\n   TurtleScreen._RUNNNING = True\n   raise Terminator\n  if self._tracing > 0:\n   self._updatecounter += 1\n   self._updatecounter %= self._tracing\n   \n def update(self):\n  \"\"\n  return\n  tracing = self._tracing\n  self._tracing = True\n  for t in self.turtles():\n  \n   t._drawturtle()\n  self._tracing = tracing\n  self._update()\n  \n def window_width(self):\n  \"\"\n  return self._window_size()[0]\n  \n def window_height(self):\n  \"\"\n  return self._window_size()[1]\n  \n def getcanvas(self):\n  \"\"\n  return self.cv\n  \n def getshapes(self):\n  \"\"\n  return sorted(self._shapes.keys())\n  \n def onclick(self, fun, btn=1, add=None):\n  \"\"\n  self._onscreenclick(fun, btn, add)\n  \n def onkey(self, fun, key):\n  \"\"\n  if fun is None:\n   if key in self._keys:\n    self._keys.remove(key)\n  elif key not in self._keys:\n   self._keys.append(key)\n  self._onkeyrelease(fun, key)\n  \n def onkeypress(self, fun, key=None):\n  \"\"\n  if fun is None:\n   if key in self._keys:\n    self._keys.remove(key)\n  elif key is not None and key not in self._keys:\n   self._keys.append(key)\n  self._onkeypress(fun, key)\n  \n def listen(self, xdummy=None, ydummy=None):\n  \"\"\n  self._listen()\n  \n def ontimer(self, fun, t=0):\n  \"\"\n  self._ontimer(fun, t)\n  \n def bgpic(self, picname=None):\n  \"\"\n  if picname is None:\n   return self._bgpicname\n  if picname not in self._bgpics:\n   self._bgpics[picname] = self._image(picname)\n  self._setbgpic(self._bgpic, self._bgpics[picname])\n  self._bgpicname = picname\n  \n def screensize(self, canvwidth=None, canvheight=None, bg=None):\n  \"\"\n  return self._resize(canvwidth, canvheight, bg)\n  \n onscreenclick = onclick\n resetscreen = reset\n clearscreen = clear\n addshape = register_shape\n onkeyrelease = onkey\n \nclass TNavigator:\n \"\"\n START_ORIENTATION = {\n \"standard\": Vec2D(1.0, 0.0),\n \"world\" : Vec2D(1.0, 0.0),\n \"logo\" : Vec2D(0.0, 1.0) }\n DEFAULT_MODE = \"standard\"\n DEFAULT_ANGLEOFFSET = 0\n DEFAULT_ANGLEORIENT = 1\n \n def __init__(self, mode=DEFAULT_MODE):\n  self._angleOffset = self.DEFAULT_ANGLEOFFSET\n  self._angleOrient = self.DEFAULT_ANGLEORIENT\n  self._mode = mode\n  self.undobuffer = None\n  self.degrees()\n  self._mode = None\n  self._setmode(mode)\n  TNavigator.reset(self)\n  \n def reset(self):\n  \"\"\n  self._position = Vec2D(0.0, 0.0)\n  self._orient = TNavigator.START_ORIENTATION[self._mode]\n  \n def _setmode(self, mode=None):\n  \"\"\n  if mode is None:\n   return self._mode\n  if mode not in [\"standard\", \"logo\", \"world\"]:\n   return\n  self._mode = mode\n  if mode in [\"standard\", \"world\"]:\n   self._angleOffset = 0\n   self._angleOrient = 1\n  else: \n   self._angleOffset = self._fullcircle/4.\n   self._angleOrient = -1\n   \n def _setDegreesPerAU(self, fullcircle):\n  \"\"\n  self._fullcircle = fullcircle\n  self._degreesPerAU = 360/fullcircle\n  if self._mode == \"standard\":\n   self._angleOffset = 0\n  else:\n   self._angleOffset = fullcircle/4.\n   \n def degrees(self, fullcircle=360.0):\n  \"\"\n  self._setDegreesPerAU(fullcircle)\n  \n def radians(self):\n  \"\"\n  self._setDegreesPerAU(2*math.pi)\n  \n def _go(self, distance):\n  \"\"\n  \n  ende = self._position + self._orient * distance\n  self._goto(ende)\n  \n def _rotate(self, angle):\n  \"\"\n  \n  angle *= self._degreesPerAU\n  self._orient = self._orient.rotate(angle)\n  \n def _goto(self, end):\n  \"\"\n  \n  self._position = end\n  \n def forward(self, distance):\n  \"\"\n  self._go(distance)\n  \n def back(self, distance):\n  \"\"\n  self._go(-distance)\n  \n def right(self, angle):\n  \"\"\n  self._rotate(-angle)\n  \n def left(self, angle):\n  \"\"\n  self._rotate(angle)\n  \n def pos(self):\n  \"\"\n  return self._position\n  \n def xcor(self):\n  \"\"\n  return self._position[0]\n  \n def ycor(self):\n  \"\"\n  return self._position[1]\n  \n  \n def goto(self, x, y=None):\n  \"\"\n  if y is None:\n   self._goto(Vec2D(*x))\n  else:\n   self._goto(Vec2D(x, y))\n   \n def home(self):\n  \"\"\n  self.goto(0, 0)\n  self.setheading(0)\n  \n def setx(self, x):\n  \"\"\n  self._goto(Vec2D(x, self._position[1]))\n  \n def sety(self, y):\n  \"\"\n  self._goto(Vec2D(self._position[0], y))\n  \n def distance(self, x, y=None):\n  \"\"\n  if y is not None:\n   pos = Vec2D(x, y)\n  if isinstance(x, Vec2D):\n   pos = x\n  elif isinstance(x, tuple):\n   pos = Vec2D(*x)\n  elif isinstance(x, TNavigator):\n   pos = x._position\n  return abs(pos - self._position)\n  \n def towards(self, x, y=None):\n  \"\"\n  if y is not None:\n   pos = Vec2D(x, y)\n  if isinstance(x, Vec2D):\n   pos = x\n  elif isinstance(x, tuple):\n   pos = Vec2D(*x)\n  elif isinstance(x, TNavigator):\n   pos = x._position\n  x, y = pos - self._position\n  result = round(math.atan2(y, x)*180.0/math.pi, 10) % 360.0\n  result /= self._degreesPerAU\n  return (self._angleOffset + self._angleOrient*result) % self._fullcircle\n  \n def heading(self):\n  \"\"\n  x, y = self._orient\n  result = round(math.atan2(y, x)*180.0/math.pi, 10) % 360.0\n  result /= self._degreesPerAU\n  return (self._angleOffset + self._angleOrient*result) % self._fullcircle\n  \n def setheading(self, to_angle):\n  \"\"\n  angle = (to_angle - self.heading())*self._angleOrient\n  full = self._fullcircle\n  angle = (angle+full/2.)%full - full/2.\n  self._rotate(angle)\n  \n def circle(self, radius, extent = None, steps = None):\n  \"\"\n  if self.undobuffer:\n   self.undobuffer.push([\"seq\"])\n   self.undobuffer.cumulate = True\n  speed = self.speed()\n  if extent is None:\n   extent = self._fullcircle\n  if steps is None:\n   frac = abs(extent)/self._fullcircle\n   steps = 1+int(min(11+abs(radius)/6.0, 59.0)*frac)\n  w = 1.0 * extent / steps\n  w2 = 0.5 * w\n  l = 2.0 * radius * math.sin(w2*math.pi/180.0*self._degreesPerAU)\n  if radius < 0:\n   l, w, w2 = -l, -w, -w2\n  tr = self._tracer()\n  dl = self._delay()\n  if speed == 0:\n   self._tracer(0, 0)\n  else:\n   self.speed(0)\n  self._rotate(w2)\n  for i in range(steps):\n   self.speed(speed)\n   self._go(l)\n   self.speed(0)\n   self._rotate(w)\n  self._rotate(-w2)\n  if speed == 0:\n   self._tracer(tr, dl)\n  self.speed(speed)\n  if self.undobuffer:\n   self.undobuffer.cumulate = False\n   \n   \n   \n def speed(self, s=0):\n  \"\"\n def _tracer(self, a=None, b=None):\n  \"\"\n def _delay(self, n=None):\n  \"\"\n  \n fd = forward\n bk = back\n backward = back\n rt = right\n lt = left\n position = pos\n setpos = goto\n setposition = goto\n seth = setheading\n \n \nclass TPen:\n \"\"\n def __init__(self, resizemode=_CFG[\"resizemode\"]):\n  self._resizemode = resizemode \n  self.undobuffer = None\n  TPen._reset(self)\n  \n def _reset(self, pencolor=_CFG[\"pencolor\"],\n fillcolor=_CFG[\"fillcolor\"]):\n  self._pensize = 1\n  self._shown = True\n  self._pencolor = pencolor\n  self._fillcolor = fillcolor\n  self._drawing = True\n  self._speed = 3\n  self._stretchfactor = (1., 1.)\n  self._shearfactor = 0.\n  self._tilt = 0.\n  self._shapetrafo = (1., 0., 0., 1.)\n  self._outlinewidth = 1\n  \n def resizemode(self, rmode=None):\n  \"\"\n  if rmode is None:\n   return self._resizemode\n  rmode = rmode.lower()\n  if rmode in [\"auto\", \"user\", \"noresize\"]:\n   self.pen(resizemode=rmode)\n   \n def pensize(self, width=None):\n  \"\"\n  if width is None:\n   return self._pensize\n  self.pen(pensize=width)\n  \n  \n def penup(self):\n  \"\"\n  if not self._drawing:\n   return\n  self.pen(pendown=False)\n  \n def pendown(self):\n  \"\"\n  if self._drawing:\n   return\n  self.pen(pendown=True)\n  \n def isdown(self):\n  \"\"\n  return self._drawing\n  \n def speed(self, speed=None):\n  \"\"\n  speeds = {'fastest':0, 'fast':10, 'normal':6, 'slow':3, 'slowest':1 }\n  if speed is None:\n   return self._speed\n  if speed in speeds:\n   speed = speeds[speed]\n  elif 0.5 < speed < 10.5:\n   speed = int(round(speed))\n  else:\n   speed = 0\n  self.pen(speed=speed)\n  \n def color(self, *args):\n  \"\"\n  if args:\n   l = len(args)\n   if l == 1:\n    pcolor = fcolor = args[0]\n   elif l == 2:\n    pcolor, fcolor = args\n   elif l == 3:\n    pcolor = fcolor = args\n   pcolor = self._colorstr(pcolor)\n   fcolor = self._colorstr(fcolor)\n   self.pen(pencolor=pcolor, fillcolor=fcolor)\n  else:\n   return self._color(self._pencolor), self._color(self._fillcolor)\n   \n def pencolor(self, *args):\n  \"\"\n  if args:\n   color = self._colorstr(args)\n   if color == self._pencolor:\n    return\n   self.pen(pencolor=color)\n  else:\n   return self._color(self._pencolor)\n   \n def fillcolor(self, *args):\n  \"\"\n  if args:\n   color = self._colorstr(args)\n   if color == self._fillcolor:\n    return\n   self.pen(fillcolor=color)\n  else:\n   return self._color(self._fillcolor)\n   \n def showturtle(self):\n  \"\"\n  self.pen(shown=True)\n  \n def hideturtle(self):\n  \"\"\n  self.pen(shown=False)\n  \n def isvisible(self):\n  \"\"\n  return self._shown\n  \n def pen(self, pen=None, **pendict):\n  \"\"\n  _pd = {\"shown\" : self._shown,\n  \"pendown\" : self._drawing,\n  \"pencolor\" : self._pencolor,\n  \"fillcolor\" : self._fillcolor,\n  \"pensize\" : self._pensize,\n  \"speed\" : self._speed,\n  \"resizemode\" : self._resizemode,\n  \"stretchfactor\" : self._stretchfactor,\n  \"shearfactor\" : self._shearfactor,\n  \"outline\" : self._outlinewidth,\n  \"tilt\" : self._tilt\n  }\n  \n  \n  if not (pen or pendict):\n   return _pd\n   \n  if isinstance(pen, dict):\n   p = pen\n  else:\n   p = {}\n  p.update(pendict)\n  \n  _p_buf = {}\n  for key in p:\n   _p_buf[key] = _pd[key]\n   \n  if self.undobuffer:\n   self.undobuffer.push((\"pen\", _p_buf))\n   \n  newLine = False\n  if \"pendown\" in p:\n   if self._drawing != p[\"pendown\"]:\n    newLine = True\n  if \"pencolor\" in p:\n   if isinstance(p[\"pencolor\"], tuple):\n    p[\"pencolor\"] = self._colorstr((p[\"pencolor\"],))\n   if self._pencolor != p[\"pencolor\"]:\n    newLine = True\n  if \"pensize\" in p:\n   if self._pensize != p[\"pensize\"]:\n    newLine = True\n  if newLine:\n   self._newLine()\n  if \"pendown\" in p:\n   self._drawing = p[\"pendown\"]\n  if \"pencolor\" in p:\n   self._pencolor = p[\"pencolor\"]\n  if \"pensize\" in p:\n   self._pensize = p[\"pensize\"]\n  if \"fillcolor\" in p:\n   if isinstance(p[\"fillcolor\"], tuple):\n    p[\"fillcolor\"] = self._colorstr((p[\"fillcolor\"],))\n   self._fillcolor = p[\"fillcolor\"]\n  if \"speed\" in p:\n   self._speed = p[\"speed\"]\n  if \"resizemode\" in p:\n   self._resizemode = p[\"resizemode\"]\n  if \"stretchfactor\" in p:\n   sf = p[\"stretchfactor\"]\n   if isinstance(sf, (int, float)):\n    sf = (sf, sf)\n   self._stretchfactor = sf\n  if \"shearfactor\" in p:\n   self._shearfactor = p[\"shearfactor\"]\n  if \"outline\" in p:\n   self._outlinewidth = p[\"outline\"]\n  if \"shown\" in p:\n   self._shown = p[\"shown\"]\n  if \"tilt\" in p:\n   self._tilt = p[\"tilt\"]\n  if \"stretchfactor\" in p or \"tilt\" in p or \"shearfactor\" in p:\n   scx, scy = self._stretchfactor\n   shf = self._shearfactor\n   sa, ca = math.sin(self._tilt), math.cos(self._tilt)\n   self._shapetrafo = ( scx*ca, scy*(shf*ca + sa),\n   -scx*sa, scy*(ca - shf*sa))\n  self._update()\n  \n  \n  \n def _newLine(self, usePos = True):\n  \"\"\n def _update(self, count=True, forced=False):\n  \"\"\n def _color(self, args):\n  \"\"\n def _colorstr(self, args):\n  \"\"\n  \n width = pensize\n up = penup\n pu = penup\n pd = pendown\n down = pendown\n st = showturtle\n ht = hideturtle\n \n \nclass _TurtleImage:\n \"\"\n \n def __init__(self, screen, shapeIndex):\n  self.screen = screen\n  self._type = None\n  self._setshape(shapeIndex)\n  \n def _setshape(self, shapeIndex):\n \n  screen = self.screen\n  self.shapeIndex = shapeIndex\n  if self._type == \"polygon\" == screen._shapes[shapeIndex]._type:\n   return\n  if self._type == \"image\" == screen._shapes[shapeIndex]._type:\n   return\n  if self._type in [\"image\", \"polygon\"]:\n   screen._delete(self._item)\n  elif self._type == \"compound\":\n   for item in self._item:\n    screen._delete(item)\n  self._type = screen._shapes[shapeIndex]._type\n  return\n  \n  if self._type == \"polygon\":\n   self._item = screen._createpoly()\n  elif self._type == \"image\":\n   self._item = screen._createimage(screen._shapes[\"blank\"]._data)\n  elif self._type == \"compound\":\n   self._item = [screen._createpoly() for item in\n   screen._shapes[shapeIndex]._data]\n   \n   \nclass RawTurtle(TPen, TNavigator):\n \"\"\n screens = []\n \n def __init__(self, canvas=None,\n shape=_CFG[\"shape\"],\n undobuffersize=_CFG[\"undobuffersize\"],\n visible=_CFG[\"visible\"]):\n  if isinstance(canvas, _Screen):\n   self.screen = canvas\n  elif isinstance(canvas, TurtleScreen):\n   if canvas not in RawTurtle.screens:\n    RawTurtle.screens.append(canvas)\n   self.screen = canvas\n   \n   \n   \n   \n   \n   \n   \n   \n  else:\n   raise TurtleGraphicsError(\"bad canvas argument %s\" % canvas)\n   \n  screen = self.screen\n  TNavigator.__init__(self, screen.mode())\n  TPen.__init__(self)\n  screen._turtles.append(self)\n  \n  self.turtle = _TurtleImage(screen, shape)\n  self._poly = None\n  self._creatingPoly = False\n  self._fillitem = self._fillpath = None\n  self._shown = visible\n  self._hidden_from_screen = False\n  \n  self.currentLine = [self._position]\n  \n  self.stampItems = []\n  self._undobuffersize = undobuffersize\n  self.undobuffer = None \n  \n  \n  \n def reset(self):\n  \"\"\n  TNavigator.reset(self)\n  TPen._reset(self)\n  self._clear()\n  self._drawturtle()\n  \n  \n def setundobuffer(self, size):\n  \"\"\n  if size is None:\n   self.undobuffer = None\n  else:\n   self.undobuffer = Tbuffer(size)\n   \n def undobufferentries(self):\n  \"\"\n  if self.undobuffer is None:\n   return 0\n  return self.undobuffer.nr_of_items()\n  \n def _clear(self):\n  \"\"\n  self._fillitem = self._fillpath = None\n  \n  \n  \n  self.currentLine = []\n  if self._drawing:\n   self.currentLine.append(self._position)\n   \n  self.clearstamps()\n  \n  \n def clear(self):\n  \"\"\n  self._clear()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def _update(self):\n  \"\"\n  return\n  screen = self.screen\n  if screen._tracing == 0:\n   return\n  elif screen._tracing == 1:\n  \n   self._drawturtle()\n   \n   \n  else:\n  \n   if screen._updatecounter == 0:\n    for t in screen.turtles():\n     t._drawturtle()\n     \n     \n def _tracer(self, flag=None, delay=None):\n  \"\"\n  return self.screen.tracer(flag, delay)\n  \n def _color(self, args):\n  return self.screen._color(args)\n  \n def _colorstr(self, args):\n  return self.screen._colorstr(args)\n  \n def _cc(self, args):\n  \"\"\n  if isinstance(args, str):\n   return args\n  try:\n   r, g, b = args\n  except:\n   raise TurtleGraphicsError(\"bad color arguments: %s\" % str(args))\n  if self.screen._colormode == 1.0:\n   r, g, b = [round(255.0*x) for x in (r, g, b)]\n  if not ((0 <= r <= 255) and (0 <= g <= 255) and (0 <= b <= 255)):\n   raise TurtleGraphicsError(\"bad color sequence: %s\" % str(args))\n  return \"#%02x%02x%02x\" % (r, g, b)\n  \n def shape(self, name=None):\n  \"\"\n  if name is None:\n   return self.turtle.shapeIndex\n  if not name in self.screen.getshapes():\n   raise TurtleGraphicsError(\"There is no shape named %s\" % name)\n  self.turtle._setshape(name)\n  \n  \n def shapesize(self, stretch_wid=None, stretch_len=None, outline=None):\n  \"\"\n  if stretch_wid is stretch_len is outline is None:\n   stretch_wid, stretch_len = self._stretchfactor\n   return stretch_wid, stretch_len, self._outlinewidth\n  if stretch_wid == 0 or stretch_len == 0:\n   raise TurtleGraphicsError(\"stretch_wid/stretch_len must not be zero\")\n  if stretch_wid is not None:\n   if stretch_len is None:\n    stretchfactor = stretch_wid, stretch_wid\n   else:\n    stretchfactor = stretch_wid, stretch_len\n  elif stretch_len is not None:\n   stretchfactor = self._stretchfactor[0], stretch_len\n  else:\n   stretchfactor = self._stretchfactor\n  if outline is None:\n   outline = self._outlinewidth\n  self.pen(resizemode=\"user\",\n  stretchfactor=stretchfactor, outline=outline)\n  \n def shearfactor(self, shear=None):\n  \"\"\n  if shear is None:\n   return self._shearfactor\n  self.pen(resizemode=\"user\", shearfactor=shear)\n  \n def settiltangle(self, angle):\n  \"\"\n  tilt = -angle * self._degreesPerAU * self._angleOrient\n  tilt = (tilt * math.pi / 180.0) % (2*math.pi)\n  self.pen(resizemode=\"user\", tilt=tilt)\n  \n def tiltangle(self, angle=None):\n  \"\"\n  if angle is None:\n   tilt = -self._tilt * (180.0/math.pi) * self._angleOrient\n   return (tilt / self._degreesPerAU) % self._fullcircle\n  else:\n   self.settiltangle(angle)\n   \n def tilt(self, angle):\n  \"\"\n  self.settiltangle(angle + self.tiltangle())\n  \n def shapetransform(self, t11=None, t12=None, t21=None, t22=None):\n  \"\"\n  \n  if t11 is t12 is t21 is t22 is None:\n   return self._shapetrafo\n  m11, m12, m21, m22 = self._shapetrafo\n  if t11 is not None: m11 = t11\n  if t12 is not None: m12 = t12\n  if t21 is not None: m21 = t21\n  if t22 is not None: m22 = t22\n  if t11 * t22 - t12 * t21 == 0:\n   raise TurtleGraphicsError(\"Bad shape transform matrix: must not be singular\")\n  self._shapetrafo = (m11, m12, m21, m22)\n  alfa = math.atan2(-m21, m11) % (2 * math.pi)\n  sa, ca = math.sin(alfa), math.cos(alfa)\n  a11, a12, a21, a22 = (ca*m11 - sa*m21, ca*m12 - sa*m22,\n  sa*m11 + ca*m21, sa*m12 + ca*m22)\n  self._stretchfactor = a11, a22\n  self._shearfactor = a12/a22\n  self._tilt = alfa\n  self._update()\n  \n  \n def _polytrafo(self, poly):\n  \"\"\n  screen = self.screen\n  p0, p1 = self._position\n  e0, e1 = self._orient\n  e = Vec2D(e0, e1 * screen.yscale / screen.xscale)\n  e0, e1 = (1.0 / abs(e)) * e\n  return [(p0+(e1*x+e0*y)/screen.xscale, p1+(-e0*x+e1*y)/screen.yscale)\n  for (x, y) in poly]\n  \n def get_shapepoly(self):\n  \"\"\n  shape = self.screen._shapes[self.turtle.shapeIndex]\n  if shape._type == \"polygon\":\n   return self._getshapepoly(shape._data, shape._type == \"compound\")\n   \n   \n def _getshapepoly(self, polygon, compound=False):\n  \"\"\n  if self._resizemode == \"user\" or compound:\n   t11, t12, t21, t22 = self._shapetrafo\n  elif self._resizemode == \"auto\":\n   l = max(1, self._pensize/5.0)\n   t11, t12, t21, t22 = l, 0, 0, l\n  elif self._resizemode == \"noresize\":\n   return polygon\n  return tuple([(t11*x + t12*y, t21*x + t22*y) for (x, y) in polygon])\n  \n def _drawturtle(self):\n  \"\"\n  return\n  \n  \n  \n def stamp(self):\n  \"\"\n  screen = self.screen\n  shape = screen._shapes[self.turtle.shapeIndex]\n  ttype = shape._type\n  tshape = shape._data\n  if ttype == \"polygon\":\n   stitem = screen._createpoly()\n   if self._resizemode == \"noresize\": w = 1\n   elif self._resizemode == \"auto\": w = self._pensize\n   else: w =self._outlinewidth\n   shape = self._polytrafo(self._getshapepoly(tshape))\n   fc, oc = self._fillcolor, self._pencolor\n   screen._drawpoly(stitem, shape, fill=fc, outline=oc,\n   width=w, top=True)\n  elif ttype == \"image\":\n   stitem = screen._createimage(\"\")\n   screen._drawimage(stitem, self._position, tshape)\n  elif ttype == \"compound\":\n   stitem = []\n   for element in tshape:\n    item = screen._createpoly()\n    stitem.append(item)\n   stitem = tuple(stitem)\n   for item, (poly, fc, oc) in zip(stitem, tshape):\n    poly = self._polytrafo(self._getshapepoly(poly, True))\n    screen._drawpoly(item, poly, fill=self._cc(fc),\n    outline=self._cc(oc), width=self._outlinewidth, top=True)\n  self.stampItems.append(stitem)\n  self.undobuffer.push((\"stamp\", stitem))\n  return stitem\n  \n def _clearstamp(self, stampid):\n  \"\"\n  if stampid in self.stampItems:\n   if isinstance(stampid, tuple):\n    for subitem in stampid:\n     self.screen._delete(subitem)\n   else:\n    self.screen._delete(stampid)\n   self.stampItems.remove(stampid)\n   \n   \n  item = (\"stamp\", stampid)\n  buf = self.undobuffer\n  if item not in buf.buffer:\n   return\n  index = buf.buffer.index(item)\n  buf.buffer.remove(item)\n  if index <= buf.ptr:\n   buf.ptr = (buf.ptr - 1) % buf.bufsize\n  buf.buffer.insert((buf.ptr+1)%buf.bufsize, [None])\n  \n def clearstamp(self, stampid):\n  \"\"\n  self._clearstamp(stampid)\n  self._update()\n  \n def clearstamps(self, n=None):\n  \"\"\n  if n is None:\n   toDelete = self.stampItems[:]\n  elif n >= 0:\n   toDelete = self.stampItems[:n]\n  else:\n   toDelete = self.stampItems[n:]\n  for item in toDelete:\n   self._clearstamp(item)\n  self._update()\n  \n def _goto(self, end):\n  \"\"\n  \n  if self._speed and self.screen._tracing == 1:\n   if self._drawing:\n   \n   \n    self.screen._drawline(self, \n    (self._position, end),\n    self._pencolor, self._pensize, False)\n    \n  if isinstance(self._fillpath, list):\n   self._fillpath.append(end)\n   \n  self._position = end\n  \n def _rotate(self, angle):\n  \"\"\n  \n  if self.undobuffer:\n   self.undobuffer.push((\"rot\", angle, self._degreesPerAU))\n  angle *= self._degreesPerAU\n  neworient = self._orient.rotate(angle)\n  tracing = self.screen._tracing\n  \n  self._orient = neworient\n  \n  \n def _newLine(self, usePos=True):\n  \"\"\n  \n  return\n  \n def filling(self):\n  \"\"\n  return isinstance(self._fillpath, list)\n  \n def begin_fill(self):\n  \"\"\n  if not self.filling():\n   self._fillitem = self.screen._createpoly()\n   \n  self._fillpath = [self._position]\n  \n  if self.undobuffer:\n   self.undobuffer.push((\"beginfill\", self._fillitem))\n   \n   \n def end_fill(self):\n  \"\"\n  if self.filling():\n   if len(self._fillpath) > 2:\n    self.screen._drawpoly(self._fillitem, self._fillpath,\n    fill=self._fillcolor)\n    if self.undobuffer:\n     self.undobuffer.push((\"dofill\", self._fillitem))\n   self._fillitem = self._fillpath = None\n   self._update()\n   \n def dot(self, size=None, *color):\n  \"\"\n  if not color:\n   if isinstance(size, (str, tuple)):\n    color = self._colorstr(size)\n    size = self._pensize + max(self._pensize, 4)\n   else:\n    color = self._pencolor\n    if not size:\n     size = self._pensize + max(self._pensize, 4)\n  else:\n   if size is None:\n    size = self._pensize + max(self._pensize, 4)\n   color = self._colorstr(color)\n  if hasattr(self.screen, \"_dot\"):\n   item = self.screen._dot(self._position, size, color)\n   \n   if self.undobuffer:\n    self.undobuffer.push((\"dot\", item))\n  else:\n   pen = self.pen()\n   if self.undobuffer:\n    self.undobuffer.push([\"seq\"])\n    self.undobuffer.cumulate = True\n   try:\n    if self.resizemode() == 'auto':\n     self.ht()\n    self.pendown()\n    self.pensize(size)\n    self.pencolor(color)\n    self.forward(0)\n   finally:\n    self.pen(pen)\n   if self.undobuffer:\n    self.undobuffer.cumulate = False\n    \n def _write(self, txt, align, font):\n  \"\"\n  item, end = self.screen._write(self._position, txt, align, font,\n  self._pencolor)\n  \n  if self.undobuffer:\n   self.undobuffer.push((\"wri\", item))\n  return end\n  \n def write(self, arg, move=False, align=\"left\", font=(\"Arial\", 8, \"normal\")):\n  \"\"\n  if self.undobuffer:\n   self.undobuffer.push([\"seq\"])\n   self.undobuffer.cumulate = True\n  end = self._write(str(arg), align.lower(), font)\n  if move:\n   x, y = self.pos()\n   self.setpos(end, y)\n  if self.undobuffer:\n   self.undobuffer.cumulate = False\n   \n def begin_poly(self):\n  \"\"\n  self._poly = [self._position]\n  self._creatingPoly = True\n  \n def end_poly(self):\n  \"\"\n  self._creatingPoly = False\n  \n def get_poly(self):\n  \"\"\n  \n  if self._poly is not None:\n   return tuple(self._poly)\n   \n def getscreen(self):\n  \"\"\n  return self.screen\n  \n def getturtle(self):\n  \"\"\n  return self\n  \n getpen = getturtle\n \n \n \n \n \n \n def _delay(self, delay=None):\n  \"\"\n  return self.screen.delay(delay)\n  \n turtlesize = shapesize\n \nRawPen = RawTurtle\n\n\n\ndef Screen():\n \"\"\n if Turtle._screen is None:\n  Turtle._screen = _Screen()\n return Turtle._screen\n \nclass _Screen(TurtleScreen):\n\n _root = None\n _canvas = None\n _title = _CFG[\"title\"]\n \n def __init__(self):\n \n \n \n \n \n  if _Screen._root is None:\n   _Screen._root = self._root = _Root()\n   \n   \n  if _Screen._canvas is None:\n   width = _CFG[\"width\"]\n   height = _CFG[\"height\"]\n   canvwidth = _CFG[\"canvwidth\"]\n   canvheight = _CFG[\"canvheight\"]\n   leftright = _CFG[\"leftright\"]\n   topbottom = _CFG[\"topbottom\"]\n   self._root.setupcanvas(width, height, canvwidth, canvheight)\n   _Screen._canvas = self._root._getcanvas()\n   TurtleScreen.__init__(self, _Screen._canvas)\n   self.setup(width, height, leftright, topbottom)\n   \n def end(self):\n  self._root.end()\n  \n def setup(self, width=_CFG[\"width\"], height=_CFG[\"height\"],\n startx=_CFG[\"leftright\"], starty=_CFG[\"topbottom\"]):\n  \"\"\n  if not hasattr(self._root, \"set_geometry\"):\n   return\n  sw = self._root.win_width()\n  sh = self._root.win_height()\n  if isinstance(width, float) and 0 <= width <= 1:\n   width = sw*width\n  if startx is None:\n   startx = (sw - width) / 2\n  if isinstance(height, float) and 0 <= height <= 1:\n   height = sh*height\n  if starty is None:\n   starty = (sh - height) / 2\n  self._root.set_geometry(width, height, startx, starty)\n  self.update()\n  \nclass Turtle(RawTurtle):\n \"\"\n _pen = None\n _screen = None\n \n def __init__(self,\n shape=_CFG[\"shape\"],\n undobuffersize=_CFG[\"undobuffersize\"],\n visible=_CFG[\"visible\"]):\n  if Turtle._screen is None:\n   Turtle._screen = Screen()\n  RawTurtle.__init__(self, Turtle._screen,\n  shape=shape,\n  undobuffersize=undobuffersize,\n  visible=visible)\n  \nPen = Turtle\n\ndef _getpen():\n \"\"\n if Turtle._pen is None:\n  Turtle._pen = Turtle()\n return Turtle._pen\n \ndef _getscreen():\n \"\"\n if Turtle._screen is None:\n  Turtle._screen = Screen()\n return Turtle._screen\n \n \nif __name__ == \"__main__\":\n def switchpen():\n  if isdown():\n   pu()\n  else:\n   pd()\n   \n def demo1():\n  \"\"\n  reset()\n  tracer(True)\n  up()\n  backward(100)\n  down()\n  \n  width(3)\n  for i in range(3):\n   if i == 2:\n    begin_fill()\n   for _ in range(4):\n    forward(20)\n    left(90)\n   if i == 2:\n    color(\"maroon\")\n    end_fill()\n   up()\n   forward(30)\n   down()\n  width(1)\n  color(\"black\")\n  \n  tracer(False)\n  up()\n  right(90)\n  forward(100)\n  right(90)\n  forward(100)\n  right(180)\n  down()\n  \n  write(\"startstart\", 1)\n  write(\"start\", 1)\n  color(\"red\")\n  \n  for i in range(5):\n   forward(20)\n   left(90)\n   forward(20)\n   right(90)\n   \n  tracer(True)\n  begin_fill()\n  for i in range(5):\n   forward(20)\n   left(90)\n   forward(20)\n   right(90)\n  end_fill()\n  \n  \n def demo2():\n  \"\"\n  speed(1)\n  st()\n  pensize(3)\n  setheading(towards(0, 0))\n  radius = distance(0, 0)/2.0\n  rt(90)\n  for _ in range(18):\n   switchpen()\n   circle(radius, 10)\n  write(\"wait a moment...\")\n  while undobufferentries():\n   undo()\n  reset()\n  lt(90)\n  colormode(255)\n  laenge = 10\n  pencolor(\"green\")\n  pensize(3)\n  lt(180)\n  for i in range(-2, 16):\n   if i > 0:\n    begin_fill()\n    fillcolor(255-15*i, 0, 15*i)\n   for _ in range(3):\n    fd(laenge)\n    lt(120)\n   end_fill()\n   laenge += 10\n   lt(15)\n   speed((speed()+1)%12)\n   \n   \n  lt(120)\n  pu()\n  fd(70)\n  rt(30)\n  pd()\n  color(\"red\",\"yellow\")\n  speed(0)\n  begin_fill()\n  for _ in range(4):\n   circle(50, 90)\n   rt(90)\n   fd(30)\n   rt(90)\n  end_fill()\n  lt(90)\n  pu()\n  fd(30)\n  pd()\n  shape(\"turtle\")\n  \n  tri = getturtle()\n  tri.resizemode(\"auto\")\n  turtle = Turtle()\n  turtle.resizemode(\"auto\")\n  turtle.shape(\"turtle\")\n  turtle.reset()\n  turtle.left(90)\n  turtle.speed(0)\n  turtle.up()\n  turtle.goto(280, 40)\n  turtle.lt(30)\n  turtle.down()\n  turtle.speed(6)\n  turtle.color(\"blue\",\"orange\")\n  turtle.pensize(2)\n  tri.speed(6)\n  setheading(towards(turtle))\n  count = 1\n  while tri.distance(turtle) > 4:\n   turtle.fd(3.5)\n   turtle.lt(0.6)\n   tri.setheading(tri.towards(turtle))\n   tri.fd(4)\n   if count % 20 == 0:\n    turtle.stamp()\n    tri.stamp()\n    switchpen()\n   count += 1\n  tri.write(\"CAUGHT! \", font=(\"Arial\", 16, \"bold\"), align=\"right\")\n  tri.pencolor(\"black\")\n  tri.pencolor(\"red\")\n  \n  def baba(xdummy, ydummy):\n   clearscreen()\n   bye()\n   \n  time.sleep(2)\n  \n  while undobufferentries():\n   tri.undo()\n   turtle.undo()\n  tri.fd(50)\n  tri.write(\"  Click me!\", font = (\"Courier\", 12, \"bold\") )\n  tri.onclick(baba, 1)\n  \n demo1()\n demo2()\n exitonclick()\n"], "itertools": [".py", "import operator\n\nclass accumulate:\n def __init__(self, iterable, func = operator.add):\n  self.it = iter(iterable)\n  self._total = None\n  self.func = func\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if not self._total:\n   self._total = next(self.it)\n   return self._total\n  else:\n   element = next(self.it)\n   try:\n    self._total = self.func(self._total, element)\n   except:\n    raise TypeError(\"unsupported operand type\")\n   return self._total\n   \n   \n   \nclass chain:\n def __init__(self, *iterables):\n  self._iterables_iter = iter(map(iter, iterables))\n  \n  self._cur_iterable_iter = iter([])\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  while True:\n   try:\n    return next(self._cur_iterable_iter)\n   except StopIteration:\n    self._cur_iterable_iter = next(self._iterables_iter)\n    \n @classmethod\n def from_iterable(cls, iterable):\n  for it in iterable:\n   for element in it:\n    yield element\n    \nclass combinations:\n def __init__(self, iterable, r):\n  self.pool = tuple(iterable)\n  self.n = len(self.pool)\n  self.r = r\n  self.indices = list(range(self.r))\n  self.zero = False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if self.r > self.n:\n   raise StopIteration\n  if not self.zero:\n   self.zero = True\n   return tuple(self.pool[i] for i in self.indices)\n  else:\n   try:\n    for i in reversed(range(self.r)):\n     if self.indices[i] != i + self.n - self.r:\n      break\n    self.indices[i] += 1\n    for j in range(i+1, self.r):\n     self.indices[j] = self.indices[j-1] + 1\n    return tuple(self.pool[i] for i in self.indices)\n   except:\n    raise StopIteration\n    \nclass combinations_with_replacement:\n def __init__(self, iterable, r):\n  self.pool = tuple(iterable)\n  self.n = len(self.pool)\n  self.r = r\n  self.indices = [0] * self.r\n  self.zero = False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if not self.n and self.r:\n   raise StopIteration\n  if not self.zero:\n   self.zero = True\n   return tuple(self.pool[i] for i in self.indices)\n  else:\n   try:\n    for i in reversed(range(self.r)):\n     if self.indices[i] != self.n - 1:\n      break\n    self.indices[i:] = [self.indices[i] + 1] * (self.r - i)\n    return tuple(self.pool[i] for i in self.indices)\n   except:\n    raise StopIteration\n    \n    \n    \nclass compress:\n def __init__(self, data, selectors):\n  self.data = iter(data)\n  self.selectors = iter(selectors)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  while True:\n   next_item = next(self.data)\n   next_selector = next(self.selectors)\n   if bool(next_selector):\n    return next_item\n    \n    \n    \n    \nclass count:\n \"\"\n def __init__(self, start = 0, step = 1):\n  if not isinstance(start, (int, float)):\n   raise TypeError('a number is required')\n  self.times = start - step\n  self.step = step\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  self.times += self.step\n  return self.times\n  \n def __repr__(self):\n  return 'count(%d)' % (self.times + self.step)\n  \n  \n  \nclass cycle:\n def __init__(self, iterable):\n  self._cur_iter = iter(iterable)\n  self._saved = []\n  self._must_save = True\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  try:\n   next_elt = next(self._cur_iter)\n   if self._must_save:\n    self._saved.append(next_elt)\n  except StopIteration:\n   self._cur_iter = iter(self._saved)\n   next_elt = next(self._cur_iter)\n   self._must_save = False\n  return next_elt\n  \n  \n  \nclass dropwhile:\n def __init__(self, predicate, iterable):\n  self._predicate = predicate\n  self._iter = iter(iterable)\n  self._dropped = False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  value = next(self._iter)\n  if self._dropped:\n   return value\n  while self._predicate(value):\n   value = next(self._iter)\n  self._dropped = True\n  return value\n  \n  \n  \nclass filterfalse:\n def __init__(self, predicate, iterable):\n \n  self._iter = iter(iterable)\n  if predicate is None:\n   self._predicate = bool\n  else:\n   self._predicate = predicate\n   \n def __iter__(self):\n  return self\n def __next__(self):\n  next_elt = next(self._iter)\n  while True:\n   if not self._predicate(next_elt):\n    return next_elt\n   next_elt = next(self._iter)\n   \nclass groupby:\n\n\n def __init__(self, iterable, key=None):\n  if key is None:\n   key = lambda x: x\n  self.keyfunc = key\n  self.it = iter(iterable)\n  self.tgtkey = self.currkey = self.currvalue = object()\n def __iter__(self):\n  return self\n def __next__(self):\n  while self.currkey == self.tgtkey:\n   self.currvalue = next(self.it) \n   self.currkey = self.keyfunc(self.currvalue)\n  self.tgtkey = self.currkey\n  return (self.currkey, self._grouper(self.tgtkey))\n def _grouper(self, tgtkey):\n  while self.currkey == tgtkey:\n   yield self.currvalue\n   self.currvalue = next(self.it) \n   self.currkey = self.keyfunc(self.currvalue)\n   \n   \n   \nclass islice:\n def __init__(self, iterable, *args):\n  s = slice(*args)\n  self.start, self.stop, self.step = s.start or 0, s.stop, s.step\n  if not isinstance(self.start, int):\n   raise ValueError(\"Start argument must be an integer\")\n  if self.stop != None and not isinstance(self.stop, int):\n   raise ValueError(\"Stop argument must be an integer or None\")\n  if self.step is None:\n   self.step = 1\n  if self.start<0 or (self.stop != None and self.stop<0\n  ) or self.step<=0:\n   raise ValueError(\"indices for islice() must be positive\")\n  self.it = iter(iterable)\n  self.donext = None\n  self.cnt = 0\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  nextindex = self.start\n  if self.stop != None and nextindex >= self.stop:\n   raise StopIteration\n  while self.cnt <= nextindex:\n   nextitem = next(self.it)\n   self.cnt += 1\n  self.start += self.step \n  return nextitem\n  \nclass permutations:\n def __init__(self, iterable, r = None):\n  self.pool = tuple(iterable)\n  self.n = len(self.pool)\n  self.r = self.n if r is None else r\n  self.indices = list(range(self.n))\n  self.cycles = list(range(self.n, self.n - self.r, -1))\n  self.zero = False\n  self.stop = False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  indices = self.indices\n  if self.r > self.n:\n   raise StopIteration\n  if not self.zero:\n   self.zero = True\n   return tuple(self.pool[i] for i in indices[:self.r])\n   \n  i = self.r - 1\n  while i >= 0:\n   j = self.cycles[i] - 1\n   if j > 0:\n    self.cycles[i] = j\n    indices[i], indices[-j] = indices[-j], indices[i]\n    return tuple(self.pool[i] for i in indices[:self.r])\n   self.cycles[i] = len(indices) - i\n   n1 = len(indices) - 1\n   assert n1 >= 0\n   num = indices[i]\n   for k in range(i, n1):\n    indices[k] = indices[k+1]\n   indices[n1] = num\n   i -= 1\n  raise StopIteration\n  \n  \ndef product(*args, repeat=1):\n\n\n pools = [tuple(pool) for pool in args] * repeat\n result = [[]]\n for pool in pools:\n  result = [x+[y] for x in result for y in pool]\n for prod in result:\n  yield tuple(prod)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _product:\n def __init__(self, *args, **kw):\n  if len(kw) > 1:\n   raise TypeError(\"product() takes at most 1 argument (%d given)\" %\n   len(kw))\n  self.repeat = kw.get('repeat', 1)\n  if not isinstance(self.repeat, int):\n   raise TypeError(\"integer argument expected, got %s\" %\n   type(self.repeat))\n  self.gears = [x for x in args] * self.repeat\n  self.num_gears = len(self.gears)\n  \n  self.indicies = [(0, len(self.gears[x]))\n  for x in range(0, self.num_gears)]\n  self.cont = True\n  self.zero = False\n  \n def roll_gears(self):\n \n \n \n  should_carry = True\n  for n in range(0, self.num_gears):\n   nth_gear = self.num_gears - n - 1\n   if should_carry:\n    count, lim = self.indicies[nth_gear]\n    count += 1\n    if count == lim and nth_gear == 0:\n     self.cont = False\n    if count == lim:\n     should_carry = True\n     count = 0\n    else:\n     should_carry = False\n    self.indicies[nth_gear] = (count, lim) \n   else:\n    break\n    \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if self.zero:\n   raise StopIteration\n  if self.repeat > 0:\n   if not self.cont:\n    raise StopIteration\n   l = []\n   for x in range(0, self.num_gears):\n    index, limit = self.indicies[x]\n    print('itertools 353',self.gears,x,index)\n    l.append(self.gears[x][index])\n   self.roll_gears()\n   return tuple(l)\n  elif self.repeat == 0:\n   self.zero = True\n   return ()\n  else:\n   raise ValueError(\"repeat argument cannot be negative\")\n   \n   \n   \nclass repeat:\n def __init__(self, obj, times=None):\n  self._obj = obj\n  if times is not None:\n   range(times) \n   if times < 0:\n    times = 0\n  self._times = times\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n \n  if self._times is not None:\n   if self._times <= 0: \n    raise StopIteration()\n   self._times -= 1\n  return self._obj\n  \n def __repr__(self):\n  if self._times is not None:\n   return 'repeat(%r, %r)' % (self._obj, self._times)\n  else:\n   return 'repeat(%r)' % (self._obj,)\n   \n def __len__(self):\n  if self._times == -1 or self._times is None:\n   raise TypeError(\"len() of uniszed object\")\n  return self._times\n  \n  \n  \nclass starmap(object):\n def __init__(self, function, iterable):\n  self._func = function\n  self._iter = iter(iterable)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  t = next(self._iter)\n  return self._func(*t)\n  \n  \n  \nclass takewhile(object):\n def __init__(self, predicate, iterable):\n  self._predicate = predicate\n  self._iter = iter(iterable)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  value = next(self._iter)\n  if not self._predicate(value):\n   raise StopIteration()\n  return value\n  \n  \n  \nclass TeeData(object):\n def __init__(self, iterator):\n  self.data = []\n  self._iter = iterator\n  \n def __getitem__(self, i):\n \n  while i>= len(self.data):\n   self.data.append(next(self._iter))\n  return self.data[i]\n  \n  \nclass TeeObject(object):\n def __init__(self, iterable=None, tee_data=None):\n  if tee_data:\n   self.tee_data = tee_data\n   self.pos = 0\n   \n  elif isinstance(iterable, TeeObject):\n   self.tee_data = iterable.tee_data\n   self.pos = iterable.pos\n  else:\n   self.tee_data = TeeData(iter(iterable))\n   self.pos = 0\n   \n def __next__(self):\n  data = self.tee_data[self.pos]\n  self.pos += 1\n  return data\n  \n def __iter__(self):\n  return self\n  \n  \ndef tee(iterable, n=2):\n if isinstance(iterable, TeeObject):\n  return tuple([iterable] +\n  [TeeObject(tee_data=iterable.tee_data) for i in range(n - 1)])\n tee_data = TeeData(iter(iterable))\n return tuple([TeeObject(tee_data=tee_data) for i in range(n)])\n \nclass zip_longest:\n def __init__(self, *args, fillvalue = None):\n  self.args = args\n  self.fillvalue = fillvalue\n  self.max_length = max([len(arg) for arg in self.args])\n  self.units = len(args)\n  self.counter = 0\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if self.counter == self.max_length:\n   raise StopIteration\n  else:\n   temp = []\n   for i in range(self.units):\n    try:\n     temp.append(self.args[i][self.counter])\n    except:\n     temp.append(self.fillvalue)\n   self.counter = self.counter + 1\n   return tuple(temp)\n"], "crypto_js.rollups.md5": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(s,p){var m={},l=m.lib={},n=function(){},r=l.Base={extend:function(b){n.prototype=this;var h=new n;b&&h.mixIn(b);h.hasOwnProperty(\"init\")||(h.init=function(){h.$super.init.apply(this,arguments)});h.init.prototype=h;h.$super=this;return h},create:function(){var b=this.extend();b.init.apply(b,arguments);return b},init:function(){},mixIn:function(b){for(var h in b)b.hasOwnProperty(h)&&(this[h]=b[h]);b.hasOwnProperty(\"toString\")&&(this.toString=b.toString)},clone:function(){return this.init.prototype.extend(this)}},\nq=l.WordArray=r.extend({init:function(b,h){b=this.words=b||[];this.sigBytes=h!=p?h:4*b.length},toString:function(b){return(b||t).stringify(this)},concat:function(b){var h=this.words,a=b.words,j=this.sigBytes;b=b.sigBytes;this.clamp();if(j%4)for(var g=0;g<b;g++)h[j+g>>>2]|=(a[g>>>2]>>>24-8*(g%4)&255)<<24-8*((j+g)%4);else if(65535<a.length)for(g=0;g<b;g+=4)h[j+g>>>2]=a[g>>>2];else h.push.apply(h,a);this.sigBytes+=b;return this},clamp:function(){var b=this.words,h=this.sigBytes;b[h>>>2]&=4294967295<<\n32-8*(h%4);b.length=s.ceil(h/4)},clone:function(){var b=r.clone.call(this);b.words=this.words.slice(0);return b},random:function(b){for(var h=[],a=0;a<b;a+=4)h.push(4294967296*s.random()|0);return new q.init(h,b)}}),v=m.enc={},t=v.Hex={stringify:function(b){var a=b.words;b=b.sigBytes;for(var g=[],j=0;j<b;j++){var k=a[j>>>2]>>>24-8*(j%4)&255;g.push((k>>>4).toString(16));g.push((k&15).toString(16))}return g.join(\"\")},parse:function(b){for(var a=b.length,g=[],j=0;j<a;j+=2)g[j>>>3]|=parseInt(b.substr(j,\n2),16)<<24-4*(j%8);return new q.init(g,a/2)}},a=v.Latin1={stringify:function(b){var a=b.words;b=b.sigBytes;for(var g=[],j=0;j<b;j++)g.push(String.fromCharCode(a[j>>>2]>>>24-8*(j%4)&255));return g.join(\"\")},parse:function(b){for(var a=b.length,g=[],j=0;j<a;j++)g[j>>>2]|=(b.charCodeAt(j)&255)<<24-8*(j%4);return new q.init(g,a)}},u=v.Utf8={stringify:function(b){try{return decodeURIComponent(escape(a.stringify(b)))}catch(g){throw Error(\"Malformed UTF-8 data\");}},parse:function(b){return a.parse(unescape(encodeURIComponent(b)))}},\ng=l.BufferedBlockAlgorithm=r.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(b){\"string\"==typeof b&&(b=u.parse(b));this._data.concat(b);this._nDataBytes+=b.sigBytes},_process:function(b){var a=this._data,g=a.words,j=a.sigBytes,k=this.blockSize,m=j/(4*k),m=b?s.ceil(m):s.max((m|0)-this._minBufferSize,0);b=m*k;j=s.min(4*b,j);if(b){for(var l=0;l<b;l+=k)this._doProcessBlock(g,l);l=g.splice(0,b);a.sigBytes-=j}return new q.init(l,j)},clone:function(){var b=r.clone.call(this);\nb._data=this._data.clone();return b},_minBufferSize:0});l.Hasher=g.extend({cfg:r.extend(),init:function(b){this.cfg=this.cfg.extend(b);this.reset()},reset:function(){g.reset.call(this);this._doReset()},update:function(b){this._append(b);this._process();return this},finalize:function(b){b&&this._append(b);return this._doFinalize()},blockSize:16,_createHelper:function(b){return function(a,g){return(new b.init(g)).finalize(a)}},_createHmacHelper:function(b){return function(a,g){return(new k.HMAC.init(b,\ng)).finalize(a)}}});var k=m.algo={};return m}(Math);\n(function(s){function p(a,k,b,h,l,j,m){a=a+(k&b|~k&h)+l+m;return(a<<j|a>>>32-j)+k}function m(a,k,b,h,l,j,m){a=a+(k&h|b&~h)+l+m;return(a<<j|a>>>32-j)+k}function l(a,k,b,h,l,j,m){a=a+(k^b^h)+l+m;return(a<<j|a>>>32-j)+k}function n(a,k,b,h,l,j,m){a=a+(b^(k|~h))+l+m;return(a<<j|a>>>32-j)+k}for(var r=CryptoJS,q=r.lib,v=q.WordArray,t=q.Hasher,q=r.algo,a=[],u=0;64>u;u++)a[u]=4294967296*s.abs(s.sin(u+1))|0;q=q.MD5=t.extend({_doReset:function(){this._hash=new v.init([1732584193,4023233417,2562383102,271733878])},\n_doProcessBlock:function(g,k){for(var b=0;16>b;b++){var h=k+b,w=g[h];g[h]=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360}var b=this._hash.words,h=g[k+0],w=g[k+1],j=g[k+2],q=g[k+3],r=g[k+4],s=g[k+5],t=g[k+6],u=g[k+7],v=g[k+8],x=g[k+9],y=g[k+10],z=g[k+11],A=g[k+12],B=g[k+13],C=g[k+14],D=g[k+15],c=b[0],d=b[1],e=b[2],f=b[3],c=p(c,d,e,f,h,7,a[0]),f=p(f,c,d,e,w,12,a[1]),e=p(e,f,c,d,j,17,a[2]),d=p(d,e,f,c,q,22,a[3]),c=p(c,d,e,f,r,7,a[4]),f=p(f,c,d,e,s,12,a[5]),e=p(e,f,c,d,t,17,a[6]),d=p(d,e,f,c,u,22,a[7]),\nc=p(c,d,e,f,v,7,a[8]),f=p(f,c,d,e,x,12,a[9]),e=p(e,f,c,d,y,17,a[10]),d=p(d,e,f,c,z,22,a[11]),c=p(c,d,e,f,A,7,a[12]),f=p(f,c,d,e,B,12,a[13]),e=p(e,f,c,d,C,17,a[14]),d=p(d,e,f,c,D,22,a[15]),c=m(c,d,e,f,w,5,a[16]),f=m(f,c,d,e,t,9,a[17]),e=m(e,f,c,d,z,14,a[18]),d=m(d,e,f,c,h,20,a[19]),c=m(c,d,e,f,s,5,a[20]),f=m(f,c,d,e,y,9,a[21]),e=m(e,f,c,d,D,14,a[22]),d=m(d,e,f,c,r,20,a[23]),c=m(c,d,e,f,x,5,a[24]),f=m(f,c,d,e,C,9,a[25]),e=m(e,f,c,d,q,14,a[26]),d=m(d,e,f,c,v,20,a[27]),c=m(c,d,e,f,B,5,a[28]),f=m(f,c,\nd,e,j,9,a[29]),e=m(e,f,c,d,u,14,a[30]),d=m(d,e,f,c,A,20,a[31]),c=l(c,d,e,f,s,4,a[32]),f=l(f,c,d,e,v,11,a[33]),e=l(e,f,c,d,z,16,a[34]),d=l(d,e,f,c,C,23,a[35]),c=l(c,d,e,f,w,4,a[36]),f=l(f,c,d,e,r,11,a[37]),e=l(e,f,c,d,u,16,a[38]),d=l(d,e,f,c,y,23,a[39]),c=l(c,d,e,f,B,4,a[40]),f=l(f,c,d,e,h,11,a[41]),e=l(e,f,c,d,q,16,a[42]),d=l(d,e,f,c,t,23,a[43]),c=l(c,d,e,f,x,4,a[44]),f=l(f,c,d,e,A,11,a[45]),e=l(e,f,c,d,D,16,a[46]),d=l(d,e,f,c,j,23,a[47]),c=n(c,d,e,f,h,6,a[48]),f=n(f,c,d,e,u,10,a[49]),e=n(e,f,c,d,\nC,15,a[50]),d=n(d,e,f,c,s,21,a[51]),c=n(c,d,e,f,A,6,a[52]),f=n(f,c,d,e,q,10,a[53]),e=n(e,f,c,d,y,15,a[54]),d=n(d,e,f,c,w,21,a[55]),c=n(c,d,e,f,v,6,a[56]),f=n(f,c,d,e,D,10,a[57]),e=n(e,f,c,d,t,15,a[58]),d=n(d,e,f,c,B,21,a[59]),c=n(c,d,e,f,r,6,a[60]),f=n(f,c,d,e,z,10,a[61]),e=n(e,f,c,d,j,15,a[62]),d=n(d,e,f,c,x,21,a[63]);b[0]=b[0]+c|0;b[1]=b[1]+d|0;b[2]=b[2]+e|0;b[3]=b[3]+f|0},_doFinalize:function(){var a=this._data,k=a.words,b=8*this._nDataBytes,h=8*a.sigBytes;k[h>>>5]|=128<<24-h%32;var l=s.floor(b/\n4294967296);k[(h+64>>>9<<4)+15]=(l<<8|l>>>24)&16711935|(l<<24|l>>>8)&4278255360;k[(h+64>>>9<<4)+14]=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360;a.sigBytes=4*(k.length+1);this._process();a=this._hash;k=a.words;for(b=0;4>b;b++)h=k[b],k[b]=(h<<8|h>>>24)&16711935|(h<<24|h>>>8)&4278255360;return a},clone:function(){var a=t.clone.call(this);a._hash=this._hash.clone();return a}});r.MD5=t._createHelper(q);r.HmacMD5=t._createHmacHelper(q)})(Math);\n"], "opcode": [".py", "\n\"\"\n\n__all__ = [\"cmp_op\", \"hasconst\", \"hasname\", \"hasjrel\", \"hasjabs\",\n\"haslocal\", \"hascompare\", \"hasfree\", \"opname\", \"opmap\",\n\"HAVE_ARGUMENT\", \"EXTENDED_ARG\", \"hasnargs\"]\n\n\n\n\n\n\n\n\ntry:\n from _opcode import stack_effect\n __all__.append('stack_effect')\nexcept ImportError:\n pass\n \ncmp_op = ('<', '<=', '==', '!=', '>', '>=', 'in', 'not in', 'is',\n'is not', 'exception match', 'BAD')\n\nhasconst = []\nhasname = []\nhasjrel = []\nhasjabs = []\nhaslocal = []\nhascompare = []\nhasfree = []\nhasnargs = []\n\nopmap = {}\nopname = [''] * 256\nfor op in range(256): opname[op] = '<%r>' % (op,)\ndel op\n\ndef def_op(name, op):\n opname[op] = name\n opmap[name] = op\n \ndef name_op(name, op):\n def_op(name, op)\n hasname.append(op)\n \ndef jrel_op(name, op):\n def_op(name, op)\n hasjrel.append(op)\n \ndef jabs_op(name, op):\n def_op(name, op)\n hasjabs.append(op)\n \n \n \n \ndef_op('POP_TOP', 1)\ndef_op('ROT_TWO', 2)\ndef_op('ROT_THREE', 3)\ndef_op('DUP_TOP', 4)\ndef_op('DUP_TOP_TWO', 5)\n\ndef_op('NOP', 9)\ndef_op('UNARY_POSITIVE', 10)\ndef_op('UNARY_NEGATIVE', 11)\ndef_op('UNARY_NOT', 12)\n\ndef_op('UNARY_INVERT', 15)\n\ndef_op('BINARY_POWER', 19)\ndef_op('BINARY_MULTIPLY', 20)\n\ndef_op('BINARY_MODULO', 22)\ndef_op('BINARY_ADD', 23)\ndef_op('BINARY_SUBTRACT', 24)\ndef_op('BINARY_SUBSCR', 25)\ndef_op('BINARY_FLOOR_DIVIDE', 26)\ndef_op('BINARY_TRUE_DIVIDE', 27)\ndef_op('INPLACE_FLOOR_DIVIDE', 28)\ndef_op('INPLACE_TRUE_DIVIDE', 29)\n\ndef_op('STORE_MAP', 54)\ndef_op('INPLACE_ADD', 55)\ndef_op('INPLACE_SUBTRACT', 56)\ndef_op('INPLACE_MULTIPLY', 57)\n\ndef_op('INPLACE_MODULO', 59)\ndef_op('STORE_SUBSCR', 60)\ndef_op('DELETE_SUBSCR', 61)\ndef_op('BINARY_LSHIFT', 62)\ndef_op('BINARY_RSHIFT', 63)\ndef_op('BINARY_AND', 64)\ndef_op('BINARY_XOR', 65)\ndef_op('BINARY_OR', 66)\ndef_op('INPLACE_POWER', 67)\ndef_op('GET_ITER', 68)\n\ndef_op('PRINT_EXPR', 70)\ndef_op('LOAD_BUILD_CLASS', 71)\ndef_op('YIELD_FROM', 72)\n\ndef_op('INPLACE_LSHIFT', 75)\ndef_op('INPLACE_RSHIFT', 76)\ndef_op('INPLACE_AND', 77)\ndef_op('INPLACE_XOR', 78)\ndef_op('INPLACE_OR', 79)\ndef_op('BREAK_LOOP', 80)\ndef_op('WITH_CLEANUP', 81)\n\ndef_op('RETURN_VALUE', 83)\ndef_op('IMPORT_STAR', 84)\n\ndef_op('YIELD_VALUE', 86)\ndef_op('POP_BLOCK', 87)\ndef_op('END_FINALLY', 88)\ndef_op('POP_EXCEPT', 89)\n\nHAVE_ARGUMENT = 90 \n\nname_op('STORE_NAME', 90) \nname_op('DELETE_NAME', 91) \ndef_op('UNPACK_SEQUENCE', 92) \njrel_op('FOR_ITER', 93)\ndef_op('UNPACK_EX', 94)\nname_op('STORE_ATTR', 95) \nname_op('DELETE_ATTR', 96) \nname_op('STORE_GLOBAL', 97) \nname_op('DELETE_GLOBAL', 98) \ndef_op('LOAD_CONST', 100) \nhasconst.append(100)\nname_op('LOAD_NAME', 101) \ndef_op('BUILD_TUPLE', 102) \ndef_op('BUILD_LIST', 103) \ndef_op('BUILD_SET', 104) \ndef_op('BUILD_MAP', 105) \nname_op('LOAD_ATTR', 106) \ndef_op('COMPARE_OP', 107) \nhascompare.append(107)\nname_op('IMPORT_NAME', 108) \nname_op('IMPORT_FROM', 109) \n\njrel_op('JUMP_FORWARD', 110) \njabs_op('JUMP_IF_FALSE_OR_POP', 111) \njabs_op('JUMP_IF_TRUE_OR_POP', 112) \njabs_op('JUMP_ABSOLUTE', 113) \njabs_op('POP_JUMP_IF_FALSE', 114) \njabs_op('POP_JUMP_IF_TRUE', 115) \n\nname_op('LOAD_GLOBAL', 116) \n\njabs_op('CONTINUE_LOOP', 119) \njrel_op('SETUP_LOOP', 120) \njrel_op('SETUP_EXCEPT', 121) \njrel_op('SETUP_FINALLY', 122) \n\ndef_op('LOAD_FAST', 124) \nhaslocal.append(124)\ndef_op('STORE_FAST', 125) \nhaslocal.append(125)\ndef_op('DELETE_FAST', 126) \nhaslocal.append(126)\n\ndef_op('RAISE_VARARGS', 130) \ndef_op('CALL_FUNCTION', 131) \nhasnargs.append(131)\ndef_op('MAKE_FUNCTION', 132) \ndef_op('BUILD_SLICE', 133) \ndef_op('MAKE_CLOSURE', 134)\ndef_op('LOAD_CLOSURE', 135)\nhasfree.append(135)\ndef_op('LOAD_DEREF', 136)\nhasfree.append(136)\ndef_op('STORE_DEREF', 137)\nhasfree.append(137)\ndef_op('DELETE_DEREF', 138)\nhasfree.append(138)\n\ndef_op('CALL_FUNCTION_VAR', 140) \nhasnargs.append(140)\ndef_op('CALL_FUNCTION_KW', 141) \nhasnargs.append(141)\ndef_op('CALL_FUNCTION_VAR_KW', 142) \nhasnargs.append(142)\n\njrel_op('SETUP_WITH', 143)\n\ndef_op('LIST_APPEND', 145)\ndef_op('SET_ADD', 146)\ndef_op('MAP_ADD', 147)\n\ndef_op('LOAD_CLASSDEREF', 148)\nhasfree.append(148)\n\ndef_op('EXTENDED_ARG', 144)\nEXTENDED_ARG = 144\n\ndel def_op, name_op, jrel_op, jabs_op\n"], "_posixsubprocess": [".js", "var $module=(function($B){\n\n    return {\n       cloexec_pipe: function() {}   // fixme\n    }\n})(__BRYTHON__)\n"], "multiprocessing.util": [".py", "\n\n\n\n\n\n\n\n\nimport sys\nimport functools\nimport os\nimport itertools\nimport weakref\nimport atexit\nimport threading \n\nfrom subprocess import _args_from_interpreter_flags\n\nfrom multiprocessing.process import current_process, active_children\n\n__all__ = [\n'sub_debug', 'debug', 'info', 'sub_warning', 'get_logger',\n'log_to_stderr', 'get_temp_dir', 'register_after_fork',\n'is_exiting', 'Finalize', 'ForkAwareThreadLock', 'ForkAwareLocal',\n'SUBDEBUG', 'SUBWARNING',\n]\n\n\n\n\n\nNOTSET = 0\nSUBDEBUG = 5\nDEBUG = 10\nINFO = 20\nSUBWARNING = 25\n\nLOGGER_NAME = 'multiprocessing'\nDEFAULT_LOGGING_FORMAT = '[%(levelname)s/%(processName)s] %(message)s'\n\n_logger = None\n_log_to_stderr = False\n\ndef sub_debug(msg, *args):\n if _logger:\n  _logger.log(SUBDEBUG, msg, *args)\n  \ndef debug(msg, *args):\n if _logger:\n  _logger.log(DEBUG, msg, *args)\n  \ndef info(msg, *args):\n if _logger:\n  _logger.log(INFO, msg, *args)\n  \ndef sub_warning(msg, *args):\n if _logger:\n  _logger.log(SUBWARNING, msg, *args)\n  \ndef get_logger():\n \"\"\n global _logger\n import logging\n \n logging._acquireLock()\n try:\n  if not _logger:\n  \n   _logger = logging.getLogger(LOGGER_NAME)\n   _logger.propagate = 0\n   logging.addLevelName(SUBDEBUG, 'SUBDEBUG')\n   logging.addLevelName(SUBWARNING, 'SUBWARNING')\n   \n   \n   if hasattr(atexit, 'unregister'):\n    atexit.unregister(_exit_function)\n    atexit.register(_exit_function)\n   else:\n    atexit._exithandlers.remove((_exit_function, (), {}))\n    atexit._exithandlers.append((_exit_function, (), {}))\n    \n finally:\n  logging._releaseLock()\n  \n return _logger\n \ndef log_to_stderr(level=None):\n \"\"\n global _log_to_stderr\n import logging\n \n logger = get_logger()\n formatter = logging.Formatter(DEFAULT_LOGGING_FORMAT)\n handler = logging.StreamHandler()\n handler.setFormatter(formatter)\n logger.addHandler(handler)\n \n if level:\n  logger.setLevel(level)\n _log_to_stderr = True\n return _logger\n \n \n \n \n \ndef get_temp_dir():\n\n if current_process()._tempdir is None:\n  import shutil, tempfile\n  tempdir = tempfile.mkdtemp(prefix='pymp-')\n  info('created temp directory %s', tempdir)\n  Finalize(None, shutil.rmtree, args=[tempdir], exitpriority=-100)\n  current_process()._tempdir = tempdir\n return current_process()._tempdir\n \n \n \n \n \n_afterfork_registry = weakref.WeakValueDictionary()\n_afterfork_counter = itertools.count()\n\ndef _run_after_forkers():\n items = list(_afterfork_registry.items())\n items.sort()\n for (index, ident, func), obj in items:\n  try:\n   func(obj)\n  except Exception as e:\n   info('after forker raised exception %s', e)\n   \ndef register_after_fork(obj, func):\n _afterfork_registry[(next(_afterfork_counter), id(obj), func)] = obj\n \n \n \n \n \n_finalizer_registry = {}\n_finalizer_counter = itertools.count()\n\n\nclass Finalize(object):\n \"\"\n def __init__(self, obj, callback, args=(), kwargs=None, exitpriority=None):\n  assert exitpriority is None or type(exitpriority) is int\n  \n  if obj is not None:\n   self._weakref = weakref.ref(obj, self)\n  else:\n   assert exitpriority is not None\n   \n  self._callback = callback\n  self._args = args\n  self._kwargs = kwargs or {}\n  self._key = (exitpriority, next(_finalizer_counter))\n  self._pid = os.getpid()\n  \n  _finalizer_registry[self._key] = self\n  \n def __call__(self, wr=None,\n \n \n _finalizer_registry=_finalizer_registry,\n sub_debug=sub_debug, getpid=os.getpid):\n  \"\"\n  try:\n   del _finalizer_registry[self._key]\n  except KeyError:\n   sub_debug('finalizer no longer registered')\n  else:\n   if self._pid != getpid():\n    sub_debug('finalizer ignored because different process')\n    res = None\n   else:\n    sub_debug('finalizer calling %s with args %s and kwargs %s',\n    self._callback, self._args, self._kwargs)\n    res = self._callback(*self._args, **self._kwargs)\n   self._weakref = self._callback = self._args = self._kwargs = self._key = None\n   return res\n   \n def cancel(self):\n  \"\"\n  try:\n   del _finalizer_registry[self._key]\n  except KeyError:\n   pass\n  else:\n   self._weakref = self._callback = self._args = self._kwargs = self._key = None\n   \n def still_active(self):\n  \"\"\n  return self._key in _finalizer_registry\n  \n def __repr__(self):\n  try:\n   obj = self._weakref()\n  except (AttributeError, TypeError):\n   obj = None\n   \n  if obj is None:\n   return '<Finalize object, dead>'\n   \n  x = '<Finalize object, callback=%s' % getattr(self._callback, '__name__', self._callback)\n  if self._args:\n   x += ', args=' + str(self._args)\n  if self._kwargs:\n   x += ', kwargs=' + str(self._kwargs)\n  if self._key[0] is not None:\n   x += ', exitprority=' + str(self._key[0])\n  return x + '>'\n  \n  \ndef _run_finalizers(minpriority=None):\n \"\"\n if _finalizer_registry is None:\n \n \n \n  return\n  \n if minpriority is None:\n  f = lambda p : p[0][0] is not None\n else:\n  f = lambda p : p[0][0] is not None and p[0][0] >= minpriority\n  \n items = [x for x in list(_finalizer_registry.items()) if f(x)]\n items.sort(reverse=True)\n \n for key, finalizer in items:\n  sub_debug('calling %s', finalizer)\n  try:\n   finalizer()\n  except Exception:\n   import traceback\n   traceback.print_exc()\n   \n if minpriority is None:\n  _finalizer_registry.clear()\n  \n  \n  \n  \n  \ndef is_exiting():\n \"\"\n return _exiting or _exiting is None\n \n_exiting = False\n\ndef _exit_function(info=info, debug=debug, _run_finalizers=_run_finalizers,\nactive_children=active_children,\ncurrent_process=current_process):\n\n\n\n\n global _exiting\n \n if not _exiting:\n  _exiting = True\n  \n  info('process shutting down')\n  debug('running all \"atexit\" finalizers with priority >= 0')\n  _run_finalizers(0)\n  \n  if current_process() is not None:\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   for p in active_children():\n    if p._daemonic:\n     info('calling terminate() for daemon %s', p.name)\n     p._popen.terminate()\n     \n   for p in active_children():\n    info('calling join() for process %s', p.name)\n    p.join()\n    \n  debug('running the remaining \"atexit\" finalizers')\n  _run_finalizers()\n  \natexit.register(_exit_function)\n\n\n\n\n\nclass ForkAwareThreadLock(object):\n def __init__(self):\n  self._reset()\n  register_after_fork(self, ForkAwareThreadLock._reset)\n  \n def _reset(self):\n  self._lock = threading.Lock()\n  self.acquire = self._lock.acquire\n  self.release = self._lock.release\n  \nclass ForkAwareLocal(threading.local):\n def __init__(self):\n  register_after_fork(self, lambda obj : obj.__dict__.clear())\n def __reduce__(self):\n  return type(self), ()\n"], "xml.dom.xmlbuilder": [".py", "\"\"\n\nimport copy\nimport xml.dom\n\nfrom xml.dom.NodeFilter import NodeFilter\n\n\n__all__ = [\"DOMBuilder\", \"DOMEntityResolver\", \"DOMInputSource\"]\n\n\nclass Options:\n \"\"\n \n \n \n \n namespaces = 1\n namespace_declarations = True\n validation = False\n external_parameter_entities = True\n external_general_entities = True\n external_dtd_subset = True\n validate_if_schema = False\n validate = False\n datatype_normalization = False\n create_entity_ref_nodes = True\n entities = True\n whitespace_in_element_content = True\n cdata_sections = True\n comments = True\n charset_overrides_xml_encoding = True\n infoset = False\n supported_mediatypes_only = False\n \n errorHandler = None\n filter = None\n \n \nclass DOMBuilder:\n entityResolver = None\n errorHandler = None\n filter = None\n \n ACTION_REPLACE = 1\n ACTION_APPEND_AS_CHILDREN = 2\n ACTION_INSERT_AFTER = 3\n ACTION_INSERT_BEFORE = 4\n \n _legal_actions = (ACTION_REPLACE, ACTION_APPEND_AS_CHILDREN,\n ACTION_INSERT_AFTER, ACTION_INSERT_BEFORE)\n \n def __init__(self):\n  self._options = Options()\n  \n def _get_entityResolver(self):\n  return self.entityResolver\n def _set_entityResolver(self, entityResolver):\n  self.entityResolver = entityResolver\n  \n def _get_errorHandler(self):\n  return self.errorHandler\n def _set_errorHandler(self, errorHandler):\n  self.errorHandler = errorHandler\n  \n def _get_filter(self):\n  return self.filter\n def _set_filter(self, filter):\n  self.filter = filter\n  \n def setFeature(self, name, state):\n  if self.supportsFeature(name):\n   state = state and 1 or 0\n   try:\n    settings = self._settings[(_name_xform(name), state)]\n   except KeyError:\n    raise xml.dom.NotSupportedErr(\n    \"unsupported feature: %r\" % (name,))\n   else:\n    for name, value in settings:\n     setattr(self._options, name, value)\n  else:\n   raise xml.dom.NotFoundErr(\"unknown feature: \" + repr(name))\n   \n def supportsFeature(self, name):\n  return hasattr(self._options, _name_xform(name))\n  \n def canSetFeature(self, name, state):\n  key = (_name_xform(name), state and 1 or 0)\n  return key in self._settings\n  \n  \n  \n  \n  \n  \n _settings = {\n (\"namespace_declarations\", 0): [\n (\"namespace_declarations\", 0)],\n (\"namespace_declarations\", 1): [\n (\"namespace_declarations\", 1)],\n (\"validation\", 0): [\n (\"validation\", 0)],\n (\"external_general_entities\", 0): [\n (\"external_general_entities\", 0)],\n (\"external_general_entities\", 1): [\n (\"external_general_entities\", 1)],\n (\"external_parameter_entities\", 0): [\n (\"external_parameter_entities\", 0)],\n (\"external_parameter_entities\", 1): [\n (\"external_parameter_entities\", 1)],\n (\"validate_if_schema\", 0): [\n (\"validate_if_schema\", 0)],\n (\"create_entity_ref_nodes\", 0): [\n (\"create_entity_ref_nodes\", 0)],\n (\"create_entity_ref_nodes\", 1): [\n (\"create_entity_ref_nodes\", 1)],\n (\"entities\", 0): [\n (\"create_entity_ref_nodes\", 0),\n (\"entities\", 0)],\n (\"entities\", 1): [\n (\"entities\", 1)],\n (\"whitespace_in_element_content\", 0): [\n (\"whitespace_in_element_content\", 0)],\n (\"whitespace_in_element_content\", 1): [\n (\"whitespace_in_element_content\", 1)],\n (\"cdata_sections\", 0): [\n (\"cdata_sections\", 0)],\n (\"cdata_sections\", 1): [\n (\"cdata_sections\", 1)],\n (\"comments\", 0): [\n (\"comments\", 0)],\n (\"comments\", 1): [\n (\"comments\", 1)],\n (\"charset_overrides_xml_encoding\", 0): [\n (\"charset_overrides_xml_encoding\", 0)],\n (\"charset_overrides_xml_encoding\", 1): [\n (\"charset_overrides_xml_encoding\", 1)],\n (\"infoset\", 0): [],\n (\"infoset\", 1): [\n (\"namespace_declarations\", 0),\n (\"validate_if_schema\", 0),\n (\"create_entity_ref_nodes\", 0),\n (\"entities\", 0),\n (\"cdata_sections\", 0),\n (\"datatype_normalization\", 1),\n (\"whitespace_in_element_content\", 1),\n (\"comments\", 1),\n (\"charset_overrides_xml_encoding\", 1)],\n (\"supported_mediatypes_only\", 0): [\n (\"supported_mediatypes_only\", 0)],\n (\"namespaces\", 0): [\n (\"namespaces\", 0)],\n (\"namespaces\", 1): [\n (\"namespaces\", 1)],\n }\n \n def getFeature(self, name):\n  xname = _name_xform(name)\n  try:\n   return getattr(self._options, xname)\n  except AttributeError:\n   if name == \"infoset\":\n    options = self._options\n    return (options.datatype_normalization\n    and options.whitespace_in_element_content\n    and options.comments\n    and options.charset_overrides_xml_encoding\n    and not (options.namespace_declarations\n    or options.validate_if_schema\n    or options.create_entity_ref_nodes\n    or options.entities\n    or options.cdata_sections))\n   raise xml.dom.NotFoundErr(\"feature %s not known\" % repr(name))\n   \n def parseURI(self, uri):\n  if self.entityResolver:\n   input = self.entityResolver.resolveEntity(None, uri)\n  else:\n   input = DOMEntityResolver().resolveEntity(None, uri)\n  return self.parse(input)\n  \n def parse(self, input):\n  options = copy.copy(self._options)\n  options.filter = self.filter\n  options.errorHandler = self.errorHandler\n  fp = input.byteStream\n  if fp is None and options.systemId:\n   import urllib.request\n   fp = urllib.request.urlopen(input.systemId)\n  return self._parse_bytestream(fp, options)\n  \n def parseWithContext(self, input, cnode, action):\n  if action not in self._legal_actions:\n   raise ValueError(\"not a legal action\")\n  raise NotImplementedError(\"Haven't written this yet...\")\n  \n def _parse_bytestream(self, stream, options):\n  import xml.dom.expatbuilder\n  builder = xml.dom.expatbuilder.makeBuilder(options)\n  return builder.parseFile(stream)\n  \n  \ndef _name_xform(name):\n return name.lower().replace('-', '_')\n \n \nclass DOMEntityResolver(object):\n __slots__ = '_opener',\n \n def resolveEntity(self, publicId, systemId):\n  assert systemId is not None\n  source = DOMInputSource()\n  source.publicId = publicId\n  source.systemId = systemId\n  source.byteStream = self._get_opener().open(systemId)\n  \n  \n  source.encoding = self._guess_media_encoding(source)\n  \n  \n  import posixpath, urllib.parse\n  parts = urllib.parse.urlparse(systemId)\n  scheme, netloc, path, params, query, fragment = parts\n  \n  if path and not path.endswith(\"/\"):\n   path = posixpath.dirname(path) + \"/\"\n   parts = scheme, netloc, path, params, query, fragment\n   source.baseURI = urllib.parse.urlunparse(parts)\n   \n  return source\n  \n def _get_opener(self):\n  try:\n   return self._opener\n  except AttributeError:\n   self._opener = self._create_opener()\n   return self._opener\n   \n def _create_opener(self):\n  import urllib.request\n  return urllib.request.build_opener()\n  \n def _guess_media_encoding(self, source):\n  info = source.byteStream.info()\n  if \"Content-Type\" in info:\n   for param in info.getplist():\n    if param.startswith(\"charset=\"):\n     return param.split(\"=\", 1)[1].lower()\n     \n     \nclass DOMInputSource(object):\n __slots__ = ('byteStream', 'characterStream', 'stringData',\n 'encoding', 'publicId', 'systemId', 'baseURI')\n \n def __init__(self):\n  self.byteStream = None\n  self.characterStream = None\n  self.stringData = None\n  self.encoding = None\n  self.publicId = None\n  self.systemId = None\n  self.baseURI = None\n  \n def _get_byteStream(self):\n  return self.byteStream\n def _set_byteStream(self, byteStream):\n  self.byteStream = byteStream\n  \n def _get_characterStream(self):\n  return self.characterStream\n def _set_characterStream(self, characterStream):\n  self.characterStream = characterStream\n  \n def _get_stringData(self):\n  return self.stringData\n def _set_stringData(self, data):\n  self.stringData = data\n  \n def _get_encoding(self):\n  return self.encoding\n def _set_encoding(self, encoding):\n  self.encoding = encoding\n  \n def _get_publicId(self):\n  return self.publicId\n def _set_publicId(self, publicId):\n  self.publicId = publicId\n  \n def _get_systemId(self):\n  return self.systemId\n def _set_systemId(self, systemId):\n  self.systemId = systemId\n  \n def _get_baseURI(self):\n  return self.baseURI\n def _set_baseURI(self, uri):\n  self.baseURI = uri\n  \n  \nclass DOMBuilderFilter:\n \"\"\n \n \n \n \n \n \n FILTER_ACCEPT = 1\n FILTER_REJECT = 2\n FILTER_SKIP = 3\n FILTER_INTERRUPT = 4\n \n whatToShow = NodeFilter.SHOW_ALL\n \n def _get_whatToShow(self):\n  return self.whatToShow\n  \n def acceptNode(self, element):\n  return self.FILTER_ACCEPT\n  \n def startContainer(self, element):\n  return self.FILTER_ACCEPT\n  \ndel NodeFilter\n\n\nclass DocumentLS:\n \"\"\n \n async = False\n \n def _get_async(self):\n  return False\n def _set_async(self, async):\n  if async:\n   raise xml.dom.NotSupportedErr(\n   \"asynchronous document loading is not supported\")\n   \n def abort(self):\n \n \n  raise NotImplementedError(\n  \"haven't figured out what this means yet\")\n  \n def load(self, uri):\n  raise NotImplementedError(\"haven't written this yet\")\n  \n def loadXML(self, source):\n  raise NotImplementedError(\"haven't written this yet\")\n  \n def saveXML(self, snode):\n  if snode is None:\n   snode = self\n  elif snode.ownerDocument is not self:\n   raise xml.dom.WrongDocumentErr()\n  return snode.toxml()\n  \n  \nclass DOMImplementationLS:\n MODE_SYNCHRONOUS = 1\n MODE_ASYNCHRONOUS = 2\n \n def createDOMBuilder(self, mode, schemaType):\n  if schemaType is not None:\n   raise xml.dom.NotSupportedErr(\n   \"schemaType not yet supported\")\n  if mode == self.MODE_SYNCHRONOUS:\n   return DOMBuilder()\n  if mode == self.MODE_ASYNCHRONOUS:\n   raise xml.dom.NotSupportedErr(\n   \"asynchronous builders are not supported\")\n  raise ValueError(\"unknown value for mode\")\n  \n def createDOMWriter(self):\n  raise NotImplementedError(\n  \"the writer interface hasn't been written yet!\")\n  \n def createDOMInputSource(self):\n  return DOMInputSource()\n"], "os": [".py", "\"\"\n\nimport sys, errno\nimport stat as st\n\n_names = sys.builtin_module_names\n\n\n__all__ = [\"altsep\", \"curdir\", \"pardir\", \"sep\", \"pathsep\", \"linesep\",\n\"defpath\", \"name\", \"path\", \"devnull\", \"SEEK_SET\", \"SEEK_CUR\",\n\"SEEK_END\", \"fsencode\", \"fsdecode\", \"get_exec_path\", \"fdopen\",\n\"popen\", \"extsep\"]\n\ndef _exists(name):\n return name in globals()\n \ndef _get_exports_list(module):\n try:\n  return list(module.__all__)\n except AttributeError:\n  return [n for n in dir(module) if n[0] != '_']\n  \n  \n  \nif 'posix' in _names:\n name = 'posix'\n linesep = '\\n'\n from posix import *\n try:\n  from posix import _exit\n  __all__.append('_exit')\n except ImportError:\n  pass\n import posixpath as path\n \n try:\n  from posix import _have_functions\n except ImportError:\n  pass\n  \nelif 'nt' in _names:\n name = 'nt'\n linesep = '\\r\\n'\n from nt import *\n try:\n  from nt import _exit\n  __all__.append('_exit')\n except ImportError:\n  pass\n import ntpath as path\n \n import nt\n __all__.extend(_get_exports_list(nt))\n del nt\n \n try:\n  from nt import _have_functions\n except ImportError:\n  pass\n  \nelif 'os2' in _names:\n name = 'os2'\n linesep = '\\r\\n'\n from os2 import *\n try:\n  from os2 import _exit\n  __all__.append('_exit')\n except ImportError:\n  pass\n if sys.version.find('EMX GCC') == -1:\n  import ntpath as path\n else:\n  import os2emxpath as path\n  from _emx_link import link\n  \n import os2\n __all__.extend(_get_exports_list(os2))\n del os2\n \n try:\n  from os2 import _have_functions\n except ImportError:\n  pass\n  \nelif 'ce' in _names:\n name = 'ce'\n linesep = '\\r\\n'\n from ce import *\n try:\n  from ce import _exit\n  __all__.append('_exit')\n except ImportError:\n  pass\n  \n import ntpath as path\n \n import ce\n __all__.extend(_get_exports_list(ce))\n del ce\n \n try:\n  from ce import _have_functions\n except ImportError:\n  pass\n  \nelse:\n raise ImportError('no os specific module found')\n \nsys.modules['os.path'] = path\nfrom os.path import (curdir, pardir, sep, pathsep, defpath, extsep, altsep,\ndevnull)\n\ndel _names\n\n\nif _exists(\"_have_functions\"):\n _globals = globals()\n def _add(str, fn):\n  if (fn in _globals) and (str in _have_functions):\n   _set.add(_globals[fn])\n   \n _set = set()\n _add(\"HAVE_FACCESSAT\", \"access\")\n _add(\"HAVE_FCHMODAT\", \"chmod\")\n _add(\"HAVE_FCHOWNAT\", \"chown\")\n _add(\"HAVE_FSTATAT\", \"stat\")\n _add(\"HAVE_FUTIMESAT\", \"utime\")\n _add(\"HAVE_LINKAT\", \"link\")\n _add(\"HAVE_MKDIRAT\", \"mkdir\")\n _add(\"HAVE_MKFIFOAT\", \"mkfifo\")\n _add(\"HAVE_MKNODAT\", \"mknod\")\n _add(\"HAVE_OPENAT\", \"open\")\n _add(\"HAVE_READLINKAT\", \"readlink\")\n _add(\"HAVE_RENAMEAT\", \"rename\")\n _add(\"HAVE_SYMLINKAT\", \"symlink\")\n _add(\"HAVE_UNLINKAT\", \"unlink\")\n _add(\"HAVE_UNLINKAT\", \"rmdir\")\n _add(\"HAVE_UTIMENSAT\", \"utime\")\n supports_dir_fd = _set\n \n _set = set()\n _add(\"HAVE_FACCESSAT\", \"access\")\n supports_effective_ids = _set\n \n _set = set()\n _add(\"HAVE_FCHDIR\", \"chdir\")\n _add(\"HAVE_FCHMOD\", \"chmod\")\n _add(\"HAVE_FCHOWN\", \"chown\")\n _add(\"HAVE_FDOPENDIR\", \"listdir\")\n _add(\"HAVE_FEXECVE\", \"execve\")\n _set.add(stat) \n _add(\"HAVE_FTRUNCATE\", \"truncate\")\n _add(\"HAVE_FUTIMENS\", \"utime\")\n _add(\"HAVE_FUTIMES\", \"utime\")\n _add(\"HAVE_FPATHCONF\", \"pathconf\")\n if _exists(\"statvfs\") and _exists(\"fstatvfs\"): \n  _add(\"HAVE_FSTATVFS\", \"statvfs\")\n supports_fd = _set\n \n _set = set()\n _add(\"HAVE_FACCESSAT\", \"access\")\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n _add(\"HAVE_FCHOWNAT\", \"chown\")\n _add(\"HAVE_FSTATAT\", \"stat\")\n _add(\"HAVE_LCHFLAGS\", \"chflags\")\n _add(\"HAVE_LCHMOD\", \"chmod\")\n if _exists(\"lchown\"): \n  _add(\"HAVE_LCHOWN\", \"chown\")\n _add(\"HAVE_LINKAT\", \"link\")\n _add(\"HAVE_LUTIMES\", \"utime\")\n _add(\"HAVE_LSTAT\", \"stat\")\n _add(\"HAVE_FSTATAT\", \"stat\")\n _add(\"HAVE_UTIMENSAT\", \"utime\")\n _add(\"MS_WINDOWS\", \"stat\")\n supports_follow_symlinks = _set\n \n del _set\n del _have_functions\n del _globals\n del _add\n \n \n \n \n \nSEEK_SET = 0\nSEEK_CUR = 1\nSEEK_END = 2\n\n\ndef _get_masked_mode(mode):\n mask = umask(0)\n umask(mask)\n return mode & ~mask\n \n \n \n \ndef makedirs(name, mode=0o777, exist_ok=False):\n \"\"\n head, tail = path.split(name)\n if not tail:\n  head, tail = path.split(head)\n if head and tail and not path.exists(head):\n  try:\n   makedirs(head, mode, exist_ok)\n  except OSError as e:\n  \n   if e.errno != errno.EEXIST:\n    raise\n  cdir = curdir\n  if isinstance(tail, bytes):\n   cdir = bytes(curdir, 'ASCII')\n  if tail == cdir: \n   return\n try:\n  mkdir(name, mode)\n except OSError as e:\n  dir_exists = path.isdir(name)\n  expected_mode = _get_masked_mode(mode)\n  if dir_exists:\n  \n  \n  \n   actual_mode = st.S_IMODE(lstat(name).st_mode) & ~st.S_ISGID\n  else:\n   actual_mode = -1\n  if not (e.errno == errno.EEXIST and exist_ok and dir_exists and\n  actual_mode == expected_mode):\n   if dir_exists and actual_mode != expected_mode:\n    e.strerror += ' (mode %o != expected mode %o)' % (\n    actual_mode, expected_mode)\n   raise\n   \ndef removedirs(name):\n \"\"\n rmdir(name)\n head, tail = path.split(name)\n if not tail:\n  head, tail = path.split(head)\n while head and tail:\n  try:\n   rmdir(head)\n  except error:\n   break\n  head, tail = path.split(head)\n  \ndef renames(old, new):\n \"\"\n head, tail = path.split(new)\n if head and tail and not path.exists(head):\n  makedirs(head)\n rename(old, new)\n head, tail = path.split(old)\n if head and tail:\n  try:\n   removedirs(head)\n  except error:\n   pass\n   \n__all__.extend([\"makedirs\", \"removedirs\", \"renames\"])\n\ndef walk(top, topdown=True, onerror=None, followlinks=False):\n \"\"\n \n islink, join, isdir = path.islink, path.join, path.isdir\n \n \n \n \n \n \n try:\n \n \n  names = listdir(top)\n except error as err:\n  if onerror is not None:\n   onerror(err)\n  return\n  \n dirs, nondirs = [], []\n for name in names:\n  if isdir(join(top, name)):\n   dirs.append(name)\n  else:\n   nondirs.append(name)\n   \n if topdown:\n  yield top, dirs, nondirs\n for name in dirs:\n  new_path = join(top, name)\n  if followlinks or not islink(new_path):\n   yield from walk(new_path, topdown, onerror, followlinks)\n if not topdown:\n  yield top, dirs, nondirs\n  \n__all__.append(\"walk\")\n\nif {open, stat} <= supports_dir_fd and {listdir, stat} <= supports_fd:\n\n def fwalk(top=\".\", topdown=True, onerror=None, *, follow_symlinks=False, dir_fd=None):\n  \"\"\n  \n  \n  orig_st = stat(top, follow_symlinks=False, dir_fd=dir_fd)\n  topfd = open(top, O_RDONLY, dir_fd=dir_fd)\n  try:\n   if (follow_symlinks or (st.S_ISDIR(orig_st.st_mode) and\n   path.samestat(orig_st, stat(topfd)))):\n    yield from _fwalk(topfd, top, topdown, onerror, follow_symlinks)\n  finally:\n   close(topfd)\n   \n def _fwalk(topfd, toppath, topdown, onerror, follow_symlinks):\n \n \n \n \n  names = listdir(topfd)\n  dirs, nondirs = [], []\n  for name in names:\n   try:\n   \n   \n   \n   \n    if st.S_ISDIR(stat(name, dir_fd=topfd).st_mode):\n     dirs.append(name)\n    else:\n     nondirs.append(name)\n   except FileNotFoundError:\n    try:\n    \n     if st.S_ISLNK(stat(name, dir_fd=topfd, follow_symlinks=False)\n     .st_mode):\n      nondirs.append(name)\n    except FileNotFoundError:\n     continue\n     \n  if topdown:\n   yield toppath, dirs, nondirs, topfd\n   \n  for name in dirs:\n   try:\n    orig_st = stat(name, dir_fd=topfd, follow_symlinks=follow_symlinks)\n    dirfd = open(name, O_RDONLY, dir_fd=topfd)\n   except error as err:\n    if onerror is not None:\n     onerror(err)\n    return\n   try:\n    if follow_symlinks or path.samestat(orig_st, stat(dirfd)):\n     dirpath = path.join(toppath, name)\n     yield from _fwalk(dirfd, dirpath, topdown, onerror, follow_symlinks)\n   finally:\n    close(dirfd)\n    \n  if not topdown:\n   yield toppath, dirs, nondirs, topfd\n   \n __all__.append(\"fwalk\")\n \n \ntry:\n environ\nexcept NameError:\n environ = {}\n \ndef execl(file, *args):\n \"\"\n execv(file, args)\n \ndef execle(file, *args):\n \"\"\n env = args[-1]\n execve(file, args[:-1], env)\n \ndef execlp(file, *args):\n \"\"\n execvp(file, args)\n \ndef execlpe(file, *args):\n \"\"\n env = args[-1]\n execvpe(file, args[:-1], env)\n \ndef execvp(file, args):\n \"\"\n _execvpe(file, args)\n \ndef execvpe(file, args, env):\n \"\"\n _execvpe(file, args, env)\n \n__all__.extend([\"execl\",\"execle\",\"execlp\",\"execlpe\",\"execvp\",\"execvpe\"])\n\ndef _execvpe(file, args, env=None):\n if env is not None:\n  exec_func = execve\n  argrest = (args, env)\n else:\n  exec_func = execv\n  argrest = (args,)\n  env = environ\n  \n head, tail = path.split(file)\n if head:\n  exec_func(file, *argrest)\n  return\n last_exc = saved_exc = None\n saved_tb = None\n path_list = get_exec_path(env)\n if name != 'nt':\n  file = fsencode(file)\n  path_list = map(fsencode, path_list)\n for dir in path_list:\n  fullname = path.join(dir, file)\n  try:\n   exec_func(fullname, *argrest)\n  except error as e:\n   last_exc = e\n   tb = sys.exc_info()[2]\n   if (e.errno != errno.ENOENT and e.errno != errno.ENOTDIR\n   and saved_exc is None):\n    saved_exc = e\n    saved_tb = tb\n if saved_exc:\n  raise saved_exc.with_traceback(saved_tb)\n raise last_exc.with_traceback(tb)\n \n \ndef get_exec_path(env=None):\n \"\"\n \n \n \n import warnings\n \n if env is None:\n  env = environ\n  \n  \n  \n with warnings.catch_warnings():\n  warnings.simplefilter(\"ignore\", BytesWarning)\n  \n  try:\n   path_list = env.get('PATH')\n  except TypeError:\n   path_list = None\n   \n  if supports_bytes_environ:\n   try:\n    path_listb = env[b'PATH']\n   except (KeyError, TypeError):\n    pass\n   else:\n    if path_list is not None:\n     raise ValueError(\n     \"env cannot contain 'PATH' and b'PATH' keys\")\n    path_list = path_listb\n    \n   if path_list is not None and isinstance(path_list, bytes):\n    path_list = fsdecode(path_list)\n    \n if path_list is None:\n  path_list = defpath\n return path_list.split(pathsep)\n \n \n \nfrom collections.abc import MutableMapping\n\nclass _Environ(MutableMapping):\n def __init__(self, data, encodekey, decodekey, encodevalue, decodevalue, putenv, unsetenv):\n  self.encodekey = encodekey\n  self.decodekey = decodekey\n  self.encodevalue = encodevalue\n  self.decodevalue = decodevalue\n  self.putenv = putenv\n  self.unsetenv = unsetenv\n  self._data = data\n  \n def __getitem__(self, key):\n  try:\n   value = self._data[self.encodekey(key)]\n  except KeyError:\n  \n   raise KeyError(key) from None\n  return self.decodevalue(value)\n  \n def __setitem__(self, key, value):\n  key = self.encodekey(key)\n  value = self.encodevalue(value)\n  self.putenv(key, value)\n  self._data[key] = value\n  \n def __delitem__(self, key):\n  encodedkey = self.encodekey(key)\n  self.unsetenv(encodedkey)\n  try:\n   del self._data[encodedkey]\n  except KeyError:\n  \n   raise KeyError(key) from None\n   \n def __iter__(self):\n  for key in self._data:\n   yield self.decodekey(key)\n   \n def __len__(self):\n  return len(self._data)\n  \n def __repr__(self):\n  return 'environ({{{}}})'.format(', '.join(\n  ('{!r}: {!r}'.format(self.decodekey(key), self.decodevalue(value))\n  for key, value in self._data.items())))\n  \n def copy(self):\n  return dict(self)\n  \n def setdefault(self, key, value):\n  if key not in self:\n   self[key] = value\n  return self[key]\n  \ntry:\n _putenv = putenv\nexcept NameError:\n _putenv = lambda key, value: None\nelse:\n __all__.append(\"putenv\")\n \ntry:\n _unsetenv = unsetenv\nexcept NameError:\n _unsetenv = lambda key: _putenv(key, \"\")\nelse:\n __all__.append(\"unsetenv\")\n \ndef _createenviron():\n if name in ('os2', 'nt'):\n \n  def check_str(value):\n   if not isinstance(value, str):\n    raise TypeError(\"str expected, not %s\" % type(value).__name__)\n   return value\n  encode = check_str\n  decode = str\n  def encodekey(key):\n   return encode(key).upper()\n  data = {}\n  for key, value in environ.items():\n   data[encodekey(key)] = value\n else:\n \n  encoding = sys.getfilesystemencoding()\n  def encode(value):\n   if not isinstance(value, str):\n    raise TypeError(\"str expected, not %s\" % type(value).__name__)\n   return value.encode(encoding, 'surrogateescape')\n  def decode(value):\n   return value.decode(encoding, 'surrogateescape')\n  encodekey = encode\n  data = environ\n return _Environ(data,\n encodekey, decode,\n encode, decode,\n _putenv, _unsetenv)\n \n \nenviron = _createenviron()\ndel _createenviron\n\n\ndef getenv(key, default=None):\n \"\"\n return environ.get(key, default)\n \nsupports_bytes_environ = name not in ('os2', 'nt')\n__all__.extend((\"getenv\", \"supports_bytes_environ\"))\n\nif supports_bytes_environ:\n def _check_bytes(value):\n  if not isinstance(value, bytes):\n   raise TypeError(\"bytes expected, not %s\" % type(value).__name__)\n  return value\n  \n  \n environb = _Environ(environ._data,\n _check_bytes, bytes,\n _check_bytes, bytes,\n _putenv, _unsetenv)\n del _check_bytes\n \n def getenvb(key, default=None):\n  \"\"\n  return environb.get(key, default)\n  \n __all__.extend((\"environb\", \"getenvb\"))\n \ndef _fscodec():\n encoding = sys.getfilesystemencoding()\n if encoding == 'mbcs':\n  errors = 'strict'\n else:\n  errors = 'surrogateescape'\n  \n def fsencode(filename):\n  \"\"\n  if isinstance(filename, bytes):\n   return filename\n  elif isinstance(filename, str):\n   return filename.encode(encoding, errors)\n  else:\n   raise TypeError(\"expect bytes or str, not %s\" % type(filename).__name__)\n   \n def fsdecode(filename):\n  \"\"\n  if isinstance(filename, str):\n   return filename\n  elif isinstance(filename, bytes):\n   return filename.decode(encoding, errors)\n  else:\n   raise TypeError(\"expect bytes or str, not %s\" % type(filename).__name__)\n   \n return fsencode, fsdecode\n \nfsencode, fsdecode = _fscodec()\ndel _fscodec\n\n\nif _exists(\"fork\") and not _exists(\"spawnv\") and _exists(\"execv\"):\n\n P_WAIT = 0\n P_NOWAIT = P_NOWAITO = 1\n \n __all__.extend([\"P_WAIT\", \"P_NOWAIT\", \"P_NOWAITO\"])\n \n \n \n \n \n def _spawnvef(mode, file, args, env, func):\n \n  pid = fork()\n  if not pid:\n  \n   try:\n    if env is None:\n     func(file, args)\n    else:\n     func(file, args, env)\n   except:\n    _exit(127)\n  else:\n  \n   if mode == P_NOWAIT:\n    return pid \n   while 1:\n    wpid, sts = waitpid(pid, 0)\n    if WIFSTOPPED(sts):\n     continue\n    elif WIFSIGNALED(sts):\n     return -WTERMSIG(sts)\n    elif WIFEXITED(sts):\n     return WEXITSTATUS(sts)\n    else:\n     raise error(\"Not stopped, signaled or exited???\")\n     \n def spawnv(mode, file, args):\n  \"\"\n  return _spawnvef(mode, file, args, None, execv)\n  \n def spawnve(mode, file, args, env):\n  \"\"\n  return _spawnvef(mode, file, args, env, execve)\n  \n  \n  \n def spawnvp(mode, file, args):\n  \"\"\n  return _spawnvef(mode, file, args, None, execvp)\n  \n def spawnvpe(mode, file, args, env):\n  \"\"\n  return _spawnvef(mode, file, args, env, execvpe)\n  \nif _exists(\"spawnv\"):\n\n\n\n def spawnl(mode, file, *args):\n  \"\"\n  return spawnv(mode, file, args)\n  \n def spawnle(mode, file, *args):\n  \"\"\n  env = args[-1]\n  return spawnve(mode, file, args[:-1], env)\n  \n  \n __all__.extend([\"spawnv\", \"spawnve\", \"spawnl\", \"spawnle\",])\n \n \nif _exists(\"spawnvp\"):\n\n\n def spawnlp(mode, file, *args):\n  \"\"\n  return spawnvp(mode, file, args)\n  \n def spawnlpe(mode, file, *args):\n  \"\"\n  env = args[-1]\n  return spawnvpe(mode, file, args[:-1], env)\n  \n  \n __all__.extend([\"spawnvp\", \"spawnvpe\", \"spawnlp\", \"spawnlpe\",])\n \nimport copyreg as _copyreg\n\ndef _make_stat_result(tup, dict):\n return stat_result(tup, dict)\n \ndef _pickle_stat_result(sr):\n (type, args) = sr.__reduce__()\n return (_make_stat_result, args)\n \ntry:\n _copyreg.pickle(stat_result, _pickle_stat_result, _make_stat_result)\nexcept NameError: \n pass\n \ndef _make_statvfs_result(tup, dict):\n return statvfs_result(tup, dict)\n \ndef _pickle_statvfs_result(sr):\n (type, args) = sr.__reduce__()\n return (_make_statvfs_result, args)\n \ntry:\n _copyreg.pickle(statvfs_result, _pickle_statvfs_result,\n _make_statvfs_result)\nexcept NameError: \n pass\n \n \ndef popen(cmd, mode=\"r\", buffering=-1):\n if not isinstance(cmd, str):\n  raise TypeError(\"invalid cmd type (%s, expected string)\" % type(cmd))\n if mode not in (\"r\", \"w\"):\n  raise ValueError(\"invalid mode %r\" % mode)\n if buffering == 0 or buffering is None:\n  raise ValueError(\"popen() does not support unbuffered streams\")\n import subprocess, io\n if mode == \"r\":\n  proc = subprocess.Popen(cmd,\n  shell=True,\n  stdout=subprocess.PIPE,\n  bufsize=buffering)\n  return _wrap_close(io.TextIOWrapper(proc.stdout), proc)\n else:\n  proc = subprocess.Popen(cmd,\n  shell=True,\n  stdin=subprocess.PIPE,\n  bufsize=buffering)\n  return _wrap_close(io.TextIOWrapper(proc.stdin), proc)\n  \n  \nclass _wrap_close:\n def __init__(self, stream, proc):\n  self._stream = stream\n  self._proc = proc\n def close(self):\n  self._stream.close()\n  returncode = self._proc.wait()\n  if returncode == 0:\n   return None\n  if name == 'nt':\n   return returncode\n  else:\n   return returncode << 8 \n def __enter__(self):\n  return self\n def __exit__(self, *args):\n  self.close()\n def __getattr__(self, name):\n  return getattr(self._stream, name)\n def __iter__(self):\n  return iter(self._stream)\n  \n  \ndef fdopen(fd, *args, **kwargs):\n if not isinstance(fd, int):\n  raise TypeError(\"invalid fd type (%s, expected integer)\" % type(fd))\n import io\n return io.open(fd, *args, **kwargs)\n"], "marshal": [".py", "from json import *"], "site-packages.pygame.font": [".py", "from browser import html\nfrom . import surface\n\ndef init():\n return\n \ndef quit():\n return\n \ndef get_init():\n return True\n \ndef get_default_font():\n return \"10px sans-serif\"\n \n \nclass Font:\n def __init__(self, obj, size):\n  self._obj=obj\n  self._size=size\n  \n def render(self, text, antialias, color, background=None):\n  _canvas=html.CANVAS()\n  _ctx=_canvas.getContext('2d')\n  \n  if background is not None:\n   _ctx.fillStyle='rgb(%s,%s,%s)' % color \n   _ctx.fillRect(0,0, _canvas.width, _canvas.height)\n   \n  _ctx.fillStyle='rgb(%s,%s,%s)' % color\n  _ctx.fillText(text, 0, 0)\n  \n  return surface.Surface(surf=_canvas) \n  \n def size(self, text):\n  _canvas = html.CANVAS(width=1000, height=1000)\n  _ctx = _canvas.getContext('2d')\n  \n  \n  \n  _metrics = _ctx.measureText(text);\n  return (_metrics.width, _metrics.height)\n  \n"], "ui.slider": [".py", "from . import widget\nfrom browser import doc,html\n\nclass Slider(widget.Widget):\n\n def __init__(self, id=None, label=False):\n \n  self._div_shell=html.DIV(Class=\"ui-slider ui-slider-horizontal ui-widget ui-widget-content ui-corner-all\")\n  \n  widget.Widget.__init__(self, self._div_shell, 'slider', id)\n  \n  self._handle=html.A(Class=\"ui-slider-handle ui-state-default ui-corner-all\",\n  Href='#', style={'left': '0px'})\n  self._value=0\n  self._isMouseDown=False\n  self.m0 = [None, None]\n  \n  def startSlide(ev):\n   self._isMouseDown=True\n   self._upperBound = self._div_shell.offsetWidth - self._handle.offsetWidth\n   \n   pos = widget.getMousePosition(ev)\n   self._startMouseX=pos['x']\n   \n   print('left', self._handle.style.left,'ev.x',ev.x)\n   self._lastElementLeft = int(self._handle.left)\n   print('left', self._lastElementLeft)\n   updatePosition(ev)\n   \n  def updatePosition(ev):\n  \n  \n   _newPos = self._lastElementLeft + ev.x - self._startMouseX\n   \n   _newPos = max(0, _newPos)\n   _newPos = min(_newPos, self._upperBound)\n   \n   self._handle.left = _newPos\n   print('new position',self._handle.style.left)\n   self._lastElementLeft = _newPos\n   \n  def moving(e):\n   if self._isMouseDown:\n    updatePosition(e)\n    \n  def dropCallback(e):\n   self._isMouseDown=False\n   self._handle.unbind('mousemove', moving)\n   \n   \n  self._handle.bind('mousemove', moving)\n  self._handle.bind('mouseup', dropCallback)\n  \n  self._handle.bind('mousedown', startSlide)\n  \n  def mouseover(e):\n   _class=self._handle.getAttribute('class')\n   self._handle.setAttribute('class', '%s %s' % (_class, 'ui-state-hover'))\n   \n  def mouseout(e):\n   self._isMouseDown=False\n   _class=self._handle.getAttribute('class')\n   self._handle.setAttribute('class', _class.replace('ui-state-hover', ''))\n   \n  self._handle.bind('mouseover', mouseover)\n  self._handle.bind('mouseout', mouseout)\n  \n  self._div_shell <= self._handle\n  \n def get_value(self):\n  return self._value\n  \n  \n  \n  \n"], "pprint": [".py", "\n\n\n\n\n\n\n\n\n\n\"\"\n\nimport sys as _sys\nfrom collections import OrderedDict as _OrderedDict\nfrom io import StringIO as _StringIO\n\n__all__ = [\"pprint\",\"pformat\",\"isreadable\",\"isrecursive\",\"saferepr\",\n\"PrettyPrinter\"]\n\n\n_commajoin = \", \".join\n_id = id\n_len = len\n_type = type\n\n\ndef pprint(object, stream=None, indent=1, width=80, depth=None):\n \"\"\n printer = PrettyPrinter(\n stream=stream, indent=indent, width=width, depth=depth)\n printer.pprint(object)\n \ndef pformat(object, indent=1, width=80, depth=None):\n \"\"\n return PrettyPrinter(indent=indent, width=width, depth=depth).pformat(object)\n \ndef saferepr(object):\n \"\"\n return _safe_repr(object, {}, None, 0)[0]\n \ndef isreadable(object):\n \"\"\n return _safe_repr(object, {}, None, 0)[1]\n \ndef isrecursive(object):\n \"\"\n return _safe_repr(object, {}, None, 0)[2]\n \nclass _safe_key:\n \"\"\n \n __slots__ = ['obj']\n \n def __init__(self, obj):\n  self.obj = obj\n  \n def __lt__(self, other):\n  try:\n   rv = self.obj.__lt__(other.obj)\n  except TypeError:\n   rv = NotImplemented\n   \n  if rv is NotImplemented:\n   rv = (str(type(self.obj)), id(self.obj)) < (str(type(other.obj)), id(other.obj))\n  return rv\n  \ndef _safe_tuple(t):\n \"\"\n return _safe_key(t[0]), _safe_key(t[1])\n \nclass PrettyPrinter:\n def __init__(self, indent=1, width=80, depth=None, stream=None):\n  \"\"\n  indent = int(indent)\n  width = int(width)\n  assert indent >= 0, \"indent must be >= 0\"\n  assert depth is None or depth > 0, \"depth must be > 0\"\n  assert width, \"width must be != 0\"\n  self._depth = depth\n  self._indent_per_level = indent\n  self._width = width\n  if stream is not None:\n   self._stream = stream\n  else:\n   self._stream = _sys.stdout\n   \n def pprint(self, object):\n  self._format(object, self._stream, 0, 0, {}, 0)\n  self._stream.write(\"\\n\")\n  \n def pformat(self, object):\n  sio = _StringIO()\n  self._format(object, sio, 0, 0, {}, 0)\n  return sio.getvalue()\n  \n def isrecursive(self, object):\n  return self.format(object, {}, 0, 0)[2]\n  \n def isreadable(self, object):\n  s, readable, recursive = self.format(object, {}, 0, 0)\n  return readable and not recursive\n  \n def _format(self, object, stream, indent, allowance, context, level):\n  level = level + 1\n  import sys\n  sys.stderr.write(str(object))\n  objid = _id(object)\n  if objid in context:\n   stream.write(_recursion(object))\n   self._recursive = True\n   self._readable = False\n   return\n  rep = self._repr(object, context, level - 1)\n  typ = _type(object)\n  sepLines = _len(rep) > (self._width - 1 - indent - allowance)\n  write = stream.write\n  \n  if self._depth and level > self._depth:\n   write(rep)\n   return\n   \n  if sepLines:\n   r = getattr(typ, \"__repr__\", None)\n   if issubclass(typ, dict):\n    write('{')\n    if self._indent_per_level > 1:\n     write((self._indent_per_level - 1) * ' ')\n    length = _len(object)\n    if length:\n     context[objid] = 1\n     indent = indent + self._indent_per_level\n     if issubclass(typ, _OrderedDict):\n      items = list(object.items())\n     else:\n      items = sorted(object.items(), key=_safe_tuple)\n     key, ent = items[0]\n     rep = self._repr(key, context, level)\n     write(rep)\n     write(': ')\n     self._format(ent, stream, indent + _len(rep) + 2,\n     allowance + 1, context, level)\n     if length > 1:\n      for key, ent in items[1:]:\n       rep = self._repr(key, context, level)\n       write(',\\n%s%s: ' % (' '*indent, rep))\n       self._format(ent, stream, indent + _len(rep) + 2,\n       allowance + 1, context, level)\n     indent = indent - self._indent_per_level\n     del context[objid]\n    write('}')\n    return\n    \n   if ((issubclass(typ, list) and r is list.__repr__) or\n   (issubclass(typ, tuple) and r is tuple.__repr__) or\n   (issubclass(typ, set) and r is set.__repr__) or\n   (issubclass(typ, frozenset) and r is frozenset.__repr__)\n   ):\n    length = _len(object)\n    if issubclass(typ, list):\n     write('[')\n     endchar = ']'\n    elif issubclass(typ, tuple):\n     write('(')\n     endchar = ')'\n    else:\n     if not length:\n      write(rep)\n      return\n     if typ is set:\n      write('{')\n      endchar = '}'\n     else:\n      write(typ.__name__)\n      write('({')\n      endchar = '})'\n      indent += len(typ.__name__) + 1\n     object = sorted(object, key=_safe_key)\n    if self._indent_per_level > 1:\n     write((self._indent_per_level - 1) * ' ')\n    if length:\n     context[objid] = 1\n     indent = indent + self._indent_per_level\n     self._format(object[0], stream, indent, allowance + 1,\n     context, level)\n     if length > 1:\n      for ent in object[1:]:\n       write(',\\n' + ' '*indent)\n       self._format(ent, stream, indent,\n       allowance + 1, context, level)\n     indent = indent - self._indent_per_level\n     del context[objid]\n    if issubclass(typ, tuple) and length == 1:\n     write(',')\n    write(endchar)\n    return\n    \n  write(rep)\n  \n def _repr(self, object, context, level):\n  repr, readable, recursive = self.format(object, context.copy(),\n  self._depth, level)\n  if not readable:\n   self._readable = False\n  if recursive:\n   self._recursive = True\n  return repr\n  \n def format(self, object, context, maxlevels, level):\n  \"\"\n  return _safe_repr(object, context, maxlevels, level)\n  \n  \n  \n  \ndef _safe_repr(object, context, maxlevels, level):\n typ = _type(object)\n if typ is str:\n  if 'locale' not in _sys.modules:\n   return repr(object), True, False\n  if \"'\" in object and '\"' not in object:\n   closure = '\"'\n   quotes = {'\"': '\\\\\"'}\n  else:\n   closure = \"'\"\n   quotes = {\"'\": \"\\\\'\"}\n  qget = quotes.get\n  sio = _StringIO()\n  write = sio.write\n  for char in object:\n   if char.isalpha():\n    write(char)\n   else:\n    write(qget(char, repr(char)[1:-1]))\n  return (\"%s%s%s\" % (closure, sio.getvalue(), closure)), True, False\n  \n r = getattr(typ, \"__repr__\", None)\n if issubclass(typ, dict) and r is dict.__repr__:\n  if not object:\n   return \"{}\", True, False\n  objid = _id(object)\n  if maxlevels and level >= maxlevels:\n   return \"{...}\", False, objid in context\n  if objid in context:\n   return _recursion(object), False, True\n  context[objid] = 1\n  readable = True\n  recursive = False\n  components = []\n  append = components.append\n  level += 1\n  saferepr = _safe_repr\n  items = sorted(object.items(), key=_safe_tuple)\n  for k, v in items:\n   krepr, kreadable, krecur = saferepr(k, context, maxlevels, level)\n   vrepr, vreadable, vrecur = saferepr(v, context, maxlevels, level)\n   append(\"%s: %s\" % (krepr, vrepr))\n   readable = readable and kreadable and vreadable\n   if krecur or vrecur:\n    recursive = True\n  del context[objid]\n  return \"{%s}\" % _commajoin(components), readable, recursive\n  \n if (issubclass(typ, list) and r is list.__repr__) or (issubclass(typ, tuple) and r is tuple.__repr__):\n  if issubclass(typ, list):\n   if not object:\n    return \"[]\", True, False\n   format = \"[%s]\"\n  elif _len(object) == 1:\n   format = \"(%s,)\"\n  else:\n   if not object:\n    return \"()\", True, False\n   format = \"(%s)\"\n  objid = _id(object)\n  if maxlevels and level >= maxlevels:\n   return format % \"...\", False, objid in context\n  if objid in context:\n   return _recursion(object), False, True\n  context[objid] = 1\n  readable = True\n  recursive = False\n  components = []\n  append = components.append\n  level += 1\n  for o in object:\n   orepr, oreadable, orecur = _safe_repr(o, context, maxlevels, level)\n   append(orepr)\n   if not oreadable:\n    readable = False\n   if orecur:\n    recursive = True\n  del context[objid]\n  return format % _commajoin(components), readable, recursive\n  \n rep = repr(object)\n return rep, (rep and not rep.startswith('<')), False\n \n \ndef _recursion(object):\n return (\"<Recursion on %s with id=%s>\"\n % (_type(object).__name__, _id(object)))\n \n \ndef _perfcheck(object=None):\n import time\n if object is None:\n  object = [(\"string\", (1, 2), [3, 4], {5: 6, 7: 8})] * 100000\n p = PrettyPrinter()\n t1 = time.time()\n _safe_repr(object, {}, None, 0)\n t2 = time.time()\n p.pformat(object)\n t3 = time.time()\n print(\"_safe_repr:\", t2 - t1)\n print(\"pformat:\", t3 - t2)\n \nif __name__ == \"__main__\":\n _perfcheck()\n"], "_collections": [".py", "\n\n\n\n\n\n\n\n\n\nimport operator\n\n\n\ndef _thread_ident():\n return -1\n \n \nn = 30\nLFTLNK = n\nRGTLNK = n+1\nBLOCKSIZ = n+2\n\n\n\n\n\n\n\n\nclass deque:\n\n def __new__(cls, iterable=(), *args, **kw):\n \n \n  self=object.__new__(cls, *args, **kw)\n  self.clear()\n  return self\n  \n def __init__(self, iterable=(), maxlen=None):\n  object.__init__(self)\n  self.clear()\n  if maxlen is not None:\n   if maxlen < 0:\n    raise ValueError(\"maxlen must be non-negative\")\n  self._maxlen = maxlen\n  add = self.append\n  for elem in iterable:\n   add(elem)\n   \n @property\n def maxlen(self):\n  return self._maxlen\n  \n def clear(self):\n  self.right = self.left = [None] * BLOCKSIZ\n  self.rightndx = n//2 \n  self.leftndx = n//2+1\n  self.length = 0\n  self.state = 0\n  \n def append(self, x):\n  self.state += 1\n  self.rightndx += 1\n  if self.rightndx == n:\n   newblock = [None] * BLOCKSIZ\n   self.right[RGTLNK] = newblock\n   newblock[LFTLNK] = self.right\n   self.right = newblock\n   self.rightndx = 0\n  self.length += 1\n  self.right[self.rightndx] = x\n  if self.maxlen is not None and self.length > self.maxlen:\n   self.popleft()\n   \n def appendleft(self, x):\n  self.state += 1\n  self.leftndx -= 1\n  if self.leftndx == -1:\n   newblock = [None] * BLOCKSIZ\n   self.left[LFTLNK] = newblock\n   newblock[RGTLNK] = self.left\n   self.left = newblock\n   self.leftndx = n-1\n  self.length += 1\n  self.left[self.leftndx] = x\n  if self.maxlen is not None and self.length > self.maxlen:\n   self.pop()\n   \n def extend(self, iterable):\n  if iterable is self:\n   iterable = list(iterable)\n  for elem in iterable:\n   self.append(elem)\n   \n def extendleft(self, iterable):\n  if iterable is self:\n   iterable = list(iterable)\n  for elem in iterable:\n   self.appendleft(elem)\n   \n def pop(self):\n  if self.left is self.right and self.leftndx > self.rightndx:\n  \n   raise IndexError(\"pop from an empty deque\")\n  x = self.right[self.rightndx]\n  self.right[self.rightndx] = None\n  self.length -= 1\n  self.rightndx -= 1\n  self.state += 1\n  if self.rightndx == -1:\n   prevblock = self.right[LFTLNK]\n   if prevblock is None:\n   \n    self.rightndx = n//2\n    self.leftndx = n//2+1\n   else:\n    prevblock[RGTLNK] = None\n    self.right[LFTLNK] = None\n    self.right = prevblock\n    self.rightndx = n-1\n  return x\n  \n def popleft(self):\n  if self.left is self.right and self.leftndx > self.rightndx:\n  \n   raise IndexError(\"pop from an empty deque\")\n  x = self.left[self.leftndx]\n  self.left[self.leftndx] = None\n  self.length -= 1\n  self.leftndx += 1\n  self.state += 1\n  if self.leftndx == n:\n   prevblock = self.left[RGTLNK]\n   if prevblock is None:\n   \n    self.rightndx = n//2\n    self.leftndx = n//2+1\n   else:\n    prevblock[LFTLNK] = None\n    self.left[RGTLNK] = None\n    self.left = prevblock\n    self.leftndx = 0\n  return x\n  \n def count(self, value):\n  c = 0\n  for item in self:\n   if item == value:\n    c += 1\n  return c\n  \n def remove(self, value):\n \n  for i in range(len(self)):\n   if self[i] == value:\n    del self[i]\n    return\n  raise ValueError(\"deque.remove(x): x not in deque\")\n  \n def rotate(self, n=1):\n  length = len(self)\n  if length == 0:\n   return\n  halflen = (length+1) >> 1\n  if n > halflen or n < -halflen:\n   n %= length\n   if n > halflen:\n    n -= length\n   elif n < -halflen:\n    n += length\n  while n > 0:\n   self.appendleft(self.pop())\n   n -= 1\n  while n < 0:\n   self.append(self.popleft())\n   n += 1\n   \n def reverse(self):\n  \"\"\n  leftblock = self.left\n  rightblock = self.right\n  leftindex = self.leftndx\n  rightindex = self.rightndx\n  for i in range(self.length // 2):\n  \n   assert leftblock != rightblock or leftindex < rightindex\n   \n   \n   (rightblock[rightindex], leftblock[leftindex]) = (\n   leftblock[leftindex], rightblock[rightindex])\n   \n   \n   leftindex += 1\n   if leftindex == n:\n    leftblock = leftblock[RGTLNK]\n    assert leftblock is not None\n    leftindex = 0\n    \n    \n   rightindex -= 1\n   if rightindex == -1:\n    rightblock = rightblock[LFTLNK]\n    assert rightblock is not None\n    rightindex = n - 1\n    \n def __repr__(self):\n  threadlocalattr = '__repr' + str(_thread_ident())\n  if threadlocalattr in self.__dict__:\n   return 'deque([...])'\n  else:\n   self.__dict__[threadlocalattr] = True\n   try:\n    if self.maxlen is not None:\n     return 'deque(%r, maxlen=%s)' % (list(self), self.maxlen)\n    else:\n     return 'deque(%r)' % (list(self),)\n   finally:\n    del self.__dict__[threadlocalattr]\n    \n def __iter__(self):\n  return deque_iterator(self, self._iter_impl)\n  \n def _iter_impl(self, original_state, giveup):\n  if self.state != original_state:\n   giveup()\n  block = self.left\n  while block:\n   l, r = 0, n\n   if block is self.left:\n    l = self.leftndx\n   if block is self.right:\n    r = self.rightndx + 1\n   for elem in block[l:r]:\n    yield elem\n    if self.state != original_state:\n     giveup()\n   block = block[RGTLNK]\n   \n def __reversed__(self):\n  return deque_iterator(self, self._reversed_impl)\n  \n def _reversed_impl(self, original_state, giveup):\n  if self.state != original_state:\n   giveup()\n  block = self.right\n  while block:\n   l, r = 0, n\n   if block is self.left:\n    l = self.leftndx\n   if block is self.right:\n    r = self.rightndx + 1\n   for elem in reversed(block[l:r]):\n    yield elem\n    if self.state != original_state:\n     giveup()\n   block = block[LFTLNK]\n   \n def __len__(self):\n \n \n \n \n \n \n  return self.length\n  \n def __getref(self, index):\n  if index >= 0:\n   block = self.left\n   while block:\n    l, r = 0, n\n    if block is self.left:\n     l = self.leftndx\n    if block is self.right:\n     r = self.rightndx + 1\n    span = r-l\n    if index < span:\n     return block, l+index\n    index -= span\n    block = block[RGTLNK]\n  else:\n   block = self.right\n   while block:\n    l, r = 0, n\n    if block is self.left:\n     l = self.leftndx\n    if block is self.right:\n     r = self.rightndx + 1\n    negative_span = l-r\n    if index >= negative_span:\n     return block, r+index\n    index -= negative_span\n    block = block[LFTLNK]\n  raise IndexError(\"deque index out of range\")\n  \n def __getitem__(self, index):\n  block, index = self.__getref(index)\n  return block[index]\n  \n def __setitem__(self, index, value):\n  block, index = self.__getref(index)\n  block[index] = value\n  \n def __delitem__(self, index):\n  length = len(self)\n  if index >= 0:\n   if index >= length:\n    raise IndexError(\"deque index out of range\")\n   self.rotate(-index)\n   self.popleft()\n   self.rotate(index)\n  else:\n  \n   index= index^(2**31)\n   if index >= length:\n    raise IndexError(\"deque index out of range\")\n   self.rotate(index)\n   self.pop()\n   self.rotate(-index)\n   \n def __reduce_ex__(self, proto):\n  return type(self), (list(self), self.maxlen)\n  \n def __hash__(self):\n \n  raise TypeError(\"deque objects are unhashable\")\n  \n def __copy__(self):\n  return self.__class__(self, self.maxlen)\n  \n  \n def __eq__(self, other):\n  if isinstance(other, deque):\n   return list(self) == list(other)\n  else:\n   return NotImplemented\n   \n def __ne__(self, other):\n  if isinstance(other, deque):\n   return list(self) != list(other)\n  else:\n   return NotImplemented\n   \n def __lt__(self, other):\n  if isinstance(other, deque):\n   return list(self) < list(other)\n  else:\n   return NotImplemented\n   \n def __le__(self, other):\n  if isinstance(other, deque):\n   return list(self) <= list(other)\n  else:\n   return NotImplemented\n   \n def __gt__(self, other):\n  if isinstance(other, deque):\n   return list(self) > list(other)\n  else:\n   return NotImplemented\n   \n def __ge__(self, other):\n  if isinstance(other, deque):\n   return list(self) >= list(other)\n  else:\n   return NotImplemented\n   \n def __iadd__(self, other):\n  self.extend(other)\n  return self\n  \n  \nclass deque_iterator(object):\n\n def __init__(self, deq, itergen):\n  self.counter = len(deq)\n  def giveup():\n   self.counter = 0\n   \n   raise RuntimeError(\"deque mutated during iteration\")\n  self._gen = itergen(deq.state, giveup)\n  \n def next(self):\n  res = self._gen.next()\n  self.counter -= 1\n  return res\n  \n def __iter__(self):\n  return self\n  \nclass defaultdict(dict):\n\n def __init__(self, *args, **kwds):\n  if len(args) > 0:\n   default_factory = args[0]\n   args = args[1:]\n   if not callable(default_factory) and default_factory is not None:\n    raise TypeError(\"first argument must be callable\")\n  else:\n   default_factory = None\n  dict.__init__(self, args, kwds)\n  self.default_factory = default_factory\n  self.update(args, kwds)\n  \n  \n  \n def __getitem__(self, key):\n  if self.__contains__(key): \n   return dict.__getitem__(self,key)\n   \n  return self.__missing__(key)\n  \n def __missing__(self, key):\n \n  if self.default_factory is None: \n   raise KeyError(key)\n  self[key] = value = self.default_factory()\n  return value\n  \n def __repr__(self, recurse=set()):\n  if id(self) in recurse:\n   return \"defaultdict(...)\"\n  try:\n   recurse.add(id(self))\n   return \"defaultdict(%s, %s)\" % (repr(self.default_factory), super(defaultdict, self).__repr__())\n  finally:\n   recurse.remove(id(self))\n   \n def copy(self):\n  return type(self)(self.default_factory, self)\n  \n def __copy__(self):\n  return self.copy()\n  \n def __reduce__(self):\n \n \n \n \n \n \n \n \n \n \n \n  return (type(self), (self.default_factory,), None, None, self.iteritems())\n  \nfrom operator import itemgetter as _itemgetter\nfrom keyword import iskeyword as _iskeyword\nimport sys as _sys\n\ndef namedtuple(typename, field_names, verbose=False, rename=False):\n \"\"\n \n \n \n if isinstance(field_names, str):\n  field_names = field_names.replace(',', ' ').split() \n field_names = tuple(map(str, field_names))\n if rename:\n  names = list(field_names)\n  seen = set()\n  for i, name in enumerate(names):\n   if (not min(c.isalnum() or c=='_' for c in name) or _iskeyword(name)\n   or not name or name[0].isdigit() or name.startswith('_')\n   or name in seen):\n    names[i] = '_%d' % i\n   seen.add(name)\n  field_names = tuple(names)\n for name in (typename,) + field_names:\n  if not min(c.isalnum() or c=='_' for c in name):\n   raise ValueError('Type names and field names can only contain alphanumeric characters and underscores: %r' % name)\n  if _iskeyword(name):\n   raise ValueError('Type names and field names cannot be a keyword: %r' % name)\n  if name[0].isdigit():\n   raise ValueError('Type names and field names cannot start with a number: %r' % name)\n seen_names = set()\n for name in field_names:\n  if name.startswith('_') and not rename:\n   raise ValueError('Field names cannot start with an underscore: %r' % name)\n  if name in seen_names:\n   raise ValueError('Encountered duplicate field name: %r' % name)\n  seen_names.add(name)\n  \n  \n numfields = len(field_names)\n argtxt = repr(field_names).replace(\"'\", \"\")[1:-1] \n reprtxt = ', '.join('%s=%%r' % name for name in field_names)\n \n template = '''class %(typename)s(tuple):\n        '%(typename)s(%(argtxt)s)' \\n\n        __slots__ = () \\n\n        _fields = %(field_names)r \\n\n        def __new__(_cls, %(argtxt)s):\n            return tuple.__new__(_cls, (%(argtxt)s)) \\n\n        @classmethod\n        def _make(cls, iterable, new=tuple.__new__, len=len):\n            'Make a new %(typename)s object from a sequence or iterable'\n            result = new(cls, iterable)\n            if len(result) != %(numfields)d:\n                raise TypeError('Expected %(numfields)d arguments, got %%d' %% len(result))\n            return result \\n\n        def __repr__(self):\n            return '%(typename)s(%(reprtxt)s)' %% self \\n\n        def _asdict(self):\n            'Return a new dict which maps field names to their values'\n            return dict(zip(self._fields, self)) \\n\n        def _replace(_self, **kwds):\n            'Return a new %(typename)s object replacing specified fields with new values'\n            result = _self._make(map(kwds.pop, %(field_names)r, _self))\n            if kwds:\n                raise ValueError('Got unexpected field names: %%r' %% kwds.keys())\n            return result \\n\n        def __getnewargs__(self):\n            return tuple(self) \\n\\n''' % locals()\n for i, name in enumerate(field_names):\n  template += '        %s = _property(_itemgetter(%d))\\n' % (name, i)\n  \n if verbose:\n  print(template)\n  \n  \n namespace = dict(_itemgetter=_itemgetter, __name__='namedtuple_%s' % typename,\n _property=property, _tuple=tuple)\n try:\n  exec(template,namespace)\n except SyntaxError as e:\n  raise SyntaxError(e.message + ':\\n' + template)\n result = namespace[typename]\n \n \n \n \n \n try:\n  result.__module__ = _sys._getframe(1).f_globals.get('__name__', '__main__')\n except (AttributeError, ValueError):\n  pass\n  \n return result\n \nif __name__ == '__main__':\n Point = namedtuple('Point', ['x', 'y'])\n p = Point(11, y=22)\n print(p[0]+p[1])\n x,y=p\n print(x,y)\n print(p.x+p.y)\n print(p)\n"], "xml.dom": [".py", "\"\"\n\n\nclass Node:\n \"\"\n __slots__ = ()\n \n \n \n \n \n \n \n \n ELEMENT_NODE = 1\n ATTRIBUTE_NODE = 2\n TEXT_NODE = 3\n CDATA_SECTION_NODE = 4\n ENTITY_REFERENCE_NODE = 5\n ENTITY_NODE = 6\n PROCESSING_INSTRUCTION_NODE = 7\n COMMENT_NODE = 8\n DOCUMENT_NODE = 9\n DOCUMENT_TYPE_NODE = 10\n DOCUMENT_FRAGMENT_NODE = 11\n NOTATION_NODE = 12\n \n \n \nINDEX_SIZE_ERR = 1\nDOMSTRING_SIZE_ERR = 2\nHIERARCHY_REQUEST_ERR = 3\nWRONG_DOCUMENT_ERR = 4\nINVALID_CHARACTER_ERR = 5\nNO_DATA_ALLOWED_ERR = 6\nNO_MODIFICATION_ALLOWED_ERR = 7\nNOT_FOUND_ERR = 8\nNOT_SUPPORTED_ERR = 9\nINUSE_ATTRIBUTE_ERR = 10\nINVALID_STATE_ERR = 11\nSYNTAX_ERR = 12\nINVALID_MODIFICATION_ERR = 13\nNAMESPACE_ERR = 14\nINVALID_ACCESS_ERR = 15\nVALIDATION_ERR = 16\n\n\nclass DOMException(Exception):\n \"\"\n \n def __init__(self, *args, **kw):\n  if self.__class__ is DOMException:\n   raise RuntimeError(\n   \"DOMException should not be instantiated directly\")\n  Exception.__init__(self, *args, **kw)\n  \n def _get_code(self):\n  return self.code\n  \n  \nclass IndexSizeErr(DOMException):\n code = INDEX_SIZE_ERR\n \nclass DomstringSizeErr(DOMException):\n code = DOMSTRING_SIZE_ERR\n \nclass HierarchyRequestErr(DOMException):\n code = HIERARCHY_REQUEST_ERR\n \nclass WrongDocumentErr(DOMException):\n code = WRONG_DOCUMENT_ERR\n \nclass InvalidCharacterErr(DOMException):\n code = INVALID_CHARACTER_ERR\n \nclass NoDataAllowedErr(DOMException):\n code = NO_DATA_ALLOWED_ERR\n \nclass NoModificationAllowedErr(DOMException):\n code = NO_MODIFICATION_ALLOWED_ERR\n \nclass NotFoundErr(DOMException):\n code = NOT_FOUND_ERR\n \nclass NotSupportedErr(DOMException):\n code = NOT_SUPPORTED_ERR\n \nclass InuseAttributeErr(DOMException):\n code = INUSE_ATTRIBUTE_ERR\n \nclass InvalidStateErr(DOMException):\n code = INVALID_STATE_ERR\n \nclass SyntaxErr(DOMException):\n code = SYNTAX_ERR\n \nclass InvalidModificationErr(DOMException):\n code = INVALID_MODIFICATION_ERR\n \nclass NamespaceErr(DOMException):\n code = NAMESPACE_ERR\n \nclass InvalidAccessErr(DOMException):\n code = INVALID_ACCESS_ERR\n \nclass ValidationErr(DOMException):\n code = VALIDATION_ERR\n \nclass UserDataHandler:\n \"\"\n \n \n \n NODE_CLONED = 1\n NODE_IMPORTED = 2\n NODE_DELETED = 3\n NODE_RENAMED = 4\n \nXML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\"\nXMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\"\nXHTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\"\nEMPTY_NAMESPACE = None\nEMPTY_PREFIX = None\n\nfrom .domreg import getDOMImplementation, registerDOMImplementation\n", 1], "_sre": [".py", "\n\"\"\n\nMAXREPEAT = 2147483648\n\n\nimport operator, sys\nfrom sre_constants import ATCODES, OPCODES, CHCODES\nfrom sre_constants import SRE_INFO_PREFIX, SRE_INFO_LITERAL\nfrom sre_constants import SRE_FLAG_UNICODE, SRE_FLAG_LOCALE\n\n\nimport sys\n\n\n\nMAGIC = 20031017\n\n\n\n\n\n\n\n\n\n\n\n\n\nCODESIZE = 4\n\ncopyright = \"_sre.py 2.4c Copyright 2005 by Nik Haldimann\"\n\n\ndef getcodesize():\n return CODESIZE\n \ndef compile(pattern, flags, code, groups=0, groupindex={}, indexgroup=[None]):\n \"\"\n return SRE_Pattern(pattern, flags, code, groups, groupindex, indexgroup)\n \ndef getlower(char_ord, flags):\n if (char_ord < 128) or (flags & SRE_FLAG_UNICODE) or (flags & SRE_FLAG_LOCALE and char_ord < 256):\n \n  return ord(chr(char_ord).lower())\n else:\n  return char_ord\n  \n  \nclass SRE_Pattern:\n\n def __init__(self, pattern, flags, code, groups=0, groupindex={}, indexgroup=[None]):\n  self.pattern = pattern\n  self.flags = flags\n  self.groups = groups\n  self.groupindex = groupindex \n  self._indexgroup = indexgroup \n  self._code = code\n  \n def match(self, string, pos=0, endpos=sys.maxsize):\n  \"\"\n  state = _State(string, pos, endpos, self.flags)\n  if state.match(self._code):\n   return SRE_Match(self, state)\n  return None\n  \n def search(self, string, pos=0, endpos=sys.maxsize):\n  \"\"\n  state = _State(string, pos, endpos, self.flags)\n  if state.search(self._code):\n   return SRE_Match(self, state)\n  else:\n   return None\n   \n def findall(self, string, pos=0, endpos=sys.maxsize):\n  \"\"\n  matchlist = []\n  state = _State(string, pos, endpos, self.flags)\n  while state.start <= state.end:\n   state.reset()\n   state.string_position = state.start\n   if not state.search(self._code):\n    break\n   match = SRE_Match(self, state)\n   if self.groups == 0 or self.groups == 1:\n    item = match.group(self.groups)\n   else:\n    item = match.groups(\"\")\n   matchlist.append(item)\n   if state.string_position == state.start:\n    state.start += 1\n   else:\n    state.start = state.string_position\n  return matchlist \n  \n def _subx(self, template, string, count=0, subn=False):\n  filter = template\n  if not callable(template) and \"\\\\\" in template:\n  \n  \n  \n  \n   import re as sre\n   filter = sre._subx(self, template)\n  state = _State(string, 0, sys.maxsize, self.flags)\n  sublist = []\n  \n  n = last_pos = 0\n  while not count or n < count:\n   state.reset()\n   state.string_position = state.start\n   if not state.search(self._code):\n    break\n   if last_pos < state.start:\n    sublist.append(string[last_pos:state.start])\n   if not (last_pos == state.start and\n   last_pos == state.string_position and n > 0):\n   \n    if callable(filter):\n     sublist.append(filter(SRE_Match(self, state)))\n    else:\n     sublist.append(filter)\n    last_pos = state.string_position\n    n += 1\n   if state.string_position == state.start:\n    state.start += 1\n   else:\n    state.start = state.string_position\n    \n  if last_pos < state.end:\n   sublist.append(string[last_pos:state.end])\n  item = \"\".join(sublist)\n  if subn:\n   return item, n\n  else:\n   return item\n   \n def sub(self, repl, string, count=0):\n  \"\"\n  return self._subx(repl, string, count, False)\n  \n def subn(self, repl, string, count=0):\n  \"\"\n  return self._subx(repl, string, count, True)\n  \n def split(self, string, maxsplit=0):\n  \"\"\n  splitlist = []\n  state = _State(string, 0, sys.maxsize, self.flags)\n  n = 0\n  last = state.start\n  while not maxsplit or n < maxsplit:\n   state.reset()\n   state.string_position = state.start\n   if not state.search(self._code):\n    break\n   if state.start == state.string_position: \n    if last == state.end: \n     break\n    state.start += 1\n    continue\n   splitlist.append(string[last:state.start])\n   \n   if self.groups:\n    match = SRE_Match(self, state)\n    splitlist.extend(list(match.groups(None)))\n   n += 1\n   last = state.start = state.string_position\n  splitlist.append(string[last:state.end])\n  return splitlist\n  \n def finditer(self, string, pos=0, endpos=sys.maxsize):\n  \"\"\n  \n  _list=[]\n  _m=self.scanner(string, pos, endpos)\n  _re=SRE_Scanner(self, string, pos, endpos)\n  _m=_re.search()\n  while _m:\n   _list.append(_m)\n   _m=_re.search()\n  return _list\n  \n  \n def scanner(self, string, start=0, end=sys.maxsize):\n  return SRE_Scanner(self, string, start, end)\n  \n def __copy__(self):\n  raise TypeError(\"cannot copy this pattern object\")\n  \n def __deepcopy__(self):\n  raise TypeError(\"cannot copy this pattern object\")\n  \nclass SRE_Scanner:\n \"\"\n \n def __init__(self, pattern, string, start, end):\n  self.pattern = pattern\n  self._state = _State(string, start, end, self.pattern.flags)\n  \n def _match_search(self, matcher):\n  state = self._state\n  state.reset()\n  state.string_position = state.start\n  match = None\n  if matcher(self.pattern._code):\n   match = SRE_Match(self.pattern, state)\n  if match is None or state.string_position == state.start:\n   state.start += 1\n  else:\n   state.start = state.string_position\n  return match\n  \n def match(self):\n  return self._match_search(self._state.match)\n  \n def search(self):\n  return self._match_search(self._state.search)\n  \nclass SRE_Match:\n\n def __init__(self, pattern, state):\n  self.re = pattern\n  self.string = state.string\n  self.pos = state.pos\n  self.endpos = state.end\n  self.lastindex = state.lastindex\n  if self.lastindex < 0:\n   self.lastindex = None\n  self.regs = self._create_regs(state)\n  \n  \n  \n  if self.lastindex is not None and pattern._indexgroup and 0 <= self.lastindex < len(pattern._indexgroup):\n  \n  \n  \n  \n  \n   self.lastgroup = pattern._indexgroup[self.lastindex]\n  else:\n   self.lastgroup = None\n   \n def _create_regs(self, state):\n  \"\"\n  regs = [(state.start, state.string_position)]\n  for group in range(self.re.groups):\n   mark_index = 2 * group\n   if mark_index + 1 < len(state.marks) and state.marks[mark_index] is not None and state.marks[mark_index + 1] is not None:\n    regs.append((state.marks[mark_index], state.marks[mark_index + 1]))\n   else:\n    regs.append((-1, -1))\n  return tuple(regs)\n  \n def _get_index(self, group):\n  if isinstance(group, int):\n   if group >= 0 and group <= self.re.groups:\n    return group\n  else:\n   if group in self.re.groupindex:\n    return self.re.groupindex[group]\n  raise IndexError(\"no such group\")\n  \n def _get_slice(self, group, default):\n  group_indices = self.regs[group]\n  if group_indices[0] >= 0:\n   return self.string[group_indices[0]:group_indices[1]]\n  else:\n   return default\n   \n def start(self, group=0):\n  \"\"\n  return self.regs[self._get_index(group)][0]\n  \n def end(self, group=0):\n  \"\"\n  return self.regs[self._get_index(group)][1]\n  \n def span(self, group=0):\n  \"\"\n  return self.start(group), self.end(group)\n  \n def expand(self, template):\n  \"\"\n  import sre\n  return sre._expand(self.re, self, template)\n  \n def groups(self, default=None):\n  \"\"\n  groups = []\n  for indices in self.regs[1:]:\n   if indices[0] >= 0:\n    groups.append(self.string[indices[0]:indices[1]])\n   else:\n    groups.append(default)\n  return tuple(groups)\n  \n def groupdict(self, default=None):\n  \"\"\n  groupdict = {}\n  for key, value in self.re.groupindex.items():\n   groupdict[key] = self._get_slice(value, default)\n  return groupdict\n  \n def group(self, *args):\n  \"\"\n  if len(args) == 0:\n   args = (0,)\n  grouplist = []\n  for group in args:\n   grouplist.append(self._get_slice(self._get_index(group), None))\n  if len(grouplist) == 1:\n   return grouplist[0]\n  else:\n   return tuple(grouplist)\n   \n def __copy__():\n  raise TypeError(\"cannot copy this pattern object\")\n  \n def __deepcopy__():\n  raise TypeError(\"cannot copy this pattern object\")\n  \n  \nclass _State:\n\n def __init__(self, string, start, end, flags):\n  self.string = string\n  if start < 0:\n   start = 0\n  if end > len(string):\n   end = len(string)\n  self.start = start\n  self.string_position = self.start\n  self.end = end\n  self.pos = start\n  self.flags = flags\n  self.reset()\n  \n def reset(self):\n  self.marks = []\n  self.lastindex = -1\n  self.marks_stack = []\n  self.context_stack = []\n  self.repeat = None\n  \n def match(self, pattern_codes):\n \n \n \n \n \n \n \n \n \n  dispatcher = _OpcodeDispatcher()\n  self.context_stack.append(_MatchContext(self, pattern_codes))\n  has_matched = None\n  while len(self.context_stack) > 0:\n   context = self.context_stack[-1]\n   has_matched = dispatcher.match(context)\n   if has_matched is not None: \n    self.context_stack.pop()\n  return has_matched\n  \n def search(self, pattern_codes):\n  flags = 0\n  if pattern_codes[0] == OPCODES[\"info\"]:\n  \n  \n   if pattern_codes[2] & SRE_INFO_PREFIX and pattern_codes[5] > 1:\n    return self.fast_search(pattern_codes)\n   flags = pattern_codes[2]\n   pattern_codes = pattern_codes[pattern_codes[1] + 1:]\n   \n  string_position = self.start\n  if pattern_codes[0] == OPCODES[\"literal\"]:\n  \n  \n   character = pattern_codes[1]\n   while True:\n    while string_position < self.end and ord(self.string[string_position]) != character:\n     string_position += 1\n    if string_position >= self.end:\n     return False\n    self.start = string_position\n    string_position += 1\n    self.string_position = string_position\n    if flags & SRE_INFO_LITERAL:\n     return True\n    if self.match(pattern_codes[2:]):\n     return True\n   return False\n   \n   \n  while string_position <= self.end:\n   self.reset()\n   self.start = self.string_position = string_position\n   if self.match(pattern_codes):\n    return True\n   string_position += 1\n  return False\n  \n def fast_search(self, pattern_codes):\n  \"\"\n  \n  \n  flags = pattern_codes[2]\n  prefix_len = pattern_codes[5]\n  prefix_skip = pattern_codes[6] \n  prefix = pattern_codes[7:7 + prefix_len]\n  overlap = pattern_codes[7 + prefix_len - 1:pattern_codes[1] + 1]\n  pattern_codes = pattern_codes[pattern_codes[1] + 1:]\n  i = 0\n  string_position = self.string_position\n  while string_position < self.end:\n   while True:\n    if ord(self.string[string_position]) != prefix[i]:\n     if i == 0:\n      break\n     else:\n      i = overlap[i]\n    else:\n     i += 1\n     if i == prefix_len:\n     \n      self.start = string_position + 1 - prefix_len\n      self.string_position = string_position + 1 - prefix_len + prefix_skip\n      if flags & SRE_INFO_LITERAL:\n       return True \n      if self.match(pattern_codes[2 * prefix_skip:]):\n       return True\n      i = overlap[i]\n     break\n   string_position += 1\n  return False\n  \n def set_mark(self, mark_nr, position):\n  if mark_nr & 1:\n  \n  \n  \n   self.lastindex = mark_nr // 2 + 1\n  if mark_nr >= len(self.marks):\n   self.marks.extend([None] * (mark_nr - len(self.marks) + 1))\n  self.marks[mark_nr] = position\n  \n def get_marks(self, group_index):\n  marks_index = 2 * group_index\n  if len(self.marks) > marks_index + 1:\n   return self.marks[marks_index], self.marks[marks_index + 1]\n  else:\n   return None, None\n   \n def marks_push(self):\n  self.marks_stack.append((self.marks[:], self.lastindex))\n  \n def marks_pop(self):\n  self.marks, self.lastindex = self.marks_stack.pop()\n  \n def marks_pop_keep(self):\n  self.marks, self.lastindex = self.marks_stack[-1]\n  \n def marks_pop_discard(self):\n  self.marks_stack.pop()\n  \n def lower(self, char_ord):\n  return getlower(char_ord, self.flags)\n  \n  \nclass _MatchContext:\n\n def __init__(self, state, pattern_codes):\n  self.state = state\n  self.pattern_codes = pattern_codes\n  self.string_position = state.string_position\n  self.code_position = 0\n  self.has_matched = None\n  \n def push_new_context(self, pattern_offset):\n  \"\"\n  child_context = _MatchContext(self.state,\n  self.pattern_codes[self.code_position + pattern_offset:])\n  \n  \n  \n  \n  self.state.context_stack.append(child_context)\n  return child_context\n  \n def peek_char(self, peek=0):\n  return self.state.string[self.string_position + peek]\n  \n def skip_char(self, skip_count):\n  self.string_position += skip_count\n  \n def remaining_chars(self):\n  return self.state.end - self.string_position\n  \n def peek_code(self, peek=0):\n  return self.pattern_codes[self.code_position + peek]\n  \n def skip_code(self, skip_count):\n  self.code_position += skip_count\n  \n def remaining_codes(self):\n  return len(self.pattern_codes) - self.code_position\n  \n def at_beginning(self):\n  return self.string_position == 0\n  \n def at_end(self):\n  return self.string_position == self.state.end\n  \n def at_linebreak(self):\n  return not self.at_end() and _is_linebreak(self.peek_char())\n  \n def at_boundary(self, word_checker):\n  if self.at_beginning() and self.at_end():\n   return False\n  that = not self.at_beginning() and word_checker(self.peek_char(-1))\n  this = not self.at_end() and word_checker(self.peek_char())\n  return this != that\n  \n  \nclass _RepeatContext(_MatchContext):\n\n def __init__(self, context):\n  _MatchContext.__init__(self, context.state,\n  context.pattern_codes[context.code_position:])\n  self.count = -1\n  \n  self.previous = context.state.repeat\n  self.last_position = None\n  \n  \nclass _Dispatcher:\n\n DISPATCH_TABLE = None\n \n def dispatch(self, code, context):\n  method = self.DISPATCH_TABLE.get(code, self.__class__.unknown)\n  return method(self, context)\n  \n def unknown(self, code, ctx):\n  raise NotImplementedError()\n  \n def build_dispatch_table(cls, code_dict, method_prefix):\n  if cls.DISPATCH_TABLE is not None:\n   return\n  table = {}\n  for key, value in code_dict.items():\n   if hasattr(cls, \"%s%s\" % (method_prefix, key)):\n    table[value] = getattr(cls, \"%s%s\" % (method_prefix, key))\n  cls.DISPATCH_TABLE = table\n  \n build_dispatch_table = classmethod(build_dispatch_table)\n \n \nclass _OpcodeDispatcher(_Dispatcher):\n\n def __init__(self):\n  self.executing_contexts = {}\n  self.at_dispatcher = _AtcodeDispatcher()\n  self.ch_dispatcher = _ChcodeDispatcher()\n  self.set_dispatcher = _CharsetDispatcher()\n  \n def match(self, context):\n  \"\"\n  while context.remaining_codes() > 0 and context.has_matched is None:\n   opcode = context.peek_code()\n   if not self.dispatch(opcode, context):\n    return None\n  if context.has_matched is None:\n   context.has_matched = False\n  return context.has_matched\n  \n def dispatch(self, opcode, context):\n  \"\"\n  \n  if id(context) in self.executing_contexts:\n   generator = self.executing_contexts[id(context)]\n   del self.executing_contexts[id(context)]\n   has_finished = next(generator)\n  else:\n   method = self.DISPATCH_TABLE.get(opcode, _OpcodeDispatcher.unknown)\n   has_finished = method(self, context)\n   if hasattr(has_finished, \"__next__\"): \n    generator = has_finished\n    has_finished = next(generator)\n  if not has_finished:\n   self.executing_contexts[id(context)] = generator\n  return has_finished\n  \n def op_success(self, ctx):\n \n \n  ctx.state.string_position = ctx.string_position\n  ctx.has_matched = True\n  return True\n  \n def op_failure(self, ctx):\n \n \n  ctx.has_matched = False\n  return True\n  \n def general_op_literal(self, ctx, compare, decorate=lambda x: x):\n \n  if ctx.at_end() or not compare(decorate(ord(ctx.peek_char())),\n  decorate(ctx.peek_code(1))):\n   ctx.has_matched = False\n  ctx.skip_code(2)\n  ctx.skip_char(1)\n  \n def op_literal(self, ctx):\n \n \n \n  self.general_op_literal(ctx, operator.eq)\n  return True\n  \n def op_not_literal(self, ctx):\n \n \n \n  self.general_op_literal(ctx, operator.ne)\n  return True\n  \n def op_literal_ignore(self, ctx):\n \n \n \n  self.general_op_literal(ctx, operator.eq, ctx.state.lower)\n  return True\n  \n def op_not_literal_ignore(self, ctx):\n \n \n \n  self.general_op_literal(ctx, operator.ne, ctx.state.lower)\n  return True\n  \n def op_at(self, ctx):\n \n \n \n  if not self.at_dispatcher.dispatch(ctx.peek_code(1), ctx):\n   ctx.has_matched = False\n   \n   return True\n  ctx.skip_code(2)\n  return True\n  \n def op_category(self, ctx):\n \n \n \n  if ctx.at_end() or not self.ch_dispatcher.dispatch(ctx.peek_code(1), ctx):\n   ctx.has_matched = False\n   \n   return True\n  ctx.skip_code(2)\n  ctx.skip_char(1)\n  return True\n  \n def op_any(self, ctx):\n \n \n \n  if ctx.at_end() or ctx.at_linebreak():\n   ctx.has_matched = False\n   \n   return True\n  ctx.skip_code(1)\n  ctx.skip_char(1)\n  return True\n  \n def op_any_all(self, ctx):\n \n \n \n  if ctx.at_end():\n   ctx.has_matched = False\n   \n   return True\n  ctx.skip_code(1)\n  ctx.skip_char(1)\n  return True\n  \n def general_op_in(self, ctx, decorate=lambda x: x):\n \n \n  if ctx.at_end():\n   ctx.has_matched = False\n   \n   return\n  skip = ctx.peek_code(1)\n  ctx.skip_code(2) \n  \n  \n  if not self.check_charset(ctx, decorate(ord(ctx.peek_char()))):\n  \n   ctx.has_matched = False\n   return\n  ctx.skip_code(skip - 1)\n  ctx.skip_char(1)\n  \n  \n def op_in(self, ctx):\n \n \n \n  self.general_op_in(ctx)\n  return True\n  \n def op_in_ignore(self, ctx):\n \n \n \n  self.general_op_in(ctx, ctx.state.lower)\n  return True\n  \n def op_jump(self, ctx):\n \n \n \n  ctx.skip_code(ctx.peek_code(1) + 1)\n  return True\n  \n  \n  \n op_info = op_jump\n \n def op_mark(self, ctx):\n \n \n \n  ctx.state.set_mark(ctx.peek_code(1), ctx.string_position)\n  ctx.skip_code(2)\n  return True\n  \n def op_branch(self, ctx):\n \n \n \n  ctx.state.marks_push()\n  ctx.skip_code(1)\n  current_branch_length = ctx.peek_code(0)\n  while current_branch_length:\n  \n  \n   if not (ctx.peek_code(1) == OPCODES[\"literal\"] and (ctx.at_end() or ctx.peek_code(2) != ord(ctx.peek_char()))):\n    ctx.state.string_position = ctx.string_position\n    child_context = ctx.push_new_context(1)\n    \n    yield False\n    if child_context.has_matched:\n     ctx.has_matched = True\n     yield True\n    ctx.state.marks_pop_keep()\n   ctx.skip_code(current_branch_length)\n   current_branch_length = ctx.peek_code(0)\n  ctx.state.marks_pop_discard()\n  ctx.has_matched = False\n  \n  yield True\n  \n def op_repeat_one(self, ctx):\n \n \n \n \n  mincount = ctx.peek_code(2)\n  maxcount = ctx.peek_code(3)\n  \n  \n  \n  if ctx.remaining_chars() < mincount:\n   ctx.has_matched = False\n   yield True\n  ctx.state.string_position = ctx.string_position\n  count = self.count_repetitions(ctx, maxcount)\n  ctx.skip_char(count)\n  if count < mincount:\n   ctx.has_matched = False\n   yield True\n  if ctx.peek_code(ctx.peek_code(1) + 1) == OPCODES[\"success\"]:\n  \n   ctx.state.string_position = ctx.string_position\n   ctx.has_matched = True\n   yield True\n   \n  ctx.state.marks_push()\n  if ctx.peek_code(ctx.peek_code(1) + 1) == OPCODES[\"literal\"]:\n  \n  \n   char = ctx.peek_code(ctx.peek_code(1) + 2)\n   while True:\n    while count >= mincount and (ctx.at_end() or ord(ctx.peek_char()) != char):\n     ctx.skip_char(-1)\n     count -= 1\n    if count < mincount:\n     break\n    ctx.state.string_position = ctx.string_position\n    child_context = ctx.push_new_context(ctx.peek_code(1) + 1)\n    \n    yield False\n    if child_context.has_matched:\n     ctx.has_matched = True\n     yield True\n    ctx.skip_char(-1)\n    count -= 1\n    ctx.state.marks_pop_keep()\n    \n  else:\n  \n   while count >= mincount:\n    ctx.state.string_position = ctx.string_position\n    child_context = ctx.push_new_context(ctx.peek_code(1) + 1)\n    yield False\n    if child_context.has_matched:\n     ctx.has_matched = True\n     yield True\n    ctx.skip_char(-1)\n    count -= 1\n    ctx.state.marks_pop_keep()\n    \n  ctx.state.marks_pop_discard()\n  ctx.has_matched = False\n  \n  yield True\n  \n def op_min_repeat_one(self, ctx):\n \n \n  mincount = ctx.peek_code(2)\n  maxcount = ctx.peek_code(3)\n  \n  \n  if ctx.remaining_chars() < mincount:\n   ctx.has_matched = False\n   yield True\n  ctx.state.string_position = ctx.string_position\n  if mincount == 0:\n   count = 0\n  else:\n   count = self.count_repetitions(ctx, mincount)\n   if count < mincount:\n    ctx.has_matched = False\n    \n    yield True\n   ctx.skip_char(count)\n  if ctx.peek_code(ctx.peek_code(1) + 1) == OPCODES[\"success\"]:\n  \n   ctx.state.string_position = ctx.string_position\n   ctx.has_matched = True\n   yield True\n   \n  ctx.state.marks_push()\n  while maxcount == MAXREPEAT or count <= maxcount:\n   ctx.state.string_position = ctx.string_position\n   child_context = ctx.push_new_context(ctx.peek_code(1) + 1)\n   \n   yield False\n   if child_context.has_matched:\n    ctx.has_matched = True\n    yield True\n   ctx.state.string_position = ctx.string_position\n   if self.count_repetitions(ctx, 1) == 0:\n    break\n   ctx.skip_char(1)\n   count += 1\n   ctx.state.marks_pop_keep()\n   \n  ctx.state.marks_pop_discard()\n  ctx.has_matched = False\n  yield True\n  \n def op_repeat(self, ctx):\n \n \n \n \n \n \n \n \n \n  repeat = _RepeatContext(ctx)\n  ctx.state.repeat = repeat\n  ctx.state.string_position = ctx.string_position\n  child_context = ctx.push_new_context(ctx.peek_code(1) + 1)\n  \n  \n  \n  \n  yield False\n  ctx.state.repeat = repeat.previous\n  ctx.has_matched = child_context.has_matched\n  yield True\n  \n def op_max_until(self, ctx):\n \n \n  repeat = ctx.state.repeat\n  \n  if repeat is None:\n  \n   raise RuntimeError(\"Internal re error: MAX_UNTIL without REPEAT.\")\n  mincount = repeat.peek_code(2)\n  maxcount = repeat.peek_code(3)\n  ctx.state.string_position = ctx.string_position\n  count = repeat.count + 1\n  \n  \n  if count < mincount:\n  \n   repeat.count = count\n   child_context = repeat.push_new_context(4)\n   yield False\n   ctx.has_matched = child_context.has_matched\n   if not ctx.has_matched:\n    repeat.count = count - 1\n    ctx.state.string_position = ctx.string_position\n   yield True\n   \n  if (count < maxcount or maxcount == MAXREPEAT) and ctx.state.string_position != repeat.last_position:\n  \n   repeat.count = count\n   ctx.state.marks_push()\n   save_last_position = repeat.last_position \n   repeat.last_position = ctx.state.string_position\n   child_context = repeat.push_new_context(4)\n   yield False\n   repeat.last_position = save_last_position\n   if child_context.has_matched:\n    ctx.state.marks_pop_discard()\n    ctx.has_matched = True\n    yield True\n   ctx.state.marks_pop()\n   repeat.count = count - 1\n   ctx.state.string_position = ctx.string_position\n   \n   \n  ctx.state.repeat = repeat.previous\n  child_context = ctx.push_new_context(1)\n  \n  yield False\n  ctx.has_matched = child_context.has_matched\n  if not ctx.has_matched:\n   ctx.state.repeat = repeat\n   ctx.state.string_position = ctx.string_position\n  yield True\n  \n def op_min_until(self, ctx):\n \n \n  repeat = ctx.state.repeat\n  if repeat is None:\n   raise RuntimeError(\"Internal re error: MIN_UNTIL without REPEAT.\")\n  mincount = repeat.peek_code(2)\n  maxcount = repeat.peek_code(3)\n  ctx.state.string_position = ctx.string_position\n  count = repeat.count + 1\n  \n  \n  if count < mincount:\n  \n   repeat.count = count\n   child_context = repeat.push_new_context(4)\n   yield False\n   ctx.has_matched = child_context.has_matched\n   if not ctx.has_matched:\n    repeat.count = count - 1\n    ctx.state.string_position = ctx.string_position\n   yield True\n   \n   \n  ctx.state.marks_push()\n  ctx.state.repeat = repeat.previous\n  child_context = ctx.push_new_context(1)\n  \n  yield False\n  if child_context.has_matched:\n   ctx.has_matched = True\n   yield True\n  ctx.state.repeat = repeat\n  ctx.state.string_position = ctx.string_position\n  ctx.state.marks_pop()\n  \n  \n  if count >= maxcount and maxcount != MAXREPEAT:\n   ctx.has_matched = False\n   \n   yield True\n  repeat.count = count\n  child_context = repeat.push_new_context(4)\n  yield False\n  ctx.has_matched = child_context.has_matched\n  if not ctx.has_matched:\n   repeat.count = count - 1\n   ctx.state.string_position = ctx.string_position\n  yield True\n  \n def general_op_groupref(self, ctx, decorate=lambda x: x):\n  group_start, group_end = ctx.state.get_marks(ctx.peek_code(1))\n  if group_start is None or group_end is None or group_end < group_start:\n   ctx.has_matched = False\n   return True\n  while group_start < group_end:\n   if ctx.at_end() or decorate(ord(ctx.peek_char())) != decorate(ord(ctx.state.string[group_start])):\n    ctx.has_matched = False\n    \n    return True\n   group_start += 1\n   ctx.skip_char(1)\n  ctx.skip_code(2)\n  return True\n  \n def op_groupref(self, ctx):\n \n \n \n  return self.general_op_groupref(ctx)\n  \n def op_groupref_ignore(self, ctx):\n \n \n \n  return self.general_op_groupref(ctx, ctx.state.lower)\n  \n def op_groupref_exists(self, ctx):\n \n \n  group_start, group_end = ctx.state.get_marks(ctx.peek_code(1))\n  if group_start is None or group_end is None or group_end < group_start:\n   ctx.skip_code(ctx.peek_code(2) + 1)\n  else:\n   ctx.skip_code(3)\n  return True\n  \n def op_assert(self, ctx):\n \n \n \n  ctx.state.string_position = ctx.string_position - ctx.peek_code(2)\n  if ctx.state.string_position < 0:\n   ctx.has_matched = False\n   yield True\n  child_context = ctx.push_new_context(3)\n  yield False\n  if child_context.has_matched:\n   ctx.skip_code(ctx.peek_code(1) + 1)\n  else:\n   ctx.has_matched = False\n  yield True\n  \n def op_assert_not(self, ctx):\n \n \n \n  ctx.state.string_position = ctx.string_position - ctx.peek_code(2)\n  if ctx.state.string_position >= 0:\n   child_context = ctx.push_new_context(3)\n   yield False\n   if child_context.has_matched:\n    ctx.has_matched = False\n    yield True\n  ctx.skip_code(ctx.peek_code(1) + 1)\n  yield True\n  \n def unknown(self, ctx):\n \n  raise RuntimeError(\"Internal re error. Unknown opcode: %s\" % ctx.peek_code())\n  \n def check_charset(self, ctx, char):\n  \"\"\n  self.set_dispatcher.reset(char)\n  save_position = ctx.code_position\n  result = None\n  while result is None:\n   result = self.set_dispatcher.dispatch(ctx.peek_code(), ctx)\n  ctx.code_position = save_position\n  \n  return result\n  \n def count_repetitions(self, ctx, maxcount):\n  \"\"\n  count = 0\n  real_maxcount = ctx.state.end - ctx.string_position\n  if maxcount < real_maxcount and maxcount != MAXREPEAT:\n   real_maxcount = maxcount\n   \n   \n   \n  code_position = ctx.code_position\n  string_position = ctx.string_position\n  ctx.skip_code(4)\n  reset_position = ctx.code_position\n  while count < real_maxcount:\n  \n  \n   ctx.code_position = reset_position\n   self.dispatch(ctx.peek_code(), ctx)\n   \n   if ctx.has_matched is False: \n    break\n   count += 1\n  ctx.has_matched = None\n  ctx.code_position = code_position\n  ctx.string_position = string_position\n  return count\n  \n def _log(self, context, opname, *args):\n  arg_string = (\"%s \" * len(args)) % args\n  _log(\"|%s|%s|%s %s\" % (context.pattern_codes,\n  context.string_position, opname, arg_string))\n  \n_OpcodeDispatcher.build_dispatch_table(OPCODES, \"op_\")\n\n\nclass _CharsetDispatcher(_Dispatcher):\n\n def __init__(self):\n  self.ch_dispatcher = _ChcodeDispatcher()\n  \n def reset(self, char):\n  self.char = char\n  self.ok = True\n  \n def set_failure(self, ctx):\n  return not self.ok\n def set_literal(self, ctx):\n \n  if ctx.peek_code(1) == self.char:\n   return self.ok\n  else:\n   ctx.skip_code(2)\n def set_category(self, ctx):\n \n  if self.ch_dispatcher.dispatch(ctx.peek_code(1), ctx):\n   return self.ok\n  else:\n   ctx.skip_code(2)\n def set_charset(self, ctx):\n \n  char_code = self.char\n  ctx.skip_code(1) \n  if CODESIZE == 2:\n   if char_code < 256 and ctx.peek_code(char_code >> 4) & (1 << (char_code & 15)):\n    return self.ok\n   ctx.skip_code(16) \n  else:\n   if char_code < 256 and ctx.peek_code(char_code >> 5) & (1 << (char_code & 31)):\n    return self.ok\n   ctx.skip_code(8) \n def set_range(self, ctx):\n \n  if ctx.peek_code(1) <= self.char <= ctx.peek_code(2):\n   return self.ok\n  ctx.skip_code(3)\n def set_negate(self, ctx):\n  self.ok = not self.ok\n  ctx.skip_code(1)\n  \n  \n def set_bigcharset(self, ctx):\n  raise NotImplementationError(\"_sre.py: set_bigcharset, array not implemented\")\n  \n  char_code = self.char\n  count = ctx.peek_code(1)\n  ctx.skip_code(2)\n  if char_code < 65536:\n   block_index = char_code >> 8\n   \n   a = array.array(\"B\")\n   a.fromstring(array.array(CODESIZE == 2 and \"H\" or \"I\",\n   [ctx.peek_code(block_index // CODESIZE)]).tostring())\n   block = a[block_index % CODESIZE]\n   ctx.skip_code(256 // CODESIZE) \n   block_value = ctx.peek_code(block * (32 // CODESIZE)\n   + ((char_code & 255) >> (CODESIZE == 2 and 4 or 5)))\n   if block_value & (1 << (char_code & ((8 * CODESIZE) - 1))):\n    return self.ok\n  else:\n   ctx.skip_code(256 // CODESIZE) \n  ctx.skip_code(count * (32 // CODESIZE)) \n  \n def unknown(self, ctx):\n  return False\n  \n_CharsetDispatcher.build_dispatch_table(OPCODES, \"set_\")\n\n\nclass _AtcodeDispatcher(_Dispatcher):\n\n def at_beginning(self, ctx):\n  return ctx.at_beginning()\n at_beginning_string = at_beginning\n def at_beginning_line(self, ctx):\n  return ctx.at_beginning() or _is_linebreak(ctx.peek_char(-1))\n def at_end(self, ctx):\n  return (ctx.remaining_chars() == 1 and ctx.at_linebreak()) or ctx.at_end()\n def at_end_line(self, ctx):\n  return ctx.at_linebreak() or ctx.at_end()\n def at_end_string(self, ctx):\n  return ctx.at_end()\n def at_boundary(self, ctx):\n  return ctx.at_boundary(_is_word)\n def at_non_boundary(self, ctx):\n  return not ctx.at_boundary(_is_word)\n def at_loc_boundary(self, ctx):\n  return ctx.at_boundary(_is_loc_word)\n def at_loc_non_boundary(self, ctx):\n  return not ctx.at_boundary(_is_loc_word)\n def at_uni_boundary(self, ctx):\n  return ctx.at_boundary(_is_uni_word)\n def at_uni_non_boundary(self, ctx):\n  return not ctx.at_boundary(_is_uni_word)\n def unknown(self, ctx):\n  return False\n  \n_AtcodeDispatcher.build_dispatch_table(ATCODES, \"\")\n\n\nclass _ChcodeDispatcher(_Dispatcher):\n\n def category_digit(self, ctx):\n  return _is_digit(ctx.peek_char())\n def category_not_digit(self, ctx):\n  return not _is_digit(ctx.peek_char())\n def category_space(self, ctx):\n  return _is_space(ctx.peek_char())\n def category_not_space(self, ctx):\n  return not _is_space(ctx.peek_char())\n def category_word(self, ctx):\n  return _is_word(ctx.peek_char())\n def category_not_word(self, ctx):\n  return not _is_word(ctx.peek_char())\n def category_linebreak(self, ctx):\n  return _is_linebreak(ctx.peek_char())\n def category_not_linebreak(self, ctx):\n  return not _is_linebreak(ctx.peek_char())\n def category_loc_word(self, ctx):\n  return _is_loc_word(ctx.peek_char())\n def category_loc_not_word(self, ctx):\n  return not _is_loc_word(ctx.peek_char())\n def category_uni_digit(self, ctx):\n  return ctx.peek_char().isdigit()\n def category_uni_not_digit(self, ctx):\n  return not ctx.peek_char().isdigit()\n def category_uni_space(self, ctx):\n  return ctx.peek_char().isspace()\n def category_uni_not_space(self, ctx):\n  return not ctx.peek_char().isspace()\n def category_uni_word(self, ctx):\n  return _is_uni_word(ctx.peek_char())\n def category_uni_not_word(self, ctx):\n  return not _is_uni_word(ctx.peek_char())\n def category_uni_linebreak(self, ctx):\n  return ord(ctx.peek_char()) in _uni_linebreaks\n def category_uni_not_linebreak(self, ctx):\n  return ord(ctx.peek_char()) not in _uni_linebreaks\n def unknown(self, ctx):\n  return False\n  \n_ChcodeDispatcher.build_dispatch_table(CHCODES, \"\")\n\n\n_ascii_char_info = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 6, 2,\n2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0,\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25, 25, 25, 25, 25, 25, 25, 25,\n25, 25, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 0, 0,\n0, 0, 16, 0, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0 ]\n\ndef _is_digit(char):\n code = ord(char)\n return code < 128 and _ascii_char_info[code] & 1\n \ndef _is_space(char):\n code = ord(char)\n return code < 128 and _ascii_char_info[code] & 2\n \ndef _is_word(char):\n\n code = ord(char)\n return code < 128 and _ascii_char_info[code] & 16\n \ndef _is_loc_word(char):\n return (not (ord(char) & ~255) and char.isalnum()) or char == '_'\n \ndef _is_uni_word(char):\n\n\n return chr(ord(char)).isalnum() or char == '_'\n \ndef _is_linebreak(char):\n return char == \"\\n\"\n \n \n_uni_linebreaks = [10, 13, 28, 29, 30, 133, 8232, 8233]\n\ndef _log(message):\n if 0:\n  print(message)\n"], "_string": [".py", "\"\"\n\nimport re\n\nclass __loader__(object):\n pass\n \ndef formatter_field_name_split(fieldname):\n \"\"\n _list=[]\n for _name in fieldname:\n  _parts = _name.split('.')\n  for _item in _parts:\n   is_attr=False \n   if re.match('\\d+', _item):\n    _list.append((int(_item), is_attr))\n   else:\n    _list.append((_item, is_attr))\n    \n return _list[0][0], iter(_list[1:])\n \ndef formatter_parser(*args,**kw):\n \"\"\n \n assert len(args)==1\n assert isinstance(args[0], str)\n \n _result=[]\n for _match in re.finditer(\"([^{]*)?(\\{[^}]*\\})?\", args[0]):\n  _pre, _fmt = _match.groups()\n  if _fmt is None:\n   _result.append((_pre, None, None, None))\n  elif _fmt == '{}':\n   _result.append((_pre, '', '', None))\n  else:\n   _m=re.match(\"\\{([^!]*)!?(.*)?\\}\", _fmt)\n   _name=_m.groups(0)\n   _flags=_m.groups(1)\n   \n   _result.append((_pre, _name, _flags, None))\n   \n return _result\n"], "xml.parsers": [".py", "\"\"\n", 1], "xml.sax.xmlreader": [".py", "\"\"\n\nfrom . import handler\n\nfrom ._exceptions import SAXNotSupportedException, SAXNotRecognizedException\n\n\n\n\nclass XMLReader:\n \"\"\n \n def __init__(self):\n  self._cont_handler = handler.ContentHandler()\n  self._dtd_handler = handler.DTDHandler()\n  self._ent_handler = handler.EntityResolver()\n  self._err_handler = handler.ErrorHandler()\n  \n def parse(self, source):\n  \"\"\n  raise NotImplementedError(\"This method must be implemented!\")\n  \n def getContentHandler(self):\n  \"\"\n  return self._cont_handler\n  \n def setContentHandler(self, handler):\n  \"\"\n  self._cont_handler = handler\n  \n def getDTDHandler(self):\n  \"\"\n  return self._dtd_handler\n  \n def setDTDHandler(self, handler):\n  \"\"\n  self._dtd_handler = handler\n  \n def getEntityResolver(self):\n  \"\"\n  return self._ent_handler\n  \n def setEntityResolver(self, resolver):\n  \"\"\n  self._ent_handler = resolver\n  \n def getErrorHandler(self):\n  \"\"\n  return self._err_handler\n  \n def setErrorHandler(self, handler):\n  \"\"\n  self._err_handler = handler\n  \n def setLocale(self, locale):\n  \"\"\n  raise SAXNotSupportedException(\"Locale support not implemented\")\n  \n def getFeature(self, name):\n  \"\"\n  raise SAXNotRecognizedException(\"Feature '%s' not recognized\" % name)\n  \n def setFeature(self, name, state):\n  \"\"\n  raise SAXNotRecognizedException(\"Feature '%s' not recognized\" % name)\n  \n def getProperty(self, name):\n  \"\"\n  raise SAXNotRecognizedException(\"Property '%s' not recognized\" % name)\n  \n def setProperty(self, name, value):\n  \"\"\n  raise SAXNotRecognizedException(\"Property '%s' not recognized\" % name)\n  \nclass IncrementalParser(XMLReader):\n \"\"\n \n def __init__(self, bufsize=2**16):\n  self._bufsize = bufsize\n  XMLReader.__init__(self)\n  \n def parse(self, source):\n  from . import saxutils\n  source = saxutils.prepare_input_source(source)\n  \n  self.prepareParser(source)\n  file = source.getByteStream()\n  buffer = file.read(self._bufsize)\n  while buffer:\n   self.feed(buffer)\n   buffer = file.read(self._bufsize)\n  self.close()\n  \n def feed(self, data):\n  \"\"\n  raise NotImplementedError(\"This method must be implemented!\")\n  \n def prepareParser(self, source):\n  \"\"\n  raise NotImplementedError(\"prepareParser must be overridden!\")\n  \n def close(self):\n  \"\"\n  raise NotImplementedError(\"This method must be implemented!\")\n  \n def reset(self):\n  \"\"\n  raise NotImplementedError(\"This method must be implemented!\")\n  \n  \n  \nclass Locator:\n \"\"\n \n def getColumnNumber(self):\n  \"\"\n  return -1\n  \n def getLineNumber(self):\n  \"\"\n  return -1\n  \n def getPublicId(self):\n  \"\"\n  return None\n  \n def getSystemId(self):\n  \"\"\n  return None\n  \n  \n  \nclass InputSource:\n \"\"\n \n def __init__(self, system_id = None):\n  self.__system_id = system_id\n  self.__public_id = None\n  self.__encoding = None\n  self.__bytefile = None\n  self.__charfile = None\n  \n def setPublicId(self, public_id):\n  \"\"\n  self.__public_id = public_id\n  \n def getPublicId(self):\n  \"\"\n  return self.__public_id\n  \n def setSystemId(self, system_id):\n  \"\"\n  self.__system_id = system_id\n  \n def getSystemId(self):\n  \"\"\n  return self.__system_id\n  \n def setEncoding(self, encoding):\n  \"\"\n  self.__encoding = encoding\n  \n def getEncoding(self):\n  \"\"\n  return self.__encoding\n  \n def setByteStream(self, bytefile):\n  \"\"\n  self.__bytefile = bytefile\n  \n def getByteStream(self):\n  \"\"\n  return self.__bytefile\n  \n def setCharacterStream(self, charfile):\n  \"\"\n  self.__charfile = charfile\n  \n def getCharacterStream(self):\n  \"\"\n  return self.__charfile\n  \n  \n  \nclass AttributesImpl:\n\n def __init__(self, attrs):\n  \"\"\n  self._attrs = attrs\n  \n def getLength(self):\n  return len(self._attrs)\n  \n def getType(self, name):\n  return \"CDATA\"\n  \n def getValue(self, name):\n  return self._attrs[name]\n  \n def getValueByQName(self, name):\n  return self._attrs[name]\n  \n def getNameByQName(self, name):\n  if name not in self._attrs:\n   raise KeyError(name)\n  return name\n  \n def getQNameByName(self, name):\n  if name not in self._attrs:\n   raise KeyError(name)\n  return name\n  \n def getNames(self):\n  return list(self._attrs.keys())\n  \n def getQNames(self):\n  return list(self._attrs.keys())\n  \n def __len__(self):\n  return len(self._attrs)\n  \n def __getitem__(self, name):\n  return self._attrs[name]\n  \n def keys(self):\n  return list(self._attrs.keys())\n  \n def __contains__(self, name):\n  return name in self._attrs\n  \n def get(self, name, alternative=None):\n  return self._attrs.get(name, alternative)\n  \n def copy(self):\n  return self.__class__(self._attrs)\n  \n def items(self):\n  return list(self._attrs.items())\n  \n def values(self):\n  return list(self._attrs.values())\n  \n  \n  \nclass AttributesNSImpl(AttributesImpl):\n\n def __init__(self, attrs, qnames):\n  \"\"\n  self._attrs = attrs\n  self._qnames = qnames\n  \n def getValueByQName(self, name):\n  for (nsname, qname) in self._qnames.items():\n   if qname == name:\n    return self._attrs[nsname]\n    \n  raise KeyError(name)\n  \n def getNameByQName(self, name):\n  for (nsname, qname) in self._qnames.items():\n   if qname == name:\n    return nsname\n    \n  raise KeyError(name)\n  \n def getQNameByName(self, name):\n  return self._qnames[name]\n  \n def getQNames(self):\n  return list(self._qnames.values())\n  \n def copy(self):\n  return self.__class__(self._attrs, self._qnames)\n  \n  \ndef _test():\n XMLReader()\n IncrementalParser()\n Locator()\n \nif __name__ == \"__main__\":\n _test()\n"], "operator": [".py", "\n\"\"\n\n\n\n\n\ndef lt(a, b):\n \"\"\n return a < b\n__lt__ = lt\n\ndef le(a, b):\n \"\"\n return a <= b\n__le__ = le\n\ndef eq(a, b):\n \"\"\n return a == b\n__eq__ = eq\n\ndef ne(a, b):\n \"\"\n return a != b\n__ne__ = ne\n\ndef ge(a, b):\n \"\"\n return a >= b\n__ge__ = ge\n\ndef gt(a, b):\n \"\"\n return a > b\n__gt__ = gt\n\ndef not_(a):\n \"\"\n return not a\n__not__ = not_\n\ndef truth(a):\n \"\"\n \n return bool(a)\n \ndef is_(a, b):\n \"\"\n return a is b\n \n \n \n \n \n \n \n \n \n \n \n__abs__ = abs\nabs=abs\n\n\ndef add(a, b):\n \"\"\n return a + b\n__add__ = add\n\ndef and_(a, b):\n \"\"\n return a & b\n__and__ = and_\n\ndef floordiv(a, b):\n \"\"\n return a // b\n__floordiv__ = floordiv\n\ndef index(a):\n \"\"\n return a.__index__()\n__index__ = index\n\ndef inv(a):\n \"\"\n return ~a \n \ninvert = __inv__ = __invert__ = inv\n\ndef lshift(a, b):\n \"\"\n return a << b\n__lshift__ = lshift\n\ndef mod(a, b):\n \"\"\n return a % b\n__mod__ = mod\n\ndef mul(a, b):\n \"\"\n return a * b\n__mul__ = mul\n\ndef neg(a):\n \"\"\n return -a\n__neg__ = neg\n\ndef or_(a, b):\n \"\"\n return a | b\n__or__ = or_\n\ndef pos(a):\n \"\"\n return +a \n if a >= 0: return a\n return -a\n__pos__ = pos\n\ndef pow(a, b):\n \"\"\n return a ** b\n__pow__ = pow\n\ndef rshift(a, b):\n \"\"\n return a >> b\n__rshift__ = rshift\n\ndef sub(a, b):\n \"\"\n return a - b\n__sub__ = sub\n\ndef truediv(a, b):\n \"\"\n return a / b\n__truediv__ = truediv\n\ndef xor(a, b):\n \"\"\n return a ^ b\n__xor__ = xor\n\ndef concat(a, b):\n \"\"\n if not (hasattr(a, '__getitem__') and hasattr(b, '__getitem__')):\n  raise TypeError('a and b must be sequences')\n return a + b\n__concat__ = concat\n\ndef contains(a, b):\n \"\"\n return b in a\n__contains__ = contains\n\ndef countOf(a, b):\n \"\"\n count = 0\n for i in a:\n  if i == b:\n   count += 1\n return count\n \ndef delitem(a, b):\n \"\"\n del a[b]\n__delitem__ = delitem\n\ndef getitem(a, b):\n \"\"\n return a[b]\n__getitem__ = getitem\n\n\ndef indexOf(a, b):\n \"\"\n \n for i, j in enumerate(a):\n  if j == b:\n   return i\n else:\n  raise ValueError('b not found in a')\n  \ndef setitem(a, b, c):\n \"\"\n a[b] = c\n__setitem__ = setitem\n\n\n\nclass attrgetter:\n \"\"\n def __init__(self, attr, *attrs):\n  self._attrs = (attr,)\n  self._attrs += attrs\n  if any(not isinstance(attr, str) for attr in self._attrs):\n   raise TypeError('attribute name must be a string')\n   \n @staticmethod\n def _resolve_attr(obj, attr):\n  for name in attr.split('.'):\n  \n   obj = getattr(obj, name)\n  return obj\n  \n def __call__(self, obj):\n  if len(self._attrs) == 1:\n   return self._resolve_attr(obj, self._attrs[0])\n  return tuple(self._resolve_attr(obj, attr) for attr in self._attrs)\n  \nclass itemgetter:\n \"\"\n def __init__(self, item, *items):\n  self._items = (item,)\n  self._items += items\n  \n def __call__(self, obj):\n  if len(self._items) == 1:\n   return obj[self._items[0]]\n  return tuple(obj[item] for item in self._items)\n  \nclass methodcaller:\n \"\"\n \n def __init__(self, name, *args, **kwargs):\n  self._name = name\n  self._args = args\n  self._kwargs = kwargs\n  \n def __call__(self, obj):\n  return getattr(obj, self._name)(*self._args, **self._kwargs)\n  \n  \ndef iadd(a, b):\n \"\"\n a += b\n return a\n__iadd__ = iadd\n\ndef iand(a, b):\n \"\"\n a &= b\n return a\n__iand__ = iand\n\ndef iconcat(a, b):\n \"\"\n if not (hasattr(a, '__getitem__') and hasattr(b, '__getitem__')):\n  raise TypeError('a and b must be sequences')\n a += b\n return a\n__iconcat__ = iconcat\n\ndef ifloordiv(a, b):\n \"\"\n a //= b\n return a\n__ifloordiv__ = ifloordiv\n\ndef ilshift(a, b):\n \"\"\n a <<= b\n return a\n__ilshift__ = ilshift\n\ndef imod(a, b):\n \"\"\n a %= b\n return a\n__imod__ = imod\n\ndef imul(a, b):\n \"\"\n a *= b\n return a\n__imul__ = imul\n\ndef ior(a, b):\n \"\"\n a |= b\n return a\n__ior__ = ior\n\ndef ipow(a, b):\n \"\"\n a **=b\n return a\n__ipow__ = ipow\n\ndef irshift(a, b):\n \"\"\n a >>= b\n return a\n__irshift__ = irshift\n\ndef isub(a, b):\n \"\"\n a -= b\n return a\n__isub__ = isub\n\ndef itruediv(a, b):\n \"\"\n a /= b\n return a\n__itruediv__ = itruediv\n\ndef ixor(a, b):\n \"\"\n a ^= b\n return a\n__ixor__ = ixor\n\ndef length_hint(obj, default=0):\n \"\"\n try:\n  return len(obj)\n except TypeError:\n  try:\n   val = obj.__length_hint__()\n   if val is NotImplemented:\n    raise TypeError\n  except (AttributeError, TypeError):\n   return default\n  else:\n   if not val > 0:\n    raise ValueError('default must be > 0')\n   return val\n   \n   \n   \n   \n   \n   \n"], "site-packages.docs": [".py", "from browser import document as doc\nfrom browser import window, html, markdown\n\nimport highlight\n\nimport time\n\ndef run(ev):\n\n ix = ev.target.parent.children.index(ev.target)\n elt = ev.target.parent.children[ix+1]\n exec(elt.text)\n elt.focus()\n \ndef load(url,target):\n\n qs = '?foo=%s' %time.time()\n try:\n  mk,scripts = markdown.mark(open(url+qs).read())\n except IOError:\n  doc[target].html = \"Page %s not found\" %url\n  return False\n doc[target].html = mk\n for script in scripts:\n  exec(script)\n for elt in doc[target].get(selector='.exec'):\n \n  elt.contentEditable = True\n  src = elt.text.strip()\n  h = highlight.highlight(src)\n  h.className = \"pycode\"\n  elt.clear()\n  elt <= h\n  elt.focus()\n  btn = html.BUTTON('\u25b6')\n  btn.bind('click', run)\n  elt.parent.insertBefore(btn, elt)\n for elt in doc[target].get(selector='.exec_on_load'):\n \n  src = elt.text.strip()\n  h = highlight.highlight(src)\n  h.className = \"pycode\"\n  elt.clear()\n  elt <= h\n  exec(src)\n for elt in doc[target].get(selector='.python'):\n  src = elt.text.strip()\n  h = highlight.highlight(src)\n  h.className = \"pycode\"\n  elt.clear()\n  elt <= h\n return False\n"], "xml.dom.pulldom": [".py", "import xml.sax\nimport xml.sax.handler\n\nSTART_ELEMENT = \"START_ELEMENT\"\nEND_ELEMENT = \"END_ELEMENT\"\nCOMMENT = \"COMMENT\"\nSTART_DOCUMENT = \"START_DOCUMENT\"\nEND_DOCUMENT = \"END_DOCUMENT\"\nPROCESSING_INSTRUCTION = \"PROCESSING_INSTRUCTION\"\nIGNORABLE_WHITESPACE = \"IGNORABLE_WHITESPACE\"\nCHARACTERS = \"CHARACTERS\"\n\nclass PullDOM(xml.sax.ContentHandler):\n _locator = None\n document = None\n \n def __init__(self, documentFactory=None):\n  from xml.dom import XML_NAMESPACE\n  self.documentFactory = documentFactory\n  self.firstEvent = [None, None]\n  self.lastEvent = self.firstEvent\n  self.elementStack = []\n  self.push = self.elementStack.append\n  try:\n   self.pop = self.elementStack.pop\n  except AttributeError:\n  \n   pass\n  self._ns_contexts = [{XML_NAMESPACE:'xml'}] \n  self._current_context = self._ns_contexts[-1]\n  self.pending_events = []\n  \n def pop(self):\n  result = self.elementStack[-1]\n  del self.elementStack[-1]\n  return result\n  \n def setDocumentLocator(self, locator):\n  self._locator = locator\n  \n def startPrefixMapping(self, prefix, uri):\n  if not hasattr(self, '_xmlns_attrs'):\n   self._xmlns_attrs = []\n  self._xmlns_attrs.append((prefix or 'xmlns', uri))\n  self._ns_contexts.append(self._current_context.copy())\n  self._current_context[uri] = prefix or None\n  \n def endPrefixMapping(self, prefix):\n  self._current_context = self._ns_contexts.pop()\n  \n def startElementNS(self, name, tagName , attrs):\n \n  xmlns_uri = 'http://www.w3.org/2000/xmlns/'\n  xmlns_attrs = getattr(self, '_xmlns_attrs', None)\n  if xmlns_attrs is not None:\n   for aname, value in xmlns_attrs:\n    attrs._attrs[(xmlns_uri, aname)] = value\n   self._xmlns_attrs = []\n  uri, localname = name\n  if uri:\n  \n  \n  \n   if tagName is None:\n    prefix = self._current_context[uri]\n    if prefix:\n     tagName = prefix + \":\" + localname\n    else:\n     tagName = localname\n   if self.document:\n    node = self.document.createElementNS(uri, tagName)\n   else:\n    node = self.buildDocument(uri, tagName)\n  else:\n  \n  \n   if self.document:\n    node = self.document.createElement(localname)\n   else:\n    node = self.buildDocument(None, localname)\n    \n  for aname,value in attrs.items():\n   a_uri, a_localname = aname\n   if a_uri == xmlns_uri:\n    if a_localname == 'xmlns':\n     qname = a_localname\n    else:\n     qname = 'xmlns:' + a_localname\n    attr = self.document.createAttributeNS(a_uri, qname)\n    node.setAttributeNodeNS(attr)\n   elif a_uri:\n    prefix = self._current_context[a_uri]\n    if prefix:\n     qname = prefix + \":\" + a_localname\n    else:\n     qname = a_localname\n    attr = self.document.createAttributeNS(a_uri, qname)\n    node.setAttributeNodeNS(attr)\n   else:\n    attr = self.document.createAttribute(a_localname)\n    node.setAttributeNode(attr)\n   attr.value = value\n   \n  self.lastEvent[1] = [(START_ELEMENT, node), None]\n  self.lastEvent = self.lastEvent[1]\n  self.push(node)\n  \n def endElementNS(self, name, tagName):\n  self.lastEvent[1] = [(END_ELEMENT, self.pop()), None]\n  self.lastEvent = self.lastEvent[1]\n  \n def startElement(self, name, attrs):\n  if self.document:\n   node = self.document.createElement(name)\n  else:\n   node = self.buildDocument(None, name)\n   \n  for aname,value in attrs.items():\n   attr = self.document.createAttribute(aname)\n   attr.value = value\n   node.setAttributeNode(attr)\n   \n  self.lastEvent[1] = [(START_ELEMENT, node), None]\n  self.lastEvent = self.lastEvent[1]\n  self.push(node)\n  \n def endElement(self, name):\n  self.lastEvent[1] = [(END_ELEMENT, self.pop()), None]\n  self.lastEvent = self.lastEvent[1]\n  \n def comment(self, s):\n  if self.document:\n   node = self.document.createComment(s)\n   self.lastEvent[1] = [(COMMENT, node), None]\n   self.lastEvent = self.lastEvent[1]\n  else:\n   event = [(COMMENT, s), None]\n   self.pending_events.append(event)\n   \n def processingInstruction(self, target, data):\n  if self.document:\n   node = self.document.createProcessingInstruction(target, data)\n   self.lastEvent[1] = [(PROCESSING_INSTRUCTION, node), None]\n   self.lastEvent = self.lastEvent[1]\n  else:\n   event = [(PROCESSING_INSTRUCTION, target, data), None]\n   self.pending_events.append(event)\n   \n def ignorableWhitespace(self, chars):\n  node = self.document.createTextNode(chars)\n  self.lastEvent[1] = [(IGNORABLE_WHITESPACE, node), None]\n  self.lastEvent = self.lastEvent[1]\n  \n def characters(self, chars):\n  node = self.document.createTextNode(chars)\n  self.lastEvent[1] = [(CHARACTERS, node), None]\n  self.lastEvent = self.lastEvent[1]\n  \n def startDocument(self):\n  if self.documentFactory is None:\n   import xml.dom.minidom\n   self.documentFactory = xml.dom.minidom.Document.implementation\n   \n def buildDocument(self, uri, tagname):\n \n \n  node = self.documentFactory.createDocument(uri, tagname, None)\n  self.document = node\n  self.lastEvent[1] = [(START_DOCUMENT, node), None]\n  self.lastEvent = self.lastEvent[1]\n  self.push(node)\n  \n  for e in self.pending_events:\n   if e[0][0] == PROCESSING_INSTRUCTION:\n    _,target,data = e[0]\n    n = self.document.createProcessingInstruction(target, data)\n    e[0] = (PROCESSING_INSTRUCTION, n)\n   elif e[0][0] == COMMENT:\n    n = self.document.createComment(e[0][1])\n    e[0] = (COMMENT, n)\n   else:\n    raise AssertionError(\"Unknown pending event \",e[0][0])\n   self.lastEvent[1] = e\n   self.lastEvent = e\n  self.pending_events = None\n  return node.firstChild\n  \n def endDocument(self):\n  self.lastEvent[1] = [(END_DOCUMENT, self.document), None]\n  self.pop()\n  \n def clear(self):\n  \"\"\n  self.document = None\n  \nclass ErrorHandler:\n def warning(self, exception):\n  print(exception)\n def error(self, exception):\n  raise exception\n def fatalError(self, exception):\n  raise exception\n  \nclass DOMEventStream:\n def __init__(self, stream, parser, bufsize):\n  self.stream = stream\n  self.parser = parser\n  self.bufsize = bufsize\n  if not hasattr(self.parser, 'feed'):\n   self.getEvent = self._slurp\n  self.reset()\n  \n def reset(self):\n  self.pulldom = PullDOM()\n  \n  self.parser.setFeature(xml.sax.handler.feature_namespaces, 1)\n  self.parser.setContentHandler(self.pulldom)\n  \n def __getitem__(self, pos):\n  rc = self.getEvent()\n  if rc:\n   return rc\n  raise IndexError\n  \n def __next__(self):\n  rc = self.getEvent()\n  if rc:\n   return rc\n  raise StopIteration\n  \n def __iter__(self):\n  return self\n  \n def expandNode(self, node):\n  event = self.getEvent()\n  parents = [node]\n  while event:\n   token, cur_node = event\n   if cur_node is node:\n    return\n   if token != END_ELEMENT:\n    parents[-1].appendChild(cur_node)\n   if token == START_ELEMENT:\n    parents.append(cur_node)\n   elif token == END_ELEMENT:\n    del parents[-1]\n   event = self.getEvent()\n   \n def getEvent(self):\n \n \n  if not self.pulldom.firstEvent[1]:\n   self.pulldom.lastEvent = self.pulldom.firstEvent\n  while not self.pulldom.firstEvent[1]:\n   buf = self.stream.read(self.bufsize)\n   if not buf:\n    self.parser.close()\n    return None\n   self.parser.feed(buf)\n  rc = self.pulldom.firstEvent[1][0]\n  self.pulldom.firstEvent[1] = self.pulldom.firstEvent[1][1]\n  return rc\n  \n def _slurp(self):\n  \"\"\n  self.parser.parse(self.stream)\n  self.getEvent = self._emit\n  return self._emit()\n  \n def _emit(self):\n  \"\"\n  rc = self.pulldom.firstEvent[1][0]\n  self.pulldom.firstEvent[1] = self.pulldom.firstEvent[1][1]\n  return rc\n  \n def clear(self):\n  \"\"\n  self.pulldom.clear()\n  del self.pulldom\n  self.parser = None\n  self.stream = None\n  \nclass SAX2DOM(PullDOM):\n\n def startElementNS(self, name, tagName , attrs):\n  PullDOM.startElementNS(self, name, tagName, attrs)\n  curNode = self.elementStack[-1]\n  parentNode = self.elementStack[-2]\n  parentNode.appendChild(curNode)\n  \n def startElement(self, name, attrs):\n  PullDOM.startElement(self, name, attrs)\n  curNode = self.elementStack[-1]\n  parentNode = self.elementStack[-2]\n  parentNode.appendChild(curNode)\n  \n def processingInstruction(self, target, data):\n  PullDOM.processingInstruction(self, target, data)\n  node = self.lastEvent[0][1]\n  parentNode = self.elementStack[-1]\n  parentNode.appendChild(node)\n  \n def ignorableWhitespace(self, chars):\n  PullDOM.ignorableWhitespace(self, chars)\n  node = self.lastEvent[0][1]\n  parentNode = self.elementStack[-1]\n  parentNode.appendChild(node)\n  \n def characters(self, chars):\n  PullDOM.characters(self, chars)\n  node = self.lastEvent[0][1]\n  parentNode = self.elementStack[-1]\n  parentNode.appendChild(node)\n  \n  \ndefault_bufsize = (2 ** 14) - 20\n\ndef parse(stream_or_string, parser=None, bufsize=None):\n if bufsize is None:\n  bufsize = default_bufsize\n if isinstance(stream_or_string, str):\n  stream = open(stream_or_string, 'rb')\n else:\n  stream = stream_or_string\n if not parser:\n  parser = xml.sax.make_parser()\n return DOMEventStream(stream, parser, bufsize)\n \ndef parseString(string, parser=None):\n from io import StringIO\n \n bufsize = len(string)\n buf = StringIO(string)\n if not parser:\n  parser = xml.sax.make_parser()\n return DOMEventStream(buf, parser, bufsize)\n"], "select": [".py", "\"\"\n\n\n\n\n\n\nimport errno\nimport os\nimport queue\nimport socket\n\nclass error(Exception): pass\n\nALL = None\n\n_exception_map = {\n\n\n\n\n\n\n}\n\ndef _map_exception(exc, circumstance=ALL):\n try:\n  mapped_exception = _exception_map[(exc.__class__, circumstance)]\n  mapped_exception.java_exception = exc\n  return mapped_exception\n except KeyError:\n  return error(-1, 'Unmapped java exception: <%s:%s>' % (exc.toString(), circumstance))\n  \nPOLLIN = 1\nPOLLOUT = 2\n\n\n\n\n\nPOLLPRI = 4\nPOLLERR = 8\nPOLLHUP = 16\nPOLLNVAL = 32\n\ndef _getselectable(selectable_object):\n try:\n  channel = selectable_object.getchannel()\n except:\n  try:\n   channel = selectable_object.fileno().getChannel()\n  except:\n   raise TypeError(\"Object '%s' is not watchable\" % selectable_object,\n   errno.ENOTSOCK)\n   \n if channel and not isinstance(channel, java.nio.channels.SelectableChannel):\n  raise TypeError(\"Object '%s' is not watchable\" % selectable_object,\n  errno.ENOTSOCK)\n return channel\n \nclass poll:\n\n def __init__(self):\n  self.selector = java.nio.channels.Selector.open()\n  self.chanmap = {}\n  self.unconnected_sockets = []\n  \n def _register_channel(self, socket_object, channel, mask):\n  jmask = 0\n  if mask & POLLIN:\n  \n   if channel.validOps() & OP_ACCEPT:\n    jmask = OP_ACCEPT\n   else:\n    jmask = OP_READ\n  if mask & POLLOUT:\n   if channel.validOps() & OP_WRITE:\n    jmask |= OP_WRITE\n   if channel.validOps() & OP_CONNECT:\n    jmask |= OP_CONNECT\n  selectionkey = channel.register(self.selector, jmask)\n  self.chanmap[channel] = (socket_object, selectionkey)\n  \n def _check_unconnected_sockets(self):\n  temp_list = []\n  for socket_object, mask in self.unconnected_sockets:\n   channel = _getselectable(socket_object)\n   if channel is not None:\n    self._register_channel(socket_object, channel, mask)\n   else:\n    temp_list.append( (socket_object, mask) )\n  self.unconnected_sockets = temp_list\n  \n def register(self, socket_object, mask = POLLIN|POLLOUT|POLLPRI):\n  try:\n   channel = _getselectable(socket_object)\n   if channel is None:\n   \n   \n    self.unconnected_sockets.append( (socket_object, mask) )\n    return\n   self._register_channel(socket_object, channel, mask)\n  except BaseException:\n  \n   raise _map_exception(jlx)\n   \n def unregister(self, socket_object):\n  try:\n   channel = _getselectable(socket_object)\n   self.chanmap[channel][1].cancel()\n   del self.chanmap[channel]\n  except BaseException:\n  \n   raise _map_exception(jlx)\n   \n def _dopoll(self, timeout):\n  if timeout is None or timeout < 0:\n   self.selector.select()\n  else:\n   try:\n    timeout = int(timeout)\n    if not timeout:\n     self.selector.selectNow()\n    else:\n    \n     self.selector.select(timeout)\n   except ValueError as vx:\n    raise error(\"poll timeout must be a number of milliseconds or None\", errno.EINVAL)\n    \n  return self.selector.selectedKeys()\n  \n def poll(self, timeout=None):\n  try:\n   self._check_unconnected_sockets()\n   selectedkeys = self._dopoll(timeout)\n   results = []\n   for k in selectedkeys.iterator():\n    jmask = k.readyOps()\n    pymask = 0\n    if jmask & OP_READ: pymask |= POLLIN\n    if jmask & OP_WRITE: pymask |= POLLOUT\n    if jmask & OP_ACCEPT: pymask |= POLLIN\n    if jmask & OP_CONNECT: pymask |= POLLOUT\n    \n    results.append( (self.chanmap[k.channel()][0], pymask) )\n   return results\n  except BaseException:\n  \n   raise _map_exception(jlx)\n   \n def _deregister_all(self):\n  try:\n   for k in self.selector.keys():\n    k.cancel()\n    \n   self.selector.selectNow()\n  except BaseException:\n  \n   raise _map_exception(jlx)\n   \n def close(self):\n  try:\n   self._deregister_all()\n   self.selector.close()\n  except BaseException:\n  \n   raise _map_exception(jlx)\n   \ndef _calcselecttimeoutvalue(value):\n if value is None:\n  return None\n try:\n  floatvalue = float(value)\n except Exception as x:\n  raise TypeError(\"Select timeout value must be a number or None\")\n if value < 0:\n  raise error(\"Select timeout value cannot be negative\", errno.EINVAL)\n if floatvalue < 0.000001:\n  return 0\n return int(floatvalue * 1000) \n \n \n \n \nclass poll_object_cache:\n\n def __init__(self):\n  self.is_windows = os.name == 'nt'\n  if self.is_windows:\n   self.poll_object_queue = Queue.Queue()\n  import atexit\n  atexit.register(self.finalize)\n  \n def get_poll_object(self):\n  if not self.is_windows:\n   return poll()\n  try:\n   return self.poll_object_queue.get(False)\n  except Queue.Empty:\n   return poll()\n   \n def release_poll_object(self, pobj):\n  if self.is_windows:\n   pobj._deregister_all()\n   self.poll_object_queue.put(pobj)\n  else:\n   pobj.close()\n   \n def finalize(self):\n  if self.is_windows:\n   while True:\n    try:\n     p = self.poll_object_queue.get(False)\n     p.close()\n    except Queue.Empty:\n     return\n     \n_poll_object_cache = poll_object_cache()\n\ndef native_select(read_fd_list, write_fd_list, outofband_fd_list, timeout=None):\n timeout = _calcselecttimeoutvalue(timeout)\n \n pobj = _poll_object_cache.get_poll_object()\n try:\n  registered_for_read = {}\n  \n  for fd in read_fd_list:\n   pobj.register(fd, POLLIN)\n   registered_for_read[fd] = 1\n   \n  for fd in write_fd_list:\n   if fd in registered_for_read:\n   \n    pobj.register(fd, POLLIN|POLLOUT)\n   else:\n    pobj.register(fd, POLLOUT)\n  results = pobj.poll(timeout)\n  \n  read_ready_list, write_ready_list, oob_ready_list = [], [], []\n  for fd, mask in results:\n   if mask & POLLIN:\n    read_ready_list.append(fd)\n   if mask & POLLOUT:\n    write_ready_list.append(fd)\n  return read_ready_list, write_ready_list, oob_ready_list\n finally:\n  _poll_object_cache.release_poll_object(pobj)\n  \nselect = native_select\n\ndef cpython_compatible_select(read_fd_list, write_fd_list, outofband_fd_list, timeout=None):\n\n\n modified_channels = []\n try:\n  for socket_list in [read_fd_list, write_fd_list, outofband_fd_list]:\n   for s in socket_list:\n    channel = _getselectable(s)\n    if channel.isBlocking():\n     modified_channels.append(channel)\n     channel.configureBlocking(0)\n  return native_select(read_fd_list, write_fd_list, outofband_fd_list, timeout)\n finally:\n  for channel in modified_channels:\n   channel.configureBlocking(1)\n"], "_threading_local": [".py", "\"\"\n\nfrom weakref import ref\nfrom contextlib import contextmanager\n\n__all__ = [\"local\"]\n\n\n\n\n\n\n\n\n\n\n\nclass _localimpl:\n \"\"\n __slots__ = 'key', 'dicts', 'localargs', 'locallock', '__weakref__'\n \n def __init__(self):\n \n \n \n  self.key = '_threading_local._localimpl.' + str(id(self))\n  \n  self.dicts = {}\n  \n def get_dict(self):\n  \"\"\n  thread = current_thread()\n  return self.dicts[id(thread)][1]\n  \n def create_dict(self):\n  \"\"\n  localdict = {}\n  key = self.key\n  thread = current_thread()\n  idt = id(thread)\n  def local_deleted(_, key=key):\n  \n   thread = wrthread()\n   if thread is not None:\n    del thread.__dict__[key]\n  def thread_deleted(_, idt=idt):\n  \n  \n  \n  \n   local = wrlocal()\n   if local is not None:\n    dct = local.dicts.pop(idt)\n  wrlocal = ref(self, local_deleted)\n  wrthread = ref(thread, thread_deleted)\n  thread.__dict__[key] = wrlocal\n  self.dicts[idt] = wrthread, localdict\n  return localdict\n  \n  \n@contextmanager\ndef _patch(self):\n impl = object.__getattribute__(self, '_local__impl')\n try:\n  dct = impl.get_dict()\n except KeyError:\n  dct = impl.create_dict()\n  args, kw = impl.localargs\n  self.__init__(*args, **kw)\n with impl.locallock:\n  object.__setattr__(self, '__dict__', dct)\n  yield\n  \n  \nclass local:\n __slots__ = '_local__impl', '__dict__'\n \n def __new__(cls, *args, **kw):\n  if (args or kw) and (cls.__init__ is object.__init__):\n   raise TypeError(\"Initialization arguments are not supported\")\n  self = object.__new__(cls)\n  impl = _localimpl()\n  impl.localargs = (args, kw)\n  impl.locallock = RLock()\n  object.__setattr__(self, '_local__impl', impl)\n  \n  \n  \n  impl.create_dict()\n  return self\n  \n def __getattribute__(self, name):\n  with _patch(self):\n   return object.__getattribute__(self, name)\n   \n def __setattr__(self, name, value):\n  if name == '__dict__':\n   raise AttributeError(\n   \"%r object attribute '__dict__' is read-only\"\n   % self.__class__.__name__)\n  with _patch(self):\n   return object.__setattr__(self, name, value)\n   \n def __delattr__(self, name):\n  if name == '__dict__':\n   raise AttributeError(\n   \"%r object attribute '__dict__' is read-only\"\n   % self.__class__.__name__)\n  with _patch(self):\n   return object.__delattr__(self, name)\n   \n   \nfrom threading import current_thread, RLock\n"], "posixpath": [".py", "\"\"\n\nimport os\nimport sys\nimport stat\nimport genericpath\nfrom genericpath import *\n\n__all__ = [\"normcase\",\"isabs\",\"join\",\"splitdrive\",\"split\",\"splitext\",\n\"basename\",\"dirname\",\"commonprefix\",\"getsize\",\"getmtime\",\n\"getatime\",\"getctime\",\"islink\",\"exists\",\"lexists\",\"isdir\",\"isfile\",\n\"ismount\", \"expanduser\",\"expandvars\",\"normpath\",\"abspath\",\n\"samefile\",\"sameopenfile\",\"samestat\",\n\"curdir\",\"pardir\",\"sep\",\"pathsep\",\"defpath\",\"altsep\",\"extsep\",\n\"devnull\",\"realpath\",\"supports_unicode_filenames\",\"relpath\"]\n\n\n\ncurdir = '.'\npardir = '..'\nextsep = '.'\nsep = '/'\npathsep = ':'\ndefpath = ':/bin:/usr/bin'\naltsep = None\ndevnull = '/dev/null'\n\ndef _get_sep(path):\n if isinstance(path, bytes):\n  return b'/'\n else:\n  return '/'\n  \n  \n  \n  \n  \n  \ndef normcase(s):\n \"\"\n \n if not isinstance(s, (bytes, str)):\n  raise TypeError(\"normcase() argument must be str or bytes, \"\n  \"not '{}'\".format(s.__class__.__name__))\n return s\n \n \n \n \n \ndef isabs(s):\n \"\"\n sep = _get_sep(s)\n return s.startswith(sep)\n \n \n \n \n \n \ndef join(a, *p):\n \"\"\n sep = _get_sep(a)\n path = a\n try:\n  for b in p:\n   if b.startswith(sep):\n    path = b\n   elif not path or path.endswith(sep):\n    path += b\n   else:\n    path += sep + b\n except TypeError:\n  valid_types = all(isinstance(s, (str, bytes, bytearray))\n  for s in (a, ) + p)\n  if valid_types:\n  \n   raise TypeError(\"Can't mix strings and bytes in path \"\n   \"components.\") from None\n  raise\n return path\n \n \n \n \n \n \n \ndef split(p):\n \"\"\n sep = _get_sep(p)\n i = p.rfind(sep) + 1\n head, tail = p[:i], p[i:]\n if head and head != sep*len(head):\n  head = head.rstrip(sep)\n return head, tail\n \n \n \n \n \n \n \ndef splitext(p):\n if isinstance(p, bytes):\n  sep = b'/'\n  extsep = b'.'\n else:\n  sep = '/'\n  extsep = '.'\n return genericpath._splitext(p, sep, None, extsep)\nsplitext.__doc__ = genericpath._splitext.__doc__\n\n\n\n\ndef splitdrive(p):\n \"\"\n return p[:0], p\n \n \n \n \ndef basename(p):\n \"\"\n sep = _get_sep(p)\n i = p.rfind(sep) + 1\n return p[i:]\n \n \n \n \ndef dirname(p):\n \"\"\n sep = _get_sep(p)\n i = p.rfind(sep) + 1\n head = p[:i]\n if head and head != sep*len(head):\n  head = head.rstrip(sep)\n return head\n \n \n \n \n \ndef islink(path):\n \"\"\n try:\n  st = os.lstat(path)\n except (os.error, AttributeError):\n  return False\n return stat.S_ISLNK(st.st_mode)\n \n \n \ndef lexists(path):\n \"\"\n try:\n  os.lstat(path)\n except os.error:\n  return False\n return True\n \n \n \n \ndef samefile(f1, f2):\n \"\"\n s1 = os.stat(f1)\n s2 = os.stat(f2)\n return samestat(s1, s2)\n \n \n \n \n \ndef sameopenfile(fp1, fp2):\n \"\"\n s1 = os.fstat(fp1)\n s2 = os.fstat(fp2)\n return samestat(s1, s2)\n \n \n \n \n \ndef samestat(s1, s2):\n \"\"\n return s1.st_ino == s2.st_ino and s1.st_dev == s2.st_dev\n \n \n \n \n \ndef ismount(path):\n \"\"\n if islink(path):\n \n  return False\n try:\n  s1 = os.lstat(path)\n  if isinstance(path, bytes):\n   parent = join(path, b'..')\n  else:\n   parent = join(path, '..')\n  s2 = os.lstat(parent)\n except os.error:\n  return False \n dev1 = s1.st_dev\n dev2 = s2.st_dev\n if dev1 != dev2:\n  return True \n ino1 = s1.st_ino\n ino2 = s2.st_ino\n if ino1 == ino2:\n  return True \n return False\n \n \n \n \n \n \n \n \n \n \n \ndef expanduser(path):\n \"\"\n if isinstance(path, bytes):\n  tilde = b'~'\n else:\n  tilde = '~'\n if not path.startswith(tilde):\n  return path\n sep = _get_sep(path)\n i = path.find(sep, 1)\n if i < 0:\n  i = len(path)\n if i == 1:\n  if 'HOME' not in os.environ:\n   import pwd\n   userhome = pwd.getpwuid(os.getuid()).pw_dir\n  else:\n   userhome = os.environ['HOME']\n else:\n  import pwd\n  name = path[1:i]\n  if isinstance(name, bytes):\n   name = str(name, 'ASCII')\n  try:\n   pwent = pwd.getpwnam(name)\n  except KeyError:\n   return path\n  userhome = pwent.pw_dir\n if isinstance(path, bytes):\n  userhome = os.fsencode(userhome)\n  root = b'/'\n else:\n  root = '/'\n userhome = userhome.rstrip(root)\n return (userhome + path[i:]) or root\n \n \n \n \n \n \n_varprog = None\n_varprogb = None\n\ndef expandvars(path):\n \"\"\n global _varprog, _varprogb\n if isinstance(path, bytes):\n  if b'$' not in path:\n   return path\n  if not _varprogb:\n   import re\n   _varprogb = re.compile(br'\\$(\\w+|\\{[^}]*\\})', re.ASCII)\n  search = _varprogb.search\n  start = b'{'\n  end = b'}'\n else:\n  if '$' not in path:\n   return path\n  if not _varprog:\n   import re\n   _varprog = re.compile(r'\\$(\\w+|\\{[^}]*\\})', re.ASCII)\n  search = _varprog.search\n  start = '{'\n  end = '}'\n i = 0\n while True:\n  m = search(path, i)\n  if not m:\n   break\n  i, j = m.span(0)\n  name = m.group(1)\n  if name.startswith(start) and name.endswith(end):\n   name = name[1:-1]\n  if isinstance(name, bytes):\n   name = str(name, 'ASCII')\n  if name in os.environ:\n   tail = path[j:]\n   value = os.environ[name]\n   if isinstance(path, bytes):\n    value = value.encode('ASCII')\n   path = path[:i] + value\n   i = len(path)\n   path += tail\n  else:\n   i = j\n return path\n \n \n \n \n \n \ndef normpath(path):\n \"\"\n if isinstance(path, bytes):\n  sep = b'/'\n  empty = b''\n  dot = b'.'\n  dotdot = b'..'\n else:\n  sep = '/'\n  empty = ''\n  dot = '.'\n  dotdot = '..'\n if path == empty:\n  return dot\n initial_slashes = path.startswith(sep)\n \n \n if (initial_slashes and\n path.startswith(sep*2) and not path.startswith(sep*3)):\n  initial_slashes = 2\n comps = path.split(sep)\n new_comps = []\n for comp in comps:\n  if comp in (empty, dot):\n   continue\n  if (comp != dotdot or (not initial_slashes and not new_comps) or\n  (new_comps and new_comps[-1] == dotdot)):\n   new_comps.append(comp)\n  elif new_comps:\n   new_comps.pop()\n comps = new_comps\n path = sep.join(comps)\n if initial_slashes:\n  path = sep*initial_slashes + path\n return path or dot\n \n \ndef abspath(path):\n \"\"\n if not isabs(path):\n  if isinstance(path, bytes):\n   cwd = os.getcwdb()\n  else:\n   cwd = os.getcwd()\n  path = join(cwd, path)\n return normpath(path)\n \n \n \n \n \ndef realpath(filename):\n \"\"\n path, ok = _joinrealpath(filename[:0], filename, {})\n return abspath(path)\n \n \n \ndef _joinrealpath(path, rest, seen):\n if isinstance(path, bytes):\n  sep = b'/'\n  curdir = b'.'\n  pardir = b'..'\n else:\n  sep = '/'\n  curdir = '.'\n  pardir = '..'\n  \n if isabs(rest):\n  rest = rest[1:]\n  path = sep\n  \n while rest:\n  name, _, rest = rest.partition(sep)\n  if not name or name == curdir:\n  \n   continue\n  if name == pardir:\n  \n   if path:\n    path, name = split(path)\n    if name == pardir:\n     path = join(path, pardir, pardir)\n   else:\n    path = pardir\n   continue\n  newpath = join(path, name)\n  if not islink(newpath):\n   path = newpath\n   continue\n   \n  if newpath in seen:\n  \n   path = seen[newpath]\n   if path is not None:\n   \n    continue\n    \n    \n   return join(newpath, rest), False\n  seen[newpath] = None \n  path, ok = _joinrealpath(path, os.readlink(newpath), seen)\n  if not ok:\n   return join(path, rest), False\n  seen[newpath] = path \n  \n return path, True\n \n \nsupports_unicode_filenames = (sys.platform == 'darwin')\n\ndef relpath(path, start=None):\n \"\"\n \n if not path:\n  raise ValueError(\"no path specified\")\n  \n if isinstance(path, bytes):\n  curdir = b'.'\n  sep = b'/'\n  pardir = b'..'\n else:\n  curdir = '.'\n  sep = '/'\n  pardir = '..'\n  \n if start is None:\n  start = curdir\n  \n start_list = [x for x in abspath(start).split(sep) if x]\n path_list = [x for x in abspath(path).split(sep) if x]\n \n \n i = len(commonprefix([start_list, path_list]))\n \n rel_list = [pardir] * (len(start_list)-i) + path_list[i:]\n if not rel_list:\n  return curdir\n return join(*rel_list)\n"], "imp": [".py", "\"\"\n\nfrom _imp import (lock_held, acquire_lock, release_lock,\nget_frozen_object, is_frozen_package,\ninit_builtin, init_frozen, is_builtin, is_frozen,\n_fix_co_filename)\ntry:\n from _imp import load_dynamic\nexcept ImportError:\n\n load_dynamic = None\n \n \nfrom importlib._bootstrap import new_module\nfrom importlib._bootstrap import cache_from_source, source_from_cache\n\n\nfrom importlib import _bootstrap\n\n\nimport importlib.machinery as machinery\nimport os\nimport sys\nimport tokenize\nimport warnings\n\n\n\nSEARCH_ERROR = 0\nPY_SOURCE = 1\nPY_COMPILED = 2\nC_EXTENSION = 3\nPY_RESOURCE = 4\nPKG_DIRECTORY = 5\nC_BUILTIN = 6\nPY_FROZEN = 7\nPY_CODERESOURCE = 8\nIMP_HOOK = 9\n\n\ndef get_magic():\n \"\"\n return _bootstrap._MAGIC_BYTES\n \n \ndef get_tag():\n \"\"\n return sys.implementation.cache_tag\n \n \ndef get_suffixes():\n warnings.warn('imp.get_suffixes() is deprecated; use the constants '\n 'defined on importlib.machinery instead',\n DeprecationWarning, 2)\n extensions = [(s, 'rb', C_EXTENSION) for s in machinery.EXTENSION_SUFFIXES]\n source = [(s, 'U', PY_SOURCE) for s in machinery.SOURCE_SUFFIXES]\n bytecode = [(s, 'rb', PY_COMPILED) for s in machinery.BYTECODE_SUFFIXES]\n \n return extensions + source + bytecode\n \n \nclass NullImporter:\n\n \"\"\n \n def __init__(self, path):\n  if path == '':\n   raise ImportError('empty pathname', path='')\n  elif os.path.isdir(path):\n   raise ImportError('existing directory', path=path)\n   \n def find_module(self, fullname):\n  \"\"\n  return None\n  \n  \nclass _HackedGetData:\n\n \"\"\n \n def __init__(self, fullname, path, file=None):\n  super().__init__(fullname, path)\n  self.file = file\n  \n def get_data(self, path):\n  \"\"\n  if self.file and path == self.path:\n   if not self.file.closed:\n    file = self.file\n   else:\n    self.file = file = open(self.path, 'r')\n    \n   with file:\n   \n   \n   \n   \n   \n    return file.read()\n  else:\n   return super().get_data(path)\n   \n   \nclass _LoadSourceCompatibility(_HackedGetData, _bootstrap.SourceFileLoader):\n\n \"\"\n \n pass\n \ndef load_source(name, pathname, file=None):\n msg = ('imp.load_source() is deprecated; use '\n 'importlib.machinery.SourceFileLoader(name, pathname).load_module()'\n ' instead')\n warnings.warn(msg, DeprecationWarning, 2)\n _LoadSourceCompatibility(name, pathname, file).load_module(name)\n module = sys.modules[name]\n \n \n module.__loader__ = _bootstrap.SourceFileLoader(name, pathname)\n return module\n \n \nclass _LoadCompiledCompatibility(_HackedGetData,\n_bootstrap.SourcelessFileLoader):\n\n \"\"\n \n pass\n \ndef load_compiled(name, pathname, file=None):\n msg = ('imp.load_compiled() is deprecated; use '\n 'importlib.machinery.SourcelessFileLoader(name, pathname).'\n 'load_module() instead ')\n warnings.warn(msg, DeprecationWarning, 2)\n _LoadCompiledCompatibility(name, pathname, file).load_module(name)\n module = sys.modules[name]\n \n \n module.__loader__ = _bootstrap.SourcelessFileLoader(name, pathname)\n return module\n \n \ndef load_package(name, path):\n msg = ('imp.load_package() is deprecated; use either '\n 'importlib.machinery.SourceFileLoader() or '\n 'importlib.machinery.SourcelessFileLoader() instead')\n warnings.warn(msg, DeprecationWarning, 2)\n if os.path.isdir(path):\n  extensions = (machinery.SOURCE_SUFFIXES[:] +\n  machinery.BYTECODE_SUFFIXES[:])\n  for extension in extensions:\n   path = os.path.join(path, '__init__'+extension)\n   if os.path.exists(path):\n    break\n  else:\n   raise ValueError('{!r} is not a package'.format(path))\n return _bootstrap.SourceFileLoader(name, path).load_module(name)\n \n \ndef load_module(name, file, filename, details):\n \"\"\n suffix, mode, type_ = details\n with warnings.catch_warnings():\n  warnings.simplefilter('ignore')\n  if mode and (not mode.startswith(('r', 'U')) or '+' in mode):\n   raise ValueError('invalid file open mode {!r}'.format(mode))\n  elif file is None and type_ in {PY_SOURCE, PY_COMPILED}:\n   msg = 'file object required for import (type code {})'.format(type_)\n   raise ValueError(msg)\n  elif type_ == PY_SOURCE:\n   return load_source(name, filename, file)\n  elif type_ == PY_COMPILED:\n   return load_compiled(name, filename, file)\n  elif type_ == C_EXTENSION and load_dynamic is not None:\n   if file is None:\n    with open(filename, 'rb') as opened_file:\n     return load_dynamic(name, filename, opened_file)\n   else:\n    return load_dynamic(name, filename, file)\n  elif type_ == PKG_DIRECTORY:\n   return load_package(name, filename)\n  elif type_ == C_BUILTIN:\n   return init_builtin(name)\n  elif type_ == PY_FROZEN:\n   return init_frozen(name)\n  else:\n   msg = \"Don't know how to import {} (type code {})\".format(name, type_)\n   raise ImportError(msg, name=name)\n   \n   \ndef find_module(name, path=None):\n \"\"\n if not isinstance(name, str):\n  raise TypeError(\"'name' must be a str, not {}\".format(type(name)))\n elif not isinstance(path, (type(None), list)):\n \n  raise RuntimeError(\"'list' must be None or a list, \"\n  \"not {}\".format(type(name)))\n  \n if path is None:\n  if is_builtin(name):\n   return None, None, ('', '', C_BUILTIN)\n  elif is_frozen(name):\n   return None, None, ('', '', PY_FROZEN)\n  else:\n   path = sys.path\n   \n for entry in path:\n  package_directory = os.path.join(entry, name)\n  for suffix in ['.py', machinery.BYTECODE_SUFFIXES[0]]:\n   package_file_name = '__init__' + suffix\n   file_path = os.path.join(package_directory, package_file_name)\n   if os.path.isfile(file_path):\n    return None, package_directory, ('', '', PKG_DIRECTORY)\n  with warnings.catch_warnings():\n   warnings.simplefilter('ignore')\n   for suffix, mode, type_ in get_suffixes():\n    file_name = name + suffix\n    file_path = os.path.join(entry, file_name)\n    if os.path.isfile(file_path):\n     break\n   else:\n    continue\n   break \n else:\n  raise ImportError(_bootstrap._ERR_MSG.format(name), name=name)\n  \n encoding = None\n if mode == 'U':\n  with open(file_path, 'rb') as file:\n   encoding = tokenize.detect_encoding(file.readline)[0]\n file = open(file_path, mode, encoding=encoding)\n return file, file_path, (suffix, mode, type_)\n \n \n_RELOADING = {}\n\ndef reload(module):\n \"\"\n if not module or type(module) != type(sys):\n  raise TypeError(\"reload() argument must be module\")\n name = module.__name__\n if name not in sys.modules:\n  msg = \"module {} not in sys.modules\"\n  raise ImportError(msg.format(name), name=name)\n if name in _RELOADING:\n  return _RELOADING[name]\n _RELOADING[name] = module\n try:\n  parent_name = name.rpartition('.')[0]\n  if parent_name and parent_name not in sys.modules:\n   msg = \"parent {!r} not in sys.modules\"\n   raise ImportError(msg.format(parent_name), name=parent_name)\n  module.__loader__.load_module(name)\n  \n  return sys.modules[module.__name__]\n finally:\n  try:\n   del _RELOADING[name]\n  except KeyError:\n   pass\n"], "errno": [".py", "\"\"\n\nerrorcode= {1: 'EPERM', 2: 'ENOENT', 3: 'ESRCH', 4: 'EINTR', 5: 'EIO', \n6: 'ENXIO', 7: 'E2BIG', 8: 'ENOEXEC', 9: 'EBADF', 10: 'ECHILD', 11: 'EAGAIN', \n12: 'ENOMEM', 13: 'EACCES', 14: 'EFAULT', 15: 'ENOTBLK', 16: 'EBUSY', \n17: 'EEXIST', 18: 'EXDEV', 19: 'ENODEV', 20: 'ENOTDIR', 21: 'EISDIR', \n22: 'EINVAL', 23: 'ENFILE', 24: 'EMFILE', 25: 'ENOTTY', 26: 'ETXTBSY', \n27: 'EFBIG', 28: 'ENOSPC', 29: 'ESPIPE', 30: 'EROFS', 31: 'EMLINK', \n32: 'EPIPE', 33: 'EDOM', 34: 'ERANGE', 35: 'EDEADLOCK', 36: 'ENAMETOOLONG', \n37: 'ENOLCK', 38: 'ENOSYS', 39: 'ENOTEMPTY', 40: 'ELOOP', 42: 'ENOMSG', \n43: 'EIDRM', 44: 'ECHRNG', 45: 'EL2NSYNC', 46: 'EL3HLT', 47: 'EL3RST', \n48: 'ELNRNG', 49: 'EUNATCH', 50: 'ENOCSI', 51: 'EL2HLT', 52: 'EBADE', \n53: 'EBADR', 54: 'EXFULL', 55: 'ENOANO', 56: 'EBADRQC', 57: 'EBADSLT', \n59: 'EBFONT', 60: 'ENOSTR', 61: 'ENODATA', 62: 'ETIME', 63: 'ENOSR', \n64: 'ENONET', 65: 'ENOPKG', 66: 'EREMOTE', 67: 'ENOLINK', 68: 'EADV', \n69: 'ESRMNT', 70: 'ECOMM', 71: 'EPROTO', 72: 'EMULTIHOP', 73: 'EDOTDOT', \n74: 'EBADMSG', 75: 'EOVERFLOW', 76: 'ENOTUNIQ', 77: 'EBADFD', 78: 'EREMCHG', \n79: 'ELIBACC', 80: 'ELIBBAD', 81: 'ELIBSCN', 82: 'ELIBMAX', 83: 'ELIBEXEC', \n84: 'EILSEQ', 85: 'ERESTART', 86: 'ESTRPIPE', 87: 'EUSERS', 88: 'ENOTSOCK', \n89: 'EDESTADDRREQ', 90: 'EMSGSIZE', 91: 'EPROTOTYPE', 92: 'ENOPROTOOPT', \n93: 'EPROTONOSUPPORT', 94: 'ESOCKTNOSUPPORT', 95: 'ENOTSUP', \n96: 'EPFNOSUPPORT', 97: 'EAFNOSUPPORT', 98: 'EADDRINUSE', \n99: 'EADDRNOTAVAIL', 100: 'ENETDOWN', 101: 'ENETUNREACH', 102: 'ENETRESET', \n103: 'ECONNABORTED', 104: 'ECONNRESET', 105: 'ENOBUFS', 106: 'EISCONN', \n107: 'ENOTCONN', 108: 'ESHUTDOWN', 109: 'ETOOMANYREFS', 110: 'ETIMEDOUT', \n111: 'ECONNREFUSED', 112: 'EHOSTDOWN', 113: 'EHOSTUNREACH', 114: 'EALREADY', \n115: 'EINPROGRESS', 116: 'ESTALE', 117: 'EUCLEAN', 118: 'ENOTNAM', \n119: 'ENAVAIL', 120: 'EISNAM', 121: 'EREMOTEIO', 122: 'EDQUOT', \n123: 'ENOMEDIUM', 124: 'EMEDIUMTYPE', 125: 'ECANCELED', 126: 'ENOKEY', \n127: 'EKEYEXPIRED', 128: 'EKEYREVOKED', 129: 'EKEYREJECTED', \n130: 'EOWNERDEAD', 131: 'ENOTRECOVERABLE', 132: 'ERFKILL'}\n\nEPERM=1\nENOENT=2\nESRCH=3\nEINTR=4\nEIO=5\nENXIO=6\nE2BIG=7\nENOEXEC=8\nEBADF=9\nECHILD=10\nEAGAIN=11\nENOMEM=12\nEACCES=13\nEFAULT=14\nENOTBLK=15\nEBUSY=16\nEEXIST=17\nEXDEV=18\nENODEV=19\nENOTDIR=20\nEISDIR=21\nEINVAL=22\nENFILE=23\nEMFILE=24\nENOTTY=25\nETXTBSY=26\nEFBIG=27\nENOSPC=28\nESPIPE=29\nEROFS=30\nEMLINK=31\nEPIPE=32\nEDOM=33\nERANGE=34\nEDEADLOCK=35\nENAMETOOLONG=36\nENOLCK=37\nENOSYS=38\nENOTEMPTY=39\nELOOP=40\nENOMSG=42\nEIDRM=43\nECHRNG=44\nEL2NSYNC=45\nEL3HLT=46\nEL3RST=47\nELNRNG=48\nEUNATCH=49\nENOCSI=50\nEL2HLT=51\nEBADE=52\nEBADR=53\nEXFULL=54\nENOANO=55\nEBADRQC=56\nEBADSLT=57\nEBFONT=59\nENOSTR=60\nENODATA=61\nETIME=62\nENOSR=63\nENONET=64\nENOPKG=65\nEREMOTE=66\nENOLINK=67\nEADV=68\nESRMNT=69\nECOMM=70\nEPROTO=71\nEMULTIHOP=72\nEDOTDOT=73\nEBADMSG=74\nEOVERFLOW=75\nENOTUNIQ=76\nEBADFD=77\nEREMCHG=78\nELIBACC=79\nELIBBAD=80\nELIBSCN=81\nELIBMAX=82\nELIBEXEC=83\nEILSEQ=84\nERESTART=85\nESTRPIPE=86\nEUSERS=87\nENOTSOCK=88\nEDESTADDRREQ=89\nEMSGSIZE=90\nEPROTOTYPE=91\nENOPROTOOPT=92\nEPROTONOSUPPORT=93\nESOCKTNOSUPPORT=94\nENOTSUP=95\nEPFNOSUPPORT=96\nEAFNOSUPPORT=97\nEADDRINUSE=98\nEADDRNOTAVAIL=99\nENETDOWN=100\nENETUNREACH=101\nENETRESET=102\nECONNABORTED=103\nECONNRESET=104\nENOBUFS=105\nEISCONN=106\nENOTCONN=107\nESHUTDOWN=108\nETOOMANYREFS=109\nETIMEDOUT=110\nECONNREFUSED=111\nEHOSTDOWN=112\nEHOSTUNREACH=113\nEALREADY=114\nEINPROGRESS=115\nESTALE=116\nEUCLEAN=117\nENOTNAM=118\nENAVAIL=119\nEISNAM=120\nEREMOTEIO=121\nEDQUOT=122\nENOMEDIUM=123\nEMEDIUMTYPE=124\nECANCELED=125\nENOKEY=126\nEKEYEXPIRED=127\nEKEYREVOKED=128\nEKEYREJECTED=129\nEOWNERDEAD=130\nENOTRECOVERABLE=131\nERFKILL=132\n"], "_socket": [".py", "\"\"\n\n\nAF_APPLETALK = 16\n\nAF_DECnet = 12\n\nAF_INET = 2\n\nAF_INET6 = 23\n\nAF_IPX = 6\n\nAF_IRDA = 26\n\nAF_SNA = 11\n\nAF_UNSPEC = 0\n\nAI_ADDRCONFIG = 1024\n\nAI_ALL = 256\n\nAI_CANONNAME = 2\n\nAI_NUMERICHOST = 4\n\nAI_NUMERICSERV = 8\n\nAI_PASSIVE = 1\n\nAI_V4MAPPED = 2048\n\nCAPI = '<capsule object \"_socket.CAPI\" at 0x00BC4F38>'\n\nEAI_AGAIN = 11002\n\nEAI_BADFLAGS = 10022\n\nEAI_FAIL = 11003\n\nEAI_FAMILY = 10047\n\nEAI_MEMORY = 8\n\nEAI_NODATA = 11001\n\nEAI_NONAME = 11001\n\nEAI_SERVICE = 10109\n\nEAI_SOCKTYPE = 10044\n\nINADDR_ALLHOSTS_GROUP = -536870911\n\nINADDR_ANY = 0\n\nINADDR_BROADCAST = -1\n\nINADDR_LOOPBACK = 2130706433\n\nINADDR_MAX_LOCAL_GROUP = -536870657\n\nINADDR_NONE = -1\n\nINADDR_UNSPEC_GROUP = -536870912\n\nIPPORT_RESERVED = 1024\n\nIPPORT_USERRESERVED = 5000\n\nIPPROTO_ICMP = 1\n\nIPPROTO_IP = 0\n\nIPPROTO_RAW = 255\n\nIPPROTO_TCP = 6\n\nIPPROTO_UDP = 17\n\nIPV6_CHECKSUM = 26\n\nIPV6_DONTFRAG = 14\n\nIPV6_HOPLIMIT = 21\n\nIPV6_HOPOPTS = 1\n\nIPV6_JOIN_GROUP = 12\n\nIPV6_LEAVE_GROUP = 13\n\nIPV6_MULTICAST_HOPS = 10\n\nIPV6_MULTICAST_IF = 9\n\nIPV6_MULTICAST_LOOP = 11\n\nIPV6_PKTINFO = 19\n\nIPV6_RECVRTHDR = 38\n\nIPV6_RECVTCLASS = 40\n\nIPV6_RTHDR = 32\n\nIPV6_TCLASS = 39\n\nIPV6_UNICAST_HOPS = 4\n\nIPV6_V6ONLY = 27\n\nIP_ADD_MEMBERSHIP = 12\n\nIP_DROP_MEMBERSHIP = 13\n\nIP_HDRINCL = 2\n\nIP_MULTICAST_IF = 9\n\nIP_MULTICAST_LOOP = 11\n\nIP_MULTICAST_TTL = 10\n\nIP_OPTIONS = 1\n\nIP_RECVDSTADDR = 25\n\nIP_TOS = 3\n\nIP_TTL = 4\n\nMSG_BCAST = 1024\n\nMSG_CTRUNC = 512\n\nMSG_DONTROUTE = 4\n\nMSG_MCAST = 2048\n\nMSG_OOB = 1\n\nMSG_PEEK = 2\n\nMSG_TRUNC = 256\n\nNI_DGRAM = 16\n\nNI_MAXHOST = 1025\n\nNI_MAXSERV = 32\n\nNI_NAMEREQD = 4\n\nNI_NOFQDN = 1\n\nNI_NUMERICHOST = 2\n\nNI_NUMERICSERV = 8\n\nRCVALL_MAX = 3\n\nRCVALL_OFF = 0\n\nRCVALL_ON = 1\n\nRCVALL_SOCKETLEVELONLY = 2\n\nSHUT_RD = 0\n\nSHUT_RDWR = 2\n\nSHUT_WR = 1\n\nSIO_KEEPALIVE_VALS = 2550136836\n\nSIO_RCVALL = 2550136833\n\nSOCK_DGRAM = 2\n\nSOCK_RAW = 3\n\nSOCK_RDM = 4\n\nSOCK_SEQPACKET = 5\n\nSOCK_STREAM = 1\n\nSOL_IP = 0\n\nSOL_SOCKET = 65535\n\nSOL_TCP = 6\n\nSOL_UDP = 17\n\nSOMAXCONN = 2147483647\n\nSO_ACCEPTCONN = 2\n\nSO_BROADCAST = 32\n\nSO_DEBUG = 1\n\nSO_DONTROUTE = 16\n\nSO_ERROR = 4103\n\nSO_EXCLUSIVEADDRUSE = -5\n\nSO_KEEPALIVE = 8\n\nSO_LINGER = 128\n\nSO_OOBINLINE = 256\n\nSO_RCVBUF = 4098\n\nSO_RCVLOWAT = 4100\n\nSO_RCVTIMEO = 4102\n\nSO_REUSEADDR = 4\n\nSO_SNDBUF = 4097\n\nSO_SNDLOWAT = 4099\n\nSO_SNDTIMEO = 4101\n\nSO_TYPE = 4104\n\nSO_USELOOPBACK = 64\n\nclass SocketType:\n pass\n \nTCP_MAXSEG = 4\n\nTCP_NODELAY = 1\n\n__loader__ = '<_frozen_importlib.ExtensionFileLoader object at 0x00CA2D90>'\n\ndef dup(*args,**kw):\n \"\"\n pass\n \nclass error:\n pass\n \nclass gaierror:\n pass\n \ndef getaddrinfo(*args,**kw):\n \"\"\n pass\n \ndef getdefaulttimeout(*args,**kw):\n \"\"\n pass\n \ndef gethostbyaddr(*args,**kw):\n \"\"\n pass\n \ndef gethostbyname(*args,**kw):\n \"\"\n pass\n \ndef gethostbyname_ex(*args,**kw):\n \"\"\n pass\n \ndef gethostname(*args,**kw):\n \"\"\n pass\n \ndef getnameinfo(*args,**kw):\n \"\"\n pass\n \ndef getprotobyname(*args,**kw):\n \"\"\n pass\n \ndef getservbyname(*args,**kw):\n \"\"\n pass\n \ndef getservbyport(*args,**kw):\n \"\"\n pass\n \nhas_ipv6 = True\n\nclass herror:\n pass\n \ndef htonl(*args,**kw):\n \"\"\n pass\n \ndef htons(*args,**kw):\n \"\"\n pass\n \ndef inet_aton(*args,**kw):\n \"\"\n pass\n \ndef inet_ntoa(*args,**kw):\n \"\"\n pass\n \ndef ntohl(*args,**kw):\n \"\"\n pass\n \ndef ntohs(*args,**kw):\n \"\"\n pass\n \ndef setdefaulttimeout(*args,**kw):\n \"\"\n pass\n \nclass socket:\n def __init__(self,*args,**kw):\n  pass\n def bind(self,*args,**kw):\n  pass\n def close(self):\n  pass\n  \nclass timeout:\n pass\n"], "binascii": [".py", "\"\"\n\n\n\nclass Error(Exception):\n pass\n \nclass Done(Exception):\n pass\n \nclass Incomplete(Exception):\n pass\n \ndef a2b_uu(s):\n if not s:\n  return ''\n  \n length = (ord(s[0]) - 0x20) % 64\n \n def quadruplets_gen(s):\n  while s:\n   try:\n    yield ord(s[0]), ord(s[1]), ord(s[2]), ord(s[3])\n   except IndexError:\n    s += '   '\n    yield ord(s[0]), ord(s[1]), ord(s[2]), ord(s[3])\n    return\n   s = s[4:]\n   \n try:\n  result = [''.join(\n  [chr((A - 0x20) << 2 | (((B - 0x20) >> 4) & 0x3)),\n  chr(((B - 0x20) & 0xf) << 4 | (((C - 0x20) >> 2) & 0xf)),\n  chr(((C - 0x20) & 0x3) << 6 | ((D - 0x20) & 0x3f))\n  ]) for A, B, C, D in quadruplets_gen(s[1:].rstrip())]\n except ValueError:\n  raise Error('Illegal char')\n result = ''.join(result)\n trailingdata = result[length:]\n if trailingdata.strip('\\x00'):\n  raise Error('Trailing garbage')\n result = result[:length]\n if len(result) < length:\n  result += ((length - len(result)) * '\\x00')\n return bytes(result, __BRYTHON__.charset)\n \n \ndef b2a_uu(s):\n length = len(s)\n if length > 45:\n  raise Error('At most 45 bytes at once')\n  \n def triples_gen(s):\n  while s:\n   try:\n    yield ord(s[0]), ord(s[1]), ord(s[2])\n   except IndexError:\n    s += '\\0\\0'\n    yield ord(s[0]), ord(s[1]), ord(s[2])\n    return\n   s = s[3:]\n   \n result = [''.join(\n [chr(0x20 + (( A >> 2 ) & 0x3F)),\n chr(0x20 + (((A << 4) | ((B >> 4) & 0xF)) & 0x3F)),\n chr(0x20 + (((B << 2) | ((C >> 6) & 0x3)) & 0x3F)),\n chr(0x20 + (( C ) & 0x3F))])\n for A, B, C in triples_gen(s)]\n return chr(ord(' ') + (length & 0o77)) + ''.join(result) + '\\n'\n \n \ntable_a2b_base64 = {\n'A': 0,\n'B': 1,\n'C': 2,\n'D': 3,\n'E': 4,\n'F': 5,\n'G': 6,\n'H': 7,\n'I': 8,\n'J': 9,\n'K': 10,\n'L': 11,\n'M': 12,\n'N': 13,\n'O': 14,\n'P': 15,\n'Q': 16,\n'R': 17,\n'S': 18,\n'T': 19,\n'U': 20,\n'V': 21,\n'W': 22,\n'X': 23,\n'Y': 24,\n'Z': 25,\n'a': 26,\n'b': 27,\n'c': 28,\n'd': 29,\n'e': 30,\n'f': 31,\n'g': 32,\n'h': 33,\n'i': 34,\n'j': 35,\n'k': 36,\n'l': 37,\n'm': 38,\n'n': 39,\n'o': 40,\n'p': 41,\n'q': 42,\n'r': 43,\n's': 44,\n't': 45,\n'u': 46,\n'v': 47,\n'w': 48,\n'x': 49,\n'y': 50,\n'z': 51,\n'0': 52,\n'1': 53,\n'2': 54,\n'3': 55,\n'4': 56,\n'5': 57,\n'6': 58,\n'7': 59,\n'8': 60,\n'9': 61,\n'+': 62,\n'/': 63,\n'=': 0,\n}\n\n\ndef a2b_base64(s):\n if not isinstance(s, (str, bytes)):\n  raise TypeError(\"expected string, got %r\" % (s,))\n s = s.rstrip()\n \n \n \n def next_valid_char(s, pos):\n  for i in range(pos + 1, len(s)):\n   c = s[i]\n   if c < '\\x7f':\n    try:\n     table_a2b_base64[c]\n     return c\n    except KeyError:\n     pass\n  return None\n  \n quad_pos = 0\n leftbits = 0\n leftchar = 0\n res = []\n for i, c in enumerate(s):\n  if isinstance(c, int):\n   c = chr(c)\n  if c > '\\x7f' or c == '\\n' or c == '\\r' or c == ' ':\n   continue\n  if c == '=':\n   if quad_pos < 2 or (quad_pos == 2 and next_valid_char(s, i) != '='):\n    continue\n   else:\n    leftbits = 0\n    break\n  try:\n   next_c = table_a2b_base64[c]\n  except KeyError:\n   continue\n  quad_pos = (quad_pos + 1) & 0x03\n  leftchar = (leftchar << 6) | next_c\n  leftbits += 6\n  if leftbits >= 8:\n   leftbits -= 8\n   res.append((leftchar >> leftbits & 0xff))\n   leftchar &= ((1 << leftbits) - 1)\n if leftbits != 0:\n  raise Error('Incorrect padding')\n  \n return bytes(''.join([chr(i) for i in res]),__BRYTHON__.charset)\n \ntable_b2a_base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" \"0123456789+/\"\n\ndef b2a_base64(s):\n length = len(s)\n final_length = length % 3\n \n def triples_gen(s):\n  while s:\n   try:\n    yield s[0], s[1], s[2]\n   except IndexError:\n    s += b'\\0\\0'\n    yield s[0], s[1], s[2]\n    return\n   s = s[3:]\n   \n a = triples_gen(s[ :length - final_length])\n \n result = [''.join(\n [table_b2a_base64[( A >> 2 ) & 0x3F],\n table_b2a_base64[((A << 4) | ((B >> 4) & 0xF)) & 0x3F],\n table_b2a_base64[((B << 2) | ((C >> 6) & 0x3)) & 0x3F],\n table_b2a_base64[( C ) & 0x3F]])\n for A, B, C in a]\n \n final = s[length - final_length:]\n if final_length == 0:\n  snippet = ''\n elif final_length == 1:\n  a = ord(final[0])\n  snippet = table_b2a_base64[(a >> 2 ) & 0x3F] + table_b2a_base64[(a << 4 ) & 0x3F] + '=='\n else:\n  a = ord(final[0])\n  b = ord(final[1])\n  snippet = table_b2a_base64[(a >> 2) & 0x3F] + table_b2a_base64[((a << 4) | (b >> 4) & 0xF) & 0x3F] + table_b2a_base64[(b << 2) & 0x3F] + '='\n  \n return bytes(''.join(result) + snippet + '\\n',__BRYTHON__.charset)\n \ndef a2b_qp(s, header=False):\n inp = 0\n odata = []\n while inp < len(s):\n  if s[inp] == '=':\n   inp += 1\n   if inp >= len(s):\n    break\n    \n   if (s[inp] == '\\n') or (s[inp] == '\\r'):\n    if s[inp] != '\\n':\n     while inp < len(s) and s[inp] != '\\n':\n      inp += 1\n    if inp < len(s):\n     inp += 1\n   elif s[inp] == '=':\n   \n    odata.append('=')\n    inp += 1\n   elif s[inp] in hex_numbers and s[inp + 1] in hex_numbers:\n    ch = chr(int(s[inp:inp+2], 16))\n    inp += 2\n    odata.append(ch)\n   else:\n    odata.append('=')\n  elif header and s[inp] == '_':\n   odata.append(' ')\n   inp += 1\n  else:\n   odata.append(s[inp])\n   inp += 1\n return bytes(''.join(odata), __BRYTHON__.charset)\n \ndef b2a_qp(data, quotetabs=False, istext=True, header=False):\n \"\"\n MAXLINESIZE = 76\n \n \n lf = data.find('\\n')\n crlf = lf > 0 and data[lf-1] == '\\r'\n \n inp = 0\n linelen = 0\n odata = []\n while inp < len(data):\n  c = data[inp]\n  if (c > '~' or\n  c == '=' or\n  (header and c == '_') or\n  (c == '.' and linelen == 0 and (inp+1 == len(data) or\n  data[inp+1] == '\\n' or\n  data[inp+1] == '\\r')) or\n  (not istext and (c == '\\r' or c == '\\n')) or\n  ((c == '\\t' or c == ' ') and (inp + 1 == len(data))) or\n  (c <= ' ' and c != '\\r' and c != '\\n' and\n  (quotetabs or (not quotetabs and (c != '\\t' and c != ' '))))):\n   linelen += 3\n   if linelen >= MAXLINESIZE:\n    odata.append('=')\n    if crlf: odata.append('\\r')\n    odata.append('\\n')\n    linelen = 3\n   odata.append('=' + two_hex_digits(ord(c)))\n   inp += 1\n  else:\n   if (istext and\n   (c == '\\n' or (inp+1 < len(data) and c == '\\r' and\n   data[inp+1] == '\\n'))):\n    linelen = 0\n    \n    if (len(odata) > 0 and\n    (odata[-1] == ' ' or odata[-1] == '\\t')):\n     ch = ord(odata[-1])\n     odata[-1] = '='\n     odata.append(two_hex_digits(ch))\n     \n    if crlf: odata.append('\\r')\n    odata.append('\\n')\n    if c == '\\r':\n     inp += 2\n    else:\n     inp += 1\n   else:\n    if (inp + 1 < len(data) and\n    data[inp+1] != '\\n' and\n    (linelen + 1) >= MAXLINESIZE):\n     odata.append('=')\n     if crlf: odata.append('\\r')\n     odata.append('\\n')\n     linelen = 0\n     \n    linelen += 1\n    if header and c == ' ':\n     c = '_'\n    odata.append(c)\n    inp += 1\n return ''.join(odata)\n \nhex_numbers = '0123456789ABCDEF'\ndef hex(n):\n if n == 0:\n  return '0'\n  \n if n < 0:\n  n = -n\n  sign = '-'\n else:\n  sign = ''\n arr = []\n \n def hex_gen(n):\n  \"\"\n  while n:\n   yield n % 0x10\n   n = n / 0x10\n   \n for nibble in hex_gen(n):\n  arr = [hex_numbers[nibble]] + arr\n return sign + ''.join(arr)\n \ndef two_hex_digits(n):\n return hex_numbers[n / 0x10] + hex_numbers[n % 0x10]\n \n \ndef strhex_to_int(s):\n i = 0\n for c in s:\n  i = i * 0x10 + hex_numbers.index(c)\n return i\n \nhqx_encoding = '!\"#$%&\\'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr'\n\nDONE = 0x7f\nSKIP = 0x7e\nFAIL = 0x7d\n\ntable_a2b_hqx = [\n\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\n\nFAIL, FAIL, SKIP, FAIL, FAIL, SKIP, FAIL, FAIL,\n\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\n\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\n\nFAIL, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,\n\n0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, FAIL, FAIL,\n\n0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, FAIL,\n\n0x14, 0x15, DONE, FAIL, FAIL, FAIL, FAIL, FAIL,\n\n0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,\n\n0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, FAIL,\n\n0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, FAIL,\n\n0x2C, 0x2D, 0x2E, 0x2F, FAIL, FAIL, FAIL, FAIL,\n\n0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, FAIL,\n\n0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, FAIL, FAIL,\n\n0x3D, 0x3E, 0x3F, FAIL, FAIL, FAIL, FAIL, FAIL,\n\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\nFAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL, FAIL,\n]\n\ndef a2b_hqx(s):\n result = []\n \n def quadruples_gen(s):\n  t = []\n  for c in s:\n   res = table_a2b_hqx[ord(c)]\n   if res == SKIP:\n    continue\n   elif res == FAIL:\n    raise Error('Illegal character')\n   elif res == DONE:\n    yield t\n    raise Done\n   else:\n    t.append(res)\n   if len(t) == 4:\n    yield t\n    t = []\n  yield t\n  \n done = 0\n try:\n  for snippet in quadruples_gen(s):\n   length = len(snippet)\n   if length == 4:\n    result.append(chr(((snippet[0] & 0x3f) << 2) | (snippet[1] >> 4))) \n    result.append(chr(((snippet[1] & 0x0f) << 4) | (snippet[2] >> 2))) \n    result.append(chr(((snippet[2] & 0x03) << 6) | (snippet[3]))) \n   elif length == 3:\n    result.append(chr(((snippet[0] & 0x3f) << 2) | (snippet[1] >> 4))) \n    result.append(chr(((snippet[1] & 0x0f) << 4) | (snippet[2] >> 2))) \n   elif length == 2:\n    result.append(chr(((snippet[0] & 0x3f) << 2) | (snippet[1] >> 4))) \n except Done:\n  done = 1\n except Error:\n  raise\n return (''.join(result), done)\n \n \n \ndef b2a_hqx(s):\n result =[]\n \n def triples_gen(s):\n  while s:\n   try:\n    yield ord(s[0]), ord(s[1]), ord(s[2])\n   except IndexError:\n    yield tuple([ord(c) for c in s])\n   s = s[3:]\n   \n for snippet in triples_gen(s):\n  length = len(snippet)\n  if length == 3:\n   result.append(\n   hqx_encoding[(snippet[0] & 0xfc) >> 2])\n   result.append(hqx_encoding[\n   ((snippet[0] & 0x03) << 4) | ((snippet[1] & 0xf0) >> 4)])\n   result.append(hqx_encoding[\n   (snippet[1] & 0x0f) << 2 | ((snippet[2] & 0xc0) >> 6)])\n   result.append(hqx_encoding[snippet[2] & 0x3f])\n  elif length == 2:\n   result.append(\n   hqx_encoding[(snippet[0] & 0xfc) >> 2])\n   result.append(hqx_encoding[\n   ((snippet[0] & 0x03) << 4) | ((snippet[1] & 0xf0) >> 4)])\n   result.append(hqx_encoding[\n   (snippet[1] & 0x0f) << 2])\n  elif length == 1:\n   result.append(\n   hqx_encoding[(snippet[0] & 0xfc) >> 2])\n   result.append(hqx_encoding[\n   ((snippet[0] & 0x03) << 4)])\n return ''.join(result)\n \ncrctab_hqx = [\n0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,\n0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,\n0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,\n0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,\n0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,\n0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,\n0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,\n0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,\n0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,\n0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,\n0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,\n0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,\n0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,\n0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,\n0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,\n0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,\n0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,\n0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,\n0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,\n0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,\n0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,\n0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,\n0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,\n0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,\n0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,\n0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,\n0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,\n0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,\n0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,\n0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,\n0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,\n0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,\n]\n\ndef crc_hqx(s, crc):\n for c in s:\n  crc = ((crc << 8) & 0xff00) ^ crctab_hqx[((crc >> 8) & 0xff) ^ ord(c)]\n  \n return crc\n \ndef rlecode_hqx(s):\n \"\"\n if not s:\n  return ''\n result = []\n prev = s[0]\n count = 1\n \n \n \n \n if s[-1] == '!':\n  s = s[1:] + '?'\n else:\n  s = s[1:] + '!'\n  \n for c in s:\n  if c == prev and count < 255:\n   count += 1\n  else:\n   if count == 1:\n    if prev != '\\x90':\n     result.append(prev)\n    else:\n     result.extend(['\\x90', '\\x00'])\n   elif count < 4:\n    if prev != '\\x90':\n     result.extend([prev] * count)\n    else:\n     result.extend(['\\x90', '\\x00'] * count)\n   else:\n    if prev != '\\x90':\n     result.extend([prev, '\\x90', chr(count)])\n    else:\n     result.extend(['\\x90', '\\x00', '\\x90', chr(count)]) \n   count = 1\n   prev = c\n   \n return ''.join(result)\n \ndef rledecode_hqx(s):\n s = s.split('\\x90')\n result = [s[0]]\n prev = s[0]\n for snippet in s[1:]:\n  count = ord(snippet[0])\n  if count > 0:\n   result.append(prev[-1] * (count-1))\n   prev = snippet\n  else:\n   result.append('\\x90')\n   prev = '\\x90'\n  result.append(snippet[1:])\n  \n return ''.join(result)\n \ncrc_32_tab = [\n0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n0x2d02ef8d\n]\n\ndef crc32(s, crc=0):\n result = 0\n crc = ~int(crc) & 0xffffffff\n \n for c in s:\n  crc = crc_32_tab[(crc ^ int(ord(c))) & 0xff] ^ (crc >> 8)\n  \n  \n  \n result = crc ^ 0xffffffff\n \n if result > 2**31:\n  result = ((result + 2**31) % 2**32) - 2**31\n  \n return result\n \ndef b2a_hex(s):\n result = []\n for char in s:\n  c = (ord(char) >> 4) & 0xf\n  if c > 9:\n   c = c + ord('a') - 10\n  else:\n   c = c + ord('0')\n  result.append(chr(c))\n  c = ord(char) & 0xf\n  if c > 9:\n   c = c + ord('a') - 10\n  else:\n   c = c + ord('0')\n  result.append(chr(c))\n return ''.join(result)\n \nhexlify = b2a_hex\n\ntable_hex = [\n-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,\n-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,\n-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1, -1,-1,-1,-1,\n-1,10,11,12, 13,14,15,-1, -1,-1,-1,-1, -1,-1,-1,-1,\n-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,\n-1,10,11,12, 13,14,15,-1, -1,-1,-1,-1, -1,-1,-1,-1,\n-1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1\n]\n\n\ndef a2b_hex(t):\n result = []\n \n def pairs_gen(s):\n  while s:\n   try:\n    yield table_hex[ord(s[0])], table_hex[ord(s[1])]\n   except IndexError:\n    if len(s):\n     raise TypeError('Odd-length string')\n    return\n   s = s[2:]\n   \n for a, b in pairs_gen(t):\n  if a < 0 or b < 0:\n   raise TypeError('Non-hexadecimal digit found')\n  result.append(chr((a << 4) + b))\n return bytes(''.join(result), __BRYTHON__.charset)\n \n \nunhexlify = a2b_hex\n"], "sre_constants": [".py", "\n\n\n\n\n\n\n\n\n\n\n\"\"\n\n\n\nMAGIC = 20031017\n\n\n\n\n\n\n\nclass error(Exception):\n pass\n \n \n \nFAILURE = \"failure\"\nSUCCESS = \"success\"\n\nANY = \"any\"\nANY_ALL = \"any_all\"\nASSERT = \"assert\"\nASSERT_NOT = \"assert_not\"\nAT = \"at\"\nBIGCHARSET = \"bigcharset\"\nBRANCH = \"branch\"\nCALL = \"call\"\nCATEGORY = \"category\"\nCHARSET = \"charset\"\nGROUPREF = \"groupref\"\nGROUPREF_IGNORE = \"groupref_ignore\"\nGROUPREF_EXISTS = \"groupref_exists\"\nIN = \"in\"\nIN_IGNORE = \"in_ignore\"\nINFO = \"info\"\nJUMP = \"jump\"\nLITERAL = \"literal\"\nLITERAL_IGNORE = \"literal_ignore\"\nMARK = \"mark\"\nMAX_REPEAT = \"max_repeat\"\nMAX_UNTIL = \"max_until\"\nMIN_REPEAT = \"min_repeat\"\nMIN_UNTIL = \"min_until\"\nNEGATE = \"negate\"\nNOT_LITERAL = \"not_literal\"\nNOT_LITERAL_IGNORE = \"not_literal_ignore\"\nRANGE = \"range\"\nREPEAT = \"repeat\"\nREPEAT_ONE = \"repeat_one\"\nSUBPATTERN = \"subpattern\"\nMIN_REPEAT_ONE = \"min_repeat_one\"\n\n\nAT_BEGINNING = \"at_beginning\"\nAT_BEGINNING_LINE = \"at_beginning_line\"\nAT_BEGINNING_STRING = \"at_beginning_string\"\nAT_BOUNDARY = \"at_boundary\"\nAT_NON_BOUNDARY = \"at_non_boundary\"\nAT_END = \"at_end\"\nAT_END_LINE = \"at_end_line\"\nAT_END_STRING = \"at_end_string\"\nAT_LOC_BOUNDARY = \"at_loc_boundary\"\nAT_LOC_NON_BOUNDARY = \"at_loc_non_boundary\"\nAT_UNI_BOUNDARY = \"at_uni_boundary\"\nAT_UNI_NON_BOUNDARY = \"at_uni_non_boundary\"\n\n\nCATEGORY_DIGIT = \"category_digit\"\nCATEGORY_NOT_DIGIT = \"category_not_digit\"\nCATEGORY_SPACE = \"category_space\"\nCATEGORY_NOT_SPACE = \"category_not_space\"\nCATEGORY_WORD = \"category_word\"\nCATEGORY_NOT_WORD = \"category_not_word\"\nCATEGORY_LINEBREAK = \"category_linebreak\"\nCATEGORY_NOT_LINEBREAK = \"category_not_linebreak\"\nCATEGORY_LOC_WORD = \"category_loc_word\"\nCATEGORY_LOC_NOT_WORD = \"category_loc_not_word\"\nCATEGORY_UNI_DIGIT = \"category_uni_digit\"\nCATEGORY_UNI_NOT_DIGIT = \"category_uni_not_digit\"\nCATEGORY_UNI_SPACE = \"category_uni_space\"\nCATEGORY_UNI_NOT_SPACE = \"category_uni_not_space\"\nCATEGORY_UNI_WORD = \"category_uni_word\"\nCATEGORY_UNI_NOT_WORD = \"category_uni_not_word\"\nCATEGORY_UNI_LINEBREAK = \"category_uni_linebreak\"\nCATEGORY_UNI_NOT_LINEBREAK = \"category_uni_not_linebreak\"\n\nOPCODES = [\n\n\nFAILURE, SUCCESS,\n\nANY, ANY_ALL,\nASSERT, ASSERT_NOT,\nAT,\nBRANCH,\nCALL,\nCATEGORY,\nCHARSET, BIGCHARSET,\nGROUPREF, GROUPREF_EXISTS, GROUPREF_IGNORE,\nIN, IN_IGNORE,\nINFO,\nJUMP,\nLITERAL, LITERAL_IGNORE,\nMARK,\nMAX_UNTIL,\nMIN_UNTIL,\nNOT_LITERAL, NOT_LITERAL_IGNORE,\nNEGATE,\nRANGE,\nREPEAT,\nREPEAT_ONE,\nSUBPATTERN,\nMIN_REPEAT_ONE\n\n]\n\nATCODES = [\nAT_BEGINNING, AT_BEGINNING_LINE, AT_BEGINNING_STRING, AT_BOUNDARY,\nAT_NON_BOUNDARY, AT_END, AT_END_LINE, AT_END_STRING,\nAT_LOC_BOUNDARY, AT_LOC_NON_BOUNDARY, AT_UNI_BOUNDARY,\nAT_UNI_NON_BOUNDARY\n]\n\nCHCODES = [\nCATEGORY_DIGIT, CATEGORY_NOT_DIGIT, CATEGORY_SPACE,\nCATEGORY_NOT_SPACE, CATEGORY_WORD, CATEGORY_NOT_WORD,\nCATEGORY_LINEBREAK, CATEGORY_NOT_LINEBREAK, CATEGORY_LOC_WORD,\nCATEGORY_LOC_NOT_WORD, CATEGORY_UNI_DIGIT, CATEGORY_UNI_NOT_DIGIT,\nCATEGORY_UNI_SPACE, CATEGORY_UNI_NOT_SPACE, CATEGORY_UNI_WORD,\nCATEGORY_UNI_NOT_WORD, CATEGORY_UNI_LINEBREAK,\nCATEGORY_UNI_NOT_LINEBREAK\n]\n\ndef makedict(list):\n d = {}\n i = 0\n for item in list:\n  d[item] = i\n  i = i + 1\n return d\n \nOPCODES = makedict(OPCODES)\nATCODES = makedict(ATCODES)\nCHCODES = makedict(CHCODES)\n\n\nOP_IGNORE = {\nGROUPREF: GROUPREF_IGNORE,\nIN: IN_IGNORE,\nLITERAL: LITERAL_IGNORE,\nNOT_LITERAL: NOT_LITERAL_IGNORE\n}\n\nAT_MULTILINE = {\nAT_BEGINNING: AT_BEGINNING_LINE,\nAT_END: AT_END_LINE\n}\n\nAT_LOCALE = {\nAT_BOUNDARY: AT_LOC_BOUNDARY,\nAT_NON_BOUNDARY: AT_LOC_NON_BOUNDARY\n}\n\nAT_UNICODE = {\nAT_BOUNDARY: AT_UNI_BOUNDARY,\nAT_NON_BOUNDARY: AT_UNI_NON_BOUNDARY\n}\n\nCH_LOCALE = {\nCATEGORY_DIGIT: CATEGORY_DIGIT,\nCATEGORY_NOT_DIGIT: CATEGORY_NOT_DIGIT,\nCATEGORY_SPACE: CATEGORY_SPACE,\nCATEGORY_NOT_SPACE: CATEGORY_NOT_SPACE,\nCATEGORY_WORD: CATEGORY_LOC_WORD,\nCATEGORY_NOT_WORD: CATEGORY_LOC_NOT_WORD,\nCATEGORY_LINEBREAK: CATEGORY_LINEBREAK,\nCATEGORY_NOT_LINEBREAK: CATEGORY_NOT_LINEBREAK\n}\n\nCH_UNICODE = {\nCATEGORY_DIGIT: CATEGORY_UNI_DIGIT,\nCATEGORY_NOT_DIGIT: CATEGORY_UNI_NOT_DIGIT,\nCATEGORY_SPACE: CATEGORY_UNI_SPACE,\nCATEGORY_NOT_SPACE: CATEGORY_UNI_NOT_SPACE,\nCATEGORY_WORD: CATEGORY_UNI_WORD,\nCATEGORY_NOT_WORD: CATEGORY_UNI_NOT_WORD,\nCATEGORY_LINEBREAK: CATEGORY_UNI_LINEBREAK,\nCATEGORY_NOT_LINEBREAK: CATEGORY_UNI_NOT_LINEBREAK\n}\n\n\nSRE_FLAG_TEMPLATE = 1 \nSRE_FLAG_IGNORECASE = 2 \nSRE_FLAG_LOCALE = 4 \nSRE_FLAG_MULTILINE = 8 \nSRE_FLAG_DOTALL = 16 \nSRE_FLAG_UNICODE = 32 \nSRE_FLAG_VERBOSE = 64 \nSRE_FLAG_DEBUG = 128 \nSRE_FLAG_ASCII = 256 \n\n\nSRE_INFO_PREFIX = 1 \nSRE_INFO_LITERAL = 2 \nSRE_INFO_CHARSET = 4 \n\nif __name__ == \"__main__\":\n def dump(f, d, prefix):\n  items = sorted(d.items(), key=lambda a: a[1])\n  for k, v in items:\n   f.write(\"#define %s_%s %s\\n\" % (prefix, k.upper(), v))\n f = open(\"sre_constants.h\", \"w\")\n f.write(\"\"\"\\\n/*\n * Secret Labs' Regular Expression Engine\n *\n * regular expression matching engine\n *\n * NOTE: This file is generated by sre_constants.py.  If you need\n * to change anything in here, edit sre_constants.py and run it.\n *\n * Copyright (c) 1997-2001 by Secret Labs AB.  All rights reserved.\n *\n * See the _sre.c file for information on usage and redistribution.\n */\n\n\"\"\" )\n \n f.write(\"#define SRE_MAGIC %d\\n\" % MAGIC)\n \n dump(f, OPCODES, \"SRE_OP\")\n dump(f, ATCODES, \"SRE\")\n dump(f, CHCODES, \"SRE\")\n \n f.write(\"#define SRE_FLAG_TEMPLATE %d\\n\" % SRE_FLAG_TEMPLATE)\n f.write(\"#define SRE_FLAG_IGNORECASE %d\\n\" % SRE_FLAG_IGNORECASE)\n f.write(\"#define SRE_FLAG_LOCALE %d\\n\" % SRE_FLAG_LOCALE)\n f.write(\"#define SRE_FLAG_MULTILINE %d\\n\" % SRE_FLAG_MULTILINE)\n f.write(\"#define SRE_FLAG_DOTALL %d\\n\" % SRE_FLAG_DOTALL)\n f.write(\"#define SRE_FLAG_UNICODE %d\\n\" % SRE_FLAG_UNICODE)\n f.write(\"#define SRE_FLAG_VERBOSE %d\\n\" % SRE_FLAG_VERBOSE)\n \n f.write(\"#define SRE_INFO_PREFIX %d\\n\" % SRE_INFO_PREFIX)\n f.write(\"#define SRE_INFO_LITERAL %d\\n\" % SRE_INFO_LITERAL)\n f.write(\"#define SRE_INFO_CHARSET %d\\n\" % SRE_INFO_CHARSET)\n \n f.close()\n print(\"done\")\n"], "site-packages.pygame.SDL": [".py", "from browser import document\n\nSDL_INIT_VIDEO=0\nSDL_GL_DOUBLEBUFFER=1\nSDL_GL_DEPTH_SIZE=2\nSDL_DOUBLEBUF=3\nSDL_ANYFORMAT=4\n\nSDL_ACTIVEEVENT=5\nSDL_ALLEVENTS=5\n\nSDL_KEYDOWN=6\nSDL_KEYUP=7\nSDL_MOUSEMOTION=8\nSDL_MOUSEBUTTONDOWN=9\n\nSDL_MOUSEBUTTONUP=10\nSDL_JOYAXISMOTION=11\nSDL_JOYBALLMOTION=12\nSDL_JOYHATMOTION=13\nSDL_JOYBUTTONUP=14\nSDL_JOYBUTTONDOWN=15\nSDL_QUIT=16\nSDL_SYSWMEVENT=17\nSDL_VIDEORESIZE=18\nSDL_VIDEOEXPOSE=19\nSDL_NOEVENT=20\n\nSDL_GETEVENT=21\nSDL_OPENGL=False\n\ndef SDL_WasInit(var):\n return True\n \n_attrs={}\n_wm={}\n\ndef SDL_PeepEvents(num, event, mask):\n pass\n \ndef SDL_GL_SetAttribute(variable, value):\n _attrs[variable]=value\n \ndef SDL_GL_GetAttribute(variable):\n return _attrs.getvalue(variable, None)\n \ndef SDL_GL_SetVideoMode(width, height, depth, flags):\n pass\n \ndef SDL_WM_SetCaption(title, icontitle):\n _wm['title']=title\n _wm['icontitle']=icontitle\n \ndef SDL_PumpEvents():\n pass\n \ndef SDL_SetVideoMode(width, height, depth, flags):\n pass\n \ndef SDL_SetColorKey(surface, key, value):\n pass\n \ndef SDL_WM_GetCaption():\n return _wm.get('title', ''), _wm.get('icontitle', '')\n \ndef SDL_UpdateRect(screen, x1, y1, x2, y2):\n screen.canvas.style.width=screen.canvas.style.width\n \ndef SDL_UpdateRects(screen, rects):\n for _rect in rects:\n  SDL_UpdateRect(screen, _rect)\n  \ndef SDL_GetVideoSurface():\n return _Screen\n \ndef SDL_GetVideoInfo():\n return \n \ndef SDL_VideoModeOK(width, height, depth, flags):\n pass\n \ndef SDL_SetPalette(surface, sdl_var, colors, flag):\n pass\n \nclass Screen:\n def __init__(self):\n  self.flags=0\n  \n @property\n def canvas(self):\n  return document.get(selector='canvas')[0]\n  \n_Screen=Screen()\n\n\n\nclass SDL_Rect:\n def __init__(self, x, y, w, h):\n  self.x=x\n  self.y=y\n  self.w=w\n  self.h=h\n  \ndef SDL_Flip(screen):\n pass\n"], "json": [".js", "var $module = (function($B){\n\nreturn  {\n    loads : function(json_obj){return $B.jsobject2pyobject(JSON.parse(json_obj))},\n    dumps : function(obj){return JSON.stringify($B.pyobject2jsobject(obj))},\n}\n\n})(__BRYTHON__)\n"], "logging.config": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\n\nimport sys, logging, logging.handlers, socket, struct, traceback, re\nimport io\n\ntry:\n import _thread as thread\n import threading\nexcept ImportError: \n thread = None\n \nfrom socketserver import ThreadingTCPServer, StreamRequestHandler\n\n\nDEFAULT_LOGGING_CONFIG_PORT = 9030\n\nif sys.platform == \"win32\":\n RESET_ERROR = 10054 \nelse:\n RESET_ERROR = 104 \n \n \n \n \n \n \n_listener = None\n\ndef fileConfig(fname, defaults=None, disable_existing_loggers=True):\n \"\"\n import configparser\n \n cp = configparser.ConfigParser(defaults)\n if hasattr(fname, 'readline'):\n  cp.read_file(fname)\n else:\n  cp.read(fname)\n  \n formatters = _create_formatters(cp)\n \n \n logging._acquireLock()\n try:\n  logging._handlers.clear()\n  del logging._handlerList[:]\n  \n  handlers = _install_handlers(cp, formatters)\n  _install_loggers(cp, handlers, disable_existing_loggers)\n finally:\n  logging._releaseLock()\n  \n  \ndef _resolve(name):\n \"\"\n name = name.split('.')\n used = name.pop(0)\n found = __import__(used)\n for n in name:\n  used = used + '.' + n\n  try:\n   found = getattr(found, n)\n  except AttributeError:\n   __import__(used)\n   found = getattr(found, n)\n return found\n \ndef _strip_spaces(alist):\n return map(lambda x: x.strip(), alist)\n \ndef _create_formatters(cp):\n \"\"\n flist = cp[\"formatters\"][\"keys\"]\n if not len(flist):\n  return {}\n flist = flist.split(\",\")\n flist = _strip_spaces(flist)\n formatters = {}\n for form in flist:\n  sectname = \"formatter_%s\" % form\n  fs = cp.get(sectname, \"format\", raw=True, fallback=None)\n  dfs = cp.get(sectname, \"datefmt\", raw=True, fallback=None)\n  c = logging.Formatter\n  class_name = cp[sectname].get(\"class\")\n  if class_name:\n   c = _resolve(class_name)\n  f = c(fs, dfs)\n  formatters[form] = f\n return formatters\n \n \ndef _install_handlers(cp, formatters):\n \"\"\n hlist = cp[\"handlers\"][\"keys\"]\n if not len(hlist):\n  return {}\n hlist = hlist.split(\",\")\n hlist = _strip_spaces(hlist)\n handlers = {}\n fixups = [] \n for hand in hlist:\n  section = cp[\"handler_%s\" % hand]\n  klass = section[\"class\"]\n  fmt = section.get(\"formatter\", \"\")\n  try:\n   klass = eval(klass, vars(logging))\n  except (AttributeError, NameError):\n   klass = _resolve(klass)\n  args = section[\"args\"]\n  args = eval(args, vars(logging))\n  h = klass(*args)\n  if \"level\" in section:\n   level = section[\"level\"]\n   h.setLevel(logging._levelNames[level])\n  if len(fmt):\n   h.setFormatter(formatters[fmt])\n  if issubclass(klass, logging.handlers.MemoryHandler):\n   target = section.get(\"target\", \"\")\n   if len(target): \n    fixups.append((h, target))\n  handlers[hand] = h\n  \n for h, t in fixups:\n  h.setTarget(handlers[t])\n return handlers\n \ndef _handle_existing_loggers(existing, child_loggers, disable_existing):\n \"\"\n root = logging.root\n for log in existing:\n  logger = root.manager.loggerDict[log]\n  if log in child_loggers:\n   logger.level = logging.NOTSET\n   logger.handlers = []\n   logger.propagate = True\n  else:\n   logger.disabled = disable_existing\n   \ndef _install_loggers(cp, handlers, disable_existing):\n \"\"\n \n \n llist = cp[\"loggers\"][\"keys\"]\n llist = llist.split(\",\")\n llist = list(map(lambda x: x.strip(), llist))\n llist.remove(\"root\")\n section = cp[\"logger_root\"]\n root = logging.root\n log = root\n if \"level\" in section:\n  level = section[\"level\"]\n  log.setLevel(logging._levelNames[level])\n for h in root.handlers[:]:\n  root.removeHandler(h)\n hlist = section[\"handlers\"]\n if len(hlist):\n  hlist = hlist.split(\",\")\n  hlist = _strip_spaces(hlist)\n  for hand in hlist:\n   log.addHandler(handlers[hand])\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n existing = list(root.manager.loggerDict.keys())\n \n \n \n \n existing.sort()\n \n \n child_loggers = []\n \n for log in llist:\n  section = cp[\"logger_%s\" % log]\n  qn = section[\"qualname\"]\n  propagate = section.getint(\"propagate\", fallback=1)\n  logger = logging.getLogger(qn)\n  if qn in existing:\n   i = existing.index(qn) + 1 \n   prefixed = qn + \".\"\n   pflen = len(prefixed)\n   num_existing = len(existing)\n   while i < num_existing:\n    if existing[i][:pflen] == prefixed:\n     child_loggers.append(existing[i])\n    i += 1\n   existing.remove(qn)\n  if \"level\" in section:\n   level = section[\"level\"]\n   logger.setLevel(logging._levelNames[level])\n  for h in logger.handlers[:]:\n   logger.removeHandler(h)\n  logger.propagate = propagate\n  logger.disabled = 0\n  hlist = section[\"handlers\"]\n  if len(hlist):\n   hlist = hlist.split(\",\")\n   hlist = _strip_spaces(hlist)\n   for hand in hlist:\n    logger.addHandler(handlers[hand])\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n _handle_existing_loggers(existing, child_loggers, disable_existing)\n \nIDENTIFIER = re.compile('^[a-z_][a-z0-9_]*$', re.I)\n\n\ndef valid_ident(s):\n m = IDENTIFIER.match(s)\n if not m:\n  raise ValueError('Not a valid Python identifier: %r' % s)\n return True\n \n \n \n \n \n \n \n \n \n \n \nclass ConvertingDict(dict):\n \"\"\n \n def __getitem__(self, key):\n  value = dict.__getitem__(self, key)\n  result = self.configurator.convert(value)\n  \n  if value is not result:\n   self[key] = result\n   if type(result) in (ConvertingDict, ConvertingList,\n   ConvertingTuple):\n    result.parent = self\n    result.key = key\n  return result\n  \n def get(self, key, default=None):\n  value = dict.get(self, key, default)\n  result = self.configurator.convert(value)\n  \n  if value is not result:\n   self[key] = result\n   if type(result) in (ConvertingDict, ConvertingList,\n   ConvertingTuple):\n    result.parent = self\n    result.key = key\n  return result\n  \n def pop(self, key, default=None):\n  value = dict.pop(self, key, default)\n  result = self.configurator.convert(value)\n  if value is not result:\n   if type(result) in (ConvertingDict, ConvertingList,\n   ConvertingTuple):\n    result.parent = self\n    result.key = key\n  return result\n  \nclass ConvertingList(list):\n \"\"\n def __getitem__(self, key):\n  value = list.__getitem__(self, key)\n  result = self.configurator.convert(value)\n  \n  if value is not result:\n   self[key] = result\n   if type(result) in (ConvertingDict, ConvertingList,\n   ConvertingTuple):\n    result.parent = self\n    result.key = key\n  return result\n  \n def pop(self, idx=-1):\n  value = list.pop(self, idx)\n  result = self.configurator.convert(value)\n  if value is not result:\n   if type(result) in (ConvertingDict, ConvertingList,\n   ConvertingTuple):\n    result.parent = self\n  return result\n  \nclass ConvertingTuple(tuple):\n \"\"\n def __getitem__(self, key):\n  value = tuple.__getitem__(self, key)\n  result = self.configurator.convert(value)\n  if value is not result:\n   if type(result) in (ConvertingDict, ConvertingList,\n   ConvertingTuple):\n    result.parent = self\n    result.key = key\n  return result\n  \nclass BaseConfigurator(object):\n \"\"\n \n CONVERT_PATTERN = re.compile(r'^(?P<prefix>[a-z]+)://(?P<suffix>.*)$')\n \n WORD_PATTERN = re.compile(r'^\\s*(\\w+)\\s*')\n DOT_PATTERN = re.compile(r'^\\.\\s*(\\w+)\\s*')\n INDEX_PATTERN = re.compile(r'^\\[\\s*(\\w+)\\s*\\]\\s*')\n DIGIT_PATTERN = re.compile(r'^\\d+$')\n \n value_converters = {\n 'ext' : 'ext_convert',\n 'cfg' : 'cfg_convert',\n }\n \n \n importer = staticmethod(__import__)\n \n def __init__(self, config):\n  self.config = ConvertingDict(config)\n  self.config.configurator = self\n  \n def resolve(self, s):\n  \"\"\n  name = s.split('.')\n  used = name.pop(0)\n  try:\n   found = self.importer(used)\n   for frag in name:\n    used += '.' + frag\n    try:\n     found = getattr(found, frag)\n    except AttributeError:\n     self.importer(used)\n     found = getattr(found, frag)\n   return found\n  except ImportError:\n   e, tb = sys.exc_info()[1:]\n   v = ValueError('Cannot resolve %r: %s' % (s, e))\n   v.__cause__, v.__traceback__ = e, tb\n   raise v\n   \n def ext_convert(self, value):\n  \"\"\n  return self.resolve(value)\n  \n def cfg_convert(self, value):\n  \"\"\n  rest = value\n  m = self.WORD_PATTERN.match(rest)\n  if m is None:\n   raise ValueError(\"Unable to convert %r\" % value)\n  else:\n   rest = rest[m.end():]\n   d = self.config[m.groups()[0]]\n   \n   while rest:\n    m = self.DOT_PATTERN.match(rest)\n    if m:\n     d = d[m.groups()[0]]\n    else:\n     m = self.INDEX_PATTERN.match(rest)\n     if m:\n      idx = m.groups()[0]\n      if not self.DIGIT_PATTERN.match(idx):\n       d = d[idx]\n      else:\n       try:\n        n = int(idx) \n        d = d[n]\n       except TypeError:\n        d = d[idx]\n    if m:\n     rest = rest[m.end():]\n    else:\n     raise ValueError('Unable to convert '\n     '%r at %r' % (value, rest))\n     \n  return d\n  \n def convert(self, value):\n  \"\"\n  if not isinstance(value, ConvertingDict) and isinstance(value, dict):\n   value = ConvertingDict(value)\n   value.configurator = self\n  elif not isinstance(value, ConvertingList) and isinstance(value, list):\n   value = ConvertingList(value)\n   value.configurator = self\n  elif not isinstance(value, ConvertingTuple) and isinstance(value, tuple):\n   value = ConvertingTuple(value)\n   value.configurator = self\n  elif isinstance(value, str): \n   m = self.CONVERT_PATTERN.match(value)\n   if m:\n    d = m.groupdict()\n    prefix = d['prefix']\n    converter = self.value_converters.get(prefix, None)\n    if converter:\n     suffix = d['suffix']\n     converter = getattr(self, converter)\n     value = converter(suffix)\n  return value\n  \n def configure_custom(self, config):\n  \"\"\n  c = config.pop('()')\n  if not callable(c):\n   c = self.resolve(c)\n  props = config.pop('.', None)\n  \n  kwargs = dict([(k, config[k]) for k in config if valid_ident(k)])\n  result = c(**kwargs)\n  if props:\n   for name, value in props.items():\n    setattr(result, name, value)\n  return result\n  \n def as_tuple(self, value):\n  \"\"\n  if isinstance(value, list):\n   value = tuple(value)\n  return value\n  \nclass DictConfigurator(BaseConfigurator):\n \"\"\n \n def configure(self):\n  \"\"\n  \n  config = self.config\n  if 'version' not in config:\n   raise ValueError(\"dictionary doesn't specify a version\")\n  if config['version'] != 1:\n   raise ValueError(\"Unsupported version: %s\" % config['version'])\n  incremental = config.pop('incremental', False)\n  EMPTY_DICT = {}\n  logging._acquireLock()\n  try:\n   if incremental:\n    handlers = config.get('handlers', EMPTY_DICT)\n    for name in handlers:\n     if name not in logging._handlers:\n      raise ValueError('No handler found with '\n      'name %r' % name)\n     else:\n      try:\n       handler = logging._handlers[name]\n       handler_config = handlers[name]\n       level = handler_config.get('level', None)\n       if level:\n        handler.setLevel(logging._checkLevel(level))\n      except Exception as e:\n       raise ValueError('Unable to configure handler '\n       '%r: %s' % (name, e))\n    loggers = config.get('loggers', EMPTY_DICT)\n    for name in loggers:\n     try:\n      self.configure_logger(name, loggers[name], True)\n     except Exception as e:\n      raise ValueError('Unable to configure logger '\n      '%r: %s' % (name, e))\n    root = config.get('root', None)\n    if root:\n     try:\n      self.configure_root(root, True)\n     except Exception as e:\n      raise ValueError('Unable to configure root '\n      'logger: %s' % e)\n   else:\n    disable_existing = config.pop('disable_existing_loggers', True)\n    \n    logging._handlers.clear()\n    del logging._handlerList[:]\n    \n    \n    formatters = config.get('formatters', EMPTY_DICT)\n    for name in formatters:\n     try:\n      formatters[name] = self.configure_formatter(\n      formatters[name])\n     except Exception as e:\n      raise ValueError('Unable to configure '\n      'formatter %r: %s' % (name, e))\n      \n    filters = config.get('filters', EMPTY_DICT)\n    for name in filters:\n     try:\n      filters[name] = self.configure_filter(filters[name])\n     except Exception as e:\n      raise ValueError('Unable to configure '\n      'filter %r: %s' % (name, e))\n      \n      \n      \n      \n    handlers = config.get('handlers', EMPTY_DICT)\n    deferred = []\n    for name in sorted(handlers):\n     try:\n      handler = self.configure_handler(handlers[name])\n      handler.name = name\n      handlers[name] = handler\n     except Exception as e:\n      if 'target not configured yet' in str(e):\n       deferred.append(name)\n      else:\n       raise ValueError('Unable to configure handler '\n       '%r: %s' % (name, e))\n       \n       \n    for name in deferred:\n     try:\n      handler = self.configure_handler(handlers[name])\n      handler.name = name\n      handlers[name] = handler\n     except Exception as e:\n      raise ValueError('Unable to configure handler '\n      '%r: %s' % (name, e))\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    root = logging.root\n    existing = list(root.manager.loggerDict.keys())\n    \n    \n    \n    \n    existing.sort()\n    \n    \n    child_loggers = []\n    \n    loggers = config.get('loggers', EMPTY_DICT)\n    for name in loggers:\n     if name in existing:\n      i = existing.index(name) + 1 \n      prefixed = name + \".\"\n      pflen = len(prefixed)\n      num_existing = len(existing)\n      while i < num_existing:\n       if existing[i][:pflen] == prefixed:\n        child_loggers.append(existing[i])\n       i += 1\n      existing.remove(name)\n     try:\n      self.configure_logger(name, loggers[name])\n     except Exception as e:\n      raise ValueError('Unable to configure logger '\n      '%r: %s' % (name, e))\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    _handle_existing_loggers(existing, child_loggers,\n    disable_existing)\n    \n    \n    root = config.get('root', None)\n    if root:\n     try:\n      self.configure_root(root)\n     except Exception as e:\n      raise ValueError('Unable to configure root '\n      'logger: %s' % e)\n  finally:\n   logging._releaseLock()\n   \n def configure_formatter(self, config):\n  \"\"\n  if '()' in config:\n   factory = config['()'] \n   try:\n    result = self.configure_custom(config)\n   except TypeError as te:\n    if \"'format'\" not in str(te):\n     raise\n     \n     \n     \n     \n    config['fmt'] = config.pop('format')\n    config['()'] = factory\n    result = self.configure_custom(config)\n  else:\n   fmt = config.get('format', None)\n   dfmt = config.get('datefmt', None)\n   style = config.get('style', '%')\n   result = logging.Formatter(fmt, dfmt, style)\n  return result\n  \n def configure_filter(self, config):\n  \"\"\n  if '()' in config:\n   result = self.configure_custom(config)\n  else:\n   name = config.get('name', '')\n   result = logging.Filter(name)\n  return result\n  \n def add_filters(self, filterer, filters):\n  \"\"\n  for f in filters:\n   try:\n    filterer.addFilter(self.config['filters'][f])\n   except Exception as e:\n    raise ValueError('Unable to add filter %r: %s' % (f, e))\n    \n def configure_handler(self, config):\n  \"\"\n  config_copy = dict(config) \n  formatter = config.pop('formatter', None)\n  if formatter:\n   try:\n    formatter = self.config['formatters'][formatter]\n   except Exception as e:\n    raise ValueError('Unable to set formatter '\n    '%r: %s' % (formatter, e))\n  level = config.pop('level', None)\n  filters = config.pop('filters', None)\n  if '()' in config:\n   c = config.pop('()')\n   if not callable(c):\n    c = self.resolve(c)\n   factory = c\n  else:\n   cname = config.pop('class')\n   klass = self.resolve(cname)\n   \n   if issubclass(klass, logging.handlers.MemoryHandler) and 'target' in config:\n    try:\n     th = self.config['handlers'][config['target']]\n     if not isinstance(th, logging.Handler):\n      config.update(config_copy) \n      raise TypeError('target not configured yet')\n     config['target'] = th\n    except Exception as e:\n     raise ValueError('Unable to set target handler '\n     '%r: %s' % (config['target'], e))\n   elif issubclass(klass, logging.handlers.SMTPHandler) and 'mailhost' in config:\n    config['mailhost'] = self.as_tuple(config['mailhost'])\n   elif issubclass(klass, logging.handlers.SysLogHandler) and 'address' in config:\n    config['address'] = self.as_tuple(config['address'])\n   factory = klass\n  kwargs = dict([(k, config[k]) for k in config if valid_ident(k)])\n  try:\n   result = factory(**kwargs)\n  except TypeError as te:\n   if \"'stream'\" not in str(te):\n    raise\n    \n    \n    \n    \n   kwargs['strm'] = kwargs.pop('stream')\n   result = factory(**kwargs)\n  if formatter:\n   result.setFormatter(formatter)\n  if level is not None:\n   result.setLevel(logging._checkLevel(level))\n  if filters:\n   self.add_filters(result, filters)\n  return result\n  \n def add_handlers(self, logger, handlers):\n  \"\"\n  for h in handlers:\n   try:\n    logger.addHandler(self.config['handlers'][h])\n   except Exception as e:\n    raise ValueError('Unable to add handler %r: %s' % (h, e))\n    \n def common_logger_config(self, logger, config, incremental=False):\n  \"\"\n  level = config.get('level', None)\n  if level is not None:\n   logger.setLevel(logging._checkLevel(level))\n  if not incremental:\n  \n   for h in logger.handlers[:]:\n    logger.removeHandler(h)\n   handlers = config.get('handlers', None)\n   if handlers:\n    self.add_handlers(logger, handlers)\n   filters = config.get('filters', None)\n   if filters:\n    self.add_filters(logger, filters)\n    \n def configure_logger(self, name, config, incremental=False):\n  \"\"\n  logger = logging.getLogger(name)\n  self.common_logger_config(logger, config, incremental)\n  propagate = config.get('propagate', None)\n  if propagate is not None:\n   logger.propagate = propagate\n   \n def configure_root(self, config, incremental=False):\n  \"\"\n  root = logging.getLogger()\n  self.common_logger_config(root, config, incremental)\n  \ndictConfigClass = DictConfigurator\n\ndef dictConfig(config):\n \"\"\n dictConfigClass(config).configure()\n \n \ndef listen(port=DEFAULT_LOGGING_CONFIG_PORT):\n \"\"\n if not thread: \n  raise NotImplementedError(\"listen() needs threading to work\")\n  \n class ConfigStreamHandler(StreamRequestHandler):\n  \"\"\n  def handle(self):\n   \"\"\n   try:\n    conn = self.connection\n    chunk = conn.recv(4)\n    if len(chunk) == 4:\n     slen = struct.unpack(\">L\", chunk)[0]\n     chunk = self.connection.recv(slen)\n     while len(chunk) < slen:\n      chunk = chunk + conn.recv(slen - len(chunk))\n     chunk = chunk.decode(\"utf-8\")\n     try:\n      import json\n      d =json.loads(chunk)\n      assert isinstance(d, dict)\n      dictConfig(d)\n     except:\n     \n     \n      file = io.StringIO(chunk)\n      try:\n       fileConfig(file)\n      except (KeyboardInterrupt, SystemExit): \n       raise\n      except:\n       traceback.print_exc()\n     if self.server.ready:\n      self.server.ready.set()\n   except socket.error as e:\n    if not isinstance(e.args, tuple):\n     raise\n    else:\n     errcode = e.args[0]\n     if errcode != RESET_ERROR:\n      raise\n      \n class ConfigSocketReceiver(ThreadingTCPServer):\n  \"\"\n  \n  allow_reuse_address = 1\n  \n  def __init__(self, host='localhost', port=DEFAULT_LOGGING_CONFIG_PORT,\n  handler=None, ready=None):\n   ThreadingTCPServer.__init__(self, (host, port), handler)\n   logging._acquireLock()\n   self.abort = 0\n   logging._releaseLock()\n   self.timeout = 1\n   self.ready = ready\n   \n  def serve_until_stopped(self):\n   import select\n   abort = 0\n   while not abort:\n    rd, wr, ex = select.select([self.socket.fileno()],\n    [], [],\n    self.timeout)\n    if rd:\n     self.handle_request()\n    logging._acquireLock()\n    abort = self.abort\n    logging._releaseLock()\n   self.socket.close()\n   \n class Server(threading.Thread):\n \n  def __init__(self, rcvr, hdlr, port):\n   super(Server, self).__init__()\n   self.rcvr = rcvr\n   self.hdlr = hdlr\n   self.port = port\n   self.ready = threading.Event()\n   \n  def run(self):\n   server = self.rcvr(port=self.port, handler=self.hdlr,\n   ready=self.ready)\n   if self.port == 0:\n    self.port = server.server_address[1]\n   self.ready.set()\n   global _listener\n   logging._acquireLock()\n   _listener = server\n   logging._releaseLock()\n   server.serve_until_stopped()\n   \n return Server(ConfigSocketReceiver, ConfigStreamHandler, port)\n \ndef stopListening():\n \"\"\n global _listener\n logging._acquireLock()\n try:\n  if _listener:\n   _listener.abort = 1\n   _listener = None\n finally:\n  logging._releaseLock()\n"], "xml.sax.handler": [".py", "\"\"\n\nversion = '2.0beta'\n\n\n\n\n\n\n\n\n\nclass ErrorHandler:\n \"\"\n \n def error(self, exception):\n  \"\"\n  raise exception\n  \n def fatalError(self, exception):\n  \"\"\n  raise exception\n  \n def warning(self, exception):\n  \"\"\n  print(exception)\n  \n  \n  \n  \nclass ContentHandler:\n \"\"\n \n def __init__(self):\n  self._locator = None\n  \n def setDocumentLocator(self, locator):\n  \"\"\n  self._locator = locator\n  \n def startDocument(self):\n  \"\"\n  \n def endDocument(self):\n  \"\"\n  \n def startPrefixMapping(self, prefix, uri):\n  \"\"\n  \n def endPrefixMapping(self, prefix):\n  \"\"\n  \n def startElement(self, name, attrs):\n  \"\"\n  \n def endElement(self, name):\n  \"\"\n  \n def startElementNS(self, name, qname, attrs):\n  \"\"\n  \n def endElementNS(self, name, qname):\n  \"\"\n  \n def characters(self, content):\n  \"\"\n  \n def ignorableWhitespace(self, whitespace):\n  \"\"\n  \n def processingInstruction(self, target, data):\n  \"\"\n  \n def skippedEntity(self, name):\n  \"\"\n  \n  \n  \n  \nclass DTDHandler:\n \"\"\n \n def notationDecl(self, name, publicId, systemId):\n  \"\"\n  \n def unparsedEntityDecl(self, name, publicId, systemId, ndata):\n  \"\"\n  \n  \n  \n  \nclass EntityResolver:\n \"\"\n \n def resolveEntity(self, publicId, systemId):\n  \"\"\n  return systemId\n  \n  \n  \n  \n  \n  \n  \n  \nfeature_namespaces = \"http://xml.org/sax/features/namespaces\"\n\n\n\n\n\nfeature_namespace_prefixes = \"http://xml.org/sax/features/namespace-prefixes\"\n\n\n\n\n\n\nfeature_string_interning = \"http://xml.org/sax/features/string-interning\"\n\n\n\n\n\nfeature_validation = \"http://xml.org/sax/features/validation\"\n\n\n\n\n\nfeature_external_ges = \"http://xml.org/sax/features/external-general-entities\"\n\n\n\n\nfeature_external_pes = \"http://xml.org/sax/features/external-parameter-entities\"\n\n\n\n\n\n\nall_features = [feature_namespaces,\nfeature_namespace_prefixes,\nfeature_string_interning,\nfeature_validation,\nfeature_external_ges,\nfeature_external_pes]\n\n\n\n\n\n\n\n\nproperty_lexical_handler = \"http://xml.org/sax/properties/lexical-handler\"\n\n\n\n\nproperty_declaration_handler = \"http://xml.org/sax/properties/declaration-handler\"\n\n\n\n\n\nproperty_dom_node = \"http://xml.org/sax/properties/dom-node\"\n\n\n\n\n\n\nproperty_xml_string = \"http://xml.org/sax/properties/xml-string\"\n\n\n\n\n\nproperty_encoding = \"http://www.python.org/sax/properties/encoding\"\n\n\n\n\n\n\n\n\n\n\nproperty_interning_dict = \"http://www.python.org/sax/properties/interning-dict\"\n\n\n\n\n\n\n\nall_properties = [property_lexical_handler,\nproperty_dom_node,\nproperty_declaration_handler,\nproperty_xml_string,\nproperty_encoding,\nproperty_interning_dict]\n"], "importlib.machinery": [".py", "\"\"\n\nimport _imp\n\nfrom ._bootstrap import (SOURCE_SUFFIXES, DEBUG_BYTECODE_SUFFIXES,\nOPTIMIZED_BYTECODE_SUFFIXES, \nEXTENSION_SUFFIXES)\nfrom ._bootstrap import BuiltinImporter\nfrom ._bootstrap import FrozenImporter\nfrom ._bootstrap import WindowsRegistryFinder\nfrom ._bootstrap import PathFinder\nfrom ._bootstrap import FileFinder\nfrom ._bootstrap import SourceFileLoader\nfrom ._bootstrap import SourcelessFileLoader\nfrom ._bootstrap import ExtensionFileLoader\n\n\n\n\n\n"], "tokenize": [".py", "\"\"\n\n__author__ = 'Ka-Ping Yee <ping@lfw.org>'\n__credits__ = ('GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, '\n'Skip Montanaro, Raymond Hettinger, Trent Nelson, '\n'Michael Foord')\nimport builtins\nimport re\nimport sys\nfrom token import *\nfrom codecs import lookup, BOM_UTF8\nimport collections\nfrom io import TextIOWrapper\ncookie_re = re.compile(r'^[ \\t\\f]*#.*coding[:=][ \\t]*([-\\w.]+)', re.ASCII)\n\nimport token\n__all__ = token.__all__ + [\"COMMENT\", \"tokenize\", \"detect_encoding\",\n\"NL\", \"untokenize\", \"ENCODING\", \"TokenInfo\"]\ndel token\n\nCOMMENT = N_TOKENS\ntok_name[COMMENT] = 'COMMENT'\nNL = N_TOKENS + 1\ntok_name[NL] = 'NL'\nENCODING = N_TOKENS + 2\ntok_name[ENCODING] = 'ENCODING'\nN_TOKENS += 3\nEXACT_TOKEN_TYPES = {\n'(': LPAR,\n')': RPAR,\n'[': LSQB,\n']': RSQB,\n':': COLON,\n',': COMMA,\n';': SEMI,\n'+': PLUS,\n'-': MINUS,\n'*': STAR,\n'/': SLASH,\n'|': VBAR,\n'&': AMPER,\n'<': LESS,\n'>': GREATER,\n'=': EQUAL,\n'.': DOT,\n'%': PERCENT,\n'{': LBRACE,\n'}': RBRACE,\n'==': EQEQUAL,\n'!=': NOTEQUAL,\n'<=': LESSEQUAL,\n'>=': GREATEREQUAL,\n'~': TILDE,\n'^': CIRCUMFLEX,\n'<<': LEFTSHIFT,\n'>>': RIGHTSHIFT,\n'**': DOUBLESTAR,\n'+=': PLUSEQUAL,\n'-=': MINEQUAL,\n'*=': STAREQUAL,\n'/=': SLASHEQUAL,\n'%=': PERCENTEQUAL,\n'&=': AMPEREQUAL,\n'|=': VBAREQUAL,\n'^=': CIRCUMFLEXEQUAL,\n'<<=': LEFTSHIFTEQUAL,\n'>>=': RIGHTSHIFTEQUAL,\n'**=': DOUBLESTAREQUAL,\n'//': DOUBLESLASH,\n'//=': DOUBLESLASHEQUAL,\n'@': AT\n}\n\nclass TokenInfo(collections.namedtuple('TokenInfo', 'type string start end line')):\n def __repr__(self):\n  annotated_type = '%d (%s)' % (self.type, tok_name[self.type])\n  return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)' %\n  self._replace(type=annotated_type))\n  \n @property\n def exact_type(self):\n  if self.type == OP and self.string in EXACT_TOKEN_TYPES:\n   return EXACT_TOKEN_TYPES[self.string]\n  else:\n   return self.type\n   \ndef group(*choices): return '(' + '|'.join(choices) + ')'\ndef any(*choices): return group(*choices) + '*'\ndef maybe(*choices): return group(*choices) + '?'\n\n\n\nWhitespace = r'[ \\f\\t]*'\nComment = r'#[^\\r\\n]*'\nIgnore = Whitespace + any(r'\\\\\\r?\\n' + Whitespace) + maybe(Comment)\nName = r'\\w+'\n\nHexnumber = r'0[xX][0-9a-fA-F]+'\nBinnumber = r'0[bB][01]+'\nOctnumber = r'0[oO][0-7]+'\nDecnumber = r'(?:0+|[1-9][0-9]*)'\nIntnumber = group(Hexnumber, Binnumber, Octnumber, Decnumber)\nExponent = r'[eE][-+]?[0-9]+'\nPointfloat = group(r'[0-9]+\\.[0-9]*', r'\\.[0-9]+') + maybe(Exponent)\nExpfloat = r'[0-9]+' + Exponent\nFloatnumber = group(Pointfloat, Expfloat)\nImagnumber = group(r'[0-9]+[jJ]', Floatnumber + r'[jJ]')\nNumber = group(Imagnumber, Floatnumber, Intnumber)\n\nStringPrefix = r'(?:[bB][rR]?|[rR][bB]?|[uU])?'\n\n\nSingle = r\"[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\"\n\nDouble = r'[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"'\n\nSingle3 = r\"[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''\"\n\nDouble3 = r'[^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*\"\"\"'\nTriple = group(StringPrefix + \"'''\", StringPrefix + '\"\"\"')\n\nString = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'\",\nStringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*\"')\n\n\n\n\nOperator = group(r\"\\*\\*=?\", r\">>=?\", r\"<<=?\", r\"!=\",\nr\"//=?\", r\"->\",\nr\"[+\\-*/%&|^=<>]=?\",\nr\"~\")\n\nBracket = '[][(){}]'\nSpecial = group(r'\\r?\\n', r'\\.\\.\\.', r'[:;.,@]')\nFunny = group(Operator, Bracket, Special)\n\nPlainToken = group(Number, Funny, String, Name)\nToken = Ignore + PlainToken\n\n\nContStr = group(StringPrefix + r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*\" +\ngroup(\"'\", r'\\\\\\r?\\n'),\nStringPrefix + r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*' +\ngroup('\"', r'\\\\\\r?\\n'))\nPseudoExtras = group(r'\\\\\\r?\\n|\\Z', Comment, Triple)\nPseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)\n\ndef _compile(expr):\n return re.compile(expr, re.UNICODE)\n \nendpats = {\"'\": Single, '\"': Double,\n\"'''\": Single3, '\"\"\"': Double3,\n\"r'''\": Single3, 'r\"\"\"': Double3,\n\"b'''\": Single3, 'b\"\"\"': Double3,\n\"R'''\": Single3, 'R\"\"\"': Double3,\n\"B'''\": Single3, 'B\"\"\"': Double3,\n\"br'''\": Single3, 'br\"\"\"': Double3,\n\"bR'''\": Single3, 'bR\"\"\"': Double3,\n\"Br'''\": Single3, 'Br\"\"\"': Double3,\n\"BR'''\": Single3, 'BR\"\"\"': Double3,\n\"rb'''\": Single3, 'rb\"\"\"': Double3,\n\"Rb'''\": Single3, 'Rb\"\"\"': Double3,\n\"rB'''\": Single3, 'rB\"\"\"': Double3,\n\"RB'''\": Single3, 'RB\"\"\"': Double3,\n\"u'''\": Single3, 'u\"\"\"': Double3,\n\"R'''\": Single3, 'R\"\"\"': Double3,\n\"U'''\": Single3, 'U\"\"\"': Double3,\n'r': None, 'R': None, 'b': None, 'B': None,\n'u': None, 'U': None}\n\ntriple_quoted = {}\nfor t in (\"'''\", '\"\"\"',\n\"r'''\", 'r\"\"\"', \"R'''\", 'R\"\"\"',\n\"b'''\", 'b\"\"\"', \"B'''\", 'B\"\"\"',\n\"br'''\", 'br\"\"\"', \"Br'''\", 'Br\"\"\"',\n\"bR'''\", 'bR\"\"\"', \"BR'''\", 'BR\"\"\"',\n\"rb'''\", 'rb\"\"\"', \"rB'''\", 'rB\"\"\"',\n\"Rb'''\", 'Rb\"\"\"', \"RB'''\", 'RB\"\"\"',\n\"u'''\", 'u\"\"\"', \"U'''\", 'U\"\"\"',\n):\n triple_quoted[t] = t\nsingle_quoted = {}\nfor t in (\"'\", '\"',\n\"r'\", 'r\"', \"R'\", 'R\"',\n\"b'\", 'b\"', \"B'\", 'B\"',\n\"br'\", 'br\"', \"Br'\", 'Br\"',\n\"bR'\", 'bR\"', \"BR'\", 'BR\"' ,\n\"rb'\", 'rb\"', \"rB'\", 'rB\"',\n\"Rb'\", 'Rb\"', \"RB'\", 'RB\"' ,\n\"u'\", 'u\"', \"U'\", 'U\"',\n):\n single_quoted[t] = t\n \ntabsize = 8\n\nclass TokenError(Exception): pass\n\nclass StopTokenizing(Exception): pass\n\n\nclass Untokenizer:\n\n def __init__(self):\n  self.tokens = []\n  self.prev_row = 1\n  self.prev_col = 0\n  self.encoding = None\n  \n def add_whitespace(self, start):\n  row, col = start\n  assert row <= self.prev_row\n  col_offset = col - self.prev_col\n  if col_offset:\n   self.tokens.append(\" \" * col_offset)\n   \n def untokenize(self, iterable):\n  for t in iterable:\n   if len(t) == 2:\n    self.compat(t, iterable)\n    break\n   tok_type, token, start, end, line = t\n   if tok_type == ENCODING:\n    self.encoding = token\n    continue\n   self.add_whitespace(start)\n   self.tokens.append(token)\n   self.prev_row, self.prev_col = end\n   if tok_type in (NEWLINE, NL):\n    self.prev_row += 1\n    self.prev_col = 0\n  return \"\".join(self.tokens)\n  \n def compat(self, token, iterable):\n  startline = False\n  indents = []\n  toks_append = self.tokens.append\n  toknum, tokval = token\n  \n  if toknum in (NAME, NUMBER):\n   tokval += ' '\n  if toknum in (NEWLINE, NL):\n   startline = True\n  prevstring = False\n  for tok in iterable:\n   toknum, tokval = tok[:2]\n   if toknum == ENCODING:\n    self.encoding = tokval\n    continue\n    \n   if toknum in (NAME, NUMBER):\n    tokval += ' '\n    \n    \n   if toknum == STRING:\n    if prevstring:\n     tokval = ' ' + tokval\n    prevstring = True\n   else:\n    prevstring = False\n    \n   if toknum == INDENT:\n    indents.append(tokval)\n    continue\n   elif toknum == DEDENT:\n    indents.pop()\n    continue\n   elif toknum in (NEWLINE, NL):\n    startline = True\n   elif startline and indents:\n    toks_append(indents[-1])\n    startline = False\n   toks_append(tokval)\n   \n   \ndef untokenize(iterable):\n \"\"\n ut = Untokenizer()\n out = ut.untokenize(iterable)\n if ut.encoding is not None:\n  out = out.encode(ut.encoding)\n return out\n \n \ndef _get_normal_name(orig_enc):\n \"\"\n \n enc = orig_enc[:12].lower().replace(\"_\", \"-\")\n if enc == \"utf-8\" or enc.startswith(\"utf-8-\"):\n  return \"utf-8\"\n if enc in (\"latin-1\", \"iso-8859-1\", \"iso-latin-1\") or enc.startswith((\"latin-1-\", \"iso-8859-1-\", \"iso-latin-1-\")):\n  return \"iso-8859-1\"\n return orig_enc\n \ndef detect_encoding(readline):\n \"\"\n try:\n  filename = readline.__self__.name\n except AttributeError:\n  filename = None\n bom_found = False\n encoding = None\n default = 'utf-8'\n def read_or_stop():\n  try:\n   return readline()\n  except StopIteration:\n   return b''\n   \n def find_cookie(line):\n  try:\n  \n  \n  \n   line_string = line.decode('utf-8')\n  except UnicodeDecodeError:\n   msg = \"invalid or missing encoding declaration\"\n   if filename is not None:\n    msg = '{} for {!r}'.format(msg, filename)\n   raise SyntaxError(msg)\n   \n  match = cookie_re.match(line_string)\n  if not match:\n   return None\n  encoding = _get_normal_name(match.group(1))\n  try:\n   codec = lookup(encoding)\n  except LookupError:\n  \n   if filename is None:\n    msg = \"unknown encoding: \" + encoding\n   else:\n    msg = \"unknown encoding for {!r}: {}\".format(filename,\n    encoding)\n   raise SyntaxError(msg)\n   \n  if bom_found:\n   if encoding != 'utf-8':\n   \n    if filename is None:\n     msg = 'encoding problem: utf-8'\n    else:\n     msg = 'encoding problem for {!r}: utf-8'.format(filename)\n    raise SyntaxError(msg)\n   encoding += '-sig'\n  return encoding\n  \n first = read_or_stop()\n if first.startswith(BOM_UTF8):\n  bom_found = True\n  first = first[3:]\n  default = 'utf-8-sig'\n if not first:\n  return default, []\n  \n encoding = find_cookie(first)\n if encoding:\n  return encoding, [first]\n  \n second = read_or_stop()\n if not second:\n  return default, [first]\n  \n encoding = find_cookie(second)\n if encoding:\n  return encoding, [first, second]\n  \n return default, [first, second]\n \n \ndef open(filename):\n \"\"\n buffer = builtins.open(filename, 'rb')\n encoding, lines = detect_encoding(buffer.readline)\n buffer.seek(0)\n text = TextIOWrapper(buffer, encoding, line_buffering=True)\n text.mode = 'r'\n return text\n \n \ndef tokenize(readline):\n \"\"\n \n \n from itertools import chain, repeat\n encoding, consumed = detect_encoding(readline)\n rl_gen = iter(readline, b\"\")\n empty = repeat(b\"\")\n return _tokenize(chain(consumed, rl_gen, empty).__next__, encoding)\n \n \ndef _tokenize(readline, encoding):\n lnum = parenlev = continued = 0\n numchars = '0123456789'\n contstr, needcont = '', 0\n contline = None\n indents = [0]\n \n if encoding is not None:\n  if encoding == \"utf-8-sig\":\n  \n   encoding = \"utf-8\"\n  yield TokenInfo(ENCODING, encoding, (0, 0), (0, 0), '')\n while True: \n  try:\n   line = readline()\n  except StopIteration:\n   line = b''\n   \n  if encoding is not None:\n   line = line.decode(encoding)\n  lnum += 1\n  pos, max = 0, len(line)\n  \n  if contstr: \n   if not line:\n    raise TokenError(\"EOF in multi-line string\", strstart)\n   endmatch = endprog.match(line)\n   if endmatch:\n    pos = end = endmatch.end(0)\n    yield TokenInfo(STRING, contstr + line[:end],\n    strstart, (lnum, end), contline + line)\n    contstr, needcont = '', 0\n    contline = None\n   elif needcont and line[-2:] != '\\\\\\n' and line[-3:] != '\\\\\\r\\n':\n    yield TokenInfo(ERRORTOKEN, contstr + line,\n    strstart, (lnum, len(line)), contline)\n    contstr = ''\n    contline = None\n    continue\n   else:\n    contstr = contstr + line\n    contline = contline + line\n    continue\n    \n  elif parenlev == 0 and not continued: \n   if not line: break\n   column = 0\n   while pos < max: \n    if line[pos] == ' ':\n     column += 1\n    elif line[pos] == '\\t':\n     column = (column//tabsize + 1)*tabsize\n    elif line[pos] == '\\f':\n     column = 0\n    else:\n     break\n    pos += 1\n   if pos == max:\n    break\n    \n   if line[pos] in '#\\r\\n': \n    if line[pos] == '#':\n     comment_token = line[pos:].rstrip('\\r\\n')\n     nl_pos = pos + len(comment_token)\n     yield TokenInfo(COMMENT, comment_token,\n     (lnum, pos), (lnum, pos + len(comment_token)), line)\n     yield TokenInfo(NL, line[nl_pos:],\n     (lnum, nl_pos), (lnum, len(line)), line)\n    else:\n     yield TokenInfo((NL, COMMENT)[line[pos] == '#'], line[pos:],\n     (lnum, pos), (lnum, len(line)), line)\n    continue\n    \n   if column > indents[-1]: \n    indents.append(column)\n    yield TokenInfo(INDENT, line[:pos], (lnum, 0), (lnum, pos), line)\n   while column < indents[-1]:\n    if column not in indents:\n     raise IndentationError(\n     \"unindent does not match any outer indentation level\",\n     (\"<tokenize>\", lnum, pos, line))\n    indents = indents[:-1]\n    yield TokenInfo(DEDENT, '', (lnum, pos), (lnum, pos), line)\n    \n  else: \n   if not line:\n    raise TokenError(\"EOF in multi-line statement\", (lnum, 0))\n   continued = 0\n   \n  while pos < max:\n   pseudomatch = _compile(PseudoToken).match(line, pos)\n   if pseudomatch: \n    start, end = pseudomatch.span(1)\n    spos, epos, pos = (lnum, start), (lnum, end), end\n    if start == end:\n     continue\n    token, initial = line[start:end], line[start]\n    \n    if (initial in numchars or \n    (initial == '.' and token != '.' and token != '...')):\n     yield TokenInfo(NUMBER, token, spos, epos, line)\n    elif initial in '\\r\\n':\n     yield TokenInfo(NL if parenlev > 0 else NEWLINE,\n     token, spos, epos, line)\n    elif initial == '#':\n     assert not token.endswith(\"\\n\")\n     yield TokenInfo(COMMENT, token, spos, epos, line)\n    elif token in triple_quoted:\n     endprog = _compile(endpats[token])\n     endmatch = endprog.match(line, pos)\n     if endmatch: \n      pos = endmatch.end(0)\n      token = line[start:pos]\n      yield TokenInfo(STRING, token, spos, (lnum, pos), line)\n     else:\n      strstart = (lnum, start) \n      contstr = line[start:]\n      contline = line\n      break\n    elif initial in single_quoted or token[:2] in single_quoted or token[:3] in single_quoted:\n     if token[-1] == '\\n': \n      strstart = (lnum, start)\n      endprog = _compile(endpats[initial] or\n      endpats[token[1]] or\n      endpats[token[2]])\n      contstr, needcont = line[start:], 1\n      contline = line\n      break\n     else: \n      yield TokenInfo(STRING, token, spos, epos, line)\n    elif initial.isidentifier(): \n     yield TokenInfo(NAME, token, spos, epos, line)\n    elif initial == '\\\\': \n     continued = 1\n    else:\n     if initial in '([{':\n      parenlev += 1\n     elif initial in ')]}':\n      parenlev -= 1\n     yield TokenInfo(OP, token, spos, epos, line)\n   else:\n    yield TokenInfo(ERRORTOKEN, line[pos],\n    (lnum, pos), (lnum, pos+1), line)\n    pos += 1\n    \n for indent in indents[1:]: \n  yield TokenInfo(DEDENT, '', (lnum, 0), (lnum, 0), '')\n yield TokenInfo(ENDMARKER, '', (lnum, 0), (lnum, 0), '')\n \n \n \n \ndef generate_tokens(readline):\n return _tokenize(readline, None)\n \ndef main():\n import argparse\n \n \n def perror(message):\n  print(message, file=sys.stderr)\n  \n def error(message, filename=None, location=None):\n  if location:\n   args = (filename,) + location + (message,)\n   perror(\"%s:%d:%d: error: %s\" % args)\n  elif filename:\n   perror(\"%s: error: %s\" % (filename, message))\n  else:\n   perror(\"error: %s\" % message)\n  sys.exit(1)\n  \n  \n parser = argparse.ArgumentParser(prog='python -m tokenize')\n parser.add_argument(dest='filename', nargs='?',\n metavar='filename.py',\n help='the file to tokenize; defaults to stdin')\n parser.add_argument('-e', '--exact', dest='exact', action='store_true',\n help='display token names using the exact type')\n args = parser.parse_args()\n \n try:\n \n  if args.filename:\n   filename = args.filename\n   with builtins.open(filename, 'rb') as f:\n    tokens = list(tokenize(f.readline))\n  else:\n   filename = \"<stdin>\"\n   tokens = _tokenize(sys.stdin.readline, None)\n   \n   \n  for token in tokens:\n   token_type = token.type\n   if args.exact:\n    token_type = token.exact_type\n   token_range = \"%d,%d-%d,%d:\" % (token.start + token.end)\n   print(\"%-20s%-15s%-15r\" %\n   (token_range, tok_name[token_type], token.string))\n except IndentationError as err:\n  line, column = err.args[1][1:3]\n  error(err.args[0], filename, (line, column))\n except TokenError as err:\n  line, column = err.args[1]\n  error(err.args[0], filename, (line, column))\n except SyntaxError as err:\n  error(err, filename)\n except IOError as err:\n  error(err)\n except KeyboardInterrupt:\n  print(\"interrupted\\n\")\n except Exception as err:\n  perror(\"unexpected error: %s\" % err)\n  raise\n  \nif __name__ == \"__main__\":\n main()\n"], "_warnings": [".py", "\"\"\n\n\ndefault_action = \"\"\"default\"\"\"\n\nfilters = \"[('ignore', None, <type 'exceptions.DeprecationWarning'>, None, 0), \n('ignore', None, <type 'exceptions.PendingDeprecationWarning'>, None, 0), \n('ignore', None, <type 'exceptions.ImportWarning'>, None, 0), \n('ignore', None, <type 'exceptions.BytesWarning'>, None, 0)]\"\n\nonce_registry = {}\n\ndef warn(*args,**kw):\n \"\"\n pass\n \ndef warn_explicit(*args,**kw):\n \"\"\n pass\n"], "ui.dialog": [".py", "from . import widget\nfrom browser import html, document\n\nclass Dialog(widget.DraggableWidget):\n def __init__(self, id=None):\n  self._div_shell=html.DIV(\n  Class=\"ui-dialog ui-widget ui-widget-content ui-corner-all ui-front ui-draggable ui-resizable\",\n  style={'position': 'absolute', 'height': 'auto', 'width': '300px',\n  'top': '98px', 'left': '140px', 'display': 'block'})\n  \n  widget.DraggableWidget.__init__(self, self._div_shell, 'dialog', id)\n  \n  _div_titlebar=html.DIV(Id=\"titlebar\",\n  Class=\"ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix\")\n  self._div_shell <= _div_titlebar\n  \n  self._div_title=html.SPAN(Id=\"title\", Class=\"ui-dialog-title\")\n  \n  _div_titlebar <= self._div_title\n  \n  self._title_button=html.BUTTON(Title=\"close\",\n  Class=\"ui-button ui-widget ui-state-default ui-corner-all ui-button-icon-only ui-dialog-titlebar-close\")\n  \n  def dialog_close(e):\n  \n   del document[self._div_shell.id]\n   \n  self._title_button.bind('click', dialog_close)\n  _span=html.SPAN(Class=\"ui-button-icon-primary ui-icon ui-icon-closethick\")\n  self._title_button <= _span\n  \n  _span=html.SPAN('close', Class=\"ui-button-text\")\n  self._title_button <= _span\n  \n  _div_titlebar <= self._title_button\n  \n  self._div_dialog=html.DIV(Class=\"ui-dialog-content ui-widget-content\",\n  style={'width': 'auto', 'min-height': '105px', \n  'max-height': 'none', 'height': 'auto'})\n  \n  self._div_shell <= self._div_dialog\n  \n  for _i in ['n', 'e', 's', 'w', 'se', 'sw', 'ne', 'nw']:\n   if _i == 'se':\n    _class=\"ui-resizable-handle ui-resizable-%s ui-icon ui-icon-gripsmall-diagonal-%s\" % (_i, _i)\n   else:\n    _class=\"ui-resizable-handle ui-resizable-%s\" % _i\n    \n   self._div_shell <= html.DIV(Class=_class, style={'z-index': '90'})\n   \n  document <= self._div_shell\n  \n def set_title(self, title):\n  self._div_title.set_text(title)\n  \n def set_body(self, body):\n  self._div_dialog.set_html(body)\n  \nclass EntryDialog(Dialog):\n\n def __init__(self, title, prompt, action, _id=None):\n  Dialog.__init__(self, _id)\n  self.set_title(title)\n  self.action = action\n  d_prompt = html.DIV(prompt, Class=\"ui-widget\", \n  style=dict(float=\"left\",paddingRight=\"10px\"))\n  self.entry = html.INPUT()\n  body = html.DIV(d_prompt+self.entry,\n  style={'padding':'15px'})\n  b_ok = html.BUTTON(\"Ok\")\n  b_ok.bind('click', self.ok)\n  b_cancel = html.BUTTON(\"Cancel\")\n  b_cancel.bind('click', self.cancel)\n  body += html.DIV(b_ok+b_cancel, style={'padding':'15px'})\n  self._div_dialog <= body\n  \n def ok(self, ev):\n  self.result = self._div_shell.get(selector='INPUT')[0].value\n  self.action(self.result)\n  document.remove(self._div_shell)\n  \n def cancel(self, ev):\n  document.remove(self._div_shell)\n  \nclass SelectDialog(Dialog):\n\n def __init__(self, title, prompt, options, action, _id=None):\n  Dialog.__init__(self, _id)\n  self.set_title(title)\n  self.options = options\n  self.action = action\n  d_prompt = html.DIV(prompt, Class=\"ui-widget\", \n  style=dict(float=\"left\",paddingRight=\"10px\"))\n  self.select = html.SELECT()\n  for option in options:\n   self.select <= html.OPTION(option)\n  body = html.DIV(d_prompt+self.select,\n  style={'padding':'15px'})\n  b_ok = html.BUTTON(\"Ok\")\n  b_ok.bind('click', self.ok)\n  b_cancel = html.BUTTON(\"Cancel\")\n  b_cancel.bind('click', self.cancel)\n  body += html.DIV(b_ok+b_cancel, style={'padding':'15px'})\n  self._div_dialog <= body\n  \n def ok(self, ev):\n  ix = self._div_shell.get(selector='SELECT')[0].selectedIndex\n  document.remove(self._div_shell)\n  self.action(self.options[ix])\n  \n def cancel(self, ev):\n  document.remove(self._div_shell)\n  \nclass YesNoDialog(Dialog):\n\n def __init__(self, title, prompt, action_if_yes, action_if_no, _id=None):\n  Dialog.__init__(self, _id)\n  self.set_title(title)\n  \n  self.action_if_yes = action_if_yes\n  self.action_if_no = action_if_no\n  \n  d_prompt = html.DIV(prompt, Class=\"ui-widget\", \n  style=dict(float=\"left\",paddingRight=\"10px\"))\n  body = html.DIV(d_prompt, style={'padding':'15px'})\n  b_ok = html.BUTTON(\"Yes\")\n  b_ok.bind('click', self.yes)\n  b_cancel = html.BUTTON(\"No\")\n  b_cancel.bind('click', self.no)\n  body += html.DIV(b_ok+b_cancel, style={'padding':'15px'})\n  self._div_dialog <= body\n  \n def yes(self, ev):\n  document.remove(self._div_shell)\n  self.action_if_yes(self)\n  \n def no(self, ev):\n  document.remove(self._div_shell)\n  if self.action_if_no is not None:\n   self.action_if_no(self)\n"], "fractions": [".py", "\n\n\n\"\"\n\nfrom decimal import Decimal\nimport math\nimport numbers\nimport operator\nimport re\nimport sys\n\n__all__ = ['Fraction', 'gcd']\n\n\n\ndef gcd(a, b):\n \"\"\n while b:\n  a, b = b, a%b\n return a\n \n \n \n_PyHASH_MODULUS = sys.hash_info.modulus\n\n\n_PyHASH_INF = sys.hash_info.inf\n\n_RATIONAL_FORMAT = re.compile(r\"\"\"\n    \\A\\s*                      # optional whitespace at the start, then\n    (?P<sign>[-+]?)            # an optional sign, then\n    (?=\\d|\\.\\d)                # lookahead for digit or .digit\n    (?P<num>\\d*)               # numerator (possibly empty)\n    (?:                        # followed by\n       (?:/(?P<denom>\\d+))?    # an optional denominator\n    |                          # or\n       (?:\\.(?P<decimal>\\d*))? # an optional fractional part\n       (?:E(?P<exp>[-+]?\\d+))? # and optional exponent\n    )\n    \\s*\\Z                      # and optional whitespace to finish\n\"\"\", re.VERBOSE | re.IGNORECASE)\n\n\nclass Fraction(numbers.Rational):\n \"\"\n \n __slots__ = ('_numerator', '_denominator')\n \n \n def __new__(cls, numerator=0, denominator=None):\n  \"\"\n  self = super(Fraction, cls).__new__(cls)\n  \n  if denominator is None:\n   if isinstance(numerator, numbers.Rational):\n    self._numerator = numerator.numerator\n    self._denominator = numerator.denominator\n    return self\n    \n   elif isinstance(numerator, float):\n   \n    value = Fraction.from_float(numerator)\n    self._numerator = value._numerator\n    self._denominator = value._denominator\n    return self\n    \n   elif isinstance(numerator, Decimal):\n    value = Fraction.from_decimal(numerator)\n    self._numerator = value._numerator\n    self._denominator = value._denominator\n    return self\n    \n   elif isinstance(numerator, str):\n   \n    m = _RATIONAL_FORMAT.match(numerator)\n    if m is None:\n     raise ValueError('Invalid literal for Fraction: %r' %\n     numerator)\n    numerator = int(m.group('num') or '0')\n    denom = m.group('denom')\n    if denom:\n     denominator = int(denom)\n    else:\n     denominator = 1\n     decimal = m.group('decimal')\n     if decimal:\n      scale = 10**len(decimal)\n      numerator = numerator * scale + int(decimal)\n      denominator *= scale\n     exp = m.group('exp')\n     if exp:\n      exp = int(exp)\n      if exp >= 0:\n       numerator *= 10**exp\n      else:\n       denominator *= 10**-exp\n    if m.group('sign') == '-':\n     numerator = -numerator\n     \n   else:\n    raise TypeError(\"argument should be a string \"\n    \"or a Rational instance\")\n    \n  elif (isinstance(numerator, numbers.Rational) and\n  isinstance(denominator, numbers.Rational)):\n   numerator, denominator = (\n   numerator.numerator * denominator.denominator,\n   denominator.numerator * numerator.denominator\n   )\n  else:\n   raise TypeError(\"both arguments should be \"\n   \"Rational instances\")\n   \n  if denominator == 0:\n   raise ZeroDivisionError('Fraction(%s, 0)' % numerator)\n  g = gcd(numerator, denominator)\n  self._numerator = numerator // g\n  self._denominator = denominator // g\n  return self\n  \n @classmethod\n def from_float(cls, f):\n  \"\"\n  if isinstance(f, numbers.Integral):\n   return cls(f)\n  elif not isinstance(f, float):\n   raise TypeError(\"%s.from_float() only takes floats, not %r (%s)\" %\n   (cls.__name__, f, type(f).__name__))\n  if math.isnan(f):\n   raise ValueError(\"Cannot convert %r to %s.\" % (f, cls.__name__))\n  if math.isinf(f):\n   raise OverflowError(\"Cannot convert %r to %s.\" % (f, cls.__name__))\n  return cls(*f.as_integer_ratio())\n  \n @classmethod\n def from_decimal(cls, dec):\n  \"\"\n  from decimal import Decimal\n  if isinstance(dec, numbers.Integral):\n   dec = Decimal(int(dec))\n  elif not isinstance(dec, Decimal):\n   raise TypeError(\n   \"%s.from_decimal() only takes Decimals, not %r (%s)\" %\n   (cls.__name__, dec, type(dec).__name__))\n  if dec.is_infinite():\n   raise OverflowError(\n   \"Cannot convert %s to %s.\" % (dec, cls.__name__))\n  if dec.is_nan():\n   raise ValueError(\"Cannot convert %s to %s.\" % (dec, cls.__name__))\n  sign, digits, exp = dec.as_tuple()\n  digits = int(''.join(map(str, digits)))\n  if sign:\n   digits = -digits\n  if exp >= 0:\n   return cls(digits * 10 ** exp)\n  else:\n   return cls(digits, 10 ** -exp)\n   \n def limit_denominator(self, max_denominator=1000000):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if max_denominator < 1:\n   raise ValueError(\"max_denominator should be at least 1\")\n  if self._denominator <= max_denominator:\n   return Fraction(self)\n   \n  p0, q0, p1, q1 = 0, 1, 1, 0\n  n, d = self._numerator, self._denominator\n  while True:\n   a = n//d\n   q2 = q0+a*q1\n   if q2 > max_denominator:\n    break\n   p0, q0, p1, q1 = p1, q1, p0+a*p1, q2\n   n, d = d, n-a*d\n   \n  k = (max_denominator-q0)//q1\n  bound1 = Fraction(p0+k*p1, q0+k*q1)\n  bound2 = Fraction(p1, q1)\n  if abs(bound2 - self) <= abs(bound1-self):\n   return bound2\n  else:\n   return bound1\n   \n @property\n def numerator(a):\n  return a._numerator\n  \n @property\n def denominator(a):\n  return a._denominator\n  \n def __repr__(self):\n  \"\"\n  return ('Fraction(%s, %s)' % (self._numerator, self._denominator))\n  \n def __str__(self):\n  \"\"\n  if self._denominator == 1:\n   return str(self._numerator)\n  else:\n   return '%s/%s' % (self._numerator, self._denominator)\n   \n def _operator_fallbacks(monomorphic_operator, fallback_operator):\n  \"\"\n  def forward(a, b):\n   if isinstance(b, (int, Fraction)):\n    return monomorphic_operator(a, b)\n   elif isinstance(b, float):\n    return fallback_operator(float(a), b)\n   elif isinstance(b, complex):\n    return fallback_operator(complex(a), b)\n   else:\n    return NotImplemented\n  forward.__name__ = '__' + fallback_operator.__name__ + '__'\n  forward.__doc__ = monomorphic_operator.__doc__\n  \n  def reverse(b, a):\n   if isinstance(a, numbers.Rational):\n   \n    return monomorphic_operator(a, b)\n   elif isinstance(a, numbers.Real):\n    return fallback_operator(float(a), float(b))\n   elif isinstance(a, numbers.Complex):\n    return fallback_operator(complex(a), complex(b))\n   else:\n    return NotImplemented\n  reverse.__name__ = '__r' + fallback_operator.__name__ + '__'\n  reverse.__doc__ = monomorphic_operator.__doc__\n  \n  return forward, reverse\n  \n def _add(a, b):\n  \"\"\n  return Fraction(a.numerator * b.denominator +\n  b.numerator * a.denominator,\n  a.denominator * b.denominator)\n  \n __add__, __radd__ = _operator_fallbacks(_add, operator.add)\n \n def _sub(a, b):\n  \"\"\n  return Fraction(a.numerator * b.denominator -\n  b.numerator * a.denominator,\n  a.denominator * b.denominator)\n  \n __sub__, __rsub__ = _operator_fallbacks(_sub, operator.sub)\n \n def _mul(a, b):\n  \"\"\n  return Fraction(a.numerator * b.numerator, a.denominator * b.denominator)\n  \n __mul__, __rmul__ = _operator_fallbacks(_mul, operator.mul)\n \n def _div(a, b):\n  \"\"\n  return Fraction(a.numerator * b.denominator,\n  a.denominator * b.numerator)\n  \n __truediv__, __rtruediv__ = _operator_fallbacks(_div, operator.truediv)\n \n def __floordiv__(a, b):\n  \"\"\n  return math.floor(a / b)\n  \n def __rfloordiv__(b, a):\n  \"\"\n  return math.floor(a / b)\n  \n def __mod__(a, b):\n  \"\"\n  div = a // b\n  return a - b * div\n  \n def __rmod__(b, a):\n  \"\"\n  div = a // b\n  return a - b * div\n  \n def __pow__(a, b):\n  \"\"\n  if isinstance(b, numbers.Rational):\n   if b.denominator == 1:\n    power = b.numerator\n    if power >= 0:\n     return Fraction(a._numerator ** power,\n     a._denominator ** power)\n    else:\n     return Fraction(a._denominator ** -power,\n     a._numerator ** -power)\n   else:\n   \n   \n    return float(a) ** float(b)\n  else:\n   return float(a) ** b\n   \n def __rpow__(b, a):\n  \"\"\n  if b._denominator == 1 and b._numerator >= 0:\n  \n   return a ** b._numerator\n   \n  if isinstance(a, numbers.Rational):\n   return Fraction(a.numerator, a.denominator) ** b\n   \n  if b._denominator == 1:\n   return a ** b._numerator\n   \n  return a ** float(b)\n  \n def __pos__(a):\n  \"\"\n  return Fraction(a._numerator, a._denominator)\n  \n def __neg__(a):\n  \"\"\n  return Fraction(-a._numerator, a._denominator)\n  \n def __abs__(a):\n  \"\"\n  return Fraction(abs(a._numerator), a._denominator)\n  \n def __trunc__(a):\n  \"\"\n  if a._numerator < 0:\n   return -(-a._numerator // a._denominator)\n  else:\n   return a._numerator // a._denominator\n   \n def __floor__(a):\n  \"\"\n  return a.numerator // a.denominator\n  \n def __ceil__(a):\n  \"\"\n  \n  return -(-a.numerator // a.denominator)\n  \n def __round__(self, ndigits=None):\n  \"\"\n  if ndigits is None:\n   floor, remainder = divmod(self.numerator, self.denominator)\n   if remainder * 2 < self.denominator:\n    return floor\n   elif remainder * 2 > self.denominator:\n    return floor + 1\n    \n   elif floor % 2 == 0:\n    return floor\n   else:\n    return floor + 1\n  shift = 10**abs(ndigits)\n  \n  \n  \n  if ndigits > 0:\n   return Fraction(round(self * shift), shift)\n  else:\n   return Fraction(round(self / shift) * shift)\n   \n def __hash__(self):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  dinv = pow(self._denominator, _PyHASH_MODULUS - 2, _PyHASH_MODULUS)\n  if not dinv:\n   hash_ = _PyHASH_INF\n  else:\n   hash_ = abs(self._numerator) * dinv % _PyHASH_MODULUS\n  result = hash_ if self >= 0 else -hash_\n  return -2 if result == -1 else result\n  \n def __eq__(a, b):\n  \"\"\n  if isinstance(b, numbers.Rational):\n   return (a._numerator == b.numerator and\n   a._denominator == b.denominator)\n  if isinstance(b, numbers.Complex) and b.imag == 0:\n   b = b.real\n  if isinstance(b, float):\n   if math.isnan(b) or math.isinf(b):\n   \n   \n    return 0.0 == b\n   else:\n    return a == a.from_float(b)\n  else:\n  \n  \n   return NotImplemented\n   \n def _richcmp(self, other, op):\n  \"\"\n  \n  if isinstance(other, numbers.Rational):\n   return op(self._numerator * other.denominator,\n   self._denominator * other.numerator)\n  if isinstance(other, float):\n   if math.isnan(other) or math.isinf(other):\n    return op(0.0, other)\n   else:\n    return op(self, self.from_float(other))\n  else:\n   return NotImplemented\n   \n def __lt__(a, b):\n  \"\"\n  return a._richcmp(b, operator.lt)\n  \n def __gt__(a, b):\n  \"\"\n  return a._richcmp(b, operator.gt)\n  \n def __le__(a, b):\n  \"\"\n  return a._richcmp(b, operator.le)\n  \n def __ge__(a, b):\n  \"\"\n  return a._richcmp(b, operator.ge)\n  \n def __bool__(a):\n  \"\"\n  return a._numerator != 0\n  \n  \n  \n def __reduce__(self):\n  return (self.__class__, (str(self),))\n  \n def __copy__(self):\n  if type(self) == Fraction:\n   return self \n  return self.__class__(self._numerator, self._denominator)\n  \n def __deepcopy__(self, memo):\n  if type(self) == Fraction:\n   return self \n  return self.__class__(self._numerator, self._denominator)\n"], "xml.dom.NodeFilter": [".py", "\n\n\nclass NodeFilter:\n \"\"\n FILTER_ACCEPT = 1\n FILTER_REJECT = 2\n FILTER_SKIP = 3\n \n SHOW_ALL = 0xFFFFFFFF\n SHOW_ELEMENT = 0x00000001\n SHOW_ATTRIBUTE = 0x00000002\n SHOW_TEXT = 0x00000004\n SHOW_CDATA_SECTION = 0x00000008\n SHOW_ENTITY_REFERENCE = 0x00000010\n SHOW_ENTITY = 0x00000020\n SHOW_PROCESSING_INSTRUCTION = 0x00000040\n SHOW_COMMENT = 0x00000080\n SHOW_DOCUMENT = 0x00000100\n SHOW_DOCUMENT_TYPE = 0x00000200\n SHOW_DOCUMENT_FRAGMENT = 0x00000400\n SHOW_NOTATION = 0x00000800\n \n def acceptNode(self, node):\n  raise NotImplementedError\n"], "long_int1": [".py", "from browser import html, document, window\nimport javascript\n\n\n\ndef _get_value(other):\n if isinstance(other, LongInt):\n  return other.value\n return other\n \n \nclass BigInt:\n def __init__(self):\n  pass\n  \n def __abs__(self):\n  return LongInt(self.value.abs())\n  \n def __add__(self, other):\n  return LongInt(self.value.plus(_get_value(other)))\n  \n def __and__(self, other):\n  pass\n  \n def __divmod__(self, other):\n  _value=_get_value(other)\n  return LongInt(self.value.div(_value)), LongInt(self.value.mod(_value))\n  \n def __div__(self, other):\n  return LongInt(self.value.div(_get_value(other)))\n  \n def __eq__(self, other):\n  return bool(self.value.eq(_get_value(other)))\n  \n def __floordiv__(self, other):\n  return LongInt(self.value.div(_get_value(other)).floor())\n  \n def __ge__(self, other):\n  return bool(self.value.gte(_get_value(other)))\n  \n def __gt__(self, other):\n  return bool(self.value.gt(_get_value(other)))\n  \n def __index__(self):\n  if self.value.isInt():\n   return int(self.value.toNumber())\n   \n  raise TypeError(\"This is not an integer\")\n  \n def __le__(self, other):\n  return bool(self.value.lte(_get_value(other)))\n  \n def __lt__(self, other):\n  return bool(self.value.lt(_get_value(other)))\n  \n def __lshift__(self, shift):\n  if isinstance(shift, int):\n   _v=LongInt(2)**shift\n   return LongInt(self.value.times(_v.value))\n   \n def __mod__(self, other):\n  return LongInt(self.value.mod(_get_value(other)))\n  \n def __mul__(self, other):\n  return LongInt(self.value.times(_get_value(other)))\n  \n def __neg__(self, other):\n  return LongInt(self.value.neg(_get_value(other)))\n  \n def __or__(self, other):\n  pass\n  \n def __pow__(self, other):\n  return LongInt(self.value.pow(_get_value(other)))\n  \n def __rshift__(self, other):\n  pass\n  \n def __sub__(self, other):\n  return LongInt(self.value.minus(_get_value(other)))\n  \n def __repr__(self):\n  return \"%s(%s)\" % (self.__name__, self.value.toString(10))\n  \n def __str__(self):\n  return \"%s(%s)\" % (self.__name__, self.value.toString(10))\n  \n def __xor__(self, other):\n  pass\n  \n  \n_precision=20\ndef get_precision(value):\n if isinstance(value, LongInt):\n  return len(str(value.value.toString(10)))\n return len(str(value))\n \nclass DecimalJS(BigInt):\n def __init__(self, value=0, base=10):\n  global _precision\n  _prec=get_precision(value)\n  if _prec > _precision:\n   _precision=_prec\n   window.eval('Decimal.precision=%s' % _precision)\n   \n  self.value=javascript.JSConstructor(window.Decimal)(value, base)\n  \nclass BigNumberJS(BigInt):\n def __init__(self, value=0, base=10):\n  self.value=javascript.JSConstructor(window.BigNumber)(value, base)\n  \nclass BigJS(BigInt):\n def __init__(self, value=0, base=10):\n  self.value=javascript.JSConstructor(window.Big)(value, base)\n  \n def __floordiv__(self, other):\n  _v=LongInt(self.value.div(_get_value(other)))\n  if _v >= 0:\n   return LongInt(_v.value.round(0, 0)) \n   \n  return LongInt(_v.value.round(0, 3)) \n  \n def __pow__(self, other):\n  if isinstance(other, LongInt):\n   _value=int(other.value.toString(10))\n  elif isinstance(other, str):\n   _value=int(other)\n   \n  return LongInt(self.value.pow(_value))\n  \n  \n_path = __file__[:__file__.rfind('/')]+'/'\n\n\n\n\n\n\njavascript.load(_path+'bignumber.min.js', ['BigNumber'])\nLongInt=BigNumberJS\n\n\n\n\n\n", 1], "xml.etree.ElementInclude": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport copy\nfrom . import ElementTree\n\nXINCLUDE = \"{http://www.w3.org/2001/XInclude}\"\n\nXINCLUDE_INCLUDE = XINCLUDE + \"include\"\nXINCLUDE_FALLBACK = XINCLUDE + \"fallback\"\n\n\n\n\nclass FatalIncludeError(SyntaxError):\n pass\n \n \n \n \n \n \n \n \n \n \n \n \n \ndef default_loader(href, parse, encoding=None):\n if parse == \"xml\":\n  file = open(href, 'rb')\n  data = ElementTree.parse(file).getroot()\n else:\n  if not encoding:\n   encoding = 'UTF-8'\n  file = open(href, 'r', encoding=encoding)\n  data = file.read()\n file.close()\n return data\n \n \n \n \n \n \n \n \n \n \n \n \ndef include(elem, loader=None):\n if loader is None:\n  loader = default_loader\n  \n i = 0\n while i < len(elem):\n  e = elem[i]\n  if e.tag == XINCLUDE_INCLUDE:\n  \n   href = e.get(\"href\")\n   parse = e.get(\"parse\", \"xml\")\n   if parse == \"xml\":\n    node = loader(href, parse)\n    if node is None:\n     raise FatalIncludeError(\n     \"cannot load %r as %r\" % (href, parse)\n     )\n    node = copy.copy(node)\n    if e.tail:\n     node.tail = (node.tail or \"\") + e.tail\n    elem[i] = node\n   elif parse == \"text\":\n    text = loader(href, parse, e.get(\"encoding\"))\n    if text is None:\n     raise FatalIncludeError(\n     \"cannot load %r as %r\" % (href, parse)\n     )\n    if i:\n     node = elem[i-1]\n     node.tail = (node.tail or \"\") + text + (e.tail or \"\")\n    else:\n     elem.text = (elem.text or \"\") + text + (e.tail or \"\")\n    del elem[i]\n    continue\n   else:\n    raise FatalIncludeError(\n    \"unknown parse type in xi:include tag (%r)\" % parse\n    )\n  elif e.tag == XINCLUDE_FALLBACK:\n   raise FatalIncludeError(\n   \"xi:fallback tag must be child of xi:include (%r)\" % e.tag\n   )\n  else:\n   include(e, loader)\n  i = i + 1\n"], "long_int1.bignumber.min": [".js", "/*! bignumber.js v2.0.0 https://github.com/MikeMcl/bignumber.js/LICENCE */\n(function(n){\"use strict\";function t(n,i){var b,a,l,p,o,w,s=this;if(!(s instanceof t))return new t(n,i);if(n instanceof t){if(i==null){u=0;s.s=n.s;s.e=n.e;s.c=(n=n.c)?n.slice():n;return}n+=\"\"}else if(p=(o=typeof n)==\"number\"){if(i==null&&n===~~n){for(s.s=1/n<0?(n=-n,-1):1,a=u=0,l=n;l>=10;l/=10,a++);s.e=a;s.c=[n];return}n=n===0&&1/n<0?\"-0\":n+\"\"}else o!=\"string\"&&(n+=\"\");if(o=n,i==null&&ft.test(o))s.s=o.charCodeAt(0)===45?(o=o.slice(1),-1):1;else{if(i==10)return s=new t(o),y(s,c+s.e+1,h);if(o=lt.call(o).replace(/^\\+(?!-)/,\"\"),s.s=o.charCodeAt(0)===45?(o=o.replace(/^-(?!-)/,\"\"),-1):1,i!=null?i!=~~i&&d||(e=!(i>=2&&i<65))?(f(i,2),w=ft.test(o)):(b=\"[\"+ut.slice(0,i=i|0)+\"]+\",o=o.replace(/\\.$/,\"\").replace(/^\\./,\"0.\"),(w=new RegExp(\"^\"+b+\"(?:\\\\.\"+b+\")?$\",i<37?\"i\":\"\").test(o))?(p&&(o.replace(/^0\\.0*|\\./,\"\").length>15&&f(n,0),p=!p),o=ct(o,10,i,s.s)):o!=\"Infinity\"&&o!=\"NaN\"&&(f(n,1,i),n=\"NaN\")):w=ft.test(o),!w){s.c=s.e=null;o!=\"Infinity\"&&(o!=\"NaN\"&&f(n,3),s.s=null);u=0;return}}for((a=o.indexOf(\".\"))>-1&&(o=o.replace(\".\",\"\")),(l=o.search(/e/i))>0?(a<0&&(a=l),a+=+o.slice(l+1),o=o.substring(0,l)):a<0&&(a=o.length),l=0;o.charCodeAt(l)===48;l++);for(i=o.length;o.charCodeAt(--i)===48;);if(o=o.slice(l,i+1),o)if(i=o.length,p&&i>15&&f(n,0),a=a-l-1,a>v)s.c=s.e=null;else if(a<nt)s.c=[s.e=0];else{if(s.e=a,s.c=[],l=(a+1)%r,a<0&&(l+=r),l<i){for(l&&s.c.push(+o.slice(0,l)),i-=r;l<i;s.c.push(+o.slice(l,l+=r)));o=o.slice(l);l=r-o.length}else l-=i;for(;l--;o+=\"0\");s.c.push(+o)}else s.c=[s.e=0];u=0}function et(n,t,i){for(var f=1,u=t.length;!t[--u];t.pop());for(u=t[0];u>=10;u/=10,f++);return(i=f+i*r-1)>v?n.c=n.e=null:i<nt?n.c=[n.e=0]:(n.e=i,n.c=t),n}function tt(n){for(var t,f,e=1,i=n.length,u=n[0]+\"\";e<i;){for(t=n[e++]+\"\",f=r-t.length;f--;t=\"0\"+t);u+=t}for(i=u.length;u.charCodeAt(--i)===48;);return u.slice(0,i+1||1)}function ht(n,t,i){for(var u,r=[0],f,e=0,o=n.length;e<o;){for(f=r.length;f--;r[f]*=t);for(r[u=0]+=ut.indexOf(n.charAt(e++));u<r.length;u++)r[u]>i-1&&(r[u+1]==null&&(r[u+1]=0),r[u+1]+=r[u]/i|0,r[u]%=i)}return r.reverse()}function ct(n,i,r,u){var l,e,v,y,s,f,w,o=n.indexOf(\".\"),p=h;for(r<37&&(n=n.toLowerCase()),o>=0&&(n=n.replace(\".\",\"\"),w=new t(r),s=w.pow(n.length-o),w.c=ht(s.toFixed(),10,i),w.e=w.c.length),f=ht(n,r,i),e=v=f.length;f[--v]==0;f.pop());if(!f[0])return\"0\";if(o<0?--e:(s.c=f,s.e=e,s.s=u,s=a(s,w,c,p,i),f=s.c,y=s.r,e=s.e),l=e+c+1,o=f[l],v=i/2,y=y||l<0||f[l+1]!=null,y=p<4?(o!=null||y)&&(p==0||p==(s.s<0?3:2)):o>v||o==v&&(p==4||y||p==6&&f[l-1]&1||p==(s.s<0?8:7)),l<1||!f[0])f.length=1,v=0,y?(f[0]=1,e=-c):e=f[0]=0;else{if(f.length=l,y)for(--i;++f[--l]>i;)f[l]=0,l||(++e,f.unshift(1));for(v=f.length;!f[--v];);}for(o=0,n=\"\";o<=v;n+=ut.charAt(f[o++]));if(e<0){for(;++e;n=\"0\"+n);n=\"0.\"+n}else if(o=n.length,++e>o)for(e-=o;e--;n+=\"0\");else e<o&&(n=n.slice(0,e)+\".\"+n.slice(e));return n}function rt(n,i,r){var o,u,e,f=(n=new t(n)).e;if(i==null?o=0:(y(n,++i,h),o=r?i:i+n.e-f,f=n.e),u=tt(n.c),r==1||r==2&&(i<=f||f<=p)){for(;u.length<o;u+=\"0\");u.length>1&&(u=u.charAt(0)+\".\"+u.slice(1));u+=(f<0?\"e\":\"e+\")+f}else{if(r=u.length,f<0){for(e=o-r;++f;u=\"0\"+u);u=\"0.\"+u}else if(++f>r){for(e=o-f,f-=r;f--;u+=\"0\");e>0&&(u+=\".\")}else e=o-r,f<r?u=u.slice(0,f)+\".\"+u.slice(f):e>0&&(u+=\".\");if(e>0)for(;e--;u+=\"0\");}return n.s<0&&n.c[0]?\"-\"+u:u}function f(n,t,i,r,f,o){if(d){var c,s=[\"new BigNumber\",\"cmp\",\"div\",\"eq\",\"gt\",\"gte\",\"lt\",\"lte\",\"minus\",\"mod\",\"plus\",\"times\",\"toFraction\",\"divToInt\"][u?u<0?-u:u:1/u<0?1:0]+\"()\",h=e?\" out of range\":\" not a\"+(f?\" non-zero\":\"n\")+\" integer\";h=([s+\" number type has more than 15 significant digits\",s+\" not a base \"+i+\" number\",s+\" base\"+h,s+\" not a number\"][t]||i+\"() \"+t+(o?\" not a boolean or binary digit\":h+(r?\" or not [\"+(e?\" negative, positive\":\" integer, integer\")+\" ]\":\"\")))+\": \"+n;e=u=0;c=new Error(h);c.name=\"BigNumber Error\";throw c;}}function y(n,t,i,u){var c,o,e,s,a,h,p,f,y=st;if(f=n.c){n:{for(c=1,s=f[0];s>=10;s/=10,c++);if(o=t-c,o<0)o+=r,e=t,a=f[h=0],p=a/y[c-e-1]%10|0;else if(h=Math.ceil((o+1)/r),h>=f.length)if(u){for(;f.length<=h;f.push(0));a=p=0;c=1;o%=r;e=o-r+1}else break n;else{for(a=s=f[h],c=1;s>=10;s/=10,c++);o%=r;e=o-r+c;p=e<0?0:a/y[c-e-1]%10|0}if(u=u||t<0||f[h+1]!=null||(e<0?a:a%y[c-e-1]),u=i<4?(p||u)&&(i==0||i==(n.s<0?3:2)):p>5||p==5&&(i==4||u||i==6&&(o>0?e>0?a/y[c-e]:0:f[h-1])%10&1||i==(n.s<0?8:7)),t<1||!f[0])return f.length=0,u?(t-=n.e+1,f[0]=y[t%r],n.e=-t||0):f[0]=n.e=0,n;if(o==0?(f.length=h,s=1,h--):(f.length=h+1,s=y[r-o],f[h]=e>0?g(a/y[c-e]%y[e])*s:0),u)for(;;)if(h==0){for(o=1,e=f[0];e>=10;e/=10,o++);for(e=f[0]+=s,s=1;e>=10;e/=10,s++);o!=s&&(n.e++,f[0]==l&&(f[0]=1));break}else{if(f[h]+=s,f[h]!=l)break;f[h--]=0;s=1}for(o=f.length;f[--o]===0;f.pop());}n.e>v?n.c=n.e=null:n.e<nt&&(n.c=[n.e=0])}return n}var o=1e9,ot=1e6,c=20,h=4,p=-7,k=21,nt=-o,v=o,d=!0,w=parseInt,b={decimalSeparator:\".\",groupSeparator:\",\",groupSize:3,secondaryGroupSize:0,fractionGroupSeparator:\"\u00a0\",fractionGroupSize:0},i=t.prototype,ut=\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\",e,u=0,g=Math.floor,ft=/^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,lt=String.prototype.trim||function(){return this.replace(/^\\s+|\\s+$/g,\"\")},l=1e14,r=14,s=1e7,st=[1,10,100,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1e10,1e11,1e12,1e13],it=new t(1),a;t.ROUND_UP=0;t.ROUND_DOWN=1;t.ROUND_CEIL=2;t.ROUND_FLOOR=3;t.ROUND_HALF_UP=4;t.ROUND_HALF_DOWN=5;t.ROUND_HALF_EVEN=6;t.ROUND_HALF_CEIL=7;t.ROUND_HALF_FLOOR=8;t.config=function(){var n,t,g=0,i={},y=arguments,a=y[0],s=\"config\",r=function(n,t,i){return!((e=n<t||n>i)||w(n)!=n&&n!==0)},l=a&&typeof a==\"object\"?function(){if(a.hasOwnProperty(t))return(n=a[t])!=null}:function(){if(y.length>g)return(n=y[g++])!=null};if(l(t=\"DECIMAL_PLACES\")&&(r(n,0,o)?c=n|0:f(n,t,s)),i[t]=c,l(t=\"ROUNDING_MODE\")&&(r(n,0,8)?h=n|0:f(n,t,s)),i[t]=h,l(t=\"EXPONENTIAL_AT\")&&(r(n,-o,o)?p=-(k=~~(n<0?-n:+n)):!e&&n&&r(n[0],-o,0)&&r(n[1],0,o)?(p=~~n[0],k=~~n[1]):f(n,t,s,1)),i[t]=[p,k],l(t=\"RANGE\")&&(r(n,-o,o)&&~~n?nt=-(v=~~(n<0?-n:+n)):!e&&n&&r(n[0],-o,-1)&&r(n[1],1,o)?(nt=~~n[0],v=~~n[1]):f(n,t,s,1,1)),i[t]=[nt,v],l(t=\"ERRORS\")&&(n===!!n||n===1||n===0?(e=u=0,w=(d=!!n)?parseInt:parseFloat):f(n,t,s,0,0,1)),i[t]=d,l(t=\"FORMAT\"))if(typeof n==\"object\")b=n;else if(d){i=new Error(s+\"() \"+t+\" not an object: \"+n);i.name=\"BigNumber Error\";throw i;}return i[t]=b,i};a=function(){function n(n,t,i){var f,e,o,h,r=0,u=n.length,c=t%s,l=t/s|0;for(n=n.slice();u--;)o=n[u]%s,h=n[u]/s|0,f=l*o+h*c,e=c*o+f%s*s+r,r=(e/i|0)+(f/s|0)+l*h,n[u]=e%i;return r&&n.unshift(r),n}function i(n,t,i,r){var u,f;if(i!=r)f=i>r?1:-1;else for(u=f=0;u<i;u++)if(n[u]!=t[u]){f=n[u]>t[u]?1:-1;break}return f}function u(n,t,i,r){for(var u=0;i--;)n[i]-=u,u=n[i]<t[i]?1:0,n[i]=u*r+n[i]-t[i];for(;!n[0]&&n.length>1;n.shift());}return function(f,e,o,s,h){var nt,ut,a,ot,p,tt,ft,it,et,v,w,st,ht,rt,lt,k,ct,d=f.s==e.s?1:-1,b=f.c,c=e.c;if(!b||!b[0]||!c||!c[0])return new t(!f.s||!e.s||(b?c&&b[0]==c[0]:!c)?NaN:b&&b[0]==0||!c?d*0:d/0);for(it=new t(d),et=it.c=[],ut=f.e-e.e,d=o+ut+1,h||(h=l,ut=(rt=f.e/r,a=rt|0,rt>0||rt===a?a:a-1)-(k=e.e/r,a=k|0,k>0||k===a?a:a-1),d=d/r|0),a=0;c[a]==(b[a]||0);a++);if(c[a]>(b[a]||0)&&ut--,d<0)et.push(1),ot=!0;else{for(rt=b.length,k=c.length,a=0,d+=2,p=g(h/(c[0]+1)),p>1&&(c=n(c,p,h),b=n(b,p,h),k=c.length,rt=b.length),ht=k,v=b.slice(0,k),w=v.length;w<k;v[w++]=0);ct=c.slice();ct.unshift(0);lt=c[0];c[1]>=h/2&&lt++;do p=0,nt=i(c,v,k,w),nt<0?(st=v[0],k!=w&&(st=st*h+(v[1]||0)),p=g(st/lt),p>1?(p>=h&&(p=h-1),tt=n(c,p,h),ft=tt.length,w=v.length,nt=i(tt,v,ft,w),nt==1&&(p--,u(tt,k<ft?ct:c,ft,h))):(p==0&&(nt=p=1),tt=c.slice()),ft=tt.length,ft<w&&tt.unshift(0),u(v,tt,w,h),nt==-1&&(w=v.length,nt=i(c,v,k,w),nt<1&&(p++,u(v,k<w?ct:c,w,h))),w=v.length):nt===0&&(p++,v=[0]),et[a++]=p,nt&&v[0]?v[w++]=b[ht]||0:(v=[b[ht]],w=1);while((ht++<rt||v[0]!=null)&&d--);ot=v[0]!=null;et[0]||et.shift()}if(h==l){for(a=1,d=et[0];d>=10;d/=10,a++);y(it,o+(it.e=a+ut*r-1)+1,s,ot)}else it.e=ut,it.r=+ot;return it}}();i.absoluteValue=i.abs=function(){var n=new t(this);return n.s<0&&(n.s=1),n};i.ceil=function(){return y(new t(this),this.e+1,2)};i.comparedTo=i.cmp=function(n,i){var f,l=this,e=l.c,o=(u=-u,n=new t(n,i)).c,r=l.s,c=n.s,s=l.e,h=n.e;if(!r||!c)return null;if(f=e&&!e[0],i=o&&!o[0],f||i)return f?i?0:-c:r;if(r!=c)return r;if(f=r<0,i=s==h,!e||!o)return i?0:!e^f?1:-1;if(!i)return s>h^f?1:-1;for(r=-1,c=(s=e.length)<(h=o.length)?s:h;++r<c;)if(e[r]!=o[r])return e[r]>o[r]^f?1:-1;return s==h?0:s>h^f?1:-1};i.decimalPlaces=i.dp=function(){var n,t,i=this.c;if(!i)return null;if(n=((t=i.length-1)-g(this.e/r))*r,t=i[t])for(;t%10==0;t/=10,n--);return n<0&&(n=0),n};i.dividedBy=i.div=function(n,i){return u=2,a(this,new t(n,i),c,h)};i.dividedToIntegerBy=i.divToInt=function(n,i){return u=13,a(this,new t(n,i),0,1)};i.equals=i.eq=function(n,t){return u=3,this.cmp(n,t)===0};i.floor=function(){return y(new t(this),this.e+1,3)};i.greaterThan=i.gt=function(n,t){return u=4,this.cmp(n,t)>0};i.greaterThanOrEqualTo=i.gte=function(n,t){return u=5,(t=this.cmp(n,t))==1||t===0};i.isFinite=function(){return!!this.c};i.isInteger=i.isInt=function(){return!!this.c&&g(this.e/r)>this.c.length-2};i.isNaN=function(){return!this.s};i.isNegative=i.isNeg=function(){return this.s<0};i.isZero=function(){return!!this.c&&this.c[0]==0};i.lessThan=i.lt=function(n,t){return u=6,this.cmp(n,t)<0};i.lessThanOrEqualTo=i.lte=function(n,t){return u=7,(t=this.cmp(n,t))==-1||t===0};i.minus=function(n,i){var e,c,v,w,p=this,s=p.s;if(u=8,n=new t(n,i),i=n.s,!s||!i)return new t(NaN);if(s!=i)return n.s=-i,p.plus(n);var y=p.e/r,a=n.e/r,f=p.c,o=n.c;if(!y||!a){if(!f||!o)return f?(n.s=-i,n):new t(o?p:NaN);if(!f[0]||!o[0])return o[0]?(n.s=-i,n):new t(f[0]?p:h==3?-0:0)}if(e=y|0,y=y>0||y===e?e:e-1,e=a|0,a=a>0||a===e?e:e-1,f=f.slice(),s=y-a){for((w=s<0)?(s=-s,v=f):(a=y,v=o),v.reverse(),i=s;i--;v.push(0));v.reverse()}else for(c=(w=(s=f.length)<(i=o.length))?s:i,s=i=0;i<c;i++)if(f[i]!=o[i]){w=f[i]<o[i];break}if(w&&(v=f,f=o,o=v,n.s=-n.s),i=(c=o.length)-(e=f.length),i>0)for(;i--;f[e++]=0);for(i=l-1;c>s;){if(f[--c]<o[c]){for(e=c;e&&!f[--e];f[e]=i);--f[e];f[c]+=l}f[c]-=o[c]}for(;f[0]==0;f.shift(),--a);return f[0]?et(n,f,a):(n.s=h==3?-1:1,n.c=[n.e=0],n)};i.modulo=i.mod=function(n,i){u=9;var r=this,f=r.c,e=(n=new t(n,i)).c,o=r.s,s=n.s;return(i=!o||!s||e&&!e[0],i||f&&!f[0])?new t(i?NaN:r):(r.s=n.s=1,i=n.cmp(r)==1,r.s=o,n.s=s,i?new t(r):r.minus(a(r,n,0,1).times(n)))};i.negated=i.neg=function(){var n=new t(this);return n.s=-n.s||null,n};i.plus=function(n,i){var h,a=this,f=a.s;if(u=10,n=new t(n,i),i=n.s,!f||!i)return new t(NaN);if(f!=i)return n.s=-i,a.minus(n);var c=a.e/r,o=n.e/r,e=a.c,s=n.c;if(!c||!o){if(!e||!s)return new t(f/0);if(!e[0]||!s[0])return s[0]?n:new t(e[0]?a:f*0)}if(f=c|0,c=c>0||c===f?f:f-1,f=o|0,o=o>0||o===f?f:f-1,e=e.slice(),f=c-o){for(f>0?(o=c,h=s):(f=-f,h=e),h.reverse();f--;h.push(0));h.reverse()}for(f=e.length,i=s.length,f-i<0&&(h=s,s=e,e=h,i=f),f=0;i;)f=(e[--i]=e[i]+s[i]+f)/l|0,e[i]%=l;return f&&(e.unshift(f),++o),et(n,e,o)};i.round=function(n,i){return n=n==null||((e=n<0||n>o)||w(n)!=n)&&!f(n,\"decimal places\",\"round\")?0:n|0,i=i==null||((e=i<0||i>8)||w(i)!=i&&i!==0)&&!f(i,\"mode\",\"round\")?h:i|0,y(new t(this),n+this.e+1,i)};i.squareRoot=i.sqrt=function(){var v,i,r,s,f,e=this,o=e.c,n=e.s,u=e.e,l=c+4,p=new t(\"0.5\");if(n!==1||!o||!o[0])return new t(!n||n<0&&(!o||o[0])?NaN:o?e:1/0);if(n=Math.sqrt(+e),n==0||n==1/0?(i=tt(o),(i.length+u)%2==0&&(i+=\"0\"),n=Math.sqrt(i),u=g((u+1)/2)-(u<0||u%2),n==1/0?i=\"1e\"+u:(i=n.toExponential(),i=i.slice(0,i.indexOf(\"e\")+1)+u),r=new t(i)):r=new t(n.toString()),r.c[0])for(u=r.e,n=u+l,n<3&&(n=0);;)if(f=r,r=p.times(f.plus(a(e,f,l,1))),tt(f.c).slice(0,n)===(i=tt(r.c)).slice(0,n))if(r.e<u&&--n,i=i.slice(n-3,n+1),i!=\"9999\"&&(s||i!=\"4999\")){+i&&(+i.slice(1)||i.charAt(0)!=\"5\")||(y(r,r.e+c+2,1),v=!r.times(r).eq(e));break}else{if(!s&&(y(f,f.e+c+2,0),f.times(f).eq(e))){r=f;break}l+=4;n+=4;s=1}return y(r,r.e+c+1,h,v)};i.times=function(n,i){var p,e,w,b,a,y,k,d,g,nt=this,o=nt.c,h=(u=11,n=new t(n,i)).c,c=nt.e/r,f=n.e/r,v=nt.s;if(n.s=v==(i=n.s)?1:-1,!c&&(!o||!o[0])||!f&&(!h||!h[0]))return new t(!v||!i||o&&!o[0]&&!h||h&&!h[0]&&!o?NaN:!o||!h?n.s/0:n.s*0);for(e=(e=c|0,c>0||c===e?e:e-1)+(e=f|0,f>0||f===e?e:e-1),v=o.length,i=h.length,v<i&&(a=o,o=h,h=a,f=v,v=i,i=f),f=v+i,a=[];f--;a.push(0));for(c=i;--c>=0;){for(p=0,f=v+c,w=v,d=h[c]%s,g=h[c]/s|0;f>c;)y=o[--w]%s,k=o[w]/s|0,b=g*y+k*d,y=d*y+b%s*s+a[f]+p,p=(y/l|0)+(b/s|0)+g*k,a[f--]=y%l;a[f]=p}return p?++e:a.shift(),et(n,a,e)};i.toExponential=function(n){var t=this;return t.c?rt(t,n==null||((e=n<0||n>o)||w(n)!=n&&n!==0)&&!f(n,\"decimal places\",\"toExponential\")?null:n|0,1):t.toString()};i.toFixed=function(n){var t,i=this,r=p,u=k;return n=n==null||((e=n<0||n>o)||w(n)!=n&&n!==0)&&!f(n,\"decimal places\",\"toFixed\")?null:i.e+(n|0),p=-(k=1/0),n!=null&&i.c?(t=rt(i,n),i.s<0&&i.c&&(i.c[0]?t.indexOf(\"-\")<0&&(t=\"-\"+t):t=t.replace(\"-\",\"\"))):t=i.toString(),p=r,k=u,t};i.toFormat=function(n){var f=this;if(!f.c)return f.toString();var t,h=f.s<0,c=b.groupSeparator,r=+b.groupSize,u=+b.secondaryGroupSize,l=f.toFixed(n).split(\".\"),i=l[0],s=l[1],e=h?i.slice(1):i,o=e.length;if(u&&(t=r,r=u,u=t,o-=t),r>0&&o>0){for(t=o%r||r,i=e.substr(0,t);t<o;t+=r)i+=c+e.substr(t,r);u>0&&(i+=c+e.slice(t));h&&(i=\"-\"+i)}return s?i+b.decimalSeparator+((u=+b.fractionGroupSize)?s.replace(new RegExp(\"\\\\d{\"+u+\"}\\\\B\",\"g\"),\"$&\"+b.fractionGroupSeparator):s):i};i.toFraction=function(n){var ut,c,i,w,k,o,s,nt,rt,l=c=new t(it),y=s=new t(it),b=this,ft=b.c,p=new t(it);if(!ft)return b.toString();for(rt=tt(ft),w=p.e=rt.length-b.e-1,p.c[0]=st[(k=w%r)<0?r+k:k],(n==null||(!(u=12,o=new t(n)).s||(e=o.cmp(l)<0||!o.c)||d&&g(o.e/r)<o.c.length-1)&&!f(n,\"max denominator\",\"toFraction\")||(n=o).cmp(p)>0)&&(n=w>0?p:l),k=v,v=1/0,o=new t(rt),s.c[0]=0;;){if(nt=a(o,p,0,1),i=c.plus(nt.times(y)),i.cmp(n)==1)break;c=y;y=i;l=s.plus(nt.times(i=l));s=i;p=o.minus(nt.times(i=p));o=i}return i=a(n.minus(c),y,0,1),s=s.plus(i.times(l)),c=c.plus(i.times(y)),s.s=l.s=b.s,w*=2,ut=a(l,y,w,h).minus(b).abs().cmp(a(s,c,w,h).minus(b).abs())<1?[l.toString(),y.toString()]:[s.toString(),c.toString()],v=k,ut};i.toNumber=function(){var n=this;return+n||(n.s?0*n.s:NaN)};i.toPower=i.pow=function(n){var i=n*0==0?~~n:n,r=new t(this),u=new t(it);if(((e=n<-ot||n>ot)&&(i=n/0)||w(n)!=n&&n!==0&&!(i=NaN))&&!f(n,\"exponent\",\"pow\")||!i)return new t(Math.pow(+r,i));for(i=i<0?-i:i;;){if(i&1&&(u=u.times(r)),i>>=1,!i)break;r=r.times(r)}return n<0?it.div(u):u};i.toPrecision=function(n){var t=this;return n==null||((e=n<1||n>o)||w(n)!=n)&&!f(n,\"precision\",\"toPrecision\")||!t.c?t.toString():rt(t,--n|0,2)};i.toString=function(n){var r,t,o,u=this,i=u.e;if(i===null)t=u.s?\"Infinity\":\"NaN\";else{if(n==r&&(i<=p||i>=k))return rt(u,r,1);if(t=tt(u.c),i<0){for(;++i;t=\"0\"+t);t=\"0.\"+t}else if(o=t.length,i>0)if(++i>o)for(i-=o;i--;t+=\"0\");else i<o&&(t=t.slice(0,i)+\".\"+t.slice(i));else if(r=t.charAt(0),o>1)t=r+\".\"+t.slice(1);else if(r==\"0\")return r;if(n!=null)if((e=!(n>=2&&n<65))||n!=~~n&&d)f(n,\"base\",\"toS\");else if(t=ct(t,n|0,10,u.s),t==\"0\")return t}return u.s<0?\"-\"+t:t};i.valueOf=i.toJSON=function(){return this.toString()};typeof module!=\"undefined\"&&module.exports?module.exports=t:typeof define==\"function\"&&define.amd?define(function(){return t}):n.BigNumber=t})(this)"], "_codecs": [".py", "\ndef ascii_decode(*args,**kw):\n pass\n \ndef ascii_encode(*args,**kw):\n pass\n \ndef charbuffer_encode(*args,**kw):\n pass\n \ndef charmap_build(*args,**kw):\n pass\n \ndef charmap_decode(*args,**kw):\n pass\n \ndef charmap_encode(*args,**kw):\n pass\n \ndef decode(*args,**kw):\n \"\"\n pass\n \ndef encode(*args,**kw):\n \"\"\n pass\n \ndef escape_decode(*args,**kw):\n pass\n \ndef escape_encode(*args,**kw):\n pass\n \ndef latin_1_decode(*args,**kw):\n pass\n \ndef latin_1_encode(*args,**kw):\n pass\n \ndef lookup(encoding):\n \"\"\n \n if encoding in ('utf-8', 'utf_8'):\n  from javascript import console\n  console.log('encoding', encoding)\n  import encodings.utf_8\n  return encodings.utf_8.getregentry()\n  \n LookupError(encoding)\n \ndef lookup_error(*args,**kw):\n \"\"\n pass\n \ndef mbcs_decode(*args,**kw):\n pass\n \ndef mbcs_encode(*args,**kw):\n pass\n \ndef raw_unicode_escape_decode(*args,**kw):\n pass\n \ndef raw_unicode_escape_encode(*args,**kw):\n pass\n \ndef readbuffer_encode(*args,**kw):\n pass\n \ndef register(*args,**kw):\n \"\"\n pass\n \ndef register_error(*args,**kw):\n \"\"\n pass\n \ndef unicode_escape_decode(*args,**kw):\n pass\n \ndef unicode_escape_encode(*args,**kw):\n pass\n \ndef unicode_internal_decode(*args,**kw):\n pass\n \ndef unicode_internal_encode(*args,**kw):\n pass\n \ndef utf_16_be_decode(*args,**kw):\n pass\n \ndef utf_16_be_encode(*args,**kw):\n pass\n \ndef utf_16_decode(*args,**kw):\n pass\n \ndef utf_16_encode(*args,**kw):\n pass\n \ndef utf_16_ex_decode(*args,**kw):\n pass\n \ndef utf_16_le_decode(*args,**kw):\n pass\n \ndef utf_16_le_encode(*args,**kw):\n pass\n \ndef utf_32_be_decode(*args,**kw):\n pass\n \ndef utf_32_be_encode(*args,**kw):\n pass\n \ndef utf_32_decode(*args,**kw):\n pass\n \ndef utf_32_encode(*args,**kw):\n pass\n \ndef utf_32_ex_decode(*args,**kw):\n pass\n \ndef utf_32_le_decode(*args,**kw):\n pass\n \ndef utf_32_le_encode(*args,**kw):\n pass\n \ndef utf_7_decode(*args,**kw):\n pass\n \ndef utf_7_encode(*args,**kw):\n pass\n \ndef utf_8_decode(*args,**kw):\n pass\n \ndef utf_8_encode(*args,**kw):\n input=args[0]\n if len(args) == 2:\n  errors = args[1]\n else:\n  errors=kw.get('errors', 'strict')\n  \n  \n  \n return (bytes([_f for _f in input], 'utf-8'), len(input))\n"], "long_int1.big.min": [".js", "/*big.js v3.0.0 https://github.com/MikeMcl/big.js/LICENCE*/(function(n){\"use strict\";function c(){function n(t){var i=this;if(!(i instanceof n))return t===void 0?c():new n(t);t instanceof n?(i.s=t.s,i.e=t.e,i.c=t.c.slice()):y(i,t);i.constructor=n}return n.prototype=t,n.DP=l,n.RM=a,n}function s(n,t,i){var e=n.constructor,r=t-(n=new e(n)).e,f=n.c;for(f.length>++t&&o(n,r,e.RM),f[0]?i?r=t:(f=n.c,r=n.e+r+1):++r;f.length<r;f.push(0));return r=n.e,i===1||i&&(t<=r||r<=u)?(n.s<0&&f[0]?\"-\":\"\")+(f.length>1?f[0]+\".\"+f.join(\"\").slice(1):f[0])+(r<0?\"e\":\"e+\")+r:n.toString()}function y(n,t){var u,r,f;for(t===0&&1/t<0?t=\"-0\":v.test(t+=\"\")||i(NaN),n.s=t.charAt(0)==\"-\"?(t=t.slice(1),-1):1,(u=t.indexOf(\".\"))>-1&&(t=t.replace(\".\",\"\")),(r=t.search(/e/i))>0?(u<0&&(u=r),u+=+t.slice(r+1),t=t.substring(0,r)):u<0&&(u=t.length),r=0;t.charAt(r)==\"0\";r++);if(r==(f=t.length))n.c=[n.e=0];else{for(;t.charAt(--f)==\"0\";);for(n.e=u-r-1,n.c=[],u=0;r<=f;n.c[u++]=+t.charAt(r++));}return n}function o(n,t,r,u){var o,e=n.c,f=n.e+t+1;if(r===1?u=e[f]>=5:r===2?u=e[f]>5||e[f]==5&&(u||f<0||e[f+1]!==o||e[f-1]&1):r===3?u=u||e[f]!==o||f<0:(u=!1,r!==0&&i(\"!Big.RM!\")),f<1||!e[0])u?(n.e=-t,n.c=[1]):n.c=[n.e=0];else{if(e.length=f--,u)for(;++e[f]>9;)e[f]=0,f--||(++n.e,e.unshift(1));for(f=e.length;!e[--f];e.pop());}return n}function i(n){var t=new Error(n);t.name=\"BigError\";throw t;}var l=20,a=1,r=1e6,h=1e6,u=-7,f=21,t={},v=/^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,e;t.abs=function(){var n=new this.constructor(this);return n.s=1,n};t.cmp=function(n){var e,o=this,u=o.c,f=(n=new o.constructor(n)).c,t=o.s,s=n.s,i=o.e,r=n.e;if(!u[0]||!f[0])return u[0]?t:f[0]?-s:0;if(t!=s)return t;if(e=t<0,i!=r)return i>r^e?1:-1;for(t=-1,s=(i=u.length)<(r=f.length)?i:r;++t<s;)if(u[t]!=f[t])return u[t]>f[t]^e?1:-1;return i==r?0:i>r^e?1:-1};t.div=function(n){var p=this,w=p.constructor,h=p.c,e=(n=new w(n)).c,v=p.s==n.s?1:-1,c=w.DP;if((c!==~~c||c<0||c>r)&&i(\"!Big.DP!\"),!h[0]||!e[0])return h[0]==e[0]&&i(NaN),e[0]||i(v/0),new w(v*0);var s,b,y,l,f,tt,it=e.slice(),k=s=e.length,rt=h.length,t=h.slice(0,s),u=t.length,a=n,d=a.c=[],g=0,nt=c+(a.e=p.e-n.e)+1;for(a.s=v,v=nt<0?0:nt,it.unshift(0);u++<s;t.push(0));do{for(y=0;y<10;y++){if(s!=(u=t.length))l=s>u?1:-1;else for(f=-1,l=0;++f<s;)if(e[f]!=t[f]){l=e[f]>t[f]?1:-1;break}if(l<0){for(b=u==s?e:it;u;){if(t[--u]<b[u]){for(f=u;f&&!t[--f];t[f]=9);--t[f];t[u]+=10}t[u]-=b[u]}for(;!t[0];t.shift());}else break}d[g++]=l?y:++y;t[0]&&l?t[u]=h[k]||0:t=[h[k]]}while((k++<rt||t[0]!==tt)&&v--);return d[0]||g==1||(d.shift(),a.e--),g>nt&&o(a,c,w.RM,t[0]!==tt),a};t.eq=function(n){return!this.cmp(n)};t.gt=function(n){return this.cmp(n)>0};t.gte=function(n){return this.cmp(n)>-1};t.lt=function(n){return this.cmp(n)<0};t.lte=function(n){return this.cmp(n)<1};t.minus=function(n){var f,u,o,c,s=this,l=s.constructor,e=s.s,i=(n=new l(n)).s;if(e!=i)return n.s=-i,s.plus(n);var t=s.c.slice(),a=s.e,r=n.c,h=n.e;if(!t[0]||!r[0])return r[0]?(n.s=-i,n):new l(t[0]?s:0);if(e=a-h){for((c=e<0)?(e=-e,o=t):(h=a,o=r),o.reverse(),i=e;i--;o.push(0));o.reverse()}else for(u=((c=t.length<r.length)?t:r).length,e=i=0;i<u;i++)if(t[i]!=r[i]){c=t[i]<r[i];break}if(c&&(o=t,t=r,r=o,n.s=-n.s),(i=(u=r.length)-(f=t.length))>0)for(;i--;t[f++]=0);for(i=f;u>e;){if(t[--u]<r[u]){for(f=u;f&&!t[--f];t[f]=9);--t[f];t[u]+=10}t[u]-=r[u]}for(;t[--i]==0;t.pop());for(;t[0]==0;)t.shift(),--h;return t[0]||(n.s=1,t=[h=0]),n.c=t,n.e=h,n};t.mod=function(n){var e,t=this,r=t.constructor,u=t.s,f=(n=new r(n)).s;return(n.c[0]||i(NaN),t.s=n.s=1,e=n.cmp(t)==1,t.s=u,n.s=f,e)?new r(t):(u=r.DP,f=r.RM,r.DP=r.RM=0,t=t.div(n),r.DP=u,r.RM=f,this.minus(t.times(n)))};t.plus=function(n){var u,e=this,s=e.constructor,i=e.s,f=(n=new s(n)).s;if(i!=f)return n.s=-f,e.minus(n);var h=e.e,t=e.c,o=n.e,r=n.c;if(!t[0]||!r[0])return r[0]?n:new s(t[0]?e:i*0);if(t=t.slice(),i=h-o){for(i>0?(o=h,u=r):(i=-i,u=t),u.reverse();i--;u.push(0));u.reverse()}for(t.length-r.length<0&&(u=r,r=t,t=u),i=r.length,f=0;i;)f=(t[--i]=t[i]+r[i]+f)/10|0,t[i]%=10;for(f&&(t.unshift(f),++o),i=t.length;t[--i]==0;t.pop());return n.c=t,n.e=o,n};t.pow=function(n){var t=this,u=new t.constructor(1),r=u,f=n<0;for((n!==~~n||n<-h||n>h)&&i(\"!pow!\"),n=f?-n:n;;){if(n&1&&(r=r.times(t)),n>>=1,!n)break;t=t.times(t)}return f?u.div(r):r};t.round=function(n,t){var u=this,f=u.constructor;return n==null?n=0:(n!==~~n||n<0||n>r)&&i(\"!round!\"),o(u=new f(u),n,t==null?f.RM:t),u};t.sqrt=function(){var f,n,e,r=this,u=r.constructor,h=r.c,t=r.s,s=r.e,c=new u(\"0.5\");if(!h[0])return new u(r);t<0&&i(NaN);t=Math.sqrt(r.toString());t==0||t==1/0?(f=h.join(\"\"),f.length+s&1||(f+=\"0\"),n=new u(Math.sqrt(f).toString()),n.e=((s+1)/2|0)-(s<0||s&1)):n=new u(t.toString());t=n.e+(u.DP+=4);do e=n,n=c.times(e.plus(r.div(e)));while(e.c.slice(0,t).join(\"\")!==n.c.slice(0,t).join(\"\"));return o(n,u.DP-=4,u.RM),n};t.times=function(n){var t,s=this,h=s.constructor,f=s.c,e=(n=new h(n)).c,o=f.length,i=e.length,u=s.e,r=n.e;if(n.s=s.s==n.s?1:-1,!f[0]||!e[0])return new h(n.s*0);for(n.e=u+r,o<i&&(t=f,f=e,e=t,r=o,o=i,i=r),t=new Array(r=o+i);r--;t[r]=0);for(u=i;u--;){for(i=0,r=o+u;r>u;)i=t[r]+e[u]*f[r-u-1]+i,t[r--]=i%10,i=i/10|0;t[r]=(t[r]+i)%10}for(i&&++n.e,t[0]||t.shift(),u=t.length;!t[--u];t.pop());return n.c=t,n};t.toString=t.valueOf=t.toJSON=function(){var r=this,t=r.e,n=r.c.join(\"\"),i=n.length;if(t<=u||t>=f)n=n.charAt(0)+(i>1?\".\"+n.slice(1):\"\")+(t<0?\"e\":\"e+\")+t;else if(t<0){for(;++t;n=\"0\"+n);n=\"0.\"+n}else if(t>0)if(++t>i)for(t-=i;t--;n+=\"0\");else t<i&&(n=n.slice(0,t)+\".\"+n.slice(t));else i>1&&(n=n.charAt(0)+\".\"+n.slice(1));return r.s<0&&r.c[0]?\"-\"+n:n};t.toExponential=function(n){return n==null?n=this.c.length-1:(n!==~~n||n<0||n>r)&&i(\"!toExp!\"),s(this,n,1)};t.toFixed=function(n){var t,e=this,o=u,h=f;return u=-(f=1/0),n==null?t=e.toString():n===~~n&&n>=0&&n<=r&&(t=s(e,e.e+n),e.s<0&&e.c[0]&&t.indexOf(\"-\")<0&&(t=\"-\"+t)),u=o,f=h,t||i(\"!toFix!\"),t};t.toPrecision=function(n){return n==null?this.toString():((n!==~~n||n<1||n>r)&&i(\"!toPre!\"),s(this,n-1,2))};e=c();typeof define==\"function\"&&define.amd?define(function(){return e}):typeof module!=\"undefined\"&&module.exports?module.exports=e:n.Big=e})(this)"], "site-packages.pygame.locals": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\" \n\nfrom pygame.constants import * \nfrom pygame.rect import Rect \nimport pygame.color as color \nColor = color.Color\n"], "_ajax": [".js", "// ajax\nvar $module = (function($B){\n\neval($B.InjectBuiltins())\n\nvar $XMLHttpDict = {__class__:$B.$type,__name__:'XMLHttp'}\n\n$XMLHttpDict.__getattribute__ = function(self,attr){\n    if(['headers','text','xml'].indexOf(attr)>-1){\n        return $XMLHttpDict[attr](self)\n    }\n    return _b_.object.$dict.__getattribute__(self,attr)\n}\n\n$XMLHttpDict.__mro__ = [$XMLHttpDict, _b_.object.$dict]\n\n$XMLHttpDict.__repr__ = function(self){return '<object XMLHttp>'}\n\n$XMLHttpDict.__str__ = $XMLHttpDict.toString = $XMLHttpDict.__repr__\n\n$XMLHttpDict.text = function(self){return self.responseText}\n\n$XMLHttpDict.xml = function(self){return $DomObject(self.responseXML)}\n\n$XMLHttpDict.headers = function(self){\n    return list(self.getAllResponseHeaders().split('\\n'))\n}\n\n$XMLHttpDict.get_header = function(){\n    var reqobj = self;\n    return function(header){ return reqobj.getResponseHeader(header) }\n}\n\nvar $AjaxDict = {__class__:$B.$type,__name__:'ajax'}\n\n$AjaxDict.__mro__ = [$AjaxDict, _b_.object.$dict]\n\n$AjaxDict.__repr__ = function(self){return '<object Ajax>'}\n\n$AjaxDict.__str__ = $AjaxDict.toString = $AjaxDict.__repr__\n\n$AjaxDict.bind = function(self,evt,func){\n    // req.bind(evt,func) is the same as req.on_evt = func\n    self['on_'+evt]=func\n}\n\n$AjaxDict.open = function(self,method,url,async){\n    self.$xmlhttp.open(method,url,async)\n}\n\n$AjaxDict.send = function(self,params){\n    // params can be Python dictionary or string\n    var res = ''\n    if(!params){\n        self.$xmlhttp.send();\n        return;\n    }else if(isinstance(params,str)){\n        res = params\n    }else if(isinstance(params,dict)){\n        var items = _b_.list(_b_.dict.$dict.items(params))\n        for(var i=0, _len_i = items.length; i < _len_i;i++){\n            var key = encodeURIComponent(str(items[i][0]));\n            if (isinstance(items[i][1],list)) {\n                for (j = 0; j < items[i][1].length; j++) {\n                    res += key +'=' + encodeURIComponent(str(items[i][1][j])) + '&'\n                }\n            } else {\n                res += key + '=' + encodeURIComponent(str(items[i][1])) + '&'\n            }\n        }\n        res = res.substr(0,res.length-1)\n    }else{\n        throw _b_.TypeError(\"send() argument must be string or dictionary, not '\"+str(params.__class__)+\"'\")\n    }\n    self.$xmlhttp.send(res)\n}\n\n$AjaxDict.set_header = function(self,key,value){\n    self.$xmlhttp.setRequestHeader(key,value)\n}\n\n$AjaxDict.set_timeout = function(self,seconds,func){\n    self.$xmlhttp.$requestTimer = setTimeout(\n        function() {self.$xmlhttp.abort();func()},\n        seconds*1000);\n}\n\nfunction ajax(){\n\n    var res = {\n        __class__:$AjaxDict\n    }\n\n    if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n        var $xmlhttp=new XMLHttpRequest();\n    }else{// code for IE6, IE5\n        var $xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n    }\n    $xmlhttp.$requestTimer = null\n    $xmlhttp.__class__ = $XMLHttpDict\n\n    $xmlhttp.onreadystatechange = function(){\n        // here, \"this\" refers to $xmlhttp\n        var state = this.readyState\n        var req = this.$ajax\n        var timer = this.$requestTimer\n        var obj = this\n        if(state===0 && 'on_uninitialized' in req){req.on_uninitialized(obj)}\n        else if(state===1 && 'on_loading' in req){req.on_loading(obj)}\n        else if(state===2 && 'on_loaded' in req){req.on_loaded(obj)}\n        else if(state===3 && 'on_interactive' in req){req.on_interactive(obj)}\n        else if(state===4 && 'on_complete' in req){\n            if(timer !== null){window.clearTimeout(timer)}\n            req.on_complete(obj)\n        }\n    }\n    $xmlhttp.$ajax = res\n    res.$xmlhttp = $xmlhttp\n    return res\n}\n\najax.__class__ = $B.$factory\najax.$dict = $AjaxDict\n\nreturn {ajax:ajax}\n\n})(__BRYTHON__)\n"], "pwd": [".py", "\ndef getpwuid():\n pass\n"], "webbrowser": [".py", "from browser import window\n\n__all__ = [\"Error\", \"open\", \"open_new\", \"open_new_tab\"]\n\nclass Error(Exception):\n pass\n \n_target = { 0: '', 1: '_blank', 2: '_new' } \n\n\ndef open(url, new=0, autoraise=True):\n \"\"\n if window.open(url, _target[new]):\n  return True\n return False\n \ndef open_new(url):\n return open(url, 1)\n \ndef open_new_tab(url):\n return open(url, 2)\n \n \n"], "site-packages.pygame": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\n\n__docformat__ = 'restructuredtext'\n__version__ = '$Id$'\n\nimport os\nimport sys\n\nclass MissingModule:\n    def __init__(self, name, info='', urgent=0):\n        self.name = name\n        self.info = str(info)\n        self.urgent = urgent\n        if urgent:\n            self.warn()\n\n    def __getattr__(self, var):\n        if not self.urgent:\n            self.warn()\n            self.urgent = 1\n        MissingPygameModule = \"%s module not available\" % self.name\n        raise NotImplementedError(MissingPygameModule)\n\n    def __nonzero__(self):\n        return 0\n\n    def warn(self):\n        if self.urgent: type = 'import'\n        else: type = 'use'\n        message = '%s %s: %s' % (type, self.name, self.info)\n        try:\n            import warnings\n            if self.urgent: level = 4\n            else: level = 3\n            warnings.warn(message, RuntimeWarning, level)\n        except ImportError:\n            print(message)\n\n\n\n\n\n\n\n\n\nfrom pygame.base import *\nfrom pygame.constants import *\nfrom pygame.version import *\nfrom pygame.rect import Rect\nimport pygame.color\nColor = pygame.color.Color\n__version__ = ver\n\n\nfrom . import time\nfrom . import display\nfrom . import constants\nfrom . import event\nfrom . import font\nfrom . import mixer\nfrom . import sprite\nfrom .surface import Surface\nfrom . import image\nfrom . import mouse\nfrom . import transform\n\n\n\n\"\"\n\nimport copyreg\ndef __rect_constructor(x,y,w,h):\n\treturn Rect(x,y,w,h)\ndef __rect_reduce(r):\n\tassert type(r) == Rect\n return __rect_constructor, (r.x, r.y, r.w, r.h)\ncopyreg.pickle(Rect, __rect_reduce, __rect_constructor)\n\n\ndel pygame, os, sys, \n", 1], "site-packages.pygame.event": [".py", "\n\n\"\"\n\n__docformat__ = 'restructuredtext'\n__version__ = '$Id$'\n\nfrom copy import copy\n\n\nfrom SDL import *\nimport pygame.base\nimport pygame.locals\nimport pygame.display\n\ndef pump():\n \"\"\n pygame.display._video_init_check()\n SDL_PumpEvents()\n \ndef get(typelist=None):\n \"\"\n pygame.display._video_init_check()\n \n if typelist is None:\n  mask = SDL_ALLEVENTS\n else:\n  if hasattr(typelist, '__len__'):\n   mask = reduce(lambda a,b: a | SDL_EVENTMASK(b), typelist, 0)\n  else:\n   mask = int(typelist)\n   \n SDL_PumpEvents()\n \n events = []\n new_events = SDL_PeepEvents(1, SDL_GETEVENT, mask)\n while new_events:\n  events.append(Event(0, sdl_event=new_events[0]))\n  new_events = SDL_PeepEvents(1, SDL_GETEVENT, mask)\n return events\n \n \ndef poll():\n \"\"\n pygame.display._video_init_check()\n \n event = SDL_PollEventAndReturn()\n if event:\n  return Event(0, sdl_event=event, keep_userdata=True)\n else:\n  return Event(pygame.locals.NOEVENT)\n  \ndef wait():\n \"\"\n pygame.display._video_init_check()\n \n return Event(0, sdl_event=SDL_WaitEventAndReturn())\n \ndef peek(typelist=None):\n \"\"\n pygame.display._video_init_check()\n \n if typelist is None:\n  mask = SDL_ALLEVENTS\n else:\n  if hasattr(typelist, '__len__'):\n   mask = reduce(lambda a,b: a | SDL_EVENTMASK(b), typelist, 0)\n  else:\n   mask = SDL_EVENTMASK(int(typelist))\n   \n SDL_PumpEvents()\n events = SDL_PeepEvents(1, SDL_PEEKEVENT, mask)\n \n if typelist is None:\n  if events:\n   return Event(0, sdl_event=events[0], keep_userdata=True)\n  else:\n   return Event(pygame.locals.NOEVENT) \n return len(events) > 0\n \ndef clear(typelist=None):\n \"\"\n pygame.display._video_init_check()\n \n if typelist is None:\n  mask = SDL_ALLEVENTS\n else:\n  if hasattr(typelist, '__len__'):\n   mask = reduce(lambda a,b: a | SDL_EVENTMASK(b), typelist, 0)\n  else:\n   mask = int(typelist)\n   \n SDL_PumpEvents()\n \n events = []\n new_events = SDL_PeepEvents(1, SDL_GETEVENT, mask)\n while new_events:\n  new_events = SDL_PeepEvents(1, SDL_GETEVENT, mask)\n  \n_event_names = {\nSDL_ACTIVEEVENT: 'ActiveEvent',\nSDL_KEYDOWN: 'KeyDown',\nSDL_KEYUP: 'KeyUp',\nSDL_MOUSEMOTION: 'MouseMotion',\nSDL_MOUSEBUTTONDOWN:'MouseButtonDown',\nSDL_MOUSEBUTTONUP: 'MouseButtonUp',\nSDL_JOYAXISMOTION: 'JoyAxisMotion',\nSDL_JOYBALLMOTION: 'JoyBallMotion',\nSDL_JOYHATMOTION: 'JoyHatMotion',\nSDL_JOYBUTTONUP: 'JoyButtonUp',\nSDL_JOYBUTTONDOWN: 'JoyButtonDown',\nSDL_QUIT: 'Quit',\nSDL_SYSWMEVENT: 'SysWMEvent',\nSDL_VIDEORESIZE: 'VideoResize',\nSDL_VIDEOEXPOSE: 'VideoExpose',\nSDL_NOEVENT: 'NoEvent'\n}\n\ndef event_name(event_type):\n \"\"\n if event_type >= SDL_USEREVENT and event_type < SDL_NUMEVENTS:\n  return 'UserEvent'\n return _event_names.get(event_type, 'Unknown')\n \ndef set_blocked(typelist):\n \"\"\n pygame.display._video_init_check()\n \n if typelist is None:\n  SDL_EventState(SDL_ALLEVENTS, SDL_IGNORE)\n elif hasattr(typelist, '__len__'):\n  for val in typelist:\n   SDL_EventState(val, SDL_IGNORE)\n else:\n  SDL_EventState(typelist, SDL_IGNORE)\n  \ndef set_allowed(typelist):\n \"\"\n pygame.display._video_init_check()\n \n if typelist is None:\n  SDL_EventState(SDL_ALLEVENTS, SDL_ENABLE)\n elif hasattr(typelist, '__len__'):\n  for val in typelist:\n   SDL_EventState(val, SDL_ENABLE)\n else:\n  SDL_EventState(typelist, SDL_ENABLE)\n  \ndef get_blocked(typelist):\n \"\"\n pygame.display._video_init_check()\n \n if typelist == None:\n  return SDL_EventState(SDL_ALLEVENTS, SDL_QUERY) == SDL_ENABLE\n elif hasattr(typelist, '__len__'): \n  for val in typelist:\n   if SDL_EventState(val, SDL_QUERY) == SDL_ENABLE:\n    return True\n  return False\n else:\n  return SDL_EventState(typelist, SDL_QUERY) == SDL_ENABLE\n  \ndef set_grab(grab):\n \"\"\n pygame.display._video_init_check()\n \n if grab:\n  SDL_WM_GrabInput(SDL_GRAB_ON)\n else:\n  SDL_WM_GrabInput(SDL_GRAB_OFF)\n  \ndef get_grab():\n \"\"\n pygame.display._video_init_check()\n \n return SDL_WM_GrabInput(SDL_GRAB_QUERY) == SDL_GRAB_ON\n \n_USEROBJECT_CHECK1 = int(0xdeadbeef) \n_USEROBJECT_CHECK2 = 0xfeedf00d\n_user_event_objects = {}\n_user_event_nextid = 1\n\ndef post(event):\n \"\"\n global _user_event_nextid\n \n pygame.display._video_init_check()\n \n sdl_event = SDL_Event(event.type)\n sdl_event.user.code = _USEROBJECT_CHECK1\n sdl_event.user.data1 = c_void_p(_USEROBJECT_CHECK2)\n sdl_event.user.data2 = c_void_p(_user_event_nextid)\n _user_event_objects[_user_event_nextid] = event\n _user_event_nextid += 1\n \n SDL_PushEvent(sdl_event)\n \nclass Event:\n def __init__(self, event_type, event_dict=None, sdl_event=None, \n keep_userdata=False, **attributes):\n  \"\"\n  if sdl_event:\n   uevent = cast(pointer(sdl_event), POINTER(SDL_UserEvent)).contents\n   if uevent.code == _USEROBJECT_CHECK1 and uevent.data1 == _USEROBJECT_CHECK2 and uevent.data2 in _user_event_objects:\n   \n    id = sdl_event.data2\n    for key, value in _user_event_objects[id].__dict__.items():\n     setattr(self, key, value)\n     \n    if not keep_userdata:\n     del _user_event_objects[id]\n   else: \n   \n    self.type = sdl_event.type\n    if self.type == SDL_QUIT:\n     pass\n    elif self.type == SDL_ACTIVEEVENT:\n     self.gain = sdl_event.gain\n     self.state = sdl_event.state\n    elif self.type == SDL_KEYDOWN:\n     self.unicode = sdl_event.keysym.unicode\n     self.key = sdl_event.keysym.sym\n     self.mod = sdl_event.keysym.mod\n    elif self.type == SDL_KEYUP:\n     self.key = sdl_event.keysym.sym\n     self.mod = sdl_event.keysym.mod\n    elif self.type == SDL_MOUSEMOTION:\n     self.pos = (sdl_event.x, sdl_event.y)\n     self.rel = (sdl_event.xrel, sdl_event.yrel)\n     self.buttons = (sdl_event.state & SDL_BUTTON(1) != 0,\n     sdl_event.state & SDL_BUTTON(2) != 0,\n     sdl_event.state & SDL_BUTTON(3) != 0)\n    elif self.type in (SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP):\n     self.pos = (sdl_event.x, sdl_event.y)\n     self.button = sdl_event.button\n    elif self.type == SDL_JOYAXISMOTION:\n     self.joy = sdl_event.which\n     self.axis = sdl_event.axis\n     self.value = sdl_event.value / 32767.0\n    elif self.type == SDL_JOYBALLMOTION:\n     self.joy = sdl_event.which\n     self.ball = sdl_event.ball\n     self.rel = (sdl_event.xrel, sdl_event.yrel)\n    elif self.type == SDL_JOYHATMOTION:\n     self.joy = sdl_event.which\n     self.hat = sdl_event.hat\n     hx = hy = 0\n     if sdl_event.value & SDL_HAT_UP:\n      hy = 1\n     if sdl_event.value & SDL_HAT_DOWN:\n      hy = -1\n     if sdl_event.value & SDL_HAT_RIGHT:\n      hx = 1\n     if sdl_event.value & SDL_HAT_LEFT:\n      hx = -1\n     self.value = (hx, hy)\n    elif self.type in (SDL_JOYBUTTONUP, SDL_JOYBUTTONDOWN):\n     self.joy = sdl_event.which\n     self.button = sdl_event.button\n    elif self.type == SDL_VIDEORESIZE:\n     self.size = (sdl_event.w, sdl_event.h)\n     self.w = sdl_event.w\n     self.h = sdl_event.h\n    elif self.type == SDL_VIDEOEXPOSE:\n     pass\n    elif self.type == SDL_SYSWMEVENT:\n     pass \n    elif self.type >= SDL_USEREVENT and self.type < SDL_NUMEVENTS:\n     self.code = sdl_event.code\n  else:\n  \n   self.type = event_type\n   if event_dict:\n    for key, value in event_dict.items():\n     setattr(self, key, value)\n   for key, value in attributes.items():\n    setattr(self, key, value)\n    \n    \n  self.dict = self.__dict__\n  \n def __repr__(self):\n  d = copy(self.__dict__)\n  del d['type']\n  return '<Event(%d-%s %r)>' % (self.type, event_name(self.type), d)\n  \n def __nonzero__(self):\n  return self.type != SDL_NOEVENT\n  \nEventType = Event\n"], "copy": [".py", "\"\"\n\nimport types\nimport weakref\nfrom copyreg import dispatch_table\nimport builtins\n\nclass Error(Exception):\n pass\nerror = Error \n\n\n\n\n\n\n\nPyStringMap = None\n\n__all__ = [\"Error\", \"copy\", \"deepcopy\"]\n\ndef copy(x):\n \"\"\n \n cls = type(x)\n \n copier = _copy_dispatch.get(cls)\n if copier:\n  return copier(x)\n  \n copier = getattr(cls, \"__copy__\", None)\n if copier:\n  return copier(x)\n  \n reductor = dispatch_table.get(cls)\n if reductor:\n  rv = reductor(x)\n else:\n  reductor = getattr(x, \"__reduce_ex__\", None)\n  if reductor:\n   rv = reductor(2)\n  else:\n   reductor = getattr(x, \"__reduce__\", None)\n   if reductor:\n    rv = reductor()\n   else:\n    raise Error(\"un(shallow)copyable object of type %s\" % cls)\n    \n return _reconstruct(x, rv, 0)\n \n \n_copy_dispatch = d = {}\n\ndef _copy_immutable(x):\n return x\nfor t in (type(None), int, float, bool, str, tuple,\nfrozenset, type, range,\ntypes.BuiltinFunctionType, type(Ellipsis),\ntypes.FunctionType, weakref.ref):\n d[t] = _copy_immutable\nt = getattr(types, \"CodeType\", None)\nif t is not None:\n d[t] = _copy_immutable\nfor name in (\"complex\", \"unicode\"):\n t = getattr(builtins, name, None)\n if t is not None:\n  d[t] = _copy_immutable\n  \ndef _copy_with_constructor(x):\n return type(x)(x)\nfor t in (list, dict, set):\n d[t] = _copy_with_constructor\n \ndef _copy_with_copy_method(x):\n return x.copy()\nif PyStringMap is not None:\n d[PyStringMap] = _copy_with_copy_method\n \ndel d\n\ndef deepcopy(x, memo=None, _nil=[]):\n \"\"\n \n if memo is None:\n  memo = {}\n  \n d = id(x)\n y = memo.get(d, _nil)\n if y is not _nil:\n  return y\n  \n cls = type(x)\n \n copier = _deepcopy_dispatch.get(cls)\n if copier:\n  y = copier(x, memo)\n else:\n  try:\n   issc = issubclass(cls, type)\n  except TypeError: \n   issc = 0\n  if issc:\n   y = _deepcopy_atomic(x, memo)\n  else:\n   copier = getattr(x, \"__deepcopy__\", None)\n   if copier:\n    y = copier(memo)\n   else:\n    reductor = dispatch_table.get(cls)\n    if reductor:\n     rv = reductor(x)\n    else:\n     reductor = getattr(x, \"__reduce_ex__\", None)\n     if reductor:\n      rv = reductor(2)\n     else:\n      reductor = getattr(x, \"__reduce__\", None)\n      if reductor:\n       rv = reductor()\n      else:\n       raise Error(\n       \"un(deep)copyable object of type %s\" % cls)\n    y = _reconstruct(x, rv, 1, memo)\n    \n    \n if y is not x:\n  memo[d] = y\n  _keep_alive(x, memo) \n return y\n \n_deepcopy_dispatch = d = {}\n\ndef _deepcopy_atomic(x, memo):\n return x\nd[type(None)] = _deepcopy_atomic\nd[type(Ellipsis)] = _deepcopy_atomic\nd[int] = _deepcopy_atomic\nd[float] = _deepcopy_atomic\nd[bool] = _deepcopy_atomic\ntry:\n d[complex] = _deepcopy_atomic\nexcept NameError:\n pass\nd[bytes] = _deepcopy_atomic\nd[str] = _deepcopy_atomic\ntry:\n d[types.CodeType] = _deepcopy_atomic\nexcept AttributeError:\n pass\nd[type] = _deepcopy_atomic\nd[range] = _deepcopy_atomic\nd[types.BuiltinFunctionType] = _deepcopy_atomic\nd[types.FunctionType] = _deepcopy_atomic\nd[weakref.ref] = _deepcopy_atomic\n\ndef _deepcopy_list(x, memo):\n y = []\n memo[id(x)] = y\n for a in x:\n  y.append(deepcopy(a, memo))\n return y\nd[list] = _deepcopy_list\n\ndef _deepcopy_tuple(x, memo):\n y = []\n for a in x:\n  y.append(deepcopy(a, memo))\n  \n  \n try:\n  return memo[id(x)]\n except KeyError:\n  pass\n for i in range(len(x)):\n  if x[i] is not y[i]:\n   y = tuple(y)\n   break\n else:\n  y = x\n return y\nd[tuple] = _deepcopy_tuple\n\ndef _deepcopy_dict(x, memo):\n y = {}\n memo[id(x)] = y\n for key, value in x.items():\n  y[deepcopy(key, memo)] = deepcopy(value, memo)\n return y\nd[dict] = _deepcopy_dict\nif PyStringMap is not None:\n d[PyStringMap] = _deepcopy_dict\n \ndef _deepcopy_method(x, memo): \n return type(x)(x.__func__, deepcopy(x.__self__, memo))\n_deepcopy_dispatch[types.MethodType] = _deepcopy_method\n\ndef _keep_alive(x, memo):\n \"\"\n try:\n  memo[id(memo)].append(x)\n except KeyError:\n \n  memo[id(memo)]=[x]\n  \ndef _reconstruct(x, info, deep, memo=None):\n if isinstance(info, str):\n  return x\n assert isinstance(info, tuple)\n if memo is None:\n  memo = {}\n n = len(info)\n assert n in (2, 3, 4, 5)\n callable, args = info[:2]\n if n > 2:\n  state = info[2]\n else:\n  state = {}\n if n > 3:\n  listiter = info[3]\n else:\n  listiter = None\n if n > 4:\n  dictiter = info[4]\n else:\n  dictiter = None\n if deep:\n  args = deepcopy(args, memo)\n y = callable(*args)\n memo[id(x)] = y\n \n if state:\n  if deep:\n   state = deepcopy(state, memo)\n  if hasattr(y, '__setstate__'):\n   y.__setstate__(state)\n  else:\n   if isinstance(state, tuple) and len(state) == 2:\n    state, slotstate = state\n   else:\n    slotstate = None\n   if state is not None:\n    y.__dict__.update(state)\n   if slotstate is not None:\n    for key, value in slotstate.items():\n     setattr(y, key, value)\n     \n if listiter is not None:\n  for item in listiter:\n   if deep:\n    item = deepcopy(item, memo)\n   y.append(item)\n if dictiter is not None:\n  for key, value in dictiter:\n   if deep:\n    key = deepcopy(key, memo)\n    value = deepcopy(value, memo)\n   y[key] = value\n return y\n \ndel d\n\ndel types\n\n\nclass _EmptyClass:\n pass\n"], "_sysconfigdata": [".py", "build_time_vars={'HAVE_SYS_WAIT_H': 1, 'HAVE_UTIL_H': 0, 'HAVE_SYMLINKAT': 1, 'HAVE_LIBSENDFILE': 0, 'SRCDIRS': 'Parser Grammar Objects Python Modules Mac', 'SIZEOF_OFF_T': 8, 'BASECFLAGS': '-Wno-unused-result', 'HAVE_UTIME_H': 1, 'EXTRAMACHDEPPATH': '', 'HAVE_SYS_TIME_H': 1, 'CFLAGSFORSHARED': '-fPIC', 'HAVE_HYPOT': 1, 'PGSRCS': '\\\\', 'HAVE_LIBUTIL_H': 0, 'HAVE_COMPUTED_GOTOS': 1, 'HAVE_LUTIMES': 1, 'HAVE_MAKEDEV': 1, 'HAVE_REALPATH': 1, 'HAVE_LINUX_TIPC_H': 1, 'MULTIARCH': 'i386-linux-gnu', 'HAVE_GETWD': 1, 'HAVE_GCC_ASM_FOR_X64': 0, 'HAVE_INET_PTON': 1, 'HAVE_GETHOSTBYNAME_R_6_ARG': 1, 'SIZEOF__BOOL': 1, 'HAVE_ZLIB_COPY': 1, 'ASDLGEN': 'python3.3 ../Parser/asdl_c.py', 'GRAMMAR_INPUT': '../Grammar/Grammar', 'HOST_GNU_TYPE': 'i686-pc-linux-gnu', 'HAVE_SCHED_RR_GET_INTERVAL': 1, 'HAVE_BLUETOOTH_H': 0, 'HAVE_MKFIFO': 1, 'TIMEMODULE_LIB': 0, 'LIBM': '-lm', 'PGENOBJS': '\\\\ \\\\', 'PYTHONFRAMEWORK': '', 'GETPGRP_HAVE_ARG': 0, 'HAVE_MMAP': 1, 'SHLIB_SUFFIX': '.so', 'SIZEOF_FLOAT': 4, 'HAVE_RENAMEAT': 1, 'HAVE_LANGINFO_H': 1, 'HAVE_STDLIB_H': 1, 'PY_CORE_CFLAGS': '-Wno-unused-result -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -g -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security   -I. -IInclude -I../Include -D_FORTIFY_SOURCE=2 -fPIC -DPy_BUILD_CORE', 'HAVE_BROKEN_PIPE_BUF': 0, 'HAVE_CONFSTR': 1, 'HAVE_SIGTIMEDWAIT': 1, 'HAVE_FTELLO': 1, 'READELF': 'readelf', 'HAVE_SIGALTSTACK': 1, 'TESTTIMEOUT': 3600, 'PYTHONPATH': ':plat-i386-linux-gnu', 'SIZEOF_WCHAR_T': 4, 'LIBOBJS': '', 'HAVE_SYSCONF': 1, 'MAKESETUP': '../Modules/makesetup', 'HAVE_UTIMENSAT': 1, 'HAVE_FCHOWNAT': 1, 'HAVE_WORKING_TZSET': 1, 'HAVE_FINITE': 1, 'HAVE_ASINH': 1, 'HAVE_SETEUID': 1, 'CONFIGFILES': 'configure configure.ac acconfig.h pyconfig.h.in Makefile.pre.in', 'HAVE_SETGROUPS': 1, 'PARSER_OBJS': '\\\\ Parser/myreadline.o Parser/parsetok.o Parser/tokenizer.o', 'HAVE_MBRTOWC': 1, 'SIZEOF_INT': 4, 'HAVE_STDARG_PROTOTYPES': 1, 'TM_IN_SYS_TIME': 0, 'HAVE_SYS_TIMES_H': 1, 'HAVE_LCHOWN': 1, 'HAVE_SSIZE_T': 1, 'HAVE_PAUSE': 1, 'SYSLIBS': '-lm', 'POSIX_SEMAPHORES_NOT_ENABLED': 0, 'HAVE_DEVICE_MACROS': 1, 'BLDSHARED': 'i686-linux-gnu-gcc -pthread -shared -Wl,-O1 -Wl,-Bsymbolic-functions -Wl,-Bsymbolic-functions -Wl,-z,relro -Wno-unused-result -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -g -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security  ', 'LIBSUBDIRS': 'tkinter tkinter/test tkinter/test/test_tkinter \\\\', 'HAVE_SYS_UN_H': 1, 'HAVE_SYS_STAT_H': 1, 'VPATH': '..', 'INCLDIRSTOMAKE': '/usr/include /usr/include /usr/include/python3.3m /usr/include/python3.3m', 'HAVE_BROKEN_SEM_GETVALUE': 0, 'HAVE_TIMEGM': 1, 'PACKAGE_VERSION': 0, 'MAJOR_IN_SYSMACROS': 0, 'HAVE_ATANH': 1, 'HAVE_GAI_STRERROR': 1, 'HAVE_SYS_POLL_H': 1, 'SIZEOF_PTHREAD_T': 4, 'SIZEOF_FPOS_T': 16, 'HAVE_CTERMID': 1, 'HAVE_TMPFILE': 1, 'HAVE_SETUID': 1, 'CXX': 'i686-linux-gnu-g++ -pthread', 'srcdir': '..', 'HAVE_UINT32_T': 1, 'HAVE_ADDRINFO': 1, 'HAVE_GETSPENT': 1, 'SIZEOF_DOUBLE': 8, 'HAVE_INT32_T': 1, 'LIBRARY_OBJS_OMIT_FROZEN': '\\\\', 'HAVE_FUTIMES': 1, 'CONFINCLUDEPY': '/usr/include/python3.3m', 'HAVE_RL_COMPLETION_APPEND_CHARACTER': 1, 'LIBFFI_INCLUDEDIR': '', 'HAVE_SETGID': 1, 'HAVE_UINT64_T': 1, 'EXEMODE': 755, 'UNIVERSALSDK': '', 'HAVE_LIBDL': 1, 'HAVE_GETNAMEINFO': 1, 'HAVE_STDINT_H': 1, 'COREPYTHONPATH': ':plat-i386-linux-gnu', 'HAVE_SOCKADDR_STORAGE': 1, 'HAVE_WAITID': 1, 'EXTRAPLATDIR': '@EXTRAPLATDIR@', 'HAVE_ACCEPT4': 1, 'RUNSHARED': 'LD_LIBRARY_PATH=/build/buildd/python3.3-3.3.1/build-shared:', 'EXE': '', 'HAVE_SIGACTION': 1, 'HAVE_CHOWN': 1, 'HAVE_GETLOGIN': 1, 'HAVE_TZNAME': 0, 'PACKAGE_NAME': 0, 'HAVE_GETPGID': 1, 'HAVE_GLIBC_MEMMOVE_BUG': 0, 'BUILD_GNU_TYPE': 'i686-pc-linux-gnu', 'HAVE_LINUX_CAN_H': 1, 'DYNLOADFILE': 'dynload_shlib.o', 'HAVE_PWRITE': 1, 'BUILDEXE': '', 'HAVE_OPENPTY': 1, 'HAVE_LOCKF': 1, 'HAVE_COPYSIGN': 1, 'HAVE_PREAD': 1, 'HAVE_DLOPEN': 1, 'HAVE_SYS_KERN_CONTROL_H': 0, 'PY_FORMAT_LONG_LONG': '\"ll\"', 'HAVE_TCSETPGRP': 1, 'HAVE_SETSID': 1, 'HAVE_STRUCT_STAT_ST_BIRTHTIME': 0, 'HAVE_STRING_H': 1, 'LDLIBRARY': 'libpython3.3m.so', 'INSTALL_SCRIPT': '/usr/bin/install -c', 'HAVE_SYS_XATTR_H': 1, 'HAVE_CURSES_IS_TERM_RESIZED': 1, 'HAVE_TMPNAM_R': 1, 'STRICT_SYSV_CURSES': \"/* Don't use ncurses extensions */\", 'WANT_SIGFPE_HANDLER': 1, 'HAVE_INT64_T': 1, 'HAVE_STAT_TV_NSEC': 1, 'HAVE_SYS_MKDEV_H': 0, 'HAVE_BROKEN_POLL': 0, 'HAVE_IF_NAMEINDEX': 1, 'HAVE_GETPWENT': 1, 'PSRCS': '\\\\', 'RANLIB': 'ranlib', 'HAVE_WCSCOLL': 1, 'WITH_NEXT_FRAMEWORK': 0, 'ASDLGEN_FILES': '../Parser/asdl.py ../Parser/asdl_c.py', 'HAVE_RL_PRE_INPUT_HOOK': 1, 'PACKAGE_URL': 0, 'SHLIB_EXT': 0, 'HAVE_SYS_LOADAVG_H': 0, 'HAVE_LIBIEEE': 0, 'HAVE_SEM_OPEN': 1, 'HAVE_TERM_H': 1, 'IO_OBJS': '\\\\', 'IO_H': 'Modules/_io/_iomodule.h', 'HAVE_STATVFS': 1, 'VERSION': '3.3', 'HAVE_GETC_UNLOCKED': 1, 'MACHDEPS': 'plat-i386-linux-gnu @EXTRAPLATDIR@', 'SUBDIRSTOO': 'Include Lib Misc', 'HAVE_SETREUID': 1, 'HAVE_ERFC': 1, 'HAVE_SETRESUID': 1, 'LINKFORSHARED': '-Xlinker -export-dynamic -Wl,-O1 -Wl,-Bsymbolic-functions', 'HAVE_SYS_TYPES_H': 1, 'HAVE_GETPAGESIZE': 1, 'HAVE_SETEGID': 1, 'HAVE_PTY_H': 1, 'HAVE_STRUCT_STAT_ST_FLAGS': 0, 'HAVE_WCHAR_H': 1, 'HAVE_FSEEKO': 1, 'Py_ENABLE_SHARED': 1, 'HAVE_SIGRELSE': 1, 'HAVE_PTHREAD_INIT': 0, 'FILEMODE': 644, 'HAVE_SYS_RESOURCE_H': 1, 'HAVE_READLINKAT': 1, 'PYLONG_BITS_IN_DIGIT': 0, 'LINKCC': 'i686-linux-gnu-gcc -pthread', 'HAVE_SETLOCALE': 1, 'HAVE_CHROOT': 1, 'HAVE_OPENAT': 1, 'HAVE_FEXECVE': 1, 'LDCXXSHARED': 'i686-linux-gnu-g++ -pthread -shared -Wl,-O1 -Wl,-Bsymbolic-functions', 'DIST': 'README ChangeLog configure configure.ac acconfig.h pyconfig.h.in Makefile.pre.in Include Lib Misc Ext-dummy', 'HAVE_MKNOD': 1, 'PY_LDFLAGS': '-Wl,-Bsymbolic-functions -Wl,-z,relro', 'HAVE_BROKEN_MBSTOWCS': 0, 'LIBRARY_OBJS': '\\\\', 'HAVE_LOG1P': 1, 'SIZEOF_VOID_P': 4, 'HAVE_FCHOWN': 1, 'PYTHONFRAMEWORKPREFIX': '', 'HAVE_LIBDLD': 0, 'HAVE_TGAMMA': 1, 'HAVE_ERRNO_H': 1, 'HAVE_IO_H': 0, 'OTHER_LIBTOOL_OPT': '', 'HAVE_POLL_H': 1, 'PY_CPPFLAGS': '-I. -IInclude -I../Include -D_FORTIFY_SOURCE=2', 'XMLLIBSUBDIRS': 'xml xml/dom xml/etree xml/parsers xml/sax', 'GRAMMAR_H': 'Include/graminit.h', 'TANH_PRESERVES_ZERO_SIGN': 1, 'HAVE_GETLOADAVG': 1, 'UNICODE_DEPS': '\\\\ \\\\', 'HAVE_GETCWD': 1, 'MANDIR': '/usr/share/man', 'MACHDESTLIB': '/usr/lib/python3.3', 'GRAMMAR_C': 'Python/graminit.c', 'PGOBJS': '\\\\', 'HAVE_DEV_PTMX': 1, 'HAVE_UINTPTR_T': 1, 'HAVE_SCHED_SETAFFINITY': 1, 'PURIFY': '', 'HAVE_DECL_ISINF': 1, 'HAVE_RL_CALLBACK': 1, 'HAVE_WRITEV': 1, 'HAVE_GETHOSTBYNAME_R_5_ARG': 0, 'HAVE_SYS_AUDIOIO_H': 0, 'EXT_SUFFIX': '.cpython-33m.so', 'SIZEOF_LONG_LONG': 8, 'DLINCLDIR': '.', 'HAVE_PATHCONF': 1, 'HAVE_UNLINKAT': 1, 'MKDIR_P': '/bin/mkdir -p', 'HAVE_ALTZONE': 0, 'SCRIPTDIR': '/usr/lib', 'OPCODETARGETGEN_FILES': '\\\\', 'HAVE_GETSPNAM': 1, 'HAVE_SYS_TERMIO_H': 0, 'HAVE_ATTRIBUTE_FORMAT_PARSETUPLE': 0, 'HAVE_PTHREAD_H': 1, 'Py_DEBUG': 0, 'HAVE_STRUCT_STAT_ST_BLOCKS': 1, 'X87_DOUBLE_ROUNDING': 1, 'SIZEOF_TIME_T': 4, 'HAVE_DYNAMIC_LOADING': 1, 'HAVE_DIRECT_H': 0, 'SRC_GDB_HOOKS': '../Tools/gdb/libpython.py', 'HAVE_GETADDRINFO': 1, 'HAVE_BROKEN_NICE': 0, 'HAVE_DIRENT_H': 1, 'HAVE_WCSXFRM': 1, 'HAVE_RL_COMPLETION_DISPLAY_MATCHES_HOOK': 1, 'HAVE_FSTATVFS': 1, 'PYTHON': 'python', 'HAVE_OSX105_SDK': 0, 'BINDIR': '/usr/bin', 'TESTPYTHON': 'LD_LIBRARY_PATH=/build/buildd/python3.3-3.3.1/build-shared: ./python', 'ARFLAGS': 'rc', 'PLATDIR': 'plat-i386-linux-gnu', 'HAVE_ASM_TYPES_H': 1, 'PY3LIBRARY': 'libpython3.so', 'HAVE_PLOCK': 0, 'FLOCK_NEEDS_LIBBSD': 0, 'WITH_TSC': 0, 'HAVE_LIBREADLINE': 1, 'MACHDEP': 'linux', 'HAVE_SELECT': 1, 'LDFLAGS': '-Wl,-Bsymbolic-functions -Wl,-z,relro', 'HAVE_HSTRERROR': 1, 'SOABI': 'cpython-33m', 'HAVE_GETTIMEOFDAY': 1, 'HAVE_LIBRESOLV': 0, 'HAVE_UNSETENV': 1, 'HAVE_TM_ZONE': 1, 'HAVE_GETPGRP': 1, 'HAVE_FLOCK': 1, 'HAVE_SYS_BSDTTY_H': 0, 'SUBDIRS': '', 'PYTHONFRAMEWORKINSTALLDIR': '', 'PACKAGE_BUGREPORT': 0, 'HAVE_CLOCK': 1, 'HAVE_GETPEERNAME': 1, 'SIZEOF_PID_T': 4, 'HAVE_CONIO_H': 0, 'HAVE_FSTATAT': 1, 'HAVE_NETPACKET_PACKET_H': 1, 'HAVE_WAIT3': 1, 'DESTPATH': '', 'HAVE_STAT_TV_NSEC2': 0, 'HAVE_GETRESGID': 1, 'HAVE_UCS4_TCL': 0, 'SIGNED_RIGHT_SHIFT_ZERO_FILLS': 0, 'HAVE_TIMES': 1, 'HAVE_UNAME': 1, 'HAVE_ERF': 1, 'SIZEOF_SHORT': 2, 'HAVE_NCURSES_H': 1, 'HAVE_SYS_SENDFILE_H': 1, 'HAVE_CTERMID_R': 0, 'HAVE_TMPNAM': 1, 'prefix': '/usr', 'HAVE_NICE': 1, 'WITH_THREAD': 1, 'LN': 'ln', 'TESTRUNNER': 'LD_LIBRARY_PATH=/build/buildd/python3.3-3.3.1/build-shared: ./python ../Tools/scripts/run_tests.py', 'HAVE_SIGINTERRUPT': 1, 'HAVE_SETPGID': 1, 'RETSIGTYPE': 'void', 'HAVE_SCHED_GET_PRIORITY_MAX': 1, 'HAVE_SYS_SYS_DOMAIN_H': 0, 'HAVE_SYS_DIR_H': 0, 'HAVE__GETPTY': 0, 'HAVE_BLUETOOTH_BLUETOOTH_H': 1, 'HAVE_BIND_TEXTDOMAIN_CODESET': 1, 'HAVE_POLL': 1, 'PYTHON_OBJS': '\\\\', 'HAVE_WAITPID': 1, 'USE_INLINE': 1, 'HAVE_FUTIMENS': 1, 'USE_COMPUTED_GOTOS': 1, 'MAINCC': 'i686-linux-gnu-gcc -pthread', 'HAVE_SOCKETPAIR': 1, 'HAVE_PROCESS_H': 0, 'HAVE_SETVBUF': 1, 'HAVE_FDOPENDIR': 1, 'CONFINCLUDEDIR': '/usr/include', 'BINLIBDEST': '/usr/lib/python3.3', 'HAVE_SYS_IOCTL_H': 1, 'HAVE_SYSEXITS_H': 1, 'LDLAST': '', 'HAVE_SYS_FILE_H': 1, 'HAVE_RL_COMPLETION_SUPPRESS_APPEND': 1, 'HAVE_RL_COMPLETION_MATCHES': 1, 'HAVE_TCGETPGRP': 1, 'SIZEOF_SIZE_T': 4, 'HAVE_EPOLL_CREATE1': 1, 'HAVE_SYS_SELECT_H': 1, 'HAVE_CLOCK_GETTIME': 1, 'CFLAGS': '-Wno-unused-result -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -g -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security  ', 'HAVE_SNPRINTF': 1, 'BLDLIBRARY': '-lpython3.3m', 'PARSER_HEADERS': '\\\\', 'SO': '.so', 'LIBRARY': 'libpython3.3m.a', 'HAVE_FPATHCONF': 1, 'HAVE_TERMIOS_H': 1, 'HAVE_BROKEN_PTHREAD_SIGMASK': 0, 'AST_H': 'Include/Python-ast.h', 'HAVE_GCC_UINT128_T': 0, 'HAVE_ACOSH': 1, 'MODOBJS': 'Modules/_threadmodule.o  Modules/signalmodule.o  Modules/arraymodule.o  Modules/mathmodule.o Modules/_math.o  Modules/_struct.o  Modules/timemodule.o  Modules/_randommodule.o  Modules/atexitmodule.o  Modules/_elementtree.o  Modules/_pickle.o  Modules/_datetimemodule.o  Modules/_bisectmodule.o  Modules/_heapqmodule.o  Modules/unicodedata.o  Modules/fcntlmodule.o  Modules/spwdmodule.o  Modules/grpmodule.o  Modules/selectmodule.o  Modules/socketmodule.o  Modules/_posixsubprocess.o  Modules/md5module.o  Modules/sha1module.o  Modules/sha256module.o  Modules/sha512module.o  Modules/syslogmodule.o  Modules/binascii.o  Modules/zlibmodule.o  Modules/pyexpat.o  Modules/posixmodule.o  Modules/errnomodule.o  Modules/pwdmodule.o  Modules/_sre.o  Modules/_codecsmodule.o  Modules/_weakref.o  Modules/_functoolsmodule.o  Modules/operator.o  Modules/_collectionsmodule.o  Modules/itertoolsmodule.o  Modules/_localemodule.o  Modules/_iomodule.o Modules/iobase.o Modules/fileio.o Modules/bytesio.o Modules/bufferedio.o Modules/textio.o Modules/stringio.o  Modules/zipimport.o  Modules/faulthandler.o  Modules/symtablemodule.o  Modules/xxsubtype.o', 'AST_C': 'Python/Python-ast.c', 'HAVE_SYS_NDIR_H': 0, 'DESTDIRS': '/usr /usr/lib /usr/lib/python3.3 /usr/lib/python3.3/lib-dynload', 'HAVE_SIGNAL_H': 1, 'PACKAGE_TARNAME': 0, 'HAVE_GETPRIORITY': 1, 'INCLUDEDIR': '/usr/include', 'HAVE_INTTYPES_H': 1, 'SIGNAL_OBJS': '', 'HAVE_READV': 1, 'HAVE_SETHOSTNAME': 1, 'MODLIBS': '-lrt    -lexpat                   -L/usr/lib -lz  -lexpat', 'CC': 'i686-linux-gnu-gcc -pthread', 'HAVE_LCHMOD': 0, 'SIZEOF_UINTPTR_T': 4, 'LIBPC': '/usr/lib/i386-linux-gnu/pkgconfig', 'BYTESTR_DEPS': '\\\\', 'HAVE_MKDIRAT': 1, 'LIBPL': '/usr/lib/python3.3/config-3.3m-i386-linux-gnu', 'HAVE_SHADOW_H': 1, 'HAVE_SYS_EVENT_H': 0, 'INSTALL': '/usr/bin/install -c', 'HAVE_GCC_ASM_FOR_X87': 1, 'HAVE_BROKEN_UNSETENV': 0, 'BASECPPFLAGS': '', 'DOUBLE_IS_BIG_ENDIAN_IEEE754': 0, 'HAVE_STRUCT_STAT_ST_RDEV': 1, 'HAVE_SEM_UNLINK': 1, 'BUILDPYTHON': 'python', 'HAVE_RL_CATCH_SIGNAL': 1, 'HAVE_DECL_TZNAME': 0, 'RESSRCDIR': 'Mac/Resources/framework', 'HAVE_PTHREAD_SIGMASK': 1, 'HAVE_UTIMES': 1, 'DISTDIRS': 'Include Lib Misc Ext-dummy', 'HAVE_FDATASYNC': 1, 'HAVE_USABLE_WCHAR_T': 0, 'PY_FORMAT_SIZE_T': '\"z\"', 'HAVE_SCHED_SETSCHEDULER': 1, 'VA_LIST_IS_ARRAY': 0, 'HAVE_LINUX_NETLINK_H': 1, 'HAVE_SETREGID': 1, 'HAVE_STROPTS_H': 1, 'LDVERSION': '3.3m', 'abs_builddir': '/build/buildd/python3.3-3.3.1/build-shared', 'SITEPATH': '', 'HAVE_GETHOSTBYNAME': 0, 'HAVE_SIGPENDING': 1, 'HAVE_KQUEUE': 0, 'HAVE_SYNC': 1, 'HAVE_GETSID': 1, 'HAVE_ROUND': 1, 'HAVE_STRFTIME': 1, 'AST_H_DIR': 'Include', 'HAVE_PIPE2': 1, 'AST_C_DIR': 'Python', 'TESTPYTHONOPTS': '', 'HAVE_DEV_PTC': 0, 'GETTIMEOFDAY_NO_TZ': 0, 'HAVE_NET_IF_H': 1, 'HAVE_SENDFILE': 1, 'HAVE_SETPGRP': 1, 'HAVE_SEM_GETVALUE': 1, 'CONFIGURE_LDFLAGS': '-Wl,-Bsymbolic-functions -Wl,-z,relro', 'DLLLIBRARY': '', 'PYTHON_FOR_BUILD': './python -E', 'SETPGRP_HAVE_ARG': 0, 'HAVE_INET_ATON': 1, 'INSTALL_SHARED': '/usr/bin/install -c -m 555', 'WITH_DOC_STRINGS': 1, 'OPCODETARGETS_H': '\\\\', 'HAVE_INITGROUPS': 1, 'HAVE_LINKAT': 1, 'BASEMODLIBS': '', 'SGI_ABI': '', 'HAVE_SCHED_SETPARAM': 1, 'OPT': '-DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes', 'HAVE_POSIX_FADVISE': 1, 'datarootdir': '/usr/share', 'HAVE_MEMRCHR': 1, 'HGTAG': '', 'HAVE_MEMMOVE': 1, 'HAVE_GETRESUID': 1, 'DOUBLE_IS_ARM_MIXED_ENDIAN_IEEE754': 0, 'HAVE_LSTAT': 1, 'AR': 'ar', 'HAVE_WAIT4': 1, 'HAVE_SYS_MODEM_H': 0, 'INSTSONAME': 'libpython3.3m.so.1.0', 'HAVE_SYS_STATVFS_H': 1, 'HAVE_LGAMMA': 1, 'HAVE_PROTOTYPES': 1, 'HAVE_SYS_UIO_H': 1, 'MAJOR_IN_MKDEV': 0, 'QUICKTESTOPTS': '-x test_subprocess test_io test_lib2to3 \\\\', 'HAVE_SYS_DEVPOLL_H': 0, 'HAVE_CHFLAGS': 0, 'HAVE_FSYNC': 1, 'HAVE_FCHMOD': 1, 'INCLUDEPY': '/usr/include/python3.3m', 'HAVE_SEM_TIMEDWAIT': 1, 'LDLIBRARYDIR': '', 'HAVE_STRUCT_TM_TM_ZONE': 1, 'HAVE_CURSES_H': 1, 'TIME_WITH_SYS_TIME': 1, 'HAVE_DUP2': 1, 'ENABLE_IPV6': 1, 'WITH_VALGRIND': 0, 'HAVE_SETITIMER': 1, 'THREADOBJ': 'Python/thread.o', 'LOCALMODLIBS': '-lrt    -lexpat                   -L/usr/lib -lz  -lexpat', 'HAVE_MEMORY_H': 1, 'HAVE_GETITIMER': 1, 'HAVE_C99_BOOL': 1, 'INSTALL_DATA': '/usr/bin/install -c -m 644', 'PGEN': 'Parser/pgen', 'HAVE_GRP_H': 1, 'HAVE_WCSFTIME': 1, 'AIX_GENUINE_CPLUSPLUS': 0, 'HAVE_LIBINTL_H': 1, 'SHELL': '/bin/sh', 'HAVE_UNISTD_H': 1, 'EXTRATESTOPTS': '', 'HAVE_EXECV': 1, 'HAVE_FSEEK64': 0, 'MVWDELCH_IS_EXPRESSION': 1, 'DESTSHARED': '/usr/lib/python3.3/lib-dynload', 'OPCODETARGETGEN': '\\\\', 'LIBDEST': '/usr/lib/python3.3', 'CCSHARED': '-fPIC', 'HAVE_EXPM1': 1, 'HAVE_DLFCN_H': 1, 'exec_prefix': '/usr', 'HAVE_READLINK': 1, 'WINDOW_HAS_FLAGS': 1, 'HAVE_FTELL64': 0, 'HAVE_STRLCPY': 0, 'MACOSX_DEPLOYMENT_TARGET': '', 'HAVE_SYS_SYSCALL_H': 1, 'DESTLIB': '/usr/lib/python3.3', 'LDSHARED': 'i686-linux-gnu-gcc -pthread -shared -Wl,-O1 -Wl,-Bsymbolic-functions -Wl,-Bsymbolic-functions -Wl,-z,relro -Wno-unused-result -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -g -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security  ', 'HGVERSION': '', 'PYTHON_HEADERS': '\\\\', 'HAVE_STRINGS_H': 1, 'DOUBLE_IS_LITTLE_ENDIAN_IEEE754': 1, 'HAVE_POSIX_FALLOCATE': 1, 'HAVE_DIRFD': 1, 'HAVE_LOG2': 1, 'HAVE_GETPID': 1, 'HAVE_ALARM': 1, 'MACHDEP_OBJS': '', 'HAVE_SPAWN_H': 1, 'HAVE_FORK': 1, 'HAVE_SETRESGID': 1, 'HAVE_FCHMODAT': 1, 'HAVE_CLOCK_GETRES': 1, 'MACHDEPPATH': ':plat-i386-linux-gnu', 'STDC_HEADERS': 1, 'HAVE_SETPRIORITY': 1, 'LIBC': '', 'HAVE_SYS_EPOLL_H': 1, 'HAVE_SYS_UTSNAME_H': 1, 'HAVE_PUTENV': 1, 'HAVE_CURSES_RESIZE_TERM': 1, 'HAVE_FUTIMESAT': 1, 'WITH_DYLD': 0, 'INSTALL_PROGRAM': '/usr/bin/install -c', 'LIBS': '-lpthread -ldl  -lutil', 'HAVE_TRUNCATE': 1, 'TESTOPTS': '', 'PROFILE_TASK': '../Tools/pybench/pybench.py -n 2 --with-gc --with-syscheck', 'HAVE_CURSES_RESIZETERM': 1, 'ABIFLAGS': 'm', 'HAVE_GETGROUPLIST': 1, 'OBJECT_OBJS': '\\\\', 'HAVE_MKNODAT': 1, 'HAVE_ST_BLOCKS': 1, 'HAVE_STRUCT_STAT_ST_GEN': 0, 'SYS_SELECT_WITH_SYS_TIME': 1, 'SHLIBS': '-lpthread -ldl  -lutil', 'HAVE_GETGROUPS': 1, 'MODULE_OBJS': '\\\\', 'PYTHONFRAMEWORKDIR': 'no-framework', 'HAVE_FCNTL_H': 1, 'HAVE_LINK': 1, 'HAVE_SIGWAIT': 1, 'HAVE_GAMMA': 1, 'HAVE_SYS_LOCK_H': 0, 'HAVE_FORKPTY': 1, 'HAVE_SOCKADDR_SA_LEN': 0, 'HAVE_TEMPNAM': 1, 'HAVE_STRUCT_STAT_ST_BLKSIZE': 1, 'HAVE_MKFIFOAT': 1, 'HAVE_SIGWAITINFO': 1, 'HAVE_FTIME': 1, 'HAVE_EPOLL': 1, 'HAVE_SYS_SOCKET_H': 1, 'HAVE_LARGEFILE_SUPPORT': 1, 'CONFIGURE_CFLAGS': '-g -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security', 'HAVE_PTHREAD_DESTRUCTOR': 0, 'CONFIGURE_CPPFLAGS': '-D_FORTIFY_SOURCE=2', 'HAVE_SYMLINK': 1, 'HAVE_LONG_LONG': 1, 'HAVE_IEEEFP_H': 0, 'LIBDIR': '/usr/lib', 'HAVE_PTHREAD_KILL': 1, 'TESTPATH': '', 'HAVE_STRDUP': 1, 'POBJS': '\\\\', 'NO_AS_NEEDED': '-Wl,--no-as-needed', 'HAVE_LONG_DOUBLE': 1, 'HGBRANCH': '', 'DISTFILES': 'README ChangeLog configure configure.ac acconfig.h pyconfig.h.in Makefile.pre.in', 'PTHREAD_SYSTEM_SCHED_SUPPORTED': 1, 'HAVE_FACCESSAT': 1, 'AST_ASDL': '../Parser/Python.asdl', 'CPPFLAGS': '-I. -IInclude -I../Include -D_FORTIFY_SOURCE=2', 'HAVE_MKTIME': 1, 'HAVE_NDIR_H': 0, 'PY_CFLAGS': '-Wno-unused-result -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -g -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security  ', 'LIBOBJDIR': 'Python/', 'HAVE_LINUX_CAN_RAW_H': 1, 'HAVE_GETHOSTBYNAME_R_3_ARG': 0, 'PACKAGE_STRING': 0, 'GNULD': 'yes', 'LOG1P_DROPS_ZERO_SIGN': 0, 'HAVE_FTRUNCATE': 1, 'WITH_LIBINTL': 0, 'HAVE_MREMAP': 1, 'HAVE_DECL_ISNAN': 1, 'HAVE_KILLPG': 1, 'SIZEOF_LONG': 4, 'HAVE_DECL_ISFINITE': 1, 'HAVE_IPA_PURE_CONST_BUG': 0, 'WITH_PYMALLOC': 1, 'abs_srcdir': '/build/buildd/python3.3-3.3.1/build-shared/..', 'HAVE_FCHDIR': 1, 'HAVE_BROKEN_POSIX_SEMAPHORES': 0, 'AC_APPLE_UNIVERSAL_BUILD': 0, 'PGENSRCS': '\\\\ \\\\', 'DIRMODE': 755, 'HAVE_GETHOSTBYNAME_R': 1, 'HAVE_LCHFLAGS': 0, 'HAVE_SYS_PARAM_H': 1, 'SIZEOF_LONG_DOUBLE': 12, 'CONFIG_ARGS': \"'--enable-shared' '--prefix=/usr' '--enable-ipv6' '--enable-loadable-sqlite-extensions' '--with-dbmliborder=bdb:gdbm' '--with-computed-gotos' '--with-system-expat' '--with-system-ffi' '--with-fpectl' 'CC=i686-linux-gnu-gcc' 'CFLAGS=-g -fstack-protector --param=ssp-buffer-size=4 -Wformat -Werror=format-security ' 'LDFLAGS=-Wl,-Bsymbolic-functions -Wl,-z,relro' 'CPPFLAGS=-D_FORTIFY_SOURCE=2'\", 'HAVE_SCHED_H': 1, 'HAVE_KILL': 1}\n\n"], "_struct": [".py", "\n\n\n\n\n\n\n\n\n\n\"\"\n\nimport math, sys\n\n\nclass StructError(Exception):\n pass\nerror = StructError\ndef unpack_int(data,index,size,le):\n bytes = [b for b in data[index:index+size]]\n if le == 'little':\n  bytes.reverse()\n number = 0\n for b in bytes:\n  number = number << 8 | b\n return int(number)\n \ndef unpack_signed_int(data,index,size,le):\n number = unpack_int(data,index,size,le)\n max = 2**(size*8)\n if number > 2**(size*8 - 1) - 1:\n  number = int(-1*(max - number))\n return number\n \nINFINITY = 1e200 * 1e200\nNAN = INFINITY / INFINITY\n\ndef unpack_char(data,index,size,le):\n return data[index:index+size]\n \ndef pack_int(number,size,le):\n x=number\n res=[]\n for i in range(size):\n  res.append(x&0xff)\n  x >>= 8\n if le == 'big':\n  res.reverse()\n return bytes(res)\n \ndef pack_signed_int(number,size,le):\n if not isinstance(number, int):\n  raise StructError(\"argument for i,I,l,L,q,Q,h,H must be integer\")\n if number > 2**(8*size-1)-1 or number < -1*2**(8*size-1):\n  raise OverflowError(\"Number:%i too large to convert\" % number)\n return pack_int(number,size,le)\n \ndef pack_unsigned_int(number,size,le):\n if not isinstance(number, int):\n  raise StructError(\"argument for i,I,l,L,q,Q,h,H must be integer\")\n if number < 0:\n  raise TypeError(\"can't convert negative long to unsigned\")\n if number > 2**(8*size)-1:\n  raise OverflowError(\"Number:%i too large to convert\" % number)\n return pack_int(number,size,le)\n \ndef pack_char(char,size,le):\n return bytes(char)\n \ndef isinf(x):\n return x != 0.0 and x / 2 == x\ndef isnan(v):\n return v != v*1.0 or (v == 1.0 and v == 2.0)\n \ndef pack_float(x, size, le):\n unsigned = float_pack(x, size)\n result = []\n for i in range(8):\n  result.append((unsigned >> (i * 8)) & 0xFF)\n if le == \"big\":\n  result.reverse()\n return bytes(result)\n \ndef unpack_float(data, index, size, le):\n binary = [data[i] for i in range(index, index + 8)]\n if le == \"big\":\n  binary.reverse()\n unsigned = 0\n for i in range(8):\n  unsigned |= binary[i] << (i * 8)\n return float_unpack(unsigned, size, le)\n \ndef round_to_nearest(x):\n \"\"\n int_part = int(x)\n frac_part = x - int_part\n if frac_part > 0.5 or frac_part == 0.5 and int_part & 1 == 1:\n  int_part += 1\n return int_part\n \ndef float_unpack(Q, size, le):\n \"\"\n \n if size == 8:\n  MIN_EXP = -1021 \n  MAX_EXP = 1024 \n  MANT_DIG = 53 \n  BITS = 64\n elif size == 4:\n  MIN_EXP = -125 \n  MAX_EXP = 128 \n  MANT_DIG = 24 \n  BITS = 32\n else:\n  raise ValueError(\"invalid size value\")\n  \n if Q >> BITS:\n  raise ValueError(\"input out of range\")\n  \n  \n sign = Q >> BITS - 1\n exp = (Q & ((1 << BITS - 1) - (1 << MANT_DIG - 1))) >> MANT_DIG - 1\n mant = Q & ((1 << MANT_DIG - 1) - 1)\n \n if exp == MAX_EXP - MIN_EXP + 2:\n \n  result = float('nan') if mant else float('inf')\n elif exp == 0:\n \n  result = math.ldexp(float(mant), MIN_EXP - MANT_DIG)\n else:\n \n  mant += 1 << MANT_DIG - 1\n  result = math.ldexp(float(mant), exp + MIN_EXP - MANT_DIG - 1)\n return -result if sign else result\n \n \ndef float_pack(x, size):\n \"\"\n \n if size == 8:\n  MIN_EXP = -1021 \n  MAX_EXP = 1024 \n  MANT_DIG = 53 \n  BITS = 64\n elif size == 4:\n  MIN_EXP = -125 \n  MAX_EXP = 128 \n  MANT_DIG = 24 \n  BITS = 32\n else:\n  raise ValueError(\"invalid size value\")\n  \n sign = math.copysign(1.0, x) < 0.0\n if math.isinf(x):\n  mant = 0\n  exp = MAX_EXP - MIN_EXP + 2\n elif math.isnan(x):\n  mant = 1 << (MANT_DIG-2) \n  exp = MAX_EXP - MIN_EXP + 2\n elif x == 0.0:\n  mant = 0\n  exp = 0\n else:\n  m, e = math.frexp(abs(x)) \n  exp = e - (MIN_EXP - 1)\n  if exp > 0:\n  \n   mant = round_to_nearest(m * (1 << MANT_DIG))\n   mant -= 1 << MANT_DIG - 1\n  else:\n  \n   if exp + MANT_DIG - 1 >= 0:\n    mant = round_to_nearest(m * (1 << exp + MANT_DIG - 1))\n   else:\n    mant = 0\n   exp = 0\n   \n   \n  assert 0 <= mant <= 1 << MANT_DIG - 1\n  if mant == 1 << MANT_DIG - 1:\n   mant = 0\n   exp += 1\n   \n   \n   \n  if exp >= MAX_EXP - MIN_EXP + 2:\n   raise OverflowError(\"float too large to pack in this format\")\n   \n   \n assert 0 <= mant < 1 << MANT_DIG - 1\n assert 0 <= exp <= MAX_EXP - MIN_EXP + 2\n assert 0 <= sign <= 1\n return ((sign << BITS - 1) | (exp << MANT_DIG - 1)) | mant\n \n \nbig_endian_format = {\n'x':{ 'size' : 1, 'alignment' : 0, 'pack' : None, 'unpack' : None},\n'b':{ 'size' : 1, 'alignment' : 0, 'pack' : pack_signed_int, 'unpack' : unpack_signed_int},\n'B':{ 'size' : 1, 'alignment' : 0, 'pack' : pack_unsigned_int, 'unpack' : unpack_int},\n'c':{ 'size' : 1, 'alignment' : 0, 'pack' : pack_char, 'unpack' : unpack_char},\n's':{ 'size' : 1, 'alignment' : 0, 'pack' : None, 'unpack' : None},\n'p':{ 'size' : 1, 'alignment' : 0, 'pack' : None, 'unpack' : None},\n'h':{ 'size' : 2, 'alignment' : 0, 'pack' : pack_signed_int, 'unpack' : unpack_signed_int},\n'H':{ 'size' : 2, 'alignment' : 0, 'pack' : pack_unsigned_int, 'unpack' : unpack_int},\n'i':{ 'size' : 4, 'alignment' : 0, 'pack' : pack_signed_int, 'unpack' : unpack_signed_int},\n'I':{ 'size' : 4, 'alignment' : 0, 'pack' : pack_unsigned_int, 'unpack' : unpack_int},\n'l':{ 'size' : 4, 'alignment' : 0, 'pack' : pack_signed_int, 'unpack' : unpack_signed_int},\n'L':{ 'size' : 4, 'alignment' : 0, 'pack' : pack_unsigned_int, 'unpack' : unpack_int},\n'q':{ 'size' : 8, 'alignment' : 0, 'pack' : pack_signed_int, 'unpack' : unpack_signed_int},\n'Q':{ 'size' : 8, 'alignment' : 0, 'pack' : pack_unsigned_int, 'unpack' : unpack_int},\n'f':{ 'size' : 4, 'alignment' : 0, 'pack' : pack_float, 'unpack' : unpack_float},\n'd':{ 'size' : 8, 'alignment' : 0, 'pack' : pack_float, 'unpack' : unpack_float},\n}\ndefault = big_endian_format\nformatmode={ '<' : (default, 'little'),\n'>' : (default, 'big'),\n'!' : (default, 'big'),\n'=' : (default, sys.byteorder),\n'@' : (default, sys.byteorder)\n}\n\ndef getmode(fmt):\n try:\n  formatdef,endianness = formatmode[fmt[0]]\n  index = 1\n except (IndexError, KeyError):\n  formatdef,endianness = formatmode['@']\n  index = 0\n return formatdef,endianness,index\ndef getNum(fmt,i):\n num=None\n cur = fmt[i]\n while ('0'<= cur ) and ( cur <= '9'):\n  if num == None:\n   num = int(cur)\n  else:\n   num = 10*num + int(cur)\n  i += 1\n  cur = fmt[i]\n return num,i\n \ndef calcsize(fmt):\n \"\"\n \n formatdef,endianness,i = getmode(fmt)\n num = 0\n result = 0\n while i<len(fmt):\n  num,i = getNum(fmt,i)\n  cur = fmt[i]\n  try:\n   format = formatdef[cur]\n  except KeyError:\n   raise StructError(\"%s is not a valid format\" % cur)\n  if num != None :\n   result += num*format['size']\n  else:\n   result += format['size']\n  num = 0\n  i += 1\n return result\n \ndef pack(fmt,*args):\n \"\"\n formatdef,endianness,i = getmode(fmt)\n args = list(args)\n n_args = len(args)\n result = []\n while i<len(fmt):\n  num,i = getNum(fmt,i)\n  cur = fmt[i]\n  try:\n   format = formatdef[cur]\n  except KeyError:\n   raise StructError(\"%s is not a valid format\" % cur)\n  if num == None :\n   num_s = 0\n   num = 1\n  else:\n   num_s = num\n   \n  if cur == 'x':\n   result += [b'\\0'*num]\n  elif cur == 's':\n   if isinstance(args[0], bytes):\n    padding = num - len(args[0])\n    result += [args[0][:num] + b'\\0'*padding]\n    args.pop(0)\n   else:\n    raise StructError(\"arg for string format not a string\")\n  elif cur == 'p':\n   if isinstance(args[0], bytes):\n    padding = num - len(args[0]) - 1\n    \n    if padding > 0:\n     result += [bytes([len(args[0])]) + args[0][:num-1] + b'\\0'*padding]\n    else:\n     if num<255:\n      result += [bytes([num-1]) + args[0][:num-1]]\n     else:\n      result += [bytes([255]) + args[0][:num-1]]\n    args.pop(0)\n   else:\n    raise StructError(\"arg for string format not a string\")\n    \n  else:\n   if len(args) < num:\n    raise StructError(\"insufficient arguments to pack\")\n   for var in args[:num]:\n    result += [format['pack'](var,format['size'],endianness)]\n   args=args[num:]\n  num = None\n  i += 1\n if len(args) != 0:\n  raise StructError(\"too many arguments for pack format\")\n return b''.join(result)\n \ndef unpack(fmt,data):\n \"\"\n formatdef,endianness,i = getmode(fmt)\n j = 0\n num = 0\n result = []\n length= calcsize(fmt)\n if length != len (data):\n  raise StructError(\"unpack str size does not match format\")\n while i<len(fmt):\n  num,i=getNum(fmt,i)\n  cur = fmt[i]\n  i += 1\n  try:\n   format = formatdef[cur]\n  except KeyError:\n   raise StructError(\"%s is not a valid format\" % cur)\n   \n  if not num :\n   num = 1\n   \n  if cur == 'x':\n   j += num\n  elif cur == 's':\n   result.append(data[j:j+num])\n   j += num\n  elif cur == 'p':\n   n=data[j]\n   if n >= num:\n    n = num-1\n   result.append(data[j+1:j+n+1])\n   j += num\n  else:\n   for n in range(num):\n    result += [format['unpack'](data,j,format['size'],endianness)]\n    j += format['size']\n    \n return tuple(result)\n \ndef pack_into(fmt, buf, offset, *args):\n data = pack(fmt, *args)\n buffer(buf)[offset:offset+len(data)] = data\n \ndef unpack_from(fmt, buf, offset=0):\n size = calcsize(fmt)\n data = buffer(buf)[offset:offset+size]\n if len(data) != size:\n  raise error(\"unpack_from requires a buffer of at least %d bytes\"\n  % (size,))\n return unpack(fmt, data)\n \ndef _clearcache():\n \"\"\n \n"], "site-packages.pygame.constants": [".py", "\n\n\"\"\n\n__docformat__ = 'restructuredtext'\n__version__ = '$Id$'\n\n\n\n\n\"\"\nFULLSCREEN = 0\n\"\"\nRLEACCELOK = 254\nRLEACCEL = 255\n\n\"\"\n\ndef _t(a, b, c, d):\n return (ord(a) << 24) | (ord(b) << 16) | (ord(c) << 8) | ord(d)\n \nSCRAP_TEXT = _t('T', 'E', 'X', 'T')\nSCRAP_BMP = _t('B', 'M', 'P', ' ')\n\nBLEND_ADD = 0x01\nBLEND_SUB = 0x02\nBLEND_MULT = 0x03\nBLEND_MIN = 0x04\nBLEND_MAX = 0x05\n\n\"\"\n\n\nK_0 = 48\nK_1 = 49\nK_2 = 50\nK_3 = 51\nK_4 = 52\nK_5 = 53\nK_6 = 54\nK_7 = 55\nK_8 = 56\nK_9 = 57\nK_AMPERSAND = 38\nK_ASTERISK = 42\nK_AT = 64\nK_BACKQUOTE = 96\nK_BACKSLASH = 92\nK_BACKSPACE = 8\n\nK_CAPSLOCK = 1073741881\nK_CARET = 94\nK_CLEAR = 1073742040\nK_COLON = 58\nK_COMMA = 44\n\nK_DELETE = 127\nK_DOLLAR = 36\nK_DOWN = 1073741905\nK_END = 1073741901\nK_EQUALS = 1073741927\nK_ESCAPE = 27\n\nK_EXCLAIM = 33\nK_F1 = 1073741882\nK_F10 = 1073741891\nK_F11 = 1073741892\nK_F12 = 1073741893\nK_F13 = 1073741928\nK_F14 = 1073741929\nK_F15 = 1073741930\nK_F2 = 1073741883\nK_F3 = 1073741884\nK_F4 = 1073741885\nK_F5 = 1073741886\nK_F6 = 1073741887\nK_F7 = 1073741888\nK_F8 = 1073741889\nK_F9 = 1073741890\n\nK_GREATER = 1073742022\nK_HASH = 1073742028\nK_HELP = 1073741941\nK_HOME = 1073741898\nK_INSERT = 1073741897\nK_KP0 = 1073741922\nK_KP1 = 1073741913\nK_KP2 = 1073741914\nK_KP3 = 1073741915\nK_KP4 = 1073741916\nK_KP5 = 1073741917\nK_KP6 = 1073741918\nK_KP7 = 1073741919\nK_KP8 = 1073741920\nK_KP9 = 1073741921\nK_KP_DIVIDE = 1073741908\nK_KP_ENTER = 1073741912\nK_KP_EQUALS = 1073741927\nK_KP_MINUS = 1073741910\nK_KP_MULTIPLY = 1073741909\nK_KP_PERIOD = 1073741923\nK_KP_PLUS = 1073741911\nK_LALT = 1073742050\n\nK_LCTRL = 1073742048\nK_LEFT = 1073741904\n\nK_LEFTPAREN = 1073742006\n\n\nK_LSHIFT = 1073742049\n\nK_MENU = 1073741942\nK_MINUS = 45\nK_MODE = 1073742081\n\nK_PAGEDOWN = 1073741902\nK_PAGEUP = 1073741899\nK_PAUSE = 1073741896\n\nK_PLUS = 43\n\n\nK_QUESTION = 63\nK_QUOTE = 39\nK_QUOTEDBL = 34\nK_RALT = 1073742054\nK_RCTRL = 1073742052\nK_RETURN = 13\nK_RIGHT = 1073741903\n\nK_RIGHTPAREN = 41\n\nK_RSHIFT = 1073742053\n\nK_SCROLLOCK = 1073741895\nK_SEMICOLON = 59\nK_SLASH = 47\nK_SPACE = 1073742029\nK_SYSREQ = 1073741978\nK_TAB = 9\nK_UNDERSCORE = 95\nK_UNDO = 1073741946\nK_UNKNOWN = 0\nK_UP = 1073741906\n\n\"\"\n\nK_a = 97\nK_b = 98\nK_c = 99\nK_d = 100\nK_e = 101\nK_f = 102\nK_g = 103\nK_h = 104\nK_i = 105\nK_j = 106\nK_k = 107\nK_l = 108\nK_m = 109\nK_n = 110\nK_o = 111\nK_p = 112\nK_q = 113\nK_r = 114\nK_s = 115\nK_t = 116\nK_u = 117\nK_v = 118\nK_w = 119\nK_x = 120\nK_y = 121\nK_z = 122\n\n\n"], "hashlib": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins\n\nvar $s=[]\nfor(var $b in _b_) $s.push('var ' + $b +'=_b_[\"'+$b+'\"]')\neval($s.join(';'))\n\nvar $mod = {\n\n    __getattr__ : function(attr){\n        if (attr == 'new') return $hashlib_new;\n        return this[attr]\n    },\n    md5: function() {return $hashlib_new('md5')},\n    sha1: function() {return $hashlib_new('sha1')},\n    sha224: function() {return $hashlib_new('sha224')},\n    sha256: function() {return $hashlib_new('sha256')},\n    sha384: function() {return $hashlib_new('sha384')},\n    sha512: function() {return $hashlib_new('sha512')},\n\n    algorithms_guaranteed: ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    algorithms_available:  ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512']\n}\n\n\n//todo: eventually move this function to a \"utility\" file or use ajax module?\nfunction $get_CryptoJS_lib(alg) {\n   var imp=$importer()\n   var $xmlhttp=imp[0], fake_qs=imp[1], timer=imp[2], res=null\n\n   $xmlhttp.onreadystatechange = function(){\n        if($xmlhttp.readyState==4){\n            window.clearTimeout(timer)\n            if($xmlhttp.status==200 || $xmlhttp.status==0){res=$xmlhttp.responseText}\n            else{\n                // don't throw an exception here, it will not be caught (issue #30)\n                res = Error()\n                res.name = 'NotFoundError'\n                res.message = \"No CryptoJS lib named '\"+alg+\"'\"\n            }\n        }\n   }\n\n   $xmlhttp.open('GET', $B.brython_path+'libs/crypto_js/rollups/'+alg+'.js'+fake_qs,false)\n   if('overrideMimeType' in $xmlhttp){$xmlhttp.overrideMimeType(\"text/plain\")}\n   $xmlhttp.send()\n   if(res.constructor===Error){throw res} // module not found\n\n   try{\n      eval(res + \"; $B.CryptoJS=CryptoJS;\")\n   } catch (err) { \n      throw Error(\"JS Eval Error\", \"Cannot eval CryptoJS algorithm '\" + alg + \"' : error:\" + err);\n   }\n}\n\nfunction $hashlib_new(alg) {\n    switch(alg) {\n      case 'md5':\n      case 'sha1':\n      case 'sha224':\n      case 'sha256':\n      case 'sha384':\n      case 'sha512':\n        var ALG=alg.toUpperCase()\n        if ($B.Crypto === undefined || \n            $B.CryptoJS.algo[ALG] === undefined) $get_CryptoJS_lib(alg)\n\n        this.hash = $B.CryptoJS.algo[ALG].create()\n        break\n      default:\n        $raise('AttributeError', 'Invalid hash algorithm:' + alg)\n    }\n \n    this.__class__ = $B.$type\n    this.__getattr__ = function(attr){return $getattr(this,attr)}\n    this.__str__ = function(){return this.hexdigest()}\n    this.update = function(msg){this.hash.update(msg)}\n    this.copy = function(){return this.hash.clone()}\n\n    this.hexdigest = function() {\n        var temp=this.hash.clone()\n        temp=temp.finalize()\n        return temp.toString()\n    }\n\n    return this\n}\n\nreturn $mod\n\n})(__BRYTHON__)\n"], "keyword": [".py", "\n\n\"\"\n\n__all__ = [\"iskeyword\", \"kwlist\"]\n\nkwlist = [\n\n'False',\n'None',\n'True',\n'and',\n'as',\n'assert',\n'break',\n'class',\n'continue',\n'def',\n'del',\n'elif',\n'else',\n'except',\n'finally',\n'for',\n'from',\n'global',\n'if',\n'import',\n'in',\n'is',\n'lambda',\n'nonlocal',\n'not',\n'or',\n'pass',\n'raise',\n'return',\n'try',\n'while',\n'with',\n'yield',\n\n]\n\niskeyword = frozenset(kwlist).__contains__\n\ndef main():\n import sys, re\n \n args = sys.argv[1:]\n iptfile = args and args[0] or \"Python/graminit.c\"\n if len(args) > 1: optfile = args[1]\n else: optfile = \"Lib/keyword.py\"\n \n \n with open(iptfile) as fp:\n  strprog = re.compile('\"([^\"]+)\"')\n  lines = []\n  for line in fp:\n   if '{1, \"' in line:\n    match = strprog.search(line)\n    if match:\n     lines.append(\"        '\" + match.group(1) + \"',\\n\")\n lines.sort()\n \n \n with open(optfile) as fp:\n  format = fp.readlines()\n  \n  \n try:\n  start = format.index(\"#--start keywords--\\n\") + 1\n  end = format.index(\"#--end keywords--\\n\")\n  format[start:end] = lines\n except ValueError:\n  sys.stderr.write(\"target does not contain format markers\\n\")\n  sys.exit(1)\n  \n  \n fp = open(optfile, 'w')\n fp.write(''.join(format))\n fp.close()\n \nif __name__ == \"__main__\":\n main()\n"], "this": [".py", "s = \"\"\"Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\"\"\"\n\nd = {}\nfor c in (65, 97):\n for i in range(26):\n  d[chr(i+c)] = chr((i+13) % 26 + c)\n  \nprint(\"\".join([d.get(c, c) for c in s]))\n"], "_csv": [".py", "\"\"\n\n__version__ = \"1.0\"\n\nQUOTE_MINIMAL, QUOTE_ALL, QUOTE_NONNUMERIC, QUOTE_NONE = range(4)\n_dialects = {}\n_field_limit = 128 * 1024 \n\nclass Error(Exception):\n pass\n \nclass Dialect(object):\n \"\"\n \n __slots__ = [\"_delimiter\", \"_doublequote\", \"_escapechar\",\n \"_lineterminator\", \"_quotechar\", \"_quoting\",\n \"_skipinitialspace\", \"_strict\"]\n \n def __new__(cls, dialect, **kwargs):\n \n  for name in kwargs:\n   if '_' + name not in Dialect.__slots__:\n    raise TypeError(\"unexpected keyword argument '%s'\" %\n    (name,))\n    \n  if dialect is not None:\n   if isinstance(dialect, str):\n    dialect = get_dialect(dialect)\n    \n    \n   if (isinstance(dialect, Dialect)\n   and all(value is None for value in kwargs.values())):\n    return dialect\n    \n  self = object.__new__(cls)\n  \n  \n  def set_char(x):\n   if x is None:\n    return None\n   if isinstance(x, str) and len(x) <= 1:\n    return x\n   raise TypeError(\"%r must be a 1-character string\" % (name,))\n  def set_str(x):\n   if isinstance(x, str):\n    return x\n   raise TypeError(\"%r must be a string\" % (name,))\n  def set_quoting(x):\n   if x in range(4):\n    return x\n   raise TypeError(\"bad 'quoting' value\")\n   \n  attributes = {\"delimiter\": (',', set_char),\n  \"doublequote\": (True, bool),\n  \"escapechar\": (None, set_char),\n  \"lineterminator\": (\"\\r\\n\", set_str),\n  \"quotechar\": ('\"', set_char),\n  \"quoting\": (QUOTE_MINIMAL, set_quoting),\n  \"skipinitialspace\": (False, bool),\n  \"strict\": (False, bool),\n  }\n  \n  \n  notset = object()\n  for name in Dialect.__slots__:\n   name = name[1:]\n   value = notset\n   if name in kwargs:\n    value = kwargs[name]\n   elif dialect is not None:\n    value = getattr(dialect, name, notset)\n    \n    \n   if value is notset:\n    value = attributes[name][0]\n    if name == 'quoting' and not self.quotechar:\n     value = QUOTE_NONE\n   else:\n    converter = attributes[name][1]\n    if converter:\n     value = converter(value)\n     \n   setattr(self, '_' + name, value)\n   \n  if not self.delimiter:\n   raise TypeError(\"delimiter must be set\")\n   \n  if self.quoting != QUOTE_NONE and not self.quotechar:\n   raise TypeError(\"quotechar must be set if quoting enabled\")\n   \n  if not self.lineterminator:\n   raise TypeError(\"lineterminator must be set\")\n   \n  return self\n  \n delimiter = property(lambda self: self._delimiter)\n doublequote = property(lambda self: self._doublequote)\n escapechar = property(lambda self: self._escapechar)\n lineterminator = property(lambda self: self._lineterminator)\n quotechar = property(lambda self: self._quotechar)\n quoting = property(lambda self: self._quoting)\n skipinitialspace = property(lambda self: self._skipinitialspace)\n strict = property(lambda self: self._strict)\n \n \ndef _call_dialect(dialect_inst, kwargs):\n return Dialect(dialect_inst, **kwargs)\n \ndef register_dialect(name, dialect=None, **kwargs):\n \"\"\n if not isinstance(name, str):\n  raise TypeError(\"dialect name must be a string or unicode\")\n  \n dialect = _call_dialect(dialect, kwargs)\n _dialects[name] = dialect\n \ndef unregister_dialect(name):\n \"\"\n try:\n  del _dialects[name]\n except KeyError:\n  raise Error(\"unknown dialect\")\n  \ndef get_dialect(name):\n \"\"\n try:\n  return _dialects[name]\n except KeyError:\n  raise Error(\"unknown dialect\")\n  \ndef list_dialects():\n \"\"\n return list(_dialects)\n \nclass Reader(object):\n \"\"\n \n \n (START_RECORD, START_FIELD, ESCAPED_CHAR, IN_FIELD,\n IN_QUOTED_FIELD, ESCAPE_IN_QUOTED_FIELD, QUOTE_IN_QUOTED_FIELD,\n EAT_CRNL) = range(8)\n \n def __init__(self, iterator, dialect=None, **kwargs):\n  self.dialect = _call_dialect(dialect, kwargs)\n  \n  \n  \n  self._delimiter = self.dialect.delimiter if self.dialect.delimiter else '\\0'\n  self._quotechar = self.dialect.quotechar if self.dialect.quotechar else '\\0'\n  self._escapechar = self.dialect.escapechar if self.dialect.escapechar else '\\0'\n  self._doublequote = self.dialect.doublequote\n  self._quoting = self.dialect.quoting\n  self._skipinitialspace = self.dialect.skipinitialspace\n  self._strict = self.dialect.strict\n  \n  self.input_iter = iter(iterator)\n  self.line_num = 0\n  \n  self._parse_reset()\n  \n def _parse_reset(self):\n  self.field = ''\n  self.fields = []\n  self.state = self.START_RECORD\n  self.numeric_field = False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  self._parse_reset()\n  while True:\n   try:\n    line = next(self.input_iter)\n   except StopIteration:\n   \n    if len(self.field) > 0:\n     raise Error(\"newline inside string\")\n    raise\n    \n   self.line_num += 1\n   \n   if '\\0' in line:\n    raise Error(\"line contains NULL byte\")\n   self._parse_process_char(line)\n   self._parse_eol()\n   \n   if self.state == self.START_RECORD:\n    break\n    \n  fields = self.fields\n  self.fields = []\n  return fields\n  \n def _parse_process_char(self, line):\n  pos = 0\n  while pos < len(line):\n   if self.state == self.IN_FIELD:\n   \n    pos2 = pos\n    while pos2 < len(line):\n     if line[pos2] == '\\n' or line[pos2] == '\\r':\n     \n      if pos2 > pos:\n       self._parse_add_str(line[pos:pos2])\n       pos = pos2\n      self._parse_save_field()\n      self.state = self.EAT_CRNL\n      break\n     elif line[pos2] == self._escapechar[0]:\n     \n      if pos2 > pos:\n       self._parse_add_str(line[pos:pos2])\n      pos = pos2\n      self.state = self.ESCAPED_CHAR\n      break\n     elif line[pos2] == self._delimiter[0]:\n     \n      if pos2 > pos:\n       self._parse_add_str(line[pos:pos2])\n       pos = pos2\n      self._parse_save_field()\n      self.state = self.START_FIELD\n      break\n      \n     pos2 += 1\n    else:\n     if pos2 > pos:\n      self._parse_add_str(line[pos:pos2])\n      pos = pos2\n      continue\n      \n   elif self.state == self.START_RECORD:\n    if line[pos] == '\\n' or line[pos] == '\\r':\n     self.state = self.EAT_CRNL\n    else:\n     self.state = self.START_FIELD\n     \n     continue\n     \n   elif self.state == self.START_FIELD:\n    if line[pos] == '\\n' or line[pos] == '\\r':\n    \n     self._parse_save_field()\n     self.state = self.EAT_CRNL\n    elif (line[pos] == self._quotechar[0]\n    and self._quoting != QUOTE_NONE):\n    \n     self.state = self.IN_QUOTED_FIELD\n    elif line[pos] == self._escapechar[0]:\n    \n     self.state = self.ESCAPED_CHAR\n    elif self._skipinitialspace and line[pos] == ' ':\n    \n     pass\n    elif line[pos] == self._delimiter[0]:\n    \n     self._parse_save_field()\n    else:\n    \n     if self._quoting == QUOTE_NONNUMERIC:\n      self.numeric_field = True\n     self.state = self.IN_FIELD\n     continue\n     \n   elif self.state == self.ESCAPED_CHAR:\n    self._parse_add_char(line[pos])\n    self.state = self.IN_FIELD\n    \n   elif self.state == self.IN_QUOTED_FIELD:\n    if line[pos] == self._escapechar:\n    \n     self.state = self.ESCAPE_IN_QUOTED_FIELD\n    elif (line[pos] == self._quotechar\n    and self._quoting != QUOTE_NONE):\n     if self._doublequote:\n     \n      self.state = self.QUOTE_IN_QUOTED_FIELD\n     else:\n     \n      self.state = self.IN_FIELD\n    else:\n    \n     self._parse_add_char(line[pos])\n     \n   elif self.state == self.ESCAPE_IN_QUOTED_FIELD:\n    self._parse_add_char(line[pos])\n    self.state = self.IN_QUOTED_FIELD\n    \n   elif self.state == self.QUOTE_IN_QUOTED_FIELD:\n   \n    if (line[pos] == self._quotechar\n    and self._quoting != QUOTE_NONE):\n    \n     self._parse_add_char(line[pos])\n     self.state = self.IN_QUOTED_FIELD\n    elif line[pos] == self._delimiter[0]:\n    \n     self._parse_save_field()\n     self.state = self.START_FIELD\n    elif line[pos] == '\\r' or line[pos] == '\\n':\n    \n     self._parse_save_field()\n     self.state = self.EAT_CRNL\n    elif not self._strict:\n     self._parse_add_char(line[pos])\n     self.state = self.IN_FIELD\n    else:\n     raise Error(\"'%c' expected after '%c'\" %\n     (self._delimiter, self._quotechar))\n     \n   elif self.state == self.EAT_CRNL:\n    if line[pos] == '\\r' or line[pos] == '\\n':\n     pass\n    else:\n     raise Error(\"new-line character seen in unquoted field - \"\n     \"do you need to open the file \"\n     \"in universal-newline mode?\")\n     \n   else:\n    raise RuntimeError(\"unknown state: %r\" % (self.state,))\n    \n   pos += 1\n   \n def _parse_eol(self):\n  if self.state == self.EAT_CRNL:\n   self.state = self.START_RECORD\n  elif self.state == self.START_RECORD:\n  \n   pass\n  elif self.state == self.IN_FIELD:\n  \n  \n   self._parse_save_field()\n   self.state = self.START_RECORD\n  elif self.state == self.START_FIELD:\n  \n   self._parse_save_field()\n   self.state = self.START_RECORD\n  elif self.state == self.ESCAPED_CHAR:\n   self._parse_add_char('\\n')\n   self.state = self.IN_FIELD\n  elif self.state == self.IN_QUOTED_FIELD:\n   pass\n  elif self.state == self.ESCAPE_IN_QUOTED_FIELD:\n   self._parse_add_char('\\n')\n   self.state = self.IN_QUOTED_FIELD\n  elif self.state == self.QUOTE_IN_QUOTED_FIELD:\n  \n   self._parse_save_field()\n   self.state = self.START_RECORD\n  else:\n   raise RuntimeError(\"unknown state: %r\" % (self.state,))\n   \n def _parse_save_field(self):\n  field, self.field = self.field, ''\n  if self.numeric_field:\n   self.numeric_field = False\n   field = float(field)\n  self.fields.append(field)\n  \n def _parse_add_char(self, c):\n  if len(self.field) + 1 > _field_limit:\n   raise Error(\"field larget than field limit (%d)\" % (_field_limit))\n  self.field += c\n  \n def _parse_add_str(self, s):\n  if len(self.field) + len(s) > _field_limit:\n   raise Error(\"field larget than field limit (%d)\" % (_field_limit))\n  self.field += s\n  \n  \nclass Writer(object):\n \"\"\n \n def __init__(self, file, dialect=None, **kwargs):\n  if not (hasattr(file, 'write') and callable(file.write)):\n   raise TypeError(\"argument 1 must have a 'write' method\")\n  self.writeline = file.write\n  self.dialect = _call_dialect(dialect, kwargs)\n  \n def _join_reset(self):\n  self.rec = []\n  self.num_fields = 0\n  \n def _join_append(self, field, quoted, quote_empty):\n  dialect = self.dialect\n  \n  if self.num_fields > 0:\n   self.rec.append(dialect.delimiter)\n   \n  if dialect.quoting == QUOTE_NONE:\n   need_escape = tuple(dialect.lineterminator) + (\n   dialect.escapechar, \n   dialect.delimiter, dialect.quotechar)\n   \n  else:\n   for c in tuple(dialect.lineterminator) + (\n   dialect.delimiter, dialect.escapechar):\n    if c and c in field:\n     quoted = True\n     \n   need_escape = ()\n   if dialect.quotechar in field:\n    if dialect.doublequote:\n     field = field.replace(dialect.quotechar,\n     dialect.quotechar * 2)\n     quoted = True\n    else:\n     need_escape = (dialect.quotechar,)\n     \n     \n  for c in need_escape:\n   if c and c in field:\n    if not dialect.escapechar:\n     raise Error(\"need to escape, but no escapechar set\")\n    field = field.replace(c, dialect.escapechar + c)\n    \n    \n  if field == '' and quote_empty:\n   if dialect.quoting == QUOTE_NONE:\n    raise Error(\"single empty field record must be quoted\")\n   quoted = 1\n   \n  if quoted:\n   field = dialect.quotechar + field + dialect.quotechar\n   \n  self.rec.append(field)\n  self.num_fields += 1\n  \n  \n  \n def writerow(self, row):\n  dialect = self.dialect\n  try:\n   rowlen = len(row)\n  except TypeError:\n   raise Error(\"sequence expected\")\n   \n   \n  self._join_reset()\n  \n  for field in row:\n   quoted = False\n   if dialect.quoting == QUOTE_NONNUMERIC:\n    try:\n     float(field)\n    except:\n     quoted = True\n     \n     \n   elif dialect.quoting == QUOTE_ALL:\n    quoted = True\n    \n   if field is None:\n    self._join_append(\"\", quoted, rowlen == 1)\n   else:\n    self._join_append(str(field), quoted, rowlen == 1)\n    \n    \n  self.rec.append(dialect.lineterminator)\n  \n  self.writeline(''.join(self.rec))\n  \n def writerows(self, rows):\n  for row in rows:\n   self.writerow(row)\n   \ndef reader(*args, **kwargs):\n \"\"\n \n return Reader(*args, **kwargs)\n \ndef writer(*args, **kwargs):\n \"\"\n return Writer(*args, **kwargs)\n \n \nundefined = object()\ndef field_size_limit(limit=undefined):\n \"\"\n \n global _field_limit\n old_limit = _field_limit\n \n if limit is not undefined:\n  if not isinstance(limit, (int, long)):\n   raise TypeError(\"int expected, got %s\" %\n   (limit.__class__.__name__,))\n  _field_limit = limit\n  \n return old_limit\n"], "xml.dom.minidom": [".py", "\"\"\n\nimport io\nimport xml.dom\n\nfrom xml.dom import EMPTY_NAMESPACE, EMPTY_PREFIX, XMLNS_NAMESPACE, domreg\nfrom xml.dom.minicompat import *\nfrom xml.dom.xmlbuilder import DOMImplementationLS, DocumentLS\n\n\n\n\n\n\n_nodeTypes_with_children = (xml.dom.Node.ELEMENT_NODE,\nxml.dom.Node.ENTITY_REFERENCE_NODE)\n\n\nclass Node(xml.dom.Node):\n namespaceURI = None \n parentNode = None\n ownerDocument = None\n nextSibling = None\n previousSibling = None\n \n prefix = EMPTY_PREFIX \n \n def __bool__(self):\n  return True\n  \n def toxml(self, encoding=None):\n  return self.toprettyxml(\"\", \"\", encoding)\n  \n def toprettyxml(self, indent=\"\\t\", newl=\"\\n\", encoding=None):\n  if encoding is None:\n   writer = io.StringIO()\n  else:\n   writer = io.TextIOWrapper(io.BytesIO(),\n   encoding=encoding,\n   errors=\"xmlcharrefreplace\",\n   newline='\\n')\n  if self.nodeType == Node.DOCUMENT_NODE:\n  \n   self.writexml(writer, \"\", indent, newl, encoding)\n  else:\n   self.writexml(writer, \"\", indent, newl)\n  if encoding is None:\n   return writer.getvalue()\n  else:\n   return writer.detach().getvalue()\n   \n def hasChildNodes(self):\n  return bool(self.childNodes)\n  \n def _get_childNodes(self):\n  return self.childNodes\n  \n def _get_firstChild(self):\n  if self.childNodes:\n   return self.childNodes[0]\n   \n def _get_lastChild(self):\n  if self.childNodes:\n   return self.childNodes[-1]\n   \n def insertBefore(self, newChild, refChild):\n  if newChild.nodeType == self.DOCUMENT_FRAGMENT_NODE:\n   for c in tuple(newChild.childNodes):\n    self.insertBefore(c, refChild)\n    \n   return newChild\n  if newChild.nodeType not in self._child_node_types:\n   raise xml.dom.HierarchyRequestErr(\n   \"%s cannot be child of %s\" % (repr(newChild), repr(self)))\n  if newChild.parentNode is not None:\n   newChild.parentNode.removeChild(newChild)\n  if refChild is None:\n   self.appendChild(newChild)\n  else:\n   try:\n    index = self.childNodes.index(refChild)\n   except ValueError:\n    raise xml.dom.NotFoundErr()\n   if newChild.nodeType in _nodeTypes_with_children:\n    _clear_id_cache(self)\n   self.childNodes.insert(index, newChild)\n   newChild.nextSibling = refChild\n   refChild.previousSibling = newChild\n   if index:\n    node = self.childNodes[index-1]\n    node.nextSibling = newChild\n    newChild.previousSibling = node\n   else:\n    newChild.previousSibling = None\n   newChild.parentNode = self\n  return newChild\n  \n def appendChild(self, node):\n  if node.nodeType == self.DOCUMENT_FRAGMENT_NODE:\n   for c in tuple(node.childNodes):\n    self.appendChild(c)\n    \n   return node\n  if node.nodeType not in self._child_node_types:\n   raise xml.dom.HierarchyRequestErr(\n   \"%s cannot be child of %s\" % (repr(node), repr(self)))\n  elif node.nodeType in _nodeTypes_with_children:\n   _clear_id_cache(self)\n  if node.parentNode is not None:\n   node.parentNode.removeChild(node)\n  _append_child(self, node)\n  node.nextSibling = None\n  return node\n  \n def replaceChild(self, newChild, oldChild):\n  if newChild.nodeType == self.DOCUMENT_FRAGMENT_NODE:\n   refChild = oldChild.nextSibling\n   self.removeChild(oldChild)\n   return self.insertBefore(newChild, refChild)\n  if newChild.nodeType not in self._child_node_types:\n   raise xml.dom.HierarchyRequestErr(\n   \"%s cannot be child of %s\" % (repr(newChild), repr(self)))\n  if newChild is oldChild:\n   return\n  if newChild.parentNode is not None:\n   newChild.parentNode.removeChild(newChild)\n  try:\n   index = self.childNodes.index(oldChild)\n  except ValueError:\n   raise xml.dom.NotFoundErr()\n  self.childNodes[index] = newChild\n  newChild.parentNode = self\n  oldChild.parentNode = None\n  if (newChild.nodeType in _nodeTypes_with_children\n  or oldChild.nodeType in _nodeTypes_with_children):\n   _clear_id_cache(self)\n  newChild.nextSibling = oldChild.nextSibling\n  newChild.previousSibling = oldChild.previousSibling\n  oldChild.nextSibling = None\n  oldChild.previousSibling = None\n  if newChild.previousSibling:\n   newChild.previousSibling.nextSibling = newChild\n  if newChild.nextSibling:\n   newChild.nextSibling.previousSibling = newChild\n  return oldChild\n  \n def removeChild(self, oldChild):\n  try:\n   self.childNodes.remove(oldChild)\n  except ValueError:\n   raise xml.dom.NotFoundErr()\n  if oldChild.nextSibling is not None:\n   oldChild.nextSibling.previousSibling = oldChild.previousSibling\n  if oldChild.previousSibling is not None:\n   oldChild.previousSibling.nextSibling = oldChild.nextSibling\n  oldChild.nextSibling = oldChild.previousSibling = None\n  if oldChild.nodeType in _nodeTypes_with_children:\n   _clear_id_cache(self)\n   \n  oldChild.parentNode = None\n  return oldChild\n  \n def normalize(self):\n  L = []\n  for child in self.childNodes:\n   if child.nodeType == Node.TEXT_NODE:\n    if not child.data:\n    \n     if L:\n      L[-1].nextSibling = child.nextSibling\n     if child.nextSibling:\n      child.nextSibling.previousSibling = child.previousSibling\n     child.unlink()\n    elif L and L[-1].nodeType == child.nodeType:\n    \n     node = L[-1]\n     node.data = node.data + child.data\n     node.nextSibling = child.nextSibling\n     if child.nextSibling:\n      child.nextSibling.previousSibling = node\n     child.unlink()\n    else:\n     L.append(child)\n   else:\n    L.append(child)\n    if child.nodeType == Node.ELEMENT_NODE:\n     child.normalize()\n  self.childNodes[:] = L\n  \n def cloneNode(self, deep):\n  return _clone_node(self, deep, self.ownerDocument or self)\n  \n def isSupported(self, feature, version):\n  return self.ownerDocument.implementation.hasFeature(feature, version)\n  \n def _get_localName(self):\n \n  return None\n  \n  \n  \n def isSameNode(self, other):\n  return self is other\n  \n def getInterface(self, feature):\n  if self.isSupported(feature, None):\n   return self\n  else:\n   return None\n   \n   \n   \n   \n   \n def getUserData(self, key):\n  try:\n   return self._user_data[key][0]\n  except (AttributeError, KeyError):\n   return None\n   \n def setUserData(self, key, data, handler):\n  old = None\n  try:\n   d = self._user_data\n  except AttributeError:\n   d = {}\n   self._user_data = d\n  if key in d:\n   old = d[key][0]\n  if data is None:\n  \n   handler = None\n   if old is not None:\n    del d[key]\n  else:\n   d[key] = (data, handler)\n  return old\n  \n def _call_user_data_handler(self, operation, src, dst):\n  if hasattr(self, \"_user_data\"):\n   for key, (data, handler) in list(self._user_data.items()):\n    if handler is not None:\n     handler.handle(operation, key, data, src, dst)\n     \n     \n     \n def unlink(self):\n  self.parentNode = self.ownerDocument = None\n  if self.childNodes:\n   for child in self.childNodes:\n    child.unlink()\n   self.childNodes = NodeList()\n  self.previousSibling = None\n  self.nextSibling = None\n  \n  \n  \n def __enter__(self):\n  return self\n  \n def __exit__(self, et, ev, tb):\n  self.unlink()\n  \ndefproperty(Node, \"firstChild\", doc=\"First child node, or None.\")\ndefproperty(Node, \"lastChild\", doc=\"Last child node, or None.\")\ndefproperty(Node, \"localName\", doc=\"Namespace-local name of this node.\")\n\n\ndef _append_child(self, node):\n\n childNodes = self.childNodes\n if childNodes:\n  last = childNodes[-1]\n  node.previousSibling = last\n  last.nextSibling = node\n childNodes.append(node)\n node.parentNode = self\n \ndef _in_document(node):\n\n while node is not None:\n  if node.nodeType == Node.DOCUMENT_NODE:\n   return True\n  node = node.parentNode\n return False\n \ndef _write_data(writer, data):\n \"\"\n if data:\n  data = data.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\"). replace(\"\\\"\", \"&quot;\").replace(\">\", \"&gt;\")\n  writer.write(data)\n  \ndef _get_elements_by_tagName_helper(parent, name, rc):\n for node in parent.childNodes:\n  if node.nodeType == Node.ELEMENT_NODE and (name == \"*\" or node.tagName == name):\n   rc.append(node)\n  _get_elements_by_tagName_helper(node, name, rc)\n return rc\n \ndef _get_elements_by_tagName_ns_helper(parent, nsURI, localName, rc):\n for node in parent.childNodes:\n  if node.nodeType == Node.ELEMENT_NODE:\n   if ((localName == \"*\" or node.localName == localName) and\n   (nsURI == \"*\" or node.namespaceURI == nsURI)):\n    rc.append(node)\n   _get_elements_by_tagName_ns_helper(node, nsURI, localName, rc)\n return rc\n \nclass DocumentFragment(Node):\n nodeType = Node.DOCUMENT_FRAGMENT_NODE\n nodeName = \"#document-fragment\"\n nodeValue = None\n attributes = None\n parentNode = None\n _child_node_types = (Node.ELEMENT_NODE,\n Node.TEXT_NODE,\n Node.CDATA_SECTION_NODE,\n Node.ENTITY_REFERENCE_NODE,\n Node.PROCESSING_INSTRUCTION_NODE,\n Node.COMMENT_NODE,\n Node.NOTATION_NODE)\n \n def __init__(self):\n  self.childNodes = NodeList()\n  \n  \nclass Attr(Node):\n __slots__=('_name', '_value', 'namespaceURI',\n '_prefix', 'childNodes', '_localName', 'ownerDocument', 'ownerElement')\n nodeType = Node.ATTRIBUTE_NODE\n attributes = None\n specified = False\n _is_id = False\n \n _child_node_types = (Node.TEXT_NODE, Node.ENTITY_REFERENCE_NODE)\n \n def __init__(self, qName, namespaceURI=EMPTY_NAMESPACE, localName=None,\n prefix=None):\n  self.ownerElement = None\n  self._name = qName\n  self.namespaceURI = namespaceURI\n  self._prefix = prefix\n  self.childNodes = NodeList()\n  \n  \n  self.childNodes.append(Text())\n  \n  \n  \n def _get_localName(self):\n  try:\n   return self._localName\n  except AttributeError:\n   return self.nodeName.split(\":\", 1)[-1]\n   \n def _get_name(self):\n  return self.name\n  \n def _get_specified(self):\n  return self.specified\n  \n def _get_name(self):\n  return self._name\n  \n def _set_name(self, value):\n  self._name = value\n  if self.ownerElement is not None:\n   _clear_id_cache(self.ownerElement)\n   \n nodeName = name = property(_get_name, _set_name)\n \n def _get_value(self):\n  return self._value\n  \n def _set_value(self, value):\n  self._value = value\n  self.childNodes[0].data = value\n  if self.ownerElement is not None:\n   _clear_id_cache(self.ownerElement)\n  self.childNodes[0].data = value\n  \n nodeValue = value = property(_get_value, _set_value)\n \n def _get_prefix(self):\n  return self._prefix\n  \n def _set_prefix(self, prefix):\n  nsuri = self.namespaceURI\n  if prefix == \"xmlns\":\n   if nsuri and nsuri != XMLNS_NAMESPACE:\n    raise xml.dom.NamespaceErr(\n    \"illegal use of 'xmlns' prefix for the wrong namespace\")\n  self._prefix = prefix\n  if prefix is None:\n   newName = self.localName\n  else:\n   newName = \"%s:%s\" % (prefix, self.localName)\n  if self.ownerElement:\n   _clear_id_cache(self.ownerElement)\n  self.name = newName\n  \n prefix = property(_get_prefix, _set_prefix)\n \n def unlink(self):\n \n \n \n \n  elem = self.ownerElement\n  if elem is not None:\n   del elem._attrs[self.nodeName]\n   del elem._attrsNS[(self.namespaceURI, self.localName)]\n   if self._is_id:\n    self._is_id = False\n    elem._magic_id_nodes -= 1\n    self.ownerDocument._magic_id_count -= 1\n  for child in self.childNodes:\n   child.unlink()\n  del self.childNodes[:]\n  \n def _get_isId(self):\n  if self._is_id:\n   return True\n  doc = self.ownerDocument\n  elem = self.ownerElement\n  if doc is None or elem is None:\n   return False\n   \n  info = doc._get_elem_info(elem)\n  if info is None:\n   return False\n  if self.namespaceURI:\n   return info.isIdNS(self.namespaceURI, self.localName)\n  else:\n   return info.isId(self.nodeName)\n   \n def _get_schemaType(self):\n  doc = self.ownerDocument\n  elem = self.ownerElement\n  if doc is None or elem is None:\n   return _no_type\n   \n  info = doc._get_elem_info(elem)\n  if info is None:\n   return _no_type\n  if self.namespaceURI:\n   return info.getAttributeTypeNS(self.namespaceURI, self.localName)\n  else:\n   return info.getAttributeType(self.nodeName)\n   \ndefproperty(Attr, \"isId\", doc=\"True if this attribute is an ID.\")\ndefproperty(Attr, \"localName\", doc=\"Namespace-local name of this attribute.\")\ndefproperty(Attr, \"schemaType\", doc=\"Schema type for this attribute.\")\n\n\nclass NamedNodeMap(object):\n \"\"\n \n __slots__ = ('_attrs', '_attrsNS', '_ownerElement')\n \n def __init__(self, attrs, attrsNS, ownerElement):\n  self._attrs = attrs\n  self._attrsNS = attrsNS\n  self._ownerElement = ownerElement\n  \n def _get_length(self):\n  return len(self._attrs)\n  \n def item(self, index):\n  try:\n   return self[list(self._attrs.keys())[index]]\n  except IndexError:\n   return None\n   \n def items(self):\n  L = []\n  for node in self._attrs.values():\n   L.append((node.nodeName, node.value))\n  return L\n  \n def itemsNS(self):\n  L = []\n  for node in self._attrs.values():\n   L.append(((node.namespaceURI, node.localName), node.value))\n  return L\n  \n def __contains__(self, key):\n  if isinstance(key, str):\n   return key in self._attrs\n  else:\n   return key in self._attrsNS\n   \n def keys(self):\n  return self._attrs.keys()\n  \n def keysNS(self):\n  return self._attrsNS.keys()\n  \n def values(self):\n  return self._attrs.values()\n  \n def get(self, name, value=None):\n  return self._attrs.get(name, value)\n  \n __len__ = _get_length\n \n def _cmp(self, other):\n  if self._attrs is getattr(other, \"_attrs\", None):\n   return 0\n  else:\n   return (id(self) > id(other)) - (id(self) < id(other))\n   \n def __eq__(self, other):\n  return self._cmp(other) == 0\n  \n def __ge__(self, other):\n  return self._cmp(other) >= 0\n  \n def __gt__(self, other):\n  return self._cmp(other) > 0\n  \n def __le__(self, other):\n  return self._cmp(other) <= 0\n  \n def __lt__(self, other):\n  return self._cmp(other) < 0\n  \n def __ne__(self, other):\n  return self._cmp(other) != 0\n  \n def __getitem__(self, attname_or_tuple):\n  if isinstance(attname_or_tuple, tuple):\n   return self._attrsNS[attname_or_tuple]\n  else:\n   return self._attrs[attname_or_tuple]\n   \n   \n def __setitem__(self, attname, value):\n  if isinstance(value, str):\n   try:\n    node = self._attrs[attname]\n   except KeyError:\n    node = Attr(attname)\n    node.ownerDocument = self._ownerElement.ownerDocument\n    self.setNamedItem(node)\n   node.value = value\n  else:\n   if not isinstance(value, Attr):\n    raise TypeError(\"value must be a string or Attr object\")\n   node = value\n   self.setNamedItem(node)\n   \n def getNamedItem(self, name):\n  try:\n   return self._attrs[name]\n  except KeyError:\n   return None\n   \n def getNamedItemNS(self, namespaceURI, localName):\n  try:\n   return self._attrsNS[(namespaceURI, localName)]\n  except KeyError:\n   return None\n   \n def removeNamedItem(self, name):\n  n = self.getNamedItem(name)\n  if n is not None:\n   _clear_id_cache(self._ownerElement)\n   del self._attrs[n.nodeName]\n   del self._attrsNS[(n.namespaceURI, n.localName)]\n   if hasattr(n, 'ownerElement'):\n    n.ownerElement = None\n   return n\n  else:\n   raise xml.dom.NotFoundErr()\n   \n def removeNamedItemNS(self, namespaceURI, localName):\n  n = self.getNamedItemNS(namespaceURI, localName)\n  if n is not None:\n   _clear_id_cache(self._ownerElement)\n   del self._attrsNS[(n.namespaceURI, n.localName)]\n   del self._attrs[n.nodeName]\n   if hasattr(n, 'ownerElement'):\n    n.ownerElement = None\n   return n\n  else:\n   raise xml.dom.NotFoundErr()\n   \n def setNamedItem(self, node):\n  if not isinstance(node, Attr):\n   raise xml.dom.HierarchyRequestErr(\n   \"%s cannot be child of %s\" % (repr(node), repr(self)))\n  old = self._attrs.get(node.name)\n  if old:\n   old.unlink()\n  self._attrs[node.name] = node\n  self._attrsNS[(node.namespaceURI, node.localName)] = node\n  node.ownerElement = self._ownerElement\n  _clear_id_cache(node.ownerElement)\n  return old\n  \n def setNamedItemNS(self, node):\n  return self.setNamedItem(node)\n  \n def __delitem__(self, attname_or_tuple):\n  node = self[attname_or_tuple]\n  _clear_id_cache(node.ownerElement)\n  node.unlink()\n  \n def __getstate__(self):\n  return self._attrs, self._attrsNS, self._ownerElement\n  \n def __setstate__(self, state):\n  self._attrs, self._attrsNS, self._ownerElement = state\n  \ndefproperty(NamedNodeMap, \"length\",\ndoc=\"Number of nodes in the NamedNodeMap.\")\n\nAttributeList = NamedNodeMap\n\n\nclass TypeInfo(object):\n __slots__ = 'namespace', 'name'\n \n def __init__(self, namespace, name):\n  self.namespace = namespace\n  self.name = name\n  \n def __repr__(self):\n  if self.namespace:\n   return \"<TypeInfo %r (from %r)>\" % (self.name, self.namespace)\n  else:\n   return \"<TypeInfo %r>\" % self.name\n   \n def _get_name(self):\n  return self.name\n  \n def _get_namespace(self):\n  return self.namespace\n  \n_no_type = TypeInfo(None, None)\n\nclass Element(Node):\n __slots__=('ownerDocument', 'parentNode', 'tagName', 'nodeName', 'prefix',\n 'namespaceURI', '_localName', 'childNodes', '_attrs', '_attrsNS',\n 'nextSibling', 'previousSibling')\n nodeType = Node.ELEMENT_NODE\n nodeValue = None\n schemaType = _no_type\n \n _magic_id_nodes = 0\n \n _child_node_types = (Node.ELEMENT_NODE,\n Node.PROCESSING_INSTRUCTION_NODE,\n Node.COMMENT_NODE,\n Node.TEXT_NODE,\n Node.CDATA_SECTION_NODE,\n Node.ENTITY_REFERENCE_NODE)\n \n def __init__(self, tagName, namespaceURI=EMPTY_NAMESPACE, prefix=None,\n localName=None):\n  self.parentNode = None\n  self.tagName = self.nodeName = tagName\n  self.prefix = prefix\n  self.namespaceURI = namespaceURI\n  self.childNodes = NodeList()\n  self.nextSibling = self.previousSibling = None\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  self._attrs = None\n  self._attrsNS = None\n  \n def _ensure_attributes(self):\n  if self._attrs is None:\n   self._attrs = {}\n   self._attrsNS = {}\n   \n def _get_localName(self):\n  try:\n   return self._localName\n  except AttributeError:\n   return self.tagName.split(\":\", 1)[-1]\n   \n def _get_tagName(self):\n  return self.tagName\n  \n def unlink(self):\n  if self._attrs is not None:\n   for attr in list(self._attrs.values()):\n    attr.unlink()\n  self._attrs = None\n  self._attrsNS = None\n  Node.unlink(self)\n  \n def getAttribute(self, attname):\n  if self._attrs is None:\n   return \"\"\n  try:\n   return self._attrs[attname].value\n  except KeyError:\n   return \"\"\n   \n def getAttributeNS(self, namespaceURI, localName):\n  if self._attrsNS is None:\n   return \"\"\n  try:\n   return self._attrsNS[(namespaceURI, localName)].value\n  except KeyError:\n   return \"\"\n   \n def setAttribute(self, attname, value):\n  attr = self.getAttributeNode(attname)\n  if attr is None:\n   attr = Attr(attname)\n   attr.value = value \n   attr.ownerDocument = self.ownerDocument\n   self.setAttributeNode(attr)\n  elif value != attr.value:\n   attr.value = value\n   if attr.isId:\n    _clear_id_cache(self)\n    \n def setAttributeNS(self, namespaceURI, qualifiedName, value):\n  prefix, localname = _nssplit(qualifiedName)\n  attr = self.getAttributeNodeNS(namespaceURI, localname)\n  if attr is None:\n   attr = Attr(qualifiedName, namespaceURI, localname, prefix)\n   attr.value = value\n   attr.ownerDocument = self.ownerDocument\n   self.setAttributeNode(attr)\n  else:\n   if value != attr.value:\n    attr.value = value\n    if attr.isId:\n     _clear_id_cache(self)\n   if attr.prefix != prefix:\n    attr.prefix = prefix\n    attr.nodeName = qualifiedName\n    \n def getAttributeNode(self, attrname):\n  if self._attrs is None:\n   return None\n  return self._attrs.get(attrname)\n  \n def getAttributeNodeNS(self, namespaceURI, localName):\n  if self._attrsNS is None:\n   return None\n  return self._attrsNS.get((namespaceURI, localName))\n  \n def setAttributeNode(self, attr):\n  if attr.ownerElement not in (None, self):\n   raise xml.dom.InuseAttributeErr(\"attribute node already owned\")\n  self._ensure_attributes()\n  old1 = self._attrs.get(attr.name, None)\n  if old1 is not None:\n   self.removeAttributeNode(old1)\n  old2 = self._attrsNS.get((attr.namespaceURI, attr.localName), None)\n  if old2 is not None and old2 is not old1:\n   self.removeAttributeNode(old2)\n  _set_attribute_node(self, attr)\n  \n  if old1 is not attr:\n  \n  \n   return old1\n  if old2 is not attr:\n   return old2\n   \n setAttributeNodeNS = setAttributeNode\n \n def removeAttribute(self, name):\n  if self._attrsNS is None:\n   raise xml.dom.NotFoundErr()\n  try:\n   attr = self._attrs[name]\n  except KeyError:\n   raise xml.dom.NotFoundErr()\n  self.removeAttributeNode(attr)\n  \n def removeAttributeNS(self, namespaceURI, localName):\n  if self._attrsNS is None:\n   raise xml.dom.NotFoundErr()\n  try:\n   attr = self._attrsNS[(namespaceURI, localName)]\n  except KeyError:\n   raise xml.dom.NotFoundErr()\n  self.removeAttributeNode(attr)\n  \n def removeAttributeNode(self, node):\n  if node is None:\n   raise xml.dom.NotFoundErr()\n  try:\n   self._attrs[node.name]\n  except KeyError:\n   raise xml.dom.NotFoundErr()\n  _clear_id_cache(self)\n  node.unlink()\n  \n  \n  node.ownerDocument = self.ownerDocument\n  \n removeAttributeNodeNS = removeAttributeNode\n \n def hasAttribute(self, name):\n  if self._attrs is None:\n   return False\n  return name in self._attrs\n  \n def hasAttributeNS(self, namespaceURI, localName):\n  if self._attrsNS is None:\n   return False\n  return (namespaceURI, localName) in self._attrsNS\n  \n def getElementsByTagName(self, name):\n  return _get_elements_by_tagName_helper(self, name, NodeList())\n  \n def getElementsByTagNameNS(self, namespaceURI, localName):\n  return _get_elements_by_tagName_ns_helper(\n  self, namespaceURI, localName, NodeList())\n  \n def __repr__(self):\n  return \"<DOM Element: %s at %#x>\" % (self.tagName, id(self))\n  \n def writexml(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n \n \n \n  writer.write(indent+\"<\" + self.tagName)\n  \n  attrs = self._get_attributes()\n  a_names = sorted(attrs.keys())\n  \n  for a_name in a_names:\n   writer.write(\" %s=\\\"\" % a_name)\n   _write_data(writer, attrs[a_name].value)\n   writer.write(\"\\\"\")\n  if self.childNodes:\n   writer.write(\">\")\n   if (len(self.childNodes) == 1 and\n   self.childNodes[0].nodeType == Node.TEXT_NODE):\n    self.childNodes[0].writexml(writer, '', '', '')\n   else:\n    writer.write(newl)\n    for node in self.childNodes:\n     node.writexml(writer, indent+addindent, addindent, newl)\n    writer.write(indent)\n   writer.write(\"</%s>%s\" % (self.tagName, newl))\n  else:\n   writer.write(\"/>%s\"%(newl))\n   \n def _get_attributes(self):\n  self._ensure_attributes()\n  return NamedNodeMap(self._attrs, self._attrsNS, self)\n  \n def hasAttributes(self):\n  if self._attrs:\n   return True\n  else:\n   return False\n   \n   \n   \n def setIdAttribute(self, name):\n  idAttr = self.getAttributeNode(name)\n  self.setIdAttributeNode(idAttr)\n  \n def setIdAttributeNS(self, namespaceURI, localName):\n  idAttr = self.getAttributeNodeNS(namespaceURI, localName)\n  self.setIdAttributeNode(idAttr)\n  \n def setIdAttributeNode(self, idAttr):\n  if idAttr is None or not self.isSameNode(idAttr.ownerElement):\n   raise xml.dom.NotFoundErr()\n  if _get_containing_entref(self) is not None:\n   raise xml.dom.NoModificationAllowedErr()\n  if not idAttr._is_id:\n   idAttr._is_id = True\n   self._magic_id_nodes += 1\n   self.ownerDocument._magic_id_count += 1\n   _clear_id_cache(self)\n   \ndefproperty(Element, \"attributes\",\ndoc=\"NamedNodeMap of attributes on the element.\")\ndefproperty(Element, \"localName\",\ndoc=\"Namespace-local name of this element.\")\n\n\ndef _set_attribute_node(element, attr):\n _clear_id_cache(element)\n element._ensure_attributes()\n element._attrs[attr.name] = attr\n element._attrsNS[(attr.namespaceURI, attr.localName)] = attr\n \n \n \n \n attr.ownerElement = element\n \nclass Childless:\n \"\"\n __slots__ = ()\n \n attributes = None\n childNodes = EmptyNodeList()\n firstChild = None\n lastChild = None\n \n def _get_firstChild(self):\n  return None\n  \n def _get_lastChild(self):\n  return None\n  \n def appendChild(self, node):\n  raise xml.dom.HierarchyRequestErr(\n  self.nodeName + \" nodes cannot have children\")\n  \n def hasChildNodes(self):\n  return False\n  \n def insertBefore(self, newChild, refChild):\n  raise xml.dom.HierarchyRequestErr(\n  self.nodeName + \" nodes do not have children\")\n  \n def removeChild(self, oldChild):\n  raise xml.dom.NotFoundErr(\n  self.nodeName + \" nodes do not have children\")\n  \n def normalize(self):\n \n  pass\n  \n def replaceChild(self, newChild, oldChild):\n  raise xml.dom.HierarchyRequestErr(\n  self.nodeName + \" nodes do not have children\")\n  \n  \nclass ProcessingInstruction(Childless, Node):\n nodeType = Node.PROCESSING_INSTRUCTION_NODE\n __slots__ = ('target', 'data')\n \n def __init__(self, target, data):\n  self.target = target\n  self.data = data\n  \n  \n def _get_nodeValue(self):\n  return self.data\n def _set_nodeValue(self, value):\n  self.data = data\n nodeValue = property(_get_nodeValue, _set_nodeValue)\n \n \n def _get_nodeName(self):\n  return self.target\n def _set_nodeName(self, value):\n  self.target = value\n nodeName = property(_get_nodeName, _set_nodeName)\n \n def writexml(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n  writer.write(\"%s<?%s %s?>%s\" % (indent,self.target, self.data, newl))\n  \n  \nclass CharacterData(Childless, Node):\n __slots__=('_data', 'ownerDocument','parentNode', 'previousSibling', 'nextSibling')\n \n def __init__(self):\n  self.ownerDocument = self.parentNode = None\n  self.previousSibling = self.nextSibling = None\n  self._data = ''\n  Node.__init__(self)\n  \n def _get_length(self):\n  return len(self.data)\n __len__ = _get_length\n \n def _get_data(self):\n  return self._data\n def _set_data(self, data):\n  self._data = data\n  \n data = nodeValue = property(_get_data, _set_data)\n \n def __repr__(self):\n  data = self.data\n  if len(data) > 10:\n   dotdotdot = \"...\"\n  else:\n   dotdotdot = \"\"\n  return '<DOM %s node \"%r%s\">' % (\n  self.__class__.__name__, data[0:10], dotdotdot)\n  \n def substringData(self, offset, count):\n  if offset < 0:\n   raise xml.dom.IndexSizeErr(\"offset cannot be negative\")\n  if offset >= len(self.data):\n   raise xml.dom.IndexSizeErr(\"offset cannot be beyond end of data\")\n  if count < 0:\n   raise xml.dom.IndexSizeErr(\"count cannot be negative\")\n  return self.data[offset:offset+count]\n  \n def appendData(self, arg):\n  self.data = self.data + arg\n  \n def insertData(self, offset, arg):\n  if offset < 0:\n   raise xml.dom.IndexSizeErr(\"offset cannot be negative\")\n  if offset >= len(self.data):\n   raise xml.dom.IndexSizeErr(\"offset cannot be beyond end of data\")\n  if arg:\n   self.data = \"%s%s%s\" % (\n   self.data[:offset], arg, self.data[offset:])\n   \n def deleteData(self, offset, count):\n  if offset < 0:\n   raise xml.dom.IndexSizeErr(\"offset cannot be negative\")\n  if offset >= len(self.data):\n   raise xml.dom.IndexSizeErr(\"offset cannot be beyond end of data\")\n  if count < 0:\n   raise xml.dom.IndexSizeErr(\"count cannot be negative\")\n  if count:\n   self.data = self.data[:offset] + self.data[offset+count:]\n   \n def replaceData(self, offset, count, arg):\n  if offset < 0:\n   raise xml.dom.IndexSizeErr(\"offset cannot be negative\")\n  if offset >= len(self.data):\n   raise xml.dom.IndexSizeErr(\"offset cannot be beyond end of data\")\n  if count < 0:\n   raise xml.dom.IndexSizeErr(\"count cannot be negative\")\n  if count:\n   self.data = \"%s%s%s\" % (\n   self.data[:offset], arg, self.data[offset+count:])\n   \ndefproperty(CharacterData, \"length\", doc=\"Length of the string data.\")\n\n\nclass Text(CharacterData):\n __slots__ = ()\n \n nodeType = Node.TEXT_NODE\n nodeName = \"#text\"\n attributes = None\n \n def splitText(self, offset):\n  if offset < 0 or offset > len(self.data):\n   raise xml.dom.IndexSizeErr(\"illegal offset value\")\n  newText = self.__class__()\n  newText.data = self.data[offset:]\n  newText.ownerDocument = self.ownerDocument\n  next = self.nextSibling\n  if self.parentNode and self in self.parentNode.childNodes:\n   if next is None:\n    self.parentNode.appendChild(newText)\n   else:\n    self.parentNode.insertBefore(newText, next)\n  self.data = self.data[:offset]\n  return newText\n  \n def writexml(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n  _write_data(writer, \"%s%s%s\" % (indent, self.data, newl))\n  \n  \n  \n def _get_wholeText(self):\n  L = [self.data]\n  n = self.previousSibling\n  while n is not None:\n   if n.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):\n    L.insert(0, n.data)\n    n = n.previousSibling\n   else:\n    break\n  n = self.nextSibling\n  while n is not None:\n   if n.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):\n    L.append(n.data)\n    n = n.nextSibling\n   else:\n    break\n  return ''.join(L)\n  \n def replaceWholeText(self, content):\n \n \n  parent = self.parentNode\n  n = self.previousSibling\n  while n is not None:\n   if n.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):\n    next = n.previousSibling\n    parent.removeChild(n)\n    n = next\n   else:\n    break\n  n = self.nextSibling\n  if not content:\n   parent.removeChild(self)\n  while n is not None:\n   if n.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):\n    next = n.nextSibling\n    parent.removeChild(n)\n    n = next\n   else:\n    break\n  if content:\n   self.data = content\n   return self\n  else:\n   return None\n   \n def _get_isWhitespaceInElementContent(self):\n  if self.data.strip():\n   return False\n  elem = _get_containing_element(self)\n  if elem is None:\n   return False\n  info = self.ownerDocument._get_elem_info(elem)\n  if info is None:\n   return False\n  else:\n   return info.isElementContent()\n   \ndefproperty(Text, \"isWhitespaceInElementContent\",\ndoc=\"True iff this text node contains only whitespace\"\n\" and is in element content.\")\ndefproperty(Text, \"wholeText\",\ndoc=\"The text of all logically-adjacent text nodes.\")\n\n\ndef _get_containing_element(node):\n c = node.parentNode\n while c is not None:\n  if c.nodeType == Node.ELEMENT_NODE:\n   return c\n  c = c.parentNode\n return None\n \ndef _get_containing_entref(node):\n c = node.parentNode\n while c is not None:\n  if c.nodeType == Node.ENTITY_REFERENCE_NODE:\n   return c\n  c = c.parentNode\n return None\n \n \nclass Comment(CharacterData):\n nodeType = Node.COMMENT_NODE\n nodeName = \"#comment\"\n \n def __init__(self, data):\n  CharacterData.__init__(self)\n  self._data = data\n  \n def writexml(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n  if \"--\" in self.data:\n   raise ValueError(\"'--' is not allowed in a comment node\")\n  writer.write(\"%s<!--%s-->%s\" % (indent, self.data, newl))\n  \n  \nclass CDATASection(Text):\n __slots__ = ()\n \n nodeType = Node.CDATA_SECTION_NODE\n nodeName = \"#cdata-section\"\n \n def writexml(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n  if self.data.find(\"]]>\") >= 0:\n   raise ValueError(\"']]>' not allowed in a CDATA section\")\n  writer.write(\"<![CDATA[%s]]>\" % self.data)\n  \n  \nclass ReadOnlySequentialNamedNodeMap(object):\n __slots__ = '_seq',\n \n def __init__(self, seq=()):\n \n  self._seq = seq\n  \n def __len__(self):\n  return len(self._seq)\n  \n def _get_length(self):\n  return len(self._seq)\n  \n def getNamedItem(self, name):\n  for n in self._seq:\n   if n.nodeName == name:\n    return n\n    \n def getNamedItemNS(self, namespaceURI, localName):\n  for n in self._seq:\n   if n.namespaceURI == namespaceURI and n.localName == localName:\n    return n\n    \n def __getitem__(self, name_or_tuple):\n  if isinstance(name_or_tuple, tuple):\n   node = self.getNamedItemNS(*name_or_tuple)\n  else:\n   node = self.getNamedItem(name_or_tuple)\n  if node is None:\n   raise KeyError(name_or_tuple)\n  return node\n  \n def item(self, index):\n  if index < 0:\n   return None\n  try:\n   return self._seq[index]\n  except IndexError:\n   return None\n   \n def removeNamedItem(self, name):\n  raise xml.dom.NoModificationAllowedErr(\n  \"NamedNodeMap instance is read-only\")\n  \n def removeNamedItemNS(self, namespaceURI, localName):\n  raise xml.dom.NoModificationAllowedErr(\n  \"NamedNodeMap instance is read-only\")\n  \n def setNamedItem(self, node):\n  raise xml.dom.NoModificationAllowedErr(\n  \"NamedNodeMap instance is read-only\")\n  \n def setNamedItemNS(self, node):\n  raise xml.dom.NoModificationAllowedErr(\n  \"NamedNodeMap instance is read-only\")\n  \n def __getstate__(self):\n  return [self._seq]\n  \n def __setstate__(self, state):\n  self._seq = state[0]\n  \ndefproperty(ReadOnlySequentialNamedNodeMap, \"length\",\ndoc=\"Number of entries in the NamedNodeMap.\")\n\n\nclass Identified:\n \"\"\n \n __slots__ = 'publicId', 'systemId'\n \n def _identified_mixin_init(self, publicId, systemId):\n  self.publicId = publicId\n  self.systemId = systemId\n  \n def _get_publicId(self):\n  return self.publicId\n  \n def _get_systemId(self):\n  return self.systemId\n  \nclass DocumentType(Identified, Childless, Node):\n nodeType = Node.DOCUMENT_TYPE_NODE\n nodeValue = None\n name = None\n publicId = None\n systemId = None\n internalSubset = None\n \n def __init__(self, qualifiedName):\n  self.entities = ReadOnlySequentialNamedNodeMap()\n  self.notations = ReadOnlySequentialNamedNodeMap()\n  if qualifiedName:\n   prefix, localname = _nssplit(qualifiedName)\n   self.name = localname\n  self.nodeName = self.name\n  \n def _get_internalSubset(self):\n  return self.internalSubset\n  \n def cloneNode(self, deep):\n  if self.ownerDocument is None:\n  \n   clone = DocumentType(None)\n   clone.name = self.name\n   clone.nodeName = self.name\n   operation = xml.dom.UserDataHandler.NODE_CLONED\n   if deep:\n    clone.entities._seq = []\n    clone.notations._seq = []\n    for n in self.notations._seq:\n     notation = Notation(n.nodeName, n.publicId, n.systemId)\n     clone.notations._seq.append(notation)\n     n._call_user_data_handler(operation, n, notation)\n    for e in self.entities._seq:\n     entity = Entity(e.nodeName, e.publicId, e.systemId,\n     e.notationName)\n     entity.actualEncoding = e.actualEncoding\n     entity.encoding = e.encoding\n     entity.version = e.version\n     clone.entities._seq.append(entity)\n     e._call_user_data_handler(operation, n, entity)\n   self._call_user_data_handler(operation, self, clone)\n   return clone\n  else:\n   return None\n   \n def writexml(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n  writer.write(\"<!DOCTYPE \")\n  writer.write(self.name)\n  if self.publicId:\n   writer.write(\"%s  PUBLIC '%s'%s  '%s'\"\n   % (newl, self.publicId, newl, self.systemId))\n  elif self.systemId:\n   writer.write(\"%s  SYSTEM '%s'\" % (newl, self.systemId))\n  if self.internalSubset is not None:\n   writer.write(\" [\")\n   writer.write(self.internalSubset)\n   writer.write(\"]\")\n  writer.write(\">\"+newl)\n  \nclass Entity(Identified, Node):\n attributes = None\n nodeType = Node.ENTITY_NODE\n nodeValue = None\n \n actualEncoding = None\n encoding = None\n version = None\n \n def __init__(self, name, publicId, systemId, notation):\n  self.nodeName = name\n  self.notationName = notation\n  self.childNodes = NodeList()\n  self._identified_mixin_init(publicId, systemId)\n  \n def _get_actualEncoding(self):\n  return self.actualEncoding\n  \n def _get_encoding(self):\n  return self.encoding\n  \n def _get_version(self):\n  return self.version\n  \n def appendChild(self, newChild):\n  raise xml.dom.HierarchyRequestErr(\n  \"cannot append children to an entity node\")\n  \n def insertBefore(self, newChild, refChild):\n  raise xml.dom.HierarchyRequestErr(\n  \"cannot insert children below an entity node\")\n  \n def removeChild(self, oldChild):\n  raise xml.dom.HierarchyRequestErr(\n  \"cannot remove children from an entity node\")\n  \n def replaceChild(self, newChild, oldChild):\n  raise xml.dom.HierarchyRequestErr(\n  \"cannot replace children of an entity node\")\n  \nclass Notation(Identified, Childless, Node):\n nodeType = Node.NOTATION_NODE\n nodeValue = None\n \n def __init__(self, name, publicId, systemId):\n  self.nodeName = name\n  self._identified_mixin_init(publicId, systemId)\n  \n  \nclass DOMImplementation(DOMImplementationLS):\n _features = [(\"core\", \"1.0\"),\n (\"core\", \"2.0\"),\n (\"core\", None),\n (\"xml\", \"1.0\"),\n (\"xml\", \"2.0\"),\n (\"xml\", None),\n (\"ls-load\", \"3.0\"),\n (\"ls-load\", None),\n ]\n \n def hasFeature(self, feature, version):\n  if version == \"\":\n   version = None\n  return (feature.lower(), version) in self._features\n  \n def createDocument(self, namespaceURI, qualifiedName, doctype):\n  if doctype and doctype.parentNode is not None:\n   raise xml.dom.WrongDocumentErr(\n   \"doctype object owned by another DOM tree\")\n  doc = self._create_document()\n  \n  add_root_element = not (namespaceURI is None\n  and qualifiedName is None\n  and doctype is None)\n  \n  if not qualifiedName and add_root_element:\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   raise xml.dom.InvalidCharacterErr(\"Element with no name\")\n   \n  if add_root_element:\n   prefix, localname = _nssplit(qualifiedName)\n   if prefix == \"xml\" and namespaceURI != \"http://www.w3.org/XML/1998/namespace\":\n    raise xml.dom.NamespaceErr(\"illegal use of 'xml' prefix\")\n   if prefix and not namespaceURI:\n    raise xml.dom.NamespaceErr(\n    \"illegal use of prefix without namespaces\")\n   element = doc.createElementNS(namespaceURI, qualifiedName)\n   if doctype:\n    doc.appendChild(doctype)\n   doc.appendChild(element)\n   \n  if doctype:\n   doctype.parentNode = doctype.ownerDocument = doc\n   \n  doc.doctype = doctype\n  doc.implementation = self\n  return doc\n  \n def createDocumentType(self, qualifiedName, publicId, systemId):\n  doctype = DocumentType(qualifiedName)\n  doctype.publicId = publicId\n  doctype.systemId = systemId\n  return doctype\n  \n  \n  \n def getInterface(self, feature):\n  if self.hasFeature(feature, None):\n   return self\n  else:\n   return None\n   \n   \n def _create_document(self):\n  return Document()\n  \nclass ElementInfo(object):\n \"\"\n \n __slots__ = 'tagName',\n \n def __init__(self, name):\n  self.tagName = name\n  \n def getAttributeType(self, aname):\n  return _no_type\n  \n def getAttributeTypeNS(self, namespaceURI, localName):\n  return _no_type\n  \n def isElementContent(self):\n  return False\n  \n def isEmpty(self):\n  \"\"\n  return False\n  \n def isId(self, aname):\n  \"\"\n  return False\n  \n def isIdNS(self, namespaceURI, localName):\n  \"\"\n  return False\n  \n def __getstate__(self):\n  return self.tagName\n  \n def __setstate__(self, state):\n  self.tagName = state\n  \ndef _clear_id_cache(node):\n if node.nodeType == Node.DOCUMENT_NODE:\n  node._id_cache.clear()\n  node._id_search_stack = None\n elif _in_document(node):\n  node.ownerDocument._id_cache.clear()\n  node.ownerDocument._id_search_stack= None\n  \nclass Document(Node, DocumentLS):\n __slots__ = ('_elem_info', 'doctype',\n '_id_search_stack', 'childNodes', '_id_cache')\n _child_node_types = (Node.ELEMENT_NODE, Node.PROCESSING_INSTRUCTION_NODE,\n Node.COMMENT_NODE, Node.DOCUMENT_TYPE_NODE)\n \n implementation = DOMImplementation()\n nodeType = Node.DOCUMENT_NODE\n nodeName = \"#document\"\n nodeValue = None\n attributes = None\n parentNode = None\n previousSibling = nextSibling = None\n \n \n \n \n actualEncoding = None\n encoding = None\n standalone = None\n version = None\n strictErrorChecking = False\n errorHandler = None\n documentURI = None\n \n _magic_id_count = 0\n \n def __init__(self):\n  self.doctype = None\n  self.childNodes = NodeList()\n  \n  \n  self._elem_info = {}\n  self._id_cache = {}\n  self._id_search_stack = None\n  \n def _get_elem_info(self, element):\n  if element.namespaceURI:\n   key = element.namespaceURI, element.localName\n  else:\n   key = element.tagName\n  return self._elem_info.get(key)\n  \n def _get_actualEncoding(self):\n  return self.actualEncoding\n  \n def _get_doctype(self):\n  return self.doctype\n  \n def _get_documentURI(self):\n  return self.documentURI\n  \n def _get_encoding(self):\n  return self.encoding\n  \n def _get_errorHandler(self):\n  return self.errorHandler\n  \n def _get_standalone(self):\n  return self.standalone\n  \n def _get_strictErrorChecking(self):\n  return self.strictErrorChecking\n  \n def _get_version(self):\n  return self.version\n  \n def appendChild(self, node):\n  if node.nodeType not in self._child_node_types:\n   raise xml.dom.HierarchyRequestErr(\n   \"%s cannot be child of %s\" % (repr(node), repr(self)))\n  if node.parentNode is not None:\n  \n  \n  \n   node.parentNode.removeChild(node)\n   \n  if node.nodeType == Node.ELEMENT_NODE and self._get_documentElement():\n   raise xml.dom.HierarchyRequestErr(\n   \"two document elements disallowed\")\n  return Node.appendChild(self, node)\n  \n def removeChild(self, oldChild):\n  try:\n   self.childNodes.remove(oldChild)\n  except ValueError:\n   raise xml.dom.NotFoundErr()\n  oldChild.nextSibling = oldChild.previousSibling = None\n  oldChild.parentNode = None\n  if self.documentElement is oldChild:\n   self.documentElement = None\n   \n  return oldChild\n  \n def _get_documentElement(self):\n  for node in self.childNodes:\n   if node.nodeType == Node.ELEMENT_NODE:\n    return node\n    \n def unlink(self):\n  if self.doctype is not None:\n   self.doctype.unlink()\n   self.doctype = None\n  Node.unlink(self)\n  \n def cloneNode(self, deep):\n  if not deep:\n   return None\n  clone = self.implementation.createDocument(None, None, None)\n  clone.encoding = self.encoding\n  clone.standalone = self.standalone\n  clone.version = self.version\n  for n in self.childNodes:\n   childclone = _clone_node(n, deep, clone)\n   assert childclone.ownerDocument.isSameNode(clone)\n   clone.childNodes.append(childclone)\n   if childclone.nodeType == Node.DOCUMENT_NODE:\n    assert clone.documentElement is None\n   elif childclone.nodeType == Node.DOCUMENT_TYPE_NODE:\n    assert clone.doctype is None\n    clone.doctype = childclone\n   childclone.parentNode = clone\n  self._call_user_data_handler(xml.dom.UserDataHandler.NODE_CLONED,\n  self, clone)\n  return clone\n  \n def createDocumentFragment(self):\n  d = DocumentFragment()\n  d.ownerDocument = self\n  return d\n  \n def createElement(self, tagName):\n  e = Element(tagName)\n  e.ownerDocument = self\n  return e\n  \n def createTextNode(self, data):\n  if not isinstance(data, str):\n   raise TypeError(\"node contents must be a string\")\n  t = Text()\n  t.data = data\n  t.ownerDocument = self\n  return t\n  \n def createCDATASection(self, data):\n  if not isinstance(data, str):\n   raise TypeError(\"node contents must be a string\")\n  c = CDATASection()\n  c.data = data\n  c.ownerDocument = self\n  return c\n  \n def createComment(self, data):\n  c = Comment(data)\n  c.ownerDocument = self\n  return c\n  \n def createProcessingInstruction(self, target, data):\n  p = ProcessingInstruction(target, data)\n  p.ownerDocument = self\n  return p\n  \n def createAttribute(self, qName):\n  a = Attr(qName)\n  a.ownerDocument = self\n  a.value = \"\"\n  return a\n  \n def createElementNS(self, namespaceURI, qualifiedName):\n  prefix, localName = _nssplit(qualifiedName)\n  e = Element(qualifiedName, namespaceURI, prefix)\n  e.ownerDocument = self\n  return e\n  \n def createAttributeNS(self, namespaceURI, qualifiedName):\n  prefix, localName = _nssplit(qualifiedName)\n  a = Attr(qualifiedName, namespaceURI, localName, prefix)\n  a.ownerDocument = self\n  a.value = \"\"\n  return a\n  \n  \n  \n  \n def _create_entity(self, name, publicId, systemId, notationName):\n  e = Entity(name, publicId, systemId, notationName)\n  e.ownerDocument = self\n  return e\n  \n def _create_notation(self, name, publicId, systemId):\n  n = Notation(name, publicId, systemId)\n  n.ownerDocument = self\n  return n\n  \n def getElementById(self, id):\n  if id in self._id_cache:\n   return self._id_cache[id]\n  if not (self._elem_info or self._magic_id_count):\n   return None\n   \n  stack = self._id_search_stack\n  if stack is None:\n  \n   stack = [self.documentElement]\n   self._id_search_stack = stack\n  elif not stack:\n  \n  \n   return None\n   \n  result = None\n  while stack:\n   node = stack.pop()\n   \n   stack.extend([child for child in node.childNodes\n   if child.nodeType in _nodeTypes_with_children])\n   \n   info = self._get_elem_info(node)\n   if info:\n   \n   \n   \n    for attr in node.attributes.values():\n     if attr.namespaceURI:\n      if info.isIdNS(attr.namespaceURI, attr.localName):\n       self._id_cache[attr.value] = node\n       if attr.value == id:\n        result = node\n       elif not node._magic_id_nodes:\n        break\n     elif info.isId(attr.name):\n      self._id_cache[attr.value] = node\n      if attr.value == id:\n       result = node\n      elif not node._magic_id_nodes:\n       break\n     elif attr._is_id:\n      self._id_cache[attr.value] = node\n      if attr.value == id:\n       result = node\n      elif node._magic_id_nodes == 1:\n       break\n   elif node._magic_id_nodes:\n    for attr in node.attributes.values():\n     if attr._is_id:\n      self._id_cache[attr.value] = node\n      if attr.value == id:\n       result = node\n   if result is not None:\n    break\n  return result\n  \n def getElementsByTagName(self, name):\n  return _get_elements_by_tagName_helper(self, name, NodeList())\n  \n def getElementsByTagNameNS(self, namespaceURI, localName):\n  return _get_elements_by_tagName_ns_helper(\n  self, namespaceURI, localName, NodeList())\n  \n def isSupported(self, feature, version):\n  return self.implementation.hasFeature(feature, version)\n  \n def importNode(self, node, deep):\n  if node.nodeType == Node.DOCUMENT_NODE:\n   raise xml.dom.NotSupportedErr(\"cannot import document nodes\")\n  elif node.nodeType == Node.DOCUMENT_TYPE_NODE:\n   raise xml.dom.NotSupportedErr(\"cannot import document type nodes\")\n  return _clone_node(node, deep, self)\n  \n def writexml(self, writer, indent=\"\", addindent=\"\", newl=\"\", encoding=None):\n  if encoding is None:\n   writer.write('<?xml version=\"1.0\" ?>'+newl)\n  else:\n   writer.write('<?xml version=\"1.0\" encoding=\"%s\"?>%s' % (\n   encoding, newl))\n  for node in self.childNodes:\n   node.writexml(writer, indent, addindent, newl)\n   \n   \n   \n def renameNode(self, n, namespaceURI, name):\n  if n.ownerDocument is not self:\n   raise xml.dom.WrongDocumentErr(\n   \"cannot rename nodes from other documents;\\n\"\n   \"expected %s,\\nfound %s\" % (self, n.ownerDocument))\n  if n.nodeType not in (Node.ELEMENT_NODE, Node.ATTRIBUTE_NODE):\n   raise xml.dom.NotSupportedErr(\n   \"renameNode() only applies to element and attribute nodes\")\n  if namespaceURI != EMPTY_NAMESPACE:\n   if ':' in name:\n    prefix, localName = name.split(':', 1)\n    if ( prefix == \"xmlns\"\n    and namespaceURI != xml.dom.XMLNS_NAMESPACE):\n     raise xml.dom.NamespaceErr(\n     \"illegal use of 'xmlns' prefix\")\n   else:\n    if ( name == \"xmlns\"\n    and namespaceURI != xml.dom.XMLNS_NAMESPACE\n    and n.nodeType == Node.ATTRIBUTE_NODE):\n     raise xml.dom.NamespaceErr(\n     \"illegal use of the 'xmlns' attribute\")\n    prefix = None\n    localName = name\n  else:\n   prefix = None\n   localName = None\n  if n.nodeType == Node.ATTRIBUTE_NODE:\n   element = n.ownerElement\n   if element is not None:\n    is_id = n._is_id\n    element.removeAttributeNode(n)\n  else:\n   element = None\n  n.prefix = prefix\n  n._localName = localName\n  n.namespaceURI = namespaceURI\n  n.nodeName = name\n  if n.nodeType == Node.ELEMENT_NODE:\n   n.tagName = name\n  else:\n  \n   n.name = name\n   if element is not None:\n    element.setAttributeNode(n)\n    if is_id:\n     element.setIdAttributeNode(n)\n     \n     \n     \n     \n     \n  return n\n  \ndefproperty(Document, \"documentElement\",\ndoc=\"Top-level element of this document.\")\n\n\ndef _clone_node(node, deep, newOwnerDocument):\n \"\"\n if node.ownerDocument.isSameNode(newOwnerDocument):\n  operation = xml.dom.UserDataHandler.NODE_CLONED\n else:\n  operation = xml.dom.UserDataHandler.NODE_IMPORTED\n if node.nodeType == Node.ELEMENT_NODE:\n  clone = newOwnerDocument.createElementNS(node.namespaceURI,\n  node.nodeName)\n  for attr in node.attributes.values():\n   clone.setAttributeNS(attr.namespaceURI, attr.nodeName, attr.value)\n   a = clone.getAttributeNodeNS(attr.namespaceURI, attr.localName)\n   a.specified = attr.specified\n   \n  if deep:\n   for child in node.childNodes:\n    c = _clone_node(child, deep, newOwnerDocument)\n    clone.appendChild(c)\n    \n elif node.nodeType == Node.DOCUMENT_FRAGMENT_NODE:\n  clone = newOwnerDocument.createDocumentFragment()\n  if deep:\n   for child in node.childNodes:\n    c = _clone_node(child, deep, newOwnerDocument)\n    clone.appendChild(c)\n    \n elif node.nodeType == Node.TEXT_NODE:\n  clone = newOwnerDocument.createTextNode(node.data)\n elif node.nodeType == Node.CDATA_SECTION_NODE:\n  clone = newOwnerDocument.createCDATASection(node.data)\n elif node.nodeType == Node.PROCESSING_INSTRUCTION_NODE:\n  clone = newOwnerDocument.createProcessingInstruction(node.target,\n  node.data)\n elif node.nodeType == Node.COMMENT_NODE:\n  clone = newOwnerDocument.createComment(node.data)\n elif node.nodeType == Node.ATTRIBUTE_NODE:\n  clone = newOwnerDocument.createAttributeNS(node.namespaceURI,\n  node.nodeName)\n  clone.specified = True\n  clone.value = node.value\n elif node.nodeType == Node.DOCUMENT_TYPE_NODE:\n  assert node.ownerDocument is not newOwnerDocument\n  operation = xml.dom.UserDataHandler.NODE_IMPORTED\n  clone = newOwnerDocument.implementation.createDocumentType(\n  node.name, node.publicId, node.systemId)\n  clone.ownerDocument = newOwnerDocument\n  if deep:\n   clone.entities._seq = []\n   clone.notations._seq = []\n   for n in node.notations._seq:\n    notation = Notation(n.nodeName, n.publicId, n.systemId)\n    notation.ownerDocument = newOwnerDocument\n    clone.notations._seq.append(notation)\n    if hasattr(n, '_call_user_data_handler'):\n     n._call_user_data_handler(operation, n, notation)\n   for e in node.entities._seq:\n    entity = Entity(e.nodeName, e.publicId, e.systemId,\n    e.notationName)\n    entity.actualEncoding = e.actualEncoding\n    entity.encoding = e.encoding\n    entity.version = e.version\n    entity.ownerDocument = newOwnerDocument\n    clone.entities._seq.append(entity)\n    if hasattr(e, '_call_user_data_handler'):\n     e._call_user_data_handler(operation, n, entity)\n else:\n \n \n \n  raise xml.dom.NotSupportedErr(\"Cannot clone node %s\" % repr(node))\n  \n  \n  \n  \n if hasattr(node, '_call_user_data_handler'):\n  node._call_user_data_handler(operation, node, clone)\n return clone\n \n \ndef _nssplit(qualifiedName):\n fields = qualifiedName.split(':', 1)\n if len(fields) == 2:\n  return fields\n else:\n  return (None, fields[0])\n  \n  \ndef _do_pulldom_parse(func, args, kwargs):\n events = func(*args, **kwargs)\n toktype, rootNode = events.getEvent()\n events.expandNode(rootNode)\n events.clear()\n return rootNode\n \ndef parse(file, parser=None, bufsize=None):\n \"\"\n if parser is None and not bufsize:\n  from xml.dom import expatbuilder\n  return expatbuilder.parse(file)\n else:\n  from xml.dom import pulldom\n  return _do_pulldom_parse(pulldom.parse, (file,),\n  {'parser': parser, 'bufsize': bufsize})\n  \ndef parseString(string, parser=None):\n \"\"\n if parser is None:\n  from xml.dom import expatbuilder\n  return expatbuilder.parseString(string)\n else:\n  from xml.dom import pulldom\n  return _do_pulldom_parse(pulldom.parseString, (string,),\n  {'parser': parser})\n  \ndef getDOMImplementation(features=None):\n if features:\n  if isinstance(features, str):\n   features = domreg._parse_feature_string(features)\n  for f, v in features:\n   if not Document.implementation.hasFeature(f, v):\n    return None\n return Document.implementation\n"], "modulefinder": [".js", "var $module=(function($B){\n\nvar _b_=$B.builtins\nvar _mod = {}\n\n$ModuleFinderDict = {__class__:$B.$type,__name__:'ModuleFinder'}\n$ModuleFinderDict.__mro__ = [$ModuleFinderDict,_b_.object.$dict]\n\n$ModuleFinderDict.run_script = function(self, pathname){\n    // pathname is the url of a Python script\n    var py_src = _b_.$open(pathname).read()\n    // transform into internal Brython tree structure\n    var root = $B.py2js(py_src)\n    // walk the tree to find occurences of imports\n    function walk(node){\n        var modules = []\n        var ctx = node.context\n        if(ctx && ctx.type=='node'){ctx = ctx.tree[0]}\n\n        if(ctx && ctx.type==\"import\"){\n            for(var i=0, _len_i = ctx.tree.length; i < _len_i;i++){\n                if(modules.indexOf(ctx.tree[i].name)==-1){\n                    modules.push(ctx.tree[i].name)\n                }\n            }\n        }else if(ctx && ctx.type==\"from\"){\n            if(modules.indexOf(ctx.module)==-1){\n                modules.push(ctx.module)\n            }\n        }\n        \n        for(var i=0, _len_i = node.children.length; i < _len_i;i++){\n            mods = walk(node.children[i])\n            for(var j=0, _len_j = mods.length; j < _len_j;j++){\n                if(modules.indexOf(mods[j])==-1){modules.push(mods[j])}\n            }\n        }\n        return modules\n    }\n    self.modules = walk(root)\n}\n\n_mod.ModuleFinder = function(){return {__class__:$ModuleFinderDict}\n}\n_mod.ModuleFinder.$dict = $ModuleFinderDict\n_mod.ModuleFinder.__class__ = $B.$factory\n$ModuleFinderDict.$factory = _mod.ModuleFinder\n\nreturn _mod\n})(__BRYTHON__)\n"], "xml.sax.saxutils": [".py", "\"\"\n\nimport os, urllib.parse, urllib.request\nimport io\nfrom . import handler\nfrom . import xmlreader\n\ndef __dict_replace(s, d):\n \"\"\n for key, value in d.items():\n  s = s.replace(key, value)\n return s\n \ndef escape(data, entities={}):\n \"\"\n \n \n data = data.replace(\"&\", \"&amp;\")\n data = data.replace(\">\", \"&gt;\")\n data = data.replace(\"<\", \"&lt;\")\n if entities:\n  data = __dict_replace(data, entities)\n return data\n \ndef unescape(data, entities={}):\n \"\"\n data = data.replace(\"&lt;\", \"<\")\n data = data.replace(\"&gt;\", \">\")\n if entities:\n  data = __dict_replace(data, entities)\n  \n return data.replace(\"&amp;\", \"&\")\n \ndef quoteattr(data, entities={}):\n \"\"\n entities = entities.copy()\n entities.update({'\\n': '&#10;', '\\r': '&#13;', '\\t':'&#9;'})\n data = escape(data, entities)\n if '\"' in data:\n  if \"'\" in data:\n   data = '\"%s\"' % data.replace('\"', \"&quot;\")\n  else:\n   data = \"'%s'\" % data\n else:\n  data = '\"%s\"' % data\n return data\n \n \ndef _gettextwriter(out, encoding):\n if out is None:\n  import sys\n  return sys.stdout\n  \n if isinstance(out, io.TextIOBase):\n \n  return out\n  \n  \n if isinstance(out, io.RawIOBase):\n \n \n  class _wrapper:\n   __class__ = out.__class__\n   def __getattr__(self, name):\n    return getattr(out, name)\n  buffer = _wrapper()\n  buffer.close = lambda: None\n else:\n \n \n  buffer = io.BufferedIOBase()\n  buffer.writable = lambda: True\n  buffer.write = out.write\n  try:\n  \n  \n   buffer.seekable = out.seekable\n   buffer.tell = out.tell\n  except AttributeError:\n   pass\n return io.TextIOWrapper(buffer, encoding=encoding,\n errors='xmlcharrefreplace',\n newline='\\n',\n write_through=True)\n \nclass XMLGenerator(handler.ContentHandler):\n\n def __init__(self, out=None, encoding=\"iso-8859-1\", short_empty_elements=False):\n  handler.ContentHandler.__init__(self)\n  out = _gettextwriter(out, encoding)\n  self._write = out.write\n  self._flush = out.flush\n  self._ns_contexts = [{}] \n  self._current_context = self._ns_contexts[-1]\n  self._undeclared_ns_maps = []\n  self._encoding = encoding\n  self._short_empty_elements = short_empty_elements\n  self._pending_start_element = False\n  \n def _qname(self, name):\n  \"\"\n  if name[0]:\n  \n  \n  \n  \n   if 'http://www.w3.org/XML/1998/namespace' == name[0]:\n    return 'xml:' + name[1]\n    \n   prefix = self._current_context[name[0]]\n   if prefix:\n   \n    return prefix + \":\" + name[1]\n    \n  return name[1]\n  \n def _finish_pending_start_element(self,endElement=False):\n  if self._pending_start_element:\n   self._write('>')\n   self._pending_start_element = False\n   \n   \n   \n def startDocument(self):\n  self._write('<?xml version=\"1.0\" encoding=\"%s\"?>\\n' %\n  self._encoding)\n  \n def endDocument(self):\n  self._flush()\n  \n def startPrefixMapping(self, prefix, uri):\n  self._ns_contexts.append(self._current_context.copy())\n  self._current_context[uri] = prefix\n  self._undeclared_ns_maps.append((prefix, uri))\n  \n def endPrefixMapping(self, prefix):\n  self._current_context = self._ns_contexts[-1]\n  del self._ns_contexts[-1]\n  \n def startElement(self, name, attrs):\n  self._finish_pending_start_element()\n  self._write('<' + name)\n  for (name, value) in attrs.items():\n   self._write(' %s=%s' % (name, quoteattr(value)))\n  if self._short_empty_elements:\n   self._pending_start_element = True\n  else:\n   self._write(\">\")\n   \n def endElement(self, name):\n  if self._pending_start_element:\n   self._write('/>')\n   self._pending_start_element = False\n  else:\n   self._write('</%s>' % name)\n   \n def startElementNS(self, name, qname, attrs):\n  self._finish_pending_start_element()\n  self._write('<' + self._qname(name))\n  \n  for prefix, uri in self._undeclared_ns_maps:\n   if prefix:\n    self._write(' xmlns:%s=\"%s\"' % (prefix, uri))\n   else:\n    self._write(' xmlns=\"%s\"' % uri)\n  self._undeclared_ns_maps = []\n  \n  for (name, value) in attrs.items():\n   self._write(' %s=%s' % (self._qname(name), quoteattr(value)))\n  if self._short_empty_elements:\n   self._pending_start_element = True\n  else:\n   self._write(\">\")\n   \n def endElementNS(self, name, qname):\n  if self._pending_start_element:\n   self._write('/>')\n   self._pending_start_element = False\n  else:\n   self._write('</%s>' % self._qname(name))\n   \n def characters(self, content):\n  if content:\n   self._finish_pending_start_element()\n   self._write(escape(content))\n   \n def ignorableWhitespace(self, content):\n  if content:\n   self._finish_pending_start_element()\n   self._write(content)\n   \n def processingInstruction(self, target, data):\n  self._finish_pending_start_element()\n  self._write('<?%s %s?>' % (target, data))\n  \n  \nclass XMLFilterBase(xmlreader.XMLReader):\n \"\"\n \n def __init__(self, parent = None):\n  xmlreader.XMLReader.__init__(self)\n  self._parent = parent\n  \n  \n  \n def error(self, exception):\n  self._err_handler.error(exception)\n  \n def fatalError(self, exception):\n  self._err_handler.fatalError(exception)\n  \n def warning(self, exception):\n  self._err_handler.warning(exception)\n  \n  \n  \n def setDocumentLocator(self, locator):\n  self._cont_handler.setDocumentLocator(locator)\n  \n def startDocument(self):\n  self._cont_handler.startDocument()\n  \n def endDocument(self):\n  self._cont_handler.endDocument()\n  \n def startPrefixMapping(self, prefix, uri):\n  self._cont_handler.startPrefixMapping(prefix, uri)\n  \n def endPrefixMapping(self, prefix):\n  self._cont_handler.endPrefixMapping(prefix)\n  \n def startElement(self, name, attrs):\n  self._cont_handler.startElement(name, attrs)\n  \n def endElement(self, name):\n  self._cont_handler.endElement(name)\n  \n def startElementNS(self, name, qname, attrs):\n  self._cont_handler.startElementNS(name, qname, attrs)\n  \n def endElementNS(self, name, qname):\n  self._cont_handler.endElementNS(name, qname)\n  \n def characters(self, content):\n  self._cont_handler.characters(content)\n  \n def ignorableWhitespace(self, chars):\n  self._cont_handler.ignorableWhitespace(chars)\n  \n def processingInstruction(self, target, data):\n  self._cont_handler.processingInstruction(target, data)\n  \n def skippedEntity(self, name):\n  self._cont_handler.skippedEntity(name)\n  \n  \n  \n def notationDecl(self, name, publicId, systemId):\n  self._dtd_handler.notationDecl(name, publicId, systemId)\n  \n def unparsedEntityDecl(self, name, publicId, systemId, ndata):\n  self._dtd_handler.unparsedEntityDecl(name, publicId, systemId, ndata)\n  \n  \n  \n def resolveEntity(self, publicId, systemId):\n  return self._ent_handler.resolveEntity(publicId, systemId)\n  \n  \n  \n def parse(self, source):\n  self._parent.setContentHandler(self)\n  self._parent.setErrorHandler(self)\n  self._parent.setEntityResolver(self)\n  self._parent.setDTDHandler(self)\n  self._parent.parse(source)\n  \n def setLocale(self, locale):\n  self._parent.setLocale(locale)\n  \n def getFeature(self, name):\n  return self._parent.getFeature(name)\n  \n def setFeature(self, name, state):\n  self._parent.setFeature(name, state)\n  \n def getProperty(self, name):\n  return self._parent.getProperty(name)\n  \n def setProperty(self, name, value):\n  self._parent.setProperty(name, value)\n  \n  \n  \n def getParent(self):\n  return self._parent\n  \n def setParent(self, parent):\n  self._parent = parent\n  \n  \n  \ndef prepare_input_source(source, base=\"\"):\n \"\"\n \n if isinstance(source, str):\n  source = xmlreader.InputSource(source)\n elif hasattr(source, \"read\"):\n  f = source\n  source = xmlreader.InputSource()\n  source.setByteStream(f)\n  if hasattr(f, \"name\"):\n   source.setSystemId(f.name)\n   \n if source.getByteStream() is None:\n  sysid = source.getSystemId()\n  basehead = os.path.dirname(os.path.normpath(base))\n  sysidfilename = os.path.join(basehead, sysid)\n  if os.path.isfile(sysidfilename):\n   source.setSystemId(sysidfilename)\n   f = open(sysidfilename, \"rb\")\n  else:\n   source.setSystemId(urllib.parse.urljoin(base, sysid))\n   f = urllib.request.urlopen(source.getSystemId())\n   \n  source.setByteStream(f)\n  \n return source\n"], "_jsre": [".js", "var $module=(function($B){\n\n    var _b_ = $B.builtins\n    var $s=[]\n    for(var $b in _b_) $s.push('var ' + $b +'=_b_[\"'+$b+'\"]')\n    eval($s.join(';'))\n\n    var JSObject = $B.JSObject\n\n    var obj = {__class__:$module,\n        __str__: function(){return \"<module 're'>\"}\n    }\n    obj.A = obj.ASCII = 256\n    obj.I = obj.IGNORECASE = 2 // 'i'\n    obj.L = obj.LOCALE = 4\n    obj.M = obj.MULTILINE = 8 // 'm'\n    obj.S = obj.DOTALL = 16\n    obj.U = obj.UNICODE = 32\n    obj.X = obj.VERBOSE = 64\n    obj._is_valid = function(pattern) {\n        if ($B.$options.re=='pyre') return false  //force use of python's re module\n        if ($B.$options.re=='jsre') return true   //force use of brythons re module\n        // FIXME: Improve\n\n        if (!isinstance(pattern, str)) {\n           // this is probably a SRE_PATTERN, so return false, and let\n           // python's re module handle this.\n           return false\n        }\n        var is_valid = false;\n        try {\n            new RegExp(pattern);\n            is_valid = true;\n        }\n        catch(e) {}\n        if (!is_valid) return false  //if js won't parse the pattern return false\n\n        // using reference http://www.regular-expressions.info/\n        // to compare python re and javascript regex libraries\n\n        // look for things javascript does not support\n        // check for name capturing group\n        var mylist=['?P=', '?P<', '(?#', '(?<=', '(?<!', '(?(']\n        for(var i=0, _len_i = mylist.length; i < _len_i; i++) {\n           if (pattern.indexOf(mylist[i]) > -1) return false\n        }\n\n        var re_list=['\\{,\\d+\\}']\n        for(var i=0, _len_i = re_list.length; i < _len_i; i++) {\n           var _re=new RegExp(re_list[i])\n           if (_re.test(pattern)) return false\n        }\n\n        // it looks like the pattern has passed all our tests so lets assume\n        // javascript can handle this pattern.\n        return true\n    }\n    var $SRE_PatternDict = {\n        __class__:$B.$type,\n        __name__:'SRE_Pattern'\n    }\n    $SRE_PatternDict.__mro__ = [$SRE_PatternDict,object.$dict]\n    $SRE_PatternDict.findall = function(self,string){\n        return obj.findall(self.pattern,string,self.flags)\n    }\n    $SRE_PatternDict.finditer = function(self,string){\n        return obj.finditer(self.pattern,string,self.flags)\n    }\n    $SRE_PatternDict.match = function(self,string){\n        return obj.match(self.pattern,string,self.flags)\n    }\n    $SRE_PatternDict.search = function(self,string){\n        return obj.search(self.pattern,string,self.flags)\n    }\n    function normflags(flags) {\n        return ((flags & obj.I)? 'i' : '') + ((flags & obj.M)? 'm' : '');\n    }\n    obj.compile = function(pattern,flags){\n        return {\n            __class__:$SRE_PatternDict,\n            pattern:pattern,\n            flags:normflags(flags)\n        }\n    }\n    obj.escape = function(string){\n        // Escape all the characters in pattern except ASCII letters, numbers \n        // and '_'. This is useful if you want to match an arbitrary literal \n        // string that may have regular expression metacharacters in it.\n        var res = ''\n        var ok = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'\n        for(var i=0, _len_i = string.length; i < _len_i;i++){\n            if(ok.search(string.charAt(i))>-1){res += string.charAt(i)}\n        }\n        return res\n    }\n    obj.findall = function(pattern,string,flags){\n        var $ns=$B.$MakeArgs('re.findall',arguments,['pattern','string'],[],'args','kw') ,\n            args = $ns['args'] ,\n            _flags = 0;\n        if(args.length>0){var flags=args[0]}\n        else{var _flags = getattr($ns['kw'], 'get')('flags',0)}\n        \n        var flags = normflags();\n        flags += 'gm'\n        var jsp = new RegExp(pattern,flags) ,\n            jsmatch = string.match(jsp);\n        if(jsmatch===null){return []}\n        return jsmatch\n    }\n    obj.finditer = function(pattern,string,flags){\n        var $ns=$B.$MakeArgs('re.finditer',arguments,['pattern','string'],[],'args','kw'),\n            args = $ns['args'],\n            _flags = 0;\n        if(args.length>0){var flags=args[0]}\n        else{var _flags = getattr($ns['kw'], 'get')('flags',0)}\n        \n        var flags = normflags();\n        flags += 'gm'\n        var jsp = new RegExp(pattern,flags),\n            jsmatch = string.match(jsp);\n        if(jsmatch===null){return []}\n        \n        var _list=[]\n        for (var j=0, _len_j = jsmatch.length; j < _len_j; j++) {\n            var mo = {}\n            mo._match=jsmatch[j]\n            mo.group = function(){\n               var res = []\n               for(var i=0, _len_i = arguments.length; i < _len_i;i++){\n                   if(jsmatch[arguments[i]]===undefined){res.push(None)}\n                   else{res.push(jsmatch[arguments[i]])}\n               }\n               if(arguments.length===1){return res[0]}\n               return tuple(res)\n            }\n            mo.groups = function(_default){\n               if(_default===undefined){_default=None}\n               var res = []\n               for(var i=1, _len_i = jsmatch.length; i < _len_i;i++){\n                  if(jsmatch[i]===undefined){res.push(_default)}\n                  else{res.push(jsmatch[i])}\n               }\n               return tuple(res)\n            }\n            mo.start = function(){return mo._match.index}\n            mo.end = function(){return mo._match.length-mo._match.index}\n            mo.string = string\n            _list.push(JSObject(mo))\n        }\n        return _list\n    }\n    obj.search = function(pattern,string){\n        var $ns=$B.$MakeArgs('re.search',arguments,['pattern','string'],[],'args','kw')\n        var args = $ns['args']\n        if(args.length>0){var flags=args[0]}\n        else{var flags = getattr($ns['kw'],'get')('flags','')}\n        flags = normflags(flags);\n        var jsp = new RegExp(pattern,flags)\n        var jsmatch = string.match(jsp)\n        if(jsmatch===null){return None}\n        var mo = new Object()\n        mo.group = function(){\n            var res = []\n            for(var i=0, _len_i = arguments.length; i < _len_i;i++){\n                if(jsmatch[arguments[i]]===undefined){res.push(None)}\n                else{res.push(jsmatch[arguments[i]])}\n            }\n            if(arguments.length===1){return res[0]}\n            return tuple(res)\n        }\n        mo.groups = function(_default){\n            if(_default===undefined){_default=None}\n            var res = []\n            for(var i=1, _len_i = jsmatch.length; i < _len_i;i++){\n                if(jsmatch[i]===undefined){res.push(_default)}\n                else{res.push(jsmatch[i])}\n            }\n            return tuple(res)\n        }\n        mo.start = function(){return jsmatch.index}\n        mo.end = function(){return jsmatch.length-jsmatch.index}\n        mo.string = string\n        return JSObject(mo)\n    }\n    obj.sub = function(pattern,repl,string){\n        var $ns=$B.$MakeArgs('re.search',arguments,['pattern','repl','string'],[],'args','kw')\n        for($var in $ns){eval(\"var \"+$var+\"=$ns[$var]\")}\n        var args = $ns['args']\n        var count = _b_.dict.$dict.get($ns['kw'],'count',0)\n        var flags = _b_.dict.$dict.get($ns['kw'],'flags','')\n        if(args.length>0){var count=args[0]}\n        if(args.length>1){var flags=args[1]}\n        flags = normflags(flags);\n        if(typeof repl===\"string\"){\n            // backreferences are \\1, \\2... in Python but $1,$2... in Javascript\n            repl = repl.replace(/\\\\(\\d+)/g,'$$$1')\n        }else if(typeof repl===\"function\"){\n            // the argument passed to the Python function is the match object\n            // the arguments passed to the Javascript function are :\n            // - the matched substring\n            // - the matched groups\n            // - the offset of the matched substring inside the string\n            // - the string being examined\n            var $repl1 = function(){\n                var mo = Object()\n                mo.string = arguments[arguments.length-1]\n                var start = arguments[arguments.length-2]\n                var end = start + arguments[0].length\n                mo.start = function(){return start}\n                mo.end = function(){return end}\n                groups = []\n                for(var i=1, _len_i = arguments.length-2; i < _len_i;i++){groups.push(arguments[i])}\n                mo.groups = function(_default){\n                    if(_default===undefined){_default=None}\n                    var res = []\n                    for(var i=0, _len_i = groups.length; i < _len_i;i++){\n                        if(groups[i]===undefined){res.push(_default)}\n                        else{res.push(groups[i])}\n                    }\n                    return res\n                }\n                return repl(JSObject(mo))\n            }\n        }\n        if(count==0){flags+='g'}\n        var jsp = new RegExp(pattern,flags)\n        if(typeof repl==='function'){return string.replace(jsp,$repl1)}\n        else{return string.replace(jsp,repl)}\n    }\n    obj.match = (function(search_func){\n        return function(){\n            // match is like search but pattern must start with ^\n            var pattern = arguments[0]\n            if(pattern.charAt(0)!=='^'){pattern = '^'+pattern}\n            var args = [pattern]\n            for(var i=1, _len_i = arguments.length; i < _len_i;i++){args.push(arguments[i])}\n            return search_func.apply(null,args)\n        }\n    })(obj.search)\n\n    return obj\n}\n)(__BRYTHON__)\n"], "posix": [".py", "\"\"\n\nimport datetime\n\nfrom browser import window\n\ndef _randint(a, b):\n return int(window.Math.random()*(b-a+1)+a)\n \nF_OK = 0\n\nO_APPEND = 8\n\nO_BINARY = 32768\n\nO_CREAT = 256\n\nO_EXCL = 1024\n\nO_NOINHERIT = 128\n\nO_RANDOM = 16\n\nO_RDONLY = 0\n\nO_RDWR = 2\n\nO_SEQUENTIAL = 32\n\nO_SHORT_LIVED = 4096\n\nO_TEMPORARY = 64\n\nO_TEXT = 16384\n\nO_TRUNC = 512\n\nO_WRONLY = 1\n\nP_DETACH = 4\n\nP_NOWAIT = 1\n\nP_NOWAITO = 3\n\nP_OVERLAY = 2\n\nP_WAIT = 0\n\nR_OK = 4\n\nTMP_MAX = 32767\n\nW_OK = 2\n\nX_OK = 1\n\nclass __loader__:\n pass\n \ndef _exit(*args,**kw):\n \"\"\n pass\n \ndef _getdiskusage(*args,**kw):\n \"\"\n pass\n \ndef _getfileinformation(*args,**kw):\n pass\n \ndef _getfinalpathname(*args,**kw):\n pass\n \ndef _getfullpathname(*args,**kw):\n pass\n \n_have_functions = ['MS_WINDOWS']\n\ndef _isdir(*args,**kw):\n \"\"\n pass\n \ndef abort(*args,**kw):\n \"\"\n pass\n \ndef access(*args,**kw):\n \"\"\n pass\n \ndef chdir(*args,**kw):\n \"\"\n pass\n \ndef chmod(*args,**kw):\n \"\"\n pass\n \ndef close(*args,**kw):\n \"\"\n pass\n \ndef closerange(*args,**kw):\n \"\"\n pass\n \ndef device_encoding(*args,**kw):\n \"\"\n pass\n \ndef dup(*args,**kw):\n \"\"\n pass\n \ndef dup2(*args,**kw):\n \"\"\n pass\n \nenviron = {'PYTHONUSERBASE': ' '}\n\nerror = OSError\n\ndef execv(*args,**kw):\n \"\"\n pass\n \ndef execve(*args,**kw):\n \"\"\n pass\n \ndef fstat(*args,**kw):\n \"\"\n pass\n \ndef fsync(*args,**kw):\n \"\"\n pass\n \ndef get_terminal_size(*args,**kw):\n \"\"\n pass\n \ndef getcwd(*args,**kw):\n \"\"\n return __BRYTHON__.brython_path \n \ndef getcwdb(*args,**kw):\n \"\"\n pass\n \ndef getlogin(*args,**kw):\n \"\"\n pass\n \ndef getpid(*args,**kw):\n \"\"\n return 0\n \ndef getppid(*args,**kw):\n \"\"\n pass\n \ndef isatty(*args,**kw):\n \"\"\n pass\n \ndef kill(*args,**kw):\n \"\"\n pass\n \ndef link(*args,**kw):\n \"\"\n pass\n \ndef listdir(*args,**kw):\n \"\"\n pass\n \ndef lseek(*args,**kw):\n \"\"\n pass\n \ndef lstat(*args,**kw):\n \"\"\n return stat_result()\n \ndef mkdir(*args,**kw):\n \"\"\n pass\n \ndef open(*args,**kw):\n \"\"\n pass\n \ndef pipe(*args,**kw):\n \"\"\n pass\n \ndef putenv(*args,**kw):\n \"\"\n pass\n \ndef read(*args,**kw):\n \"\"\n pass\n \ndef readlink(*args,**kw):\n \"\"\n pass\n \ndef remove(*args,**kw):\n \"\"\n pass\n \ndef rename(*args,**kw):\n \"\"\n pass\n \ndef replace(*args,**kw):\n \"\"\n pass\n \ndef rmdir(*args,**kw):\n \"\"\n pass\n \ndef spawnv(*args,**kw):\n \"\"\n pass\n \ndef spawnve(*args,**kw):\n \"\"\n pass\n \ndef startfile(*args,**kw):\n \"\"\n pass\n \ndef stat(*args,**kw):\n \"\"\n return stat_result()\n \ndef stat_float_times(*args,**kw):\n \"\"\n pass\n \nclass stat_result:\n\n def __init__(self):\n  \"\"\n  \n  self.st_atime = datetime.datetime.now()\n  self.st_mtime = self.st_ctime = self.st_atime_ns = self.st_mtime_ns = self.st_ctime_ns = self.st_atime\n  self.st_uid = self.st_gid = self.st_ino = -1\n  self.st_mode = 0\n  self.st_size = 1\n  \nclass statvfs_result:\n pass\n \ndef strerror(*args,**kw):\n \"\"\n pass\n \ndef symlink(*args,**kw):\n \"\"\n pass\n \ndef system(*args,**kw):\n \"\"\n pass\n \nclass terminal_size:\n pass\n \ndef times(*args,**kw):\n \"\"\n pass\n \nclass times_result:\n pass\n \ndef umask(*args,**kw):\n \"\"\n pass\n \nclass uname_result:\n pass\n \ndef unlink(*args,**kw):\n \"\"\n pass\n \ndef urandom(n):\n \"\"\n randbytes= [_randint(0,255) for i in range(n)]\n return bytes(randbytes)\n \ndef utime(*args,**kw):\n \"\"\n pass\n \ndef waitpid(*args,**kw):\n \"\"\n pass\n \ndef write(*args,**kw):\n \"\"\n pass\n \n \n \ndef WIFSIGNALED(a):\n return False\n \ndef WTERMSIG(status):\n return 0\n \ndef WIFSIGNALED(status):\n \"\"\n return False\n \ndef WIFEXITED(status):\n return False\n \ndef WEXITSTATUS(status):\n pass\n \ndef WNOHANG():\n return (0,0)\n"], "encodings.aliases": [".py", "\"\"\naliases = {\n\n\n\n\n'646' : 'ascii',\n'ansi_x3.4_1968' : 'ascii',\n'ansi_x3_4_1968' : 'ascii', \n'ansi_x3.4_1986' : 'ascii',\n'cp367' : 'ascii',\n'csascii' : 'ascii',\n'ibm367' : 'ascii',\n'iso646_us' : 'ascii',\n'iso_646.irv_1991' : 'ascii',\n'iso_ir_6' : 'ascii',\n'us' : 'ascii',\n'us_ascii' : 'ascii',\n\n\n'base64' : 'base64_codec',\n'base_64' : 'base64_codec',\n\n\n'big5_tw' : 'big5',\n'csbig5' : 'big5',\n\n\n'big5_hkscs' : 'big5hkscs',\n'hkscs' : 'big5hkscs',\n\n\n'bz2' : 'bz2_codec',\n\n\n'037' : 'cp037',\n'csibm037' : 'cp037',\n'ebcdic_cp_ca' : 'cp037',\n'ebcdic_cp_nl' : 'cp037',\n'ebcdic_cp_us' : 'cp037',\n'ebcdic_cp_wt' : 'cp037',\n'ibm037' : 'cp037',\n'ibm039' : 'cp037',\n\n\n'1026' : 'cp1026',\n'csibm1026' : 'cp1026',\n'ibm1026' : 'cp1026',\n\n\n'1125' : 'cp1125',\n'ibm1125' : 'cp1125',\n'cp866u' : 'cp1125',\n'ruscii' : 'cp1125',\n\n\n'1140' : 'cp1140',\n'ibm1140' : 'cp1140',\n\n\n'1250' : 'cp1250',\n'windows_1250' : 'cp1250',\n\n\n'1251' : 'cp1251',\n'windows_1251' : 'cp1251',\n\n\n'1252' : 'cp1252',\n'windows_1252' : 'cp1252',\n\n\n'1253' : 'cp1253',\n'windows_1253' : 'cp1253',\n\n\n'1254' : 'cp1254',\n'windows_1254' : 'cp1254',\n\n\n'1255' : 'cp1255',\n'windows_1255' : 'cp1255',\n\n\n'1256' : 'cp1256',\n'windows_1256' : 'cp1256',\n\n\n'1257' : 'cp1257',\n'windows_1257' : 'cp1257',\n\n\n'1258' : 'cp1258',\n'windows_1258' : 'cp1258',\n\n\n'273' : 'cp273',\n'ibm273' : 'cp273',\n'csibm273' : 'cp273',\n\n\n'424' : 'cp424',\n'csibm424' : 'cp424',\n'ebcdic_cp_he' : 'cp424',\n'ibm424' : 'cp424',\n\n\n'437' : 'cp437',\n'cspc8codepage437' : 'cp437',\n'ibm437' : 'cp437',\n\n\n'500' : 'cp500',\n'csibm500' : 'cp500',\n'ebcdic_cp_be' : 'cp500',\n'ebcdic_cp_ch' : 'cp500',\n'ibm500' : 'cp500',\n\n\n'775' : 'cp775',\n'cspc775baltic' : 'cp775',\n'ibm775' : 'cp775',\n\n\n'850' : 'cp850',\n'cspc850multilingual' : 'cp850',\n'ibm850' : 'cp850',\n\n\n'852' : 'cp852',\n'cspcp852' : 'cp852',\n'ibm852' : 'cp852',\n\n\n'855' : 'cp855',\n'csibm855' : 'cp855',\n'ibm855' : 'cp855',\n\n\n'857' : 'cp857',\n'csibm857' : 'cp857',\n'ibm857' : 'cp857',\n\n\n'858' : 'cp858',\n'csibm858' : 'cp858',\n'ibm858' : 'cp858',\n\n\n'860' : 'cp860',\n'csibm860' : 'cp860',\n'ibm860' : 'cp860',\n\n\n'861' : 'cp861',\n'cp_is' : 'cp861',\n'csibm861' : 'cp861',\n'ibm861' : 'cp861',\n\n\n'862' : 'cp862',\n'cspc862latinhebrew' : 'cp862',\n'ibm862' : 'cp862',\n\n\n'863' : 'cp863',\n'csibm863' : 'cp863',\n'ibm863' : 'cp863',\n\n\n'864' : 'cp864',\n'csibm864' : 'cp864',\n'ibm864' : 'cp864',\n\n\n'865' : 'cp865',\n'csibm865' : 'cp865',\n'ibm865' : 'cp865',\n\n\n'866' : 'cp866',\n'csibm866' : 'cp866',\n'ibm866' : 'cp866',\n\n\n'869' : 'cp869',\n'cp_gr' : 'cp869',\n'csibm869' : 'cp869',\n'ibm869' : 'cp869',\n\n\n'932' : 'cp932',\n'ms932' : 'cp932',\n'mskanji' : 'cp932',\n'ms_kanji' : 'cp932',\n\n\n'949' : 'cp949',\n'ms949' : 'cp949',\n'uhc' : 'cp949',\n\n\n'950' : 'cp950',\n'ms950' : 'cp950',\n\n\n'jisx0213' : 'euc_jis_2004',\n'eucjis2004' : 'euc_jis_2004',\n'euc_jis2004' : 'euc_jis_2004',\n\n\n'eucjisx0213' : 'euc_jisx0213',\n\n\n'eucjp' : 'euc_jp',\n'ujis' : 'euc_jp',\n'u_jis' : 'euc_jp',\n\n\n'euckr' : 'euc_kr',\n'korean' : 'euc_kr',\n'ksc5601' : 'euc_kr',\n'ks_c_5601' : 'euc_kr',\n'ks_c_5601_1987' : 'euc_kr',\n'ksx1001' : 'euc_kr',\n'ks_x_1001' : 'euc_kr',\n\n\n'gb18030_2000' : 'gb18030',\n\n\n'chinese' : 'gb2312',\n'csiso58gb231280' : 'gb2312',\n'euc_cn' : 'gb2312',\n'euccn' : 'gb2312',\n'eucgb2312_cn' : 'gb2312',\n'gb2312_1980' : 'gb2312',\n'gb2312_80' : 'gb2312',\n'iso_ir_58' : 'gb2312',\n\n\n'936' : 'gbk',\n'cp936' : 'gbk',\n'ms936' : 'gbk',\n\n\n'hex' : 'hex_codec',\n\n\n'roman8' : 'hp_roman8',\n'r8' : 'hp_roman8',\n'csHPRoman8' : 'hp_roman8',\n\n\n'hzgb' : 'hz',\n'hz_gb' : 'hz',\n'hz_gb_2312' : 'hz',\n\n\n'csiso2022jp' : 'iso2022_jp',\n'iso2022jp' : 'iso2022_jp',\n'iso_2022_jp' : 'iso2022_jp',\n\n\n'iso2022jp_1' : 'iso2022_jp_1',\n'iso_2022_jp_1' : 'iso2022_jp_1',\n\n\n'iso2022jp_2' : 'iso2022_jp_2',\n'iso_2022_jp_2' : 'iso2022_jp_2',\n\n\n'iso_2022_jp_2004' : 'iso2022_jp_2004',\n'iso2022jp_2004' : 'iso2022_jp_2004',\n\n\n'iso2022jp_3' : 'iso2022_jp_3',\n'iso_2022_jp_3' : 'iso2022_jp_3',\n\n\n'iso2022jp_ext' : 'iso2022_jp_ext',\n'iso_2022_jp_ext' : 'iso2022_jp_ext',\n\n\n'csiso2022kr' : 'iso2022_kr',\n'iso2022kr' : 'iso2022_kr',\n'iso_2022_kr' : 'iso2022_kr',\n\n\n'csisolatin6' : 'iso8859_10',\n'iso_8859_10' : 'iso8859_10',\n'iso_8859_10_1992' : 'iso8859_10',\n'iso_ir_157' : 'iso8859_10',\n'l6' : 'iso8859_10',\n'latin6' : 'iso8859_10',\n\n\n'thai' : 'iso8859_11',\n'iso_8859_11' : 'iso8859_11',\n'iso_8859_11_2001' : 'iso8859_11',\n\n\n'iso_8859_13' : 'iso8859_13',\n'l7' : 'iso8859_13',\n'latin7' : 'iso8859_13',\n\n\n'iso_8859_14' : 'iso8859_14',\n'iso_8859_14_1998' : 'iso8859_14',\n'iso_celtic' : 'iso8859_14',\n'iso_ir_199' : 'iso8859_14',\n'l8' : 'iso8859_14',\n'latin8' : 'iso8859_14',\n\n\n'iso_8859_15' : 'iso8859_15',\n'l9' : 'iso8859_15',\n'latin9' : 'iso8859_15',\n\n\n'iso_8859_16' : 'iso8859_16',\n'iso_8859_16_2001' : 'iso8859_16',\n'iso_ir_226' : 'iso8859_16',\n'l10' : 'iso8859_16',\n'latin10' : 'iso8859_16',\n\n\n'csisolatin2' : 'iso8859_2',\n'iso_8859_2' : 'iso8859_2',\n'iso_8859_2_1987' : 'iso8859_2',\n'iso_ir_101' : 'iso8859_2',\n'l2' : 'iso8859_2',\n'latin2' : 'iso8859_2',\n\n\n'csisolatin3' : 'iso8859_3',\n'iso_8859_3' : 'iso8859_3',\n'iso_8859_3_1988' : 'iso8859_3',\n'iso_ir_109' : 'iso8859_3',\n'l3' : 'iso8859_3',\n'latin3' : 'iso8859_3',\n\n\n'csisolatin4' : 'iso8859_4',\n'iso_8859_4' : 'iso8859_4',\n'iso_8859_4_1988' : 'iso8859_4',\n'iso_ir_110' : 'iso8859_4',\n'l4' : 'iso8859_4',\n'latin4' : 'iso8859_4',\n\n\n'csisolatincyrillic' : 'iso8859_5',\n'cyrillic' : 'iso8859_5',\n'iso_8859_5' : 'iso8859_5',\n'iso_8859_5_1988' : 'iso8859_5',\n'iso_ir_144' : 'iso8859_5',\n\n\n'arabic' : 'iso8859_6',\n'asmo_708' : 'iso8859_6',\n'csisolatinarabic' : 'iso8859_6',\n'ecma_114' : 'iso8859_6',\n'iso_8859_6' : 'iso8859_6',\n'iso_8859_6_1987' : 'iso8859_6',\n'iso_ir_127' : 'iso8859_6',\n\n\n'csisolatingreek' : 'iso8859_7',\n'ecma_118' : 'iso8859_7',\n'elot_928' : 'iso8859_7',\n'greek' : 'iso8859_7',\n'greek8' : 'iso8859_7',\n'iso_8859_7' : 'iso8859_7',\n'iso_8859_7_1987' : 'iso8859_7',\n'iso_ir_126' : 'iso8859_7',\n\n\n'csisolatinhebrew' : 'iso8859_8',\n'hebrew' : 'iso8859_8',\n'iso_8859_8' : 'iso8859_8',\n'iso_8859_8_1988' : 'iso8859_8',\n'iso_ir_138' : 'iso8859_8',\n\n\n'csisolatin5' : 'iso8859_9',\n'iso_8859_9' : 'iso8859_9',\n'iso_8859_9_1989' : 'iso8859_9',\n'iso_ir_148' : 'iso8859_9',\n'l5' : 'iso8859_9',\n'latin5' : 'iso8859_9',\n\n\n'cp1361' : 'johab',\n'ms1361' : 'johab',\n\n\n'cskoi8r' : 'koi8_r',\n\n\n\n\n\n\n\n\n'8859' : 'latin_1',\n'cp819' : 'latin_1',\n'csisolatin1' : 'latin_1',\n'ibm819' : 'latin_1',\n'iso8859' : 'latin_1',\n'iso8859_1' : 'latin_1',\n'iso_8859_1' : 'latin_1',\n'iso_8859_1_1987' : 'latin_1',\n'iso_ir_100' : 'latin_1',\n'l1' : 'latin_1',\n'latin' : 'latin_1',\n'latin1' : 'latin_1',\n\n\n'maccyrillic' : 'mac_cyrillic',\n\n\n'macgreek' : 'mac_greek',\n\n\n'maciceland' : 'mac_iceland',\n\n\n'maccentraleurope' : 'mac_latin2',\n'maclatin2' : 'mac_latin2',\n\n\n'macintosh' : 'mac_roman',\n'macroman' : 'mac_roman',\n\n\n'macturkish' : 'mac_turkish',\n\n\n'dbcs' : 'mbcs',\n\n\n'csptcp154' : 'ptcp154',\n'pt154' : 'ptcp154',\n'cp154' : 'ptcp154',\n'cyrillic_asian' : 'ptcp154',\n\n\n'quopri' : 'quopri_codec',\n'quoted_printable' : 'quopri_codec',\n'quotedprintable' : 'quopri_codec',\n\n\n'rot13' : 'rot_13',\n\n\n'csshiftjis' : 'shift_jis',\n'shiftjis' : 'shift_jis',\n'sjis' : 'shift_jis',\n's_jis' : 'shift_jis',\n\n\n'shiftjis2004' : 'shift_jis_2004',\n'sjis_2004' : 'shift_jis_2004',\n's_jis_2004' : 'shift_jis_2004',\n\n\n'shiftjisx0213' : 'shift_jisx0213',\n'sjisx0213' : 'shift_jisx0213',\n's_jisx0213' : 'shift_jisx0213',\n\n\n'tis260' : 'tactis',\n\n\n'tis620' : 'tis_620',\n'tis_620_0' : 'tis_620',\n'tis_620_2529_0' : 'tis_620',\n'tis_620_2529_1' : 'tis_620',\n'iso_ir_166' : 'tis_620',\n\n\n'u16' : 'utf_16',\n'utf16' : 'utf_16',\n\n\n'unicodebigunmarked' : 'utf_16_be',\n'utf_16be' : 'utf_16_be',\n\n\n'unicodelittleunmarked' : 'utf_16_le',\n'utf_16le' : 'utf_16_le',\n\n\n'u32' : 'utf_32',\n'utf32' : 'utf_32',\n\n\n'utf_32be' : 'utf_32_be',\n\n\n'utf_32le' : 'utf_32_le',\n\n\n'u7' : 'utf_7',\n'utf7' : 'utf_7',\n'unicode_1_1_utf_7' : 'utf_7',\n\n\n'u8' : 'utf_8',\n'utf' : 'utf_8',\n'utf8' : 'utf_8',\n'utf8_ucs2' : 'utf_8',\n'utf8_ucs4' : 'utf_8',\n\n\n'uu' : 'uu_codec',\n\n\n'zip' : 'zlib_codec',\n'zlib' : 'zlib_codec',\n\n\n'x_mac_japanese' : 'shift_jis',\n'x_mac_korean' : 'euc_kr',\n'x_mac_simp_chinese' : 'gb2312',\n'x_mac_trad_chinese' : 'big5',\n}\n"], "fnmatch": [".py", "\"\"\nimport os\nimport posixpath\nimport re\nimport functools\n\n__all__ = [\"filter\", \"fnmatch\", \"fnmatchcase\", \"translate\"]\n\ndef fnmatch(name, pat):\n \"\"\n name = os.path.normcase(name)\n pat = os.path.normcase(pat)\n return fnmatchcase(name, pat)\n \n@functools.lru_cache(maxsize=256, typed=True)\ndef _compile_pattern(pat):\n if isinstance(pat, bytes):\n  pat_str = str(pat, 'ISO-8859-1')\n  res_str = translate(pat_str)\n  res = bytes(res_str, 'ISO-8859-1')\n else:\n  res = translate(pat)\n return re.compile(res).match\n \ndef filter(names, pat):\n \"\"\n result = []\n pat = os.path.normcase(pat)\n match = _compile_pattern(pat)\n if os.path is posixpath:\n \n  for name in names:\n   if match(name):\n    result.append(name)\n else:\n  for name in names:\n   if match(os.path.normcase(name)):\n    result.append(name)\n return result\n \ndef fnmatchcase(name, pat):\n \"\"\n match = _compile_pattern(pat)\n return match(name) is not None\n \n \ndef translate(pat):\n \"\"\n \n i, n = 0, len(pat)\n res = ''\n while i < n:\n  c = pat[i]\n  i = i+1\n  if c == '*':\n   res = res + '.*'\n  elif c == '?':\n   res = res + '.'\n  elif c == '[':\n   j = i\n   if j < n and pat[j] == '!':\n    j = j+1\n   if j < n and pat[j] == ']':\n    j = j+1\n   while j < n and pat[j] != ']':\n    j = j+1\n   if j >= n:\n    res = res + '\\\\['\n   else:\n    stuff = pat[i:j].replace('\\\\','\\\\\\\\')\n    i = j+1\n    if stuff[0] == '!':\n     stuff = '^' + stuff[1:]\n    elif stuff[0] == '^':\n     stuff = '\\\\' + stuff\n    res = '%s[%s]' % (res, stuff)\n  else:\n   res = res + re.escape(c)\n return res + '\\Z(?ms)'\n"], "sre_parse": [".py", "\n\n\n\n\n\n\n\n\n\n\"\"\n\n\n\nimport sys\n\nfrom sre_constants import *\nfrom _sre import MAXREPEAT\n\nSPECIAL_CHARS = \".\\\\[{()*+?^$|\"\nREPEAT_CHARS = \"*+?{\"\n\nDIGITS = set(\"0123456789\")\n\nOCTDIGITS = set(\"01234567\")\nHEXDIGITS = set(\"0123456789abcdefABCDEF\")\n\nWHITESPACE = set(\" \\t\\n\\r\\v\\f\")\n\nESCAPES = {\nr\"\\a\": (LITERAL, ord(\"\\a\")),\nr\"\\b\": (LITERAL, ord(\"\\b\")),\nr\"\\f\": (LITERAL, ord(\"\\f\")),\nr\"\\n\": (LITERAL, ord(\"\\n\")),\nr\"\\r\": (LITERAL, ord(\"\\r\")),\nr\"\\t\": (LITERAL, ord(\"\\t\")),\nr\"\\v\": (LITERAL, ord(\"\\v\")),\nr\"\\\\\": (LITERAL, ord(\"\\\\\"))\n}\n\nCATEGORIES = {\nr\"\\A\": (AT, AT_BEGINNING_STRING), \nr\"\\b\": (AT, AT_BOUNDARY),\nr\"\\B\": (AT, AT_NON_BOUNDARY),\nr\"\\d\": (IN, [(CATEGORY, CATEGORY_DIGIT)]),\nr\"\\D\": (IN, [(CATEGORY, CATEGORY_NOT_DIGIT)]),\nr\"\\s\": (IN, [(CATEGORY, CATEGORY_SPACE)]),\nr\"\\S\": (IN, [(CATEGORY, CATEGORY_NOT_SPACE)]),\nr\"\\w\": (IN, [(CATEGORY, CATEGORY_WORD)]),\nr\"\\W\": (IN, [(CATEGORY, CATEGORY_NOT_WORD)]),\nr\"\\Z\": (AT, AT_END_STRING), \n}\n\nFLAGS = {\n\n\"i\": SRE_FLAG_IGNORECASE,\n\"L\": SRE_FLAG_LOCALE,\n\"m\": SRE_FLAG_MULTILINE,\n\"s\": SRE_FLAG_DOTALL,\n\"x\": SRE_FLAG_VERBOSE,\n\n\"a\": SRE_FLAG_ASCII,\n\"t\": SRE_FLAG_TEMPLATE,\n\"u\": SRE_FLAG_UNICODE,\n}\n\nclass Pattern:\n\n def __init__(self):\n  self.flags = 0\n  self.open = []\n  self.groups = 1\n  self.groupdict = {}\n def opengroup(self, name=None):\n  gid = self.groups\n  self.groups = gid + 1\n  if name is not None:\n   ogid = self.groupdict.get(name, None)\n   if ogid is not None:\n    raise error(\"redefinition of group name %s as group %d; \"\n    \"was group %d\" % (repr(name), gid, ogid))\n   self.groupdict[name] = gid\n  self.open.append(gid)\n  return gid\n def closegroup(self, gid):\n  self.open.remove(gid)\n def checkgroup(self, gid):\n  return gid < self.groups and gid not in self.open\n  \nclass SubPattern:\n\n def __init__(self, pattern, data=None):\n  self.pattern = pattern\n  if data is None:\n   data = []\n  self.data = data\n  self.width = None\n def __iter__(self):\n  return iter(self.data)\n  \n def dump(self, level=0):\n  nl = 1\n  seqtypes = (tuple, list)\n  for op, av in self.data:\n   print(level*\"  \" + op, end=' '); nl = 0\n   if op == \"in\":\n   \n    print(); nl = 1\n    for op, a in av:\n     print((level+1)*\"  \" + op, a)\n   elif op == \"branch\":\n    print(); nl = 1\n    i = 0\n    for a in av[1]:\n     if i > 0:\n      print(level*\"  \" + \"or\")\n     a.dump(level+1); nl = 1\n     i = i + 1\n   elif isinstance(av, seqtypes):\n    for a in av:\n     if isinstance(a, SubPattern):\n      if not nl: print()\n      a.dump(level+1); nl = 1\n     else:\n      print(a, end=' ') ; nl = 0\n   else:\n    print(av, end=' ') ; nl = 0\n   if not nl: print()\n def __repr__(self):\n  return repr(self.data)\n def __len__(self):\n  return len(self.data)\n def __delitem__(self, index):\n  del self.data[index]\n def __getitem__(self, index):\n  if isinstance(index, slice):\n   return SubPattern(self.pattern, self.data[index])\n  return self.data[index]\n def __setitem__(self, index, code):\n  self.data[index] = code\n def insert(self, index, code):\n  self.data.insert(index, code)\n def append(self, code):\n  self.data.append(code)\n def getwidth(self):\n \n  if self.width:\n   return self.width\n  lo = hi = 0\n  UNITCODES = (ANY, RANGE, IN, LITERAL, NOT_LITERAL, CATEGORY)\n  REPEATCODES = (MIN_REPEAT, MAX_REPEAT)\n  for op, av in self.data:\n   if op is BRANCH:\n    i = sys.maxsize\n    j = 0\n    for av in av[1]:\n     l, h = av.getwidth()\n     i = min(i, l)\n     j = max(j, h)\n    lo = lo + i\n    hi = hi + j\n   elif op is CALL:\n    i, j = av.getwidth()\n    lo = lo + i\n    hi = hi + j\n   elif op is SUBPATTERN:\n    i, j = av[1].getwidth()\n    lo = lo + i\n    hi = hi + j\n   elif op in REPEATCODES:\n    i, j = av[2].getwidth()\n    lo = lo + int(i) * av[0]\n    hi = hi + int(j) * av[1]\n   elif op in UNITCODES:\n    lo = lo + 1\n    hi = hi + 1\n   elif op == SUCCESS:\n    break\n  self.width = int(min(lo, sys.maxsize)), int(min(hi, sys.maxsize))\n  return self.width\n  \nclass Tokenizer:\n def __init__(self, string):\n  self.istext = isinstance(string, str)\n  self.string = string\n  self.index = 0\n  self.__next()\n def __next(self):\n  if self.index >= len(self.string):\n   self.next = None\n   return\n  char = self.string[self.index:self.index+1]\n  \n  \n  if char and not self.istext:\n   char = chr(char[0])\n  if char == \"\\\\\":\n   try:\n    c = self.string[self.index + 1]\n   except IndexError:\n    raise error(\"bogus escape (end of line)\")\n   if not self.istext:\n    c = chr(c)\n   char = char + c\n  self.index = self.index + len(char)\n  self.next = char\n def match(self, char, skip=1):\n  if char == self.next:\n   if skip:\n    self.__next()\n   return 1\n  return 0\n def get(self):\n  this = self.next\n  self.__next()\n  return this\n def getwhile(self, n, charset):\n  result = ''\n  for _ in range(n):\n   c = self.next\n   if c not in charset:\n    break\n   result += c\n   self.__next()\n  return result\n def tell(self):\n  return self.index, self.next\n def seek(self, index):\n  self.index, self.next = index\n  \ndef isident(char):\n return \"a\" <= char <= \"z\" or \"A\" <= char <= \"Z\" or char == \"_\"\n \ndef isdigit(char):\n return \"0\" <= char <= \"9\"\n \ndef isname(name):\n\n if not isident(name[0]):\n  return False\n for char in name[1:]:\n  if not isident(char) and not isdigit(char):\n   return False\n return True\n \ndef _class_escape(source, escape):\n\n code = ESCAPES.get(escape)\n if code:\n  return code\n code = CATEGORIES.get(escape)\n if code and code[0] == IN:\n  return code\n try:\n  c = escape[1:2]\n  if c == \"x\":\n  \n   escape += source.getwhile(2, HEXDIGITS)\n   if len(escape) != 4:\n    raise ValueError\n   return LITERAL, int(escape[2:], 16) & 0xff\n  elif c == \"u\" and source.istext:\n  \n   escape += source.getwhile(4, HEXDIGITS)\n   if len(escape) != 6:\n    raise ValueError\n   return LITERAL, int(escape[2:], 16)\n  elif c == \"U\" and source.istext:\n  \n   escape += source.getwhile(8, HEXDIGITS)\n   if len(escape) != 10:\n    raise ValueError\n   c = int(escape[2:], 16)\n   chr(c) \n   return LITERAL, c\n  elif c in OCTDIGITS:\n  \n   escape += source.getwhile(2, OCTDIGITS)\n   return LITERAL, int(escape[1:], 8) & 0xff\n  elif c in DIGITS:\n   raise ValueError\n  if len(escape) == 2:\n   return LITERAL, ord(escape[1])\n except ValueError:\n  pass\n raise error(\"bogus escape: %s\" % repr(escape))\n \ndef _escape(source, escape, state):\n\n code = CATEGORIES.get(escape)\n if code:\n  return code\n code = ESCAPES.get(escape)\n if code:\n  return code\n try:\n  c = escape[1:2]\n  if c == \"x\":\n  \n   escape += source.getwhile(2, HEXDIGITS)\n   if len(escape) != 4:\n    raise ValueError\n   return LITERAL, int(escape[2:], 16) & 0xff\n  elif c == \"u\" and source.istext:\n  \n   escape += source.getwhile(4, HEXDIGITS)\n   if len(escape) != 6:\n    raise ValueError\n   return LITERAL, int(escape[2:], 16)\n  elif c == \"U\" and source.istext:\n  \n   escape += source.getwhile(8, HEXDIGITS)\n   if len(escape) != 10:\n    raise ValueError\n   c = int(escape[2:], 16)\n   chr(c) \n   return LITERAL, c\n  elif c == \"0\":\n  \n   escape += source.getwhile(2, OCTDIGITS)\n   return LITERAL, int(escape[1:], 8) & 0xff\n  elif c in DIGITS:\n  \n   if source.next in DIGITS:\n    escape = escape + source.get()\n    if (escape[1] in OCTDIGITS and escape[2] in OCTDIGITS and\n    source.next in OCTDIGITS):\n    \n     escape = escape + source.get()\n     return LITERAL, int(escape[1:], 8) & 0xff\n     \n   group = int(escape[1:])\n   if group < state.groups:\n    if not state.checkgroup(group):\n     raise error(\"cannot refer to open group\")\n    return GROUPREF, group\n   raise ValueError\n  if len(escape) == 2:\n   return LITERAL, ord(escape[1])\n except ValueError:\n  pass\n raise error(\"bogus escape: %s\" % repr(escape))\n \ndef _parse_sub(source, state, nested=1):\n\n\n items = []\n itemsappend = items.append\n sourcematch = source.match\n while 1:\n  itemsappend(_parse(source, state))\n  if sourcematch(\"|\"):\n   continue\n  if not nested:\n   break\n  if not source.next or sourcematch(\")\", 0):\n   break\n  else:\n   raise error(\"pattern not properly closed\")\n   \n if len(items) == 1:\n  return items[0]\n  \n subpattern = SubPattern(state)\n subpatternappend = subpattern.append\n \n \n while 1:\n  prefix = None\n  for item in items:\n   if not item:\n    break\n   if prefix is None:\n    prefix = item[0]\n   elif item[0] != prefix:\n    break\n  else:\n  \n  \n   for item in items:\n    del item[0]\n   subpatternappend(prefix)\n   continue \n  break\n  \n  \n for item in items:\n  if len(item) != 1 or item[0][0] != LITERAL:\n   break\n else:\n \n \n  set = []\n  setappend = set.append\n  for item in items:\n   setappend(item[0])\n  subpatternappend((IN, set))\n  return subpattern\n  \n subpattern.append((BRANCH, (None, items)))\n return subpattern\n \ndef _parse_sub_cond(source, state, condgroup):\n item_yes = _parse(source, state)\n if source.match(\"|\"):\n  item_no = _parse(source, state)\n  if source.match(\"|\"):\n   raise error(\"conditional backref with more than two branches\")\n else:\n  item_no = None\n if source.next and not source.match(\")\", 0):\n  raise error(\"pattern not properly closed\")\n subpattern = SubPattern(state)\n subpattern.append((GROUPREF_EXISTS, (condgroup, item_yes, item_no)))\n return subpattern\n \n_PATTERNENDERS = set(\"|)\")\n_ASSERTCHARS = set(\"=!<\")\n_LOOKBEHINDASSERTCHARS = set(\"=!\")\n_REPEATCODES = set([MIN_REPEAT, MAX_REPEAT])\n\ndef _parse(source, state):\n\n subpattern = SubPattern(state)\n \n \n subpatternappend = subpattern.append\n sourceget = source.get\n sourcematch = source.match\n _len = len\n PATTERNENDERS = _PATTERNENDERS\n ASSERTCHARS = _ASSERTCHARS\n LOOKBEHINDASSERTCHARS = _LOOKBEHINDASSERTCHARS\n REPEATCODES = _REPEATCODES\n \n while 1:\n \n  if source.next in PATTERNENDERS:\n   break \n  this = sourceget()\n  if this is None:\n   break \n   \n  if state.flags & SRE_FLAG_VERBOSE:\n  \n   if this in WHITESPACE:\n    continue\n   if this == \"#\":\n    while 1:\n     this = sourceget()\n     if this in (None, \"\\n\"):\n      break\n    continue\n    \n  if this and this[0] not in SPECIAL_CHARS:\n   subpatternappend((LITERAL, ord(this)))\n   \n  elif this == \"[\":\n  \n   set = []\n   setappend = set.append\n   \n   \n   if sourcematch(\"^\"):\n    setappend((NEGATE, None))\n    \n   start = set[:]\n   while 1:\n    this = sourceget()\n    if this == \"]\" and set != start:\n     break\n    elif this and this[0] == \"\\\\\":\n     code1 = _class_escape(source, this)\n    elif this:\n     code1 = LITERAL, ord(this)\n    else:\n     raise error(\"unexpected end of regular expression\")\n    if sourcematch(\"-\"):\n    \n     this = sourceget()\n     if this == \"]\":\n      if code1[0] is IN:\n       code1 = code1[1][0]\n      setappend(code1)\n      setappend((LITERAL, ord(\"-\")))\n      break\n     elif this:\n      if this[0] == \"\\\\\":\n       code2 = _class_escape(source, this)\n      else:\n       code2 = LITERAL, ord(this)\n      if code1[0] != LITERAL or code2[0] != LITERAL:\n       raise error(\"bad character range\")\n      lo = code1[1]\n      hi = code2[1]\n      if hi < lo:\n       raise error(\"bad character range\")\n      setappend((RANGE, (lo, hi)))\n     else:\n      raise error(\"unexpected end of regular expression\")\n    else:\n     if code1[0] is IN:\n      code1 = code1[1][0]\n     setappend(code1)\n     \n     \n   if _len(set)==1 and set[0][0] is LITERAL:\n    subpatternappend(set[0]) \n   elif _len(set)==2 and set[0][0] is NEGATE and set[1][0] is LITERAL:\n    subpatternappend((NOT_LITERAL, set[1][1])) \n   else:\n   \n    subpatternappend((IN, set))\n    \n  elif this and this[0] in REPEAT_CHARS:\n  \n   if this == \"?\":\n    min, max = 0, 1\n   elif this == \"*\":\n    min, max = 0, MAXREPEAT\n    \n   elif this == \"+\":\n    min, max = 1, MAXREPEAT\n   elif this == \"{\":\n    if source.next == \"}\":\n     subpatternappend((LITERAL, ord(this)))\n     continue\n    here = source.tell()\n    min, max = 0, MAXREPEAT\n    lo = hi = \"\"\n    while source.next in DIGITS:\n     lo = lo + source.get()\n    if sourcematch(\",\"):\n     while source.next in DIGITS:\n      hi = hi + sourceget()\n    else:\n     hi = lo\n    if not sourcematch(\"}\"):\n     subpatternappend((LITERAL, ord(this)))\n     source.seek(here)\n     continue\n    if lo:\n     min = int(lo)\n     if min >= MAXREPEAT:\n      raise OverflowError(\"the repetition number is too large\")\n    if hi:\n     max = int(hi)\n     if max >= MAXREPEAT:\n      raise OverflowError(\"the repetition number is too large\")\n     if max < min:\n      raise error(\"bad repeat interval\")\n   else:\n    raise error(\"not supported\")\n    \n   if subpattern:\n    item = subpattern[-1:]\n   else:\n    item = None\n   if not item or (_len(item) == 1 and item[0][0] == AT):\n    raise error(\"nothing to repeat\")\n   if item[0][0] in REPEATCODES:\n    raise error(\"multiple repeat\")\n   if sourcematch(\"?\"):\n    subpattern[-1] = (MIN_REPEAT, (min, max, item))\n   else:\n    subpattern[-1] = (MAX_REPEAT, (min, max, item))\n    \n  elif this == \".\":\n   subpatternappend((ANY, None))\n   \n  elif this == \"(\":\n   group = 1\n   name = None\n   condgroup = None\n   if sourcematch(\"?\"):\n    group = 0\n    \n    if sourcematch(\"P\"):\n    \n     if sourcematch(\"<\"):\n     \n      name = \"\"\n      while 1:\n       char = sourceget()\n       if char is None:\n        raise error(\"unterminated name\")\n       if char == \">\":\n        break\n       name = name + char\n      group = 1\n      if not name:\n       raise error(\"missing group name\")\n      if not isname(name):\n       raise error(\"bad character in group name\")\n     elif sourcematch(\"=\"):\n     \n      name = \"\"\n      while 1:\n       char = sourceget()\n       if char is None:\n        raise error(\"unterminated name\")\n       if char == \")\":\n        break\n       name = name + char\n      if not name:\n       raise error(\"missing group name\")\n      if not isname(name):\n       raise error(\"bad character in group name\")\n      gid = state.groupdict.get(name)\n      if gid is None:\n       raise error(\"unknown group name\")\n      subpatternappend((GROUPREF, gid))\n      continue\n     else:\n      char = sourceget()\n      if char is None:\n       raise error(\"unexpected end of pattern\")\n      raise error(\"unknown specifier: ?P%s\" % char)\n    elif sourcematch(\":\"):\n    \n     group = 2\n    elif sourcematch(\"#\"):\n    \n     while 1:\n      if source.next is None or source.next == \")\":\n       break\n      sourceget()\n     if not sourcematch(\")\"):\n      raise error(\"unbalanced parenthesis\")\n     continue\n    elif source.next in ASSERTCHARS:\n    \n     char = sourceget()\n     dir = 1\n     if char == \"<\":\n      if source.next not in LOOKBEHINDASSERTCHARS:\n       raise error(\"syntax error\")\n      dir = -1 \n      char = sourceget()\n     p = _parse_sub(source, state)\n     if not sourcematch(\")\"):\n      raise error(\"unbalanced parenthesis\")\n     if char == \"=\":\n      subpatternappend((ASSERT, (dir, p)))\n     else:\n      subpatternappend((ASSERT_NOT, (dir, p)))\n     continue\n    elif sourcematch(\"(\"):\n    \n     condname = \"\"\n     while 1:\n      char = sourceget()\n      if char is None:\n       raise error(\"unterminated name\")\n      if char == \")\":\n       break\n      condname = condname + char\n     group = 2\n     if not condname:\n      raise error(\"missing group name\")\n     if isname(condname):\n      condgroup = state.groupdict.get(condname)\n      if condgroup is None:\n       raise error(\"unknown group name\")\n     else:\n      try:\n       condgroup = int(condname)\n      except ValueError:\n       raise error(\"bad character in group name\")\n    else:\n    \n     if not source.next in FLAGS:\n      raise error(\"unexpected end of pattern\")\n     while source.next in FLAGS:\n      state.flags = state.flags | FLAGS[sourceget()]\n   if group:\n   \n    if group == 2:\n    \n     group = None\n    else:\n     group = state.opengroup(name)\n    if condgroup:\n     p = _parse_sub_cond(source, state, condgroup)\n    else:\n     p = _parse_sub(source, state)\n    if not sourcematch(\")\"):\n     raise error(\"unbalanced parenthesis\")\n    if group is not None:\n     state.closegroup(group)\n    subpatternappend((SUBPATTERN, (group, p)))\n   else:\n    while 1:\n     char = sourceget()\n     if char is None:\n      raise error(\"unexpected end of pattern\")\n     if char == \")\":\n      break\n     raise error(\"unknown extension\")\n     \n  elif this == \"^\":\n   subpatternappend((AT, AT_BEGINNING))\n   \n  elif this == \"$\":\n   subpattern.append((AT, AT_END))\n   \n  elif this and this[0] == \"\\\\\":\n   code = _escape(source, this, state)\n   subpatternappend(code)\n   \n  else:\n   raise error(\"parser error\")\n   \n return subpattern\n \ndef fix_flags(src, flags):\n\n if isinstance(src, str):\n  if not flags & SRE_FLAG_ASCII:\n   flags |= SRE_FLAG_UNICODE\n  elif flags & SRE_FLAG_UNICODE:\n   raise ValueError(\"ASCII and UNICODE flags are incompatible\")\n else:\n  if flags & SRE_FLAG_UNICODE:\n   raise ValueError(\"can't use UNICODE flag with a bytes pattern\")\n return flags\n \ndef parse(str, flags=0, pattern=None):\n\n source = Tokenizer(str)\n \n if pattern is None:\n  pattern = Pattern()\n pattern.flags = flags\n pattern.str = str\n p = _parse_sub(source, pattern, 0)\n p.pattern.flags = fix_flags(str, p.pattern.flags)\n \n tail = source.get()\n if tail == \")\":\n  raise error(\"unbalanced parenthesis\")\n elif tail:\n  raise error(\"bogus characters at end of regular expression\")\n  \n if flags & SRE_FLAG_DEBUG:\n  p.dump()\n  \n if not (flags & SRE_FLAG_VERBOSE) and p.pattern.flags & SRE_FLAG_VERBOSE:\n \n \n  return parse(str, p.pattern.flags)\n  \n return p\n \ndef parse_template(source, pattern):\n\n\n s = Tokenizer(source)\n sget = s.get\n p = []\n a = p.append\n def literal(literal, p=p, pappend=a):\n  if p and p[-1][0] is LITERAL:\n   p[-1] = LITERAL, p[-1][1] + literal\n  else:\n   pappend((LITERAL, literal))\n sep = source[:0]\n if isinstance(sep, str):\n  makechar = chr\n else:\n  makechar = chr\n while 1:\n  this = sget()\n  if this is None:\n   break \n  if this and this[0] == \"\\\\\":\n  \n   c = this[1:2]\n   if c == \"g\":\n    name = \"\"\n    if s.match(\"<\"):\n     while 1:\n      char = sget()\n      if char is None:\n       raise error(\"unterminated group name\")\n      if char == \">\":\n       break\n      name = name + char\n    if not name:\n     raise error(\"missing group name\")\n    try:\n     index = int(name)\n     if index < 0:\n      raise error(\"negative group number\")\n    except ValueError:\n     if not isname(name):\n      raise error(\"bad character in group name\")\n     try:\n      index = pattern.groupindex[name]\n     except KeyError:\n      raise IndexError(\"unknown group name\")\n    a((MARK, index))\n   elif c == \"0\":\n    if s.next in OCTDIGITS:\n     this = this + sget()\n     if s.next in OCTDIGITS:\n      this = this + sget()\n    literal(makechar(int(this[1:], 8) & 0xff))\n   elif c in DIGITS:\n    isoctal = False\n    if s.next in DIGITS:\n     this = this + sget()\n     if (c in OCTDIGITS and this[2] in OCTDIGITS and\n     s.next in OCTDIGITS):\n      this = this + sget()\n      isoctal = True\n      literal(makechar(int(this[1:], 8) & 0xff))\n    if not isoctal:\n     a((MARK, int(this[1:])))\n   else:\n    try:\n     this = makechar(ESCAPES[this][1])\n    except KeyError:\n     pass\n    literal(this)\n  else:\n   literal(this)\n   \n i = 0\n groups = []\n groupsappend = groups.append\n literals = [None] * len(p)\n if isinstance(source, str):\n  encode = lambda x: x\n else:\n \n \n  encode = lambda x: x.encode('latin-1')\n for c, s in p:\n  if c is MARK:\n   groupsappend((i, s))\n   \n  else:\n   literals[i] = encode(s)\n  i = i + 1\n return groups, literals\n \ndef expand_template(template, match):\n g = match.group\n sep = match.string[:0]\n groups, literals = template\n literals = literals[:]\n try:\n  for index, group in groups:\n   literals[index] = s = g(group)\n   if s is None:\n    raise error(\"unmatched group\")\n except IndexError:\n  raise error(\"invalid group reference\")\n return sep.join(literals)\n \n \n"], "site-packages.test_sp": [".py", "test = \"site package\"\n"], "pickle": [".py", "from json import *"], "site-packages.pygame.image": [".py", "\n\n\"\"\n\n__docformat__ = 'restructuredtext'\n__version__ = '$Id$'\n\nfrom browser import html, window\nfrom javascript import JSConstructor, console\n\n\nimport os\nimport re\n\n\n\nimport pygame.surface\n\n\n\n\n\n_have_SDL_image = False\n\ndef load_extended(file, namehint=''):\n \"\"\n if not _have_SDL_image:\n  raise NotImplementedError('load_extended requires SDL.image')\n  \n if not hasattr(file, 'read'):\n  surf = IMG_Load(file)\n else:\n  if not namehint and hasattr(file, 'name'):\n   namehint = file.name\n  namehint = os.path.splitext(namehint)[1]\n  rw = SDL_RWFromObject(file)\n  \n  surf = IMG_LoadTyped_RW(rw, 0, namehint)\n return pygame.surface.Surface(surf=surf)\n \ndef load_basic(file, namehint=''):\n \"\"\n \n \n \n \n \n \n \n \n _img=JSConstructor(window.Image)()\n _img.src=file\n \n _img.canvas=html.CANVAS()\n def img_onload(*args):\n \n \n \n  console.log(args)\n  if hasattr(args[0], 'target'): \n   this=args[0].target\n  else: \n   this=args[0].path[0]\n   \n  this.canvas.width=this.width\n  this.canvas.height=this.height\n  this.canvas.getContext('2d').drawImage(this,0,0)\n  \n  \n _img.onload=img_onload\n return pygame.surface.Surface(surf=_img.canvas)\n \n \ndef load(file, namehint=''):\n \"\"\n \n \n \n return load_basic(file, namehint)\n \ndef save(surface, file):\n \"\"\n \n \n \n \n pass\n \n if surface._surf.flags & SDL_OPENGL:\n  surf = _get_opengl_surface(surface._surf)\n else:\n  surface._prep()\n  surf = surface._surf\n  \n if hasattr(file, 'write'):\n \n  rw = SDL_RWFromObject(file)\n  \n  SDL_SaveBMP_RW(surf, rw, 0) \n else:\n  fileext = os.path.splitext(file)[1].lower()\n  if fileext == '.bmp':\n   SDL_SaveBMP(surf, file)\n  elif fileext in ('.jpg', '.jpeg'):\n   raise pygame.base.error('No support for jpg compiled in.') \n  elif fileext == '.png':\n   raise pygame.base.error('No support for png compiled in.') \n  else:\n   raise NotImplementedError('TODO: TGA support')\n   \n if surface._surf.flags & SDL_OPENGL:\n  SDL_FreeSurface(surf)\n else:\n  surface._unprep()\n  \n  \ndef get_extended():\n \"\"\n return _have_SDL_image\n \ndef tostring(surface, format, flipped=False):\n \"\"\n \n return pygame.surface.Surface.toDataURL('image/%s' % format)\n \n \n surf = surface._surf\n if surf.flags & SDL_OPENGL:\n  surf = _get_opengl_surface(surf)\n  \n result = None\n rows = []\n pitch = surf.pitch\n w = surf.w\n h = surf.h\n \n if flipped:\n  h_range = range(surf.h - 1, -1, -1)\n else:\n  h_range = range(surf.h)\n  \n if format == 'P':\n \n  if surf.format.BytesPerPixel != 1:\n   raise ValueError('Can only create \"P\" format data with 8bit Surfaces')\n   \n  surface.lock()\n  pixels = surf.pixels.to_string()\n  surface.unlock()\n  \n  if pitch == w:\n   result = pixels \n  else:\n   flipped = False \n   for y in h_range:\n    rows.append(pixels[y*pitch:y*pitch + w])\n elif surf.format.BytesPerPixel == len(format) and format != 'RGBX':\n \n \n  if format == 'RGBA':\n   Rmask = SDL_SwapLE32(0x000000ff)\n   Gmask = SDL_SwapLE32(0x0000ff00)\n   Bmask = SDL_SwapLE32(0x00ff0000)\n   Amask = SDL_SwapLE32(0xff000000)\n  elif format == 'ARGB':\n   Amask = SDL_SwapLE32(0x000000ff)\n   Rmask = SDL_SwapLE32(0x0000ff00)\n   Gmask = SDL_SwapLE32(0x00ff0000)\n   Bmask = SDL_SwapLE32(0xff000000)\n  elif format == 'RGB':\n   if SDL_BYTEORDER == SDL_LIL_ENDIAN:\n    Rmask = 0x000000ff\n    Gmask = 0x0000ff00\n    Bmask = 0x00ff0000\n   else:\n    Rmask = 0x00ff0000\n    Gmask = 0x0000ff00\n    Bmask = 0x000000ff \n   Amask = surf.format.Amask \n  if surf.format.Rmask == Rmask and surf.format.Gmask == Gmask and surf.format.Bmask == Bmask and surf.format.Amask == Amask and pitch == w * surf.format.BytesPerPixel:\n  \n  \n   surface.lock()\n   result = surf.pixels.to_string()\n   surface.unlock()\n elif surf.format.BytesPerPixel == 3 and (format in ('RGBA', 'ARGB') or format == 'RGBX' and not surf.flags & SDL_SRCCOLORKEY):\n \n  if surf.format.Rmask == SDL_SwapLE32(0x000000ff) and surf.format.Gmask == SDL_SwapLE32(0x0000ff00) and surf.format.Bmask == SDL_SwapLE32(0x00ff0000) and pitch == w * surf.format.BytesPerPixel:\n   surface.lock()\n   result = surf.pixels.to_string()\n   surface.unlock()\n   \n   \n   alpha = chr(0xff)\n   result = alpha.join(re.findall('...', result, re.DOTALL))\n   if format == 'ARGB':\n    result = alpha + result\n   else:\n    result += alpha\n    \n elif surf.format.BytesPerPixel == 4 and format == 'RGB':\n \n \n  if surf.format.Rmask == SDL_SwapLE32(0x000000ff):\n  \n   Gmask = SDL_SwapLE32(0x0000ff00)\n   Bmask = SDL_SwapLE32(0x00ff0000)\n   pattern = '(...).'\n  elif surf.format.Rmask == SDL_SwapLE32(0x0000ff00):\n  \n   Gmask = SDL_SwapLE32(0x00ff0000)\n   Bmask = SDL_SwapLE32(0xff000000)\n   pattern = '.(...)'\n  else:\n  \n   pattern = None\n   \n  if pattern and surf.format.Gmask == Gmask and surf.format.Bmask == Bmask and pitch == w * surf.format.BytesPerPixel:\n   surface.lock()\n   result = surf.pixels.to_string()\n   surface.unlock()\n   \n   \n   result = ''.join(re.findall(pattern, result, re.DOTALL))\n   \n if not result and not rows:\n \n  surface.lock()\n  if surf.format.BytesPerPixel == 1:\n   palette = surf.format.palette.colors\n   if surf.flags & SDL_SRCCOLORKEY and not Amask and format == 'RGBX':\n    colorkey = surf.format.colorkey\n    pixels = [(palette[c].r, palette[c].g, palette[c].b, \n    (c != colorkey) * 0xff) for c in surf.pixels]\n   else:\n    pixels = [(palette[c].r, palette[c].g, palette[c].b, 255) for c in surf.pixels]\n  elif surf.format.BytesPerPixel == 3:\n   raise NotImplementedError('TODO')\n  else:\n   Rmask = surf.format.Rmask\n   Gmask = surf.format.Gmask\n   Bmask = surf.format.Bmask\n   Amask = surf.format.Amask\n   Rshift = surf.format.Rshift\n   Gshift = surf.format.Gshift\n   Bshift = surf.format.Bshift\n   Ashift = surf.format.Ashift\n   Rloss = surf.format.Rloss\n   Gloss = surf.format.Gloss\n   Bloss = surf.format.Bloss\n   Aloss = surf.format.Aloss\n   if surf.flags & SDL_SRCCOLORKEY and not Amask and format == 'RGBX':\n    colorkey = surf.format.colorkey\n    pixels = [( ((c & Rmask) >> Rshift) << Rloss,\n    ((c & Gmask) >> Gshift) << Gloss,\n    ((c & Bmask) >> Bshift) << Bloss,\n    (c != colorkey) * 0xff ) for c in surf.pixels]\n   else:\n    pixels = [( ((c & Rmask) >> Rshift) << Rloss,\n    ((c & Gmask) >> Gshift) << Gloss,\n    ((c & Bmask) >> Bshift) << Bloss,\n    ((c & Amask) >> Ashift) << Aloss ) for c in surf.pixels]\n  surface.unlock()\n  pitch /= surf.format.BytesPerPixel\n  flipped = False \n  if format == 'RGB':\n   for y in h_range:\n    rows.append(''.join([ chr(c[0]) + chr(c[1]) + chr(c[2]) for c in pixels[y*pitch:y*pitch + w] ]))\n  elif format in ('RGBA', 'RGBX'):\n   for y in h_range:\n    rows.append(''.join([ chr(c[0]) + chr(c[1]) + chr(c[2]) + chr(c[3]) for c in pixels[y*pitch:y*pitch + w] ]))\n  elif format == 'ARGB':\n   for y in h_range:\n    rows.append(''.join([ chr(c[3]) + chr(c[1]) + chr(c[2]) + chr(c[0]) for c in pixels[y*pitch:y*pitch + w] ]))\n    \n if surface._surf.flags & SDL_OPENGL:\n  SDL_FreeSurface(surf)\n  \n  \n if result:\n  if flipped:\n  \n   rows = re.findall('.' * w * len(format), result, re.DOTALL)\n  else:\n   return result\n   \n if flipped:\n  rows.reverse()\n return ''.join(rows)\n \ndef fromstring(string, size, format, flipped=False):\n \"\"\n \n _img = html.IMG(width=size[0], height=size[1])\n _img.src=string\n \n _canvas=html.CANVAS(width=size[0], height=size[1])\n _ctx=_canvas.getContext('2d')\n _ctx.drawImage(_img,0,0)\n \n return pygame.surface.Surface(surf=_canvas)\n \n \n width, height = size\n if format == 'P':\n  Rmask = 0\n  Gmask = 0\n  Bmask = 0\n  Amask = 0\n  depth = 8\n  pitch = width\n elif format == 'RGB':\n  if SDL_BYTEORDER == SDL_LIL_ENDIAN:\n   Rmask = 0x000000ff\n   Gmask = 0x0000ff00\n   Bmask = 0x00ff0000\n  else:\n   Rmask = 0x00ff0000\n   Gmask = 0x0000ff00\n   Bmask = 0x000000ff\n  Amask = 0x00000000\n  depth = 24\n  pitch = width * 3\n elif format in ('RGBA', 'RGBX'):\n  if SDL_BYTEORDER == SDL_LIL_ENDIAN:\n   Rmask = 0x000000ff\n   Gmask = 0x0000ff00\n   Bmask = 0x00ff0000\n   Amask = 0xff000000\n  else:\n   Rmask = 0xff000000\n   Gmask = 0x00ff0000\n   Bmask = 0x0000ff00\n   Amask = 0x000000ff\n  if format == 'RGBX':\n   Amask = 0x00000000\n  depth = 32\n  pitch = width * 4\n elif format == 'ARGB':\n  if SDL_BYTEORDER == SDL_LIL_ENDIAN:\n   Rmask = 0x0000ff00\n   Gmask = 0x00ff0000\n   Bmask = 0xff000000\n   Amask = 0x000000ff\n  else:\n   Rmask = 0x00ff0000\n   Gmask = 0x0000ff00\n   Bmask = 0x000000ff\n   Amask = 0xff000000\n  depth = 32\n  pitch = width * 4\n if len(string) != pitch * height:\n  raise ValueError('String length does not equal format and resolution size')\n if flipped:\n  string = ''.join([string[y*pitch:y*pitch+pitch] for y in range(height - 1, -1, -1)])\n surf = SDL_CreateRGBSurfaceFrom(string, width, height, depth, pitch,\n Rmask, Gmask, Bmask, Amask)\n \n return pygame.surface.Surface(surf=surf)\n \ndef frombuffer(string, size, format):\n \"\"\n return fromstring(string, size, format)\n \ndef _get_opengl_surface(surf):\n import OpenGL.GL\n data = OpenGL.GL.glReadPixels(0, 0, surf.w, surf.h, \n OpenGL.GL.GL_RGB, OpenGL.GL.GL_UNSIGNED_BYTE)\n if SDL_BYTEORDER == SDL_LIL_ENDIAN:\n  Rmask = 0x000000ff\n  Gmask = 0x0000ff00\n  Bmask = 0x00ff0000\n else:\n  Rmask = 0x00ff0000\n  Gmask = 0x0000ff00\n  Bmask = 0x000000ff\n  \n pitch = surf.w * 3\n data = ''.join([data[y*pitch:y*pitch+pitch] for y in range(surf.h - 1, -1, -1)])\n newsurf = SDL_CreateRGBSurfaceFrom(data, surf.w, surf.h, 24, pitch,\n Rmask, Gmask, Bmask, 0)\n return newsurf\n \n"], "browser": [".py", "import javascript\n\nfrom _browser import *\n\nfrom .local_storage import LocalStorage\nfrom .session_storage import SessionStorage\nfrom .object_storage import ObjectStorage\n\nWebSocket = javascript.JSConstructor(window.WebSocket)", 1], "reprlib": [".py", "\"\"\n\n__all__ = [\"Repr\", \"repr\", \"recursive_repr\"]\n\nimport builtins\nfrom itertools import islice\ntry:\n from _thread import get_ident\nexcept ImportError:\n from _dummy_thread import get_ident\n \ndef recursive_repr(fillvalue='...'):\n \"\"\n \n def decorating_function(user_function):\n  repr_running = set()\n  \n  def wrapper(self):\n   key = id(self), get_ident()\n   if key in repr_running:\n    return fillvalue\n   repr_running.add(key)\n   try:\n    result = user_function(self)\n   finally:\n    repr_running.discard(key)\n   return result\n   \n   \n  wrapper.__module__ = getattr(user_function, '__module__')\n  wrapper.__doc__ = getattr(user_function, '__doc__')\n  wrapper.__name__ = getattr(user_function, '__name__')\n  wrapper.__annotations__ = getattr(user_function, '__annotations__', {})\n  return wrapper\n  \n return decorating_function\n \nclass Repr:\n\n def __init__(self):\n  self.maxlevel = 6\n  self.maxtuple = 6\n  self.maxlist = 6\n  self.maxarray = 5\n  self.maxdict = 4\n  self.maxset = 6\n  self.maxfrozenset = 6\n  self.maxdeque = 6\n  self.maxstring = 30\n  self.maxlong = 40\n  self.maxother = 30\n  \n def repr(self, x):\n  return self.repr1(x, self.maxlevel)\n  \n def repr1(self, x, level):\n  typename = type(x).__name__\n  if ' ' in typename:\n   parts = typename.split()\n   typename = '_'.join(parts)\n  if hasattr(self, 'repr_' + typename):\n   return getattr(self, 'repr_' + typename)(x, level)\n  else:\n   return self.repr_instance(x, level)\n   \n def _repr_iterable(self, x, level, left, right, maxiter, trail=''):\n  n = len(x)\n  if level <= 0 and n:\n   s = '...'\n  else:\n   newlevel = level - 1\n   repr1 = self.repr1\n   pieces = [repr1(elem, newlevel) for elem in islice(x, maxiter)]\n   if n > maxiter: pieces.append('...')\n   s = ', '.join(pieces)\n   if n == 1 and trail: right = trail + right\n  return '%s%s%s' % (left, s, right)\n  \n def repr_tuple(self, x, level):\n  return self._repr_iterable(x, level, '(', ')', self.maxtuple, ',')\n  \n def repr_list(self, x, level):\n  return self._repr_iterable(x, level, '[', ']', self.maxlist)\n  \n def repr_array(self, x, level):\n  header = \"array('%s', [\" % x.typecode\n  return self._repr_iterable(x, level, header, '])', self.maxarray)\n  \n def repr_set(self, x, level):\n  x = _possibly_sorted(x)\n  return self._repr_iterable(x, level, 'set([', '])', self.maxset)\n  \n def repr_frozenset(self, x, level):\n  x = _possibly_sorted(x)\n  return self._repr_iterable(x, level, 'frozenset([', '])',\n  self.maxfrozenset)\n  \n def repr_deque(self, x, level):\n  return self._repr_iterable(x, level, 'deque([', '])', self.maxdeque)\n  \n def repr_dict(self, x, level):\n  n = len(x)\n  if n == 0: return '{}'\n  if level <= 0: return '{...}'\n  newlevel = level - 1\n  repr1 = self.repr1\n  pieces = []\n  for key in islice(_possibly_sorted(x), self.maxdict):\n   keyrepr = repr1(key, newlevel)\n   valrepr = repr1(x[key], newlevel)\n   pieces.append('%s: %s' % (keyrepr, valrepr))\n  if n > self.maxdict: pieces.append('...')\n  s = ', '.join(pieces)\n  return '{%s}' % (s,)\n  \n def repr_str(self, x, level):\n  s = builtins.repr(x[:self.maxstring])\n  if len(s) > self.maxstring:\n   i = max(0, (self.maxstring-3)//2)\n   j = max(0, self.maxstring-3-i)\n   s = builtins.repr(x[:i] + x[len(x)-j:])\n   s = s[:i] + '...' + s[len(s)-j:]\n  return s\n  \n def repr_int(self, x, level):\n  s = builtins.repr(x) \n  if len(s) > self.maxlong:\n   i = max(0, (self.maxlong-3)//2)\n   j = max(0, self.maxlong-3-i)\n   s = s[:i] + '...' + s[len(s)-j:]\n  return s\n  \n def repr_instance(self, x, level):\n  try:\n   s = builtins.repr(x)\n   \n   \n  except Exception:\n   return '<%s instance at %x>' % (x.__class__.__name__, id(x))\n  if len(s) > self.maxother:\n   i = max(0, (self.maxother-3)//2)\n   j = max(0, self.maxother-3-i)\n   s = s[:i] + '...' + s[len(s)-j:]\n  return s\n  \n  \ndef _possibly_sorted(x):\n\n\n\n try:\n  return sorted(x)\n except Exception:\n  return list(x)\n  \naRepr = Repr()\nrepr = aRepr.repr\n"], "browser.indexed_db": [".py", "class EventListener:\n def __init__(self, events=[]):\n  self._events=events\n  \n def append(self, event):\n  self._events.append(event)\n  \n def fire(self, e):\n  for _event in self._events:\n   _event(e)\n   \nclass IndexedDB:\n def __init__(self):\n  if not __BRYTHON__.has_indexedDB:\n   raise NotImplementedError(\"Your browser doesn't support indexedDB\")\n   return\n   \n  self._indexedDB=__BRYTHON__.indexedDB()\n  self._db=None\n  self._version=None\n  \n def _onsuccess(self, event):\n  self._db=event.target.result\n  \n def open(self, name, onsuccess, version=1.0, onerror=None, \n onupgradeneeded=None):\n  self._version=version\n  _result=self._indexedDB.open(name, version)\n  _success=EventListener([self._onsuccess, onsuccess])\n  _result.onsuccess=_success.fire\n  _result.onupgradeneeded=onupgradeneeded\n  \n  \n  def onerror(e):\n   print(\"onerror: %s:%s\" % (e.type, e.target.result))\n   \n  def onblocked(e):\n   print(\"blocked: %s:%s\" % (e.type, e.result))\n   \n  _result.onerror=onerror\n  _result.onblocked=onblocked\n  \n def transaction(self, entities, mode='read'):\n  return Transaction(self._db.transaction(entities, mode))\n  \nclass Transaction:\n\n def __init__(self, transaction):\n  self._transaction=transaction\n  \n def objectStore(self, name):\n  return ObjectStore(self._transaction.objectStore(name))\n  \nclass ObjectStore:\n\n def __init__(self, objectStore):\n  self._objectStore=objectStore\n  self._data=[]\n  \n def clear(self, onsuccess=None, onerror=None):\n  _result=self._objectStore.clear()\n  \n  if onsuccess is not None:\n   _result.onsuccess=onsuccess\n   \n  if onerror is not None:\n   _result.onerror=onerror\n   \n def _helper(self, func, object, onsuccess=None, onerror=None):\n  _result=func(object)\n  \n  if onsuccess is not None:\n   _result.onsuccess=onsuccess\n   \n  if onerror is not None:\n   _result.onerror=onerror\n   \n def put(self, obj, key=None, onsuccess=None, onerror=None):\n  _r = self._objectStore.put(obj, key)\n  _r.onsuccess = onsuccess\n  _r.onerror = onerror\n  \n def add(self, obj, key, onsuccess=None, onerror=None):\n  _r = self._objectStore.add(obj, key)\n  _r.onsuccess = onsuccess\n  _r.onerror = onerror\n  \n  \n def delete(self, index, onsuccess=None, onerror=None): \n  self._helper(self._objectStore.delete, index, onsuccess, onerror)\n  \n def query(self, *args):\n  self._data=[]\n  def onsuccess(event):\n   cursor=event.target.result\n   if cursor is not None:\n    self._data.append(cursor.value)\n    getattr(cursor,\"continue\")() \n    \n  self._objectStore.openCursor(args).onsuccess=onsuccess\n  \n def fetchall(self):\n  yield self._data\n  \n def get(self, key, onsuccess=None, onerror=None):\n  self._helper(self._objectStore.get, key, onsuccess, onerror)\n"], "sre_compile": [".py", "\n\n\n\n\n\n\n\n\n\n\"\"\n\n\nimport sys\nimport _sre\nimport sre_parse\nfrom sre_constants import *\nfrom _sre import MAXREPEAT\n\n\nassert _sre.MAGIC == MAGIC, \"SRE module mismatch\"\n\nif _sre.CODESIZE == 2:\n MAXCODE = 65535\nelse:\n MAXCODE = 0xFFFFFFFF\n \ndef _identityfunction(x):\n return x\n \n \n_LITERAL_CODES = set([LITERAL, NOT_LITERAL])\n_REPEATING_CODES = set([REPEAT, MIN_REPEAT, MAX_REPEAT])\n_SUCCESS_CODES = set([SUCCESS, FAILURE])\n_ASSERT_CODES = set([ASSERT, ASSERT_NOT])\n\ndef _compile(code, pattern, flags):\n\n emit = code.append\n _len = len\n LITERAL_CODES = _LITERAL_CODES\n REPEATING_CODES = _REPEATING_CODES\n SUCCESS_CODES = _SUCCESS_CODES\n ASSERT_CODES = _ASSERT_CODES\n for op, av in pattern:\n \n \n  if op in LITERAL_CODES:\n   if flags & SRE_FLAG_IGNORECASE:\n    emit(OPCODES[OP_IGNORE[op]])\n    emit(_sre.getlower(av, flags))\n   else:\n    emit(OPCODES[op])\n    emit(av)\n  elif op is IN:\n   if flags & SRE_FLAG_IGNORECASE:\n    emit(OPCODES[OP_IGNORE[op]])\n    def fixup(literal, flags=flags):\n     return _sre.getlower(literal, flags)\n   else:\n    emit(OPCODES[op])\n    fixup = _identityfunction\n   skip = _len(code); emit(0)\n   _compile_charset(av, flags, code, fixup)\n   code[skip] = _len(code) - skip\n  elif op is ANY:\n   if flags & SRE_FLAG_DOTALL:\n    emit(OPCODES[ANY_ALL])\n   else:\n    emit(OPCODES[ANY])\n  elif op in REPEATING_CODES:\n   if flags & SRE_FLAG_TEMPLATE:\n    raise error(\"internal: unsupported template operator\")\n    emit(OPCODES[REPEAT])\n    skip = _len(code); emit(0)\n    emit(av[0])\n    emit(av[1])\n    _compile(code, av[2], flags)\n    emit(OPCODES[SUCCESS])\n    code[skip] = _len(code) - skip\n   elif _simple(av) and op is not REPEAT:\n    if op is MAX_REPEAT:\n     emit(OPCODES[REPEAT_ONE])\n    else:\n     emit(OPCODES[MIN_REPEAT_ONE])\n    skip = _len(code); emit(0)\n    emit(av[0])\n    emit(av[1])\n    _compile(code, av[2], flags)\n    emit(OPCODES[SUCCESS])\n    code[skip] = _len(code) - skip\n   else:\n    emit(OPCODES[REPEAT])\n    skip = _len(code); emit(0)\n    emit(av[0])\n    emit(av[1])\n    _compile(code, av[2], flags)\n    code[skip] = _len(code) - skip\n    if op is MAX_REPEAT:\n     emit(OPCODES[MAX_UNTIL])\n    else:\n     emit(OPCODES[MIN_UNTIL])\n  elif op is SUBPATTERN:\n   if av[0]:\n    emit(OPCODES[MARK])\n    emit((av[0]-1)*2)\n    \n   _compile(code, av[1], flags)\n   if av[0]:\n    emit(OPCODES[MARK])\n    emit((av[0]-1)*2+1)\n  elif op in SUCCESS_CODES:\n   emit(OPCODES[op])\n  elif op in ASSERT_CODES:\n   emit(OPCODES[op])\n   skip = _len(code); emit(0)\n   if av[0] >= 0:\n    emit(0) \n   else:\n    lo, hi = av[1].getwidth()\n    if lo != hi:\n     raise error(\"look-behind requires fixed-width pattern\")\n    emit(lo) \n   _compile(code, av[1], flags)\n   emit(OPCODES[SUCCESS])\n   code[skip] = _len(code) - skip\n  elif op is CALL:\n   emit(OPCODES[op])\n   skip = _len(code); emit(0)\n   _compile(code, av, flags)\n   emit(OPCODES[SUCCESS])\n   code[skip] = _len(code) - skip\n  elif op is AT:\n   emit(OPCODES[op])\n   if flags & SRE_FLAG_MULTILINE:\n    av = AT_MULTILINE.get(av, av)\n   if flags & SRE_FLAG_LOCALE:\n    av = AT_LOCALE.get(av, av)\n   elif flags & SRE_FLAG_UNICODE:\n    av = AT_UNICODE.get(av, av)\n   emit(ATCODES[av])\n  elif op is BRANCH:\n   emit(OPCODES[op])\n   tail = []\n   tailappend = tail.append\n   for av in av[1]:\n    skip = _len(code); emit(0)\n    \n    _compile(code, av, flags)\n    emit(OPCODES[JUMP])\n    tailappend(_len(code)); emit(0)\n    code[skip] = _len(code) - skip\n   emit(0) \n   for tail in tail:\n    code[tail] = _len(code) - tail\n  elif op is CATEGORY:\n   emit(OPCODES[op])\n   if flags & SRE_FLAG_LOCALE:\n    av = CH_LOCALE[av]\n   elif flags & SRE_FLAG_UNICODE:\n    av = CH_UNICODE[av]\n   emit(CHCODES[av])\n  elif op is GROUPREF:\n   if flags & SRE_FLAG_IGNORECASE:\n    emit(OPCODES[OP_IGNORE[op]])\n   else:\n    emit(OPCODES[op])\n   emit(av-1)\n  elif op is GROUPREF_EXISTS:\n   emit(OPCODES[op])\n   emit(av[0]-1)\n   skipyes = _len(code); emit(0)\n   _compile(code, av[1], flags)\n   if av[2]:\n    emit(OPCODES[JUMP])\n    skipno = _len(code); emit(0)\n    code[skipyes] = _len(code) - skipyes + 1\n    _compile(code, av[2], flags)\n    code[skipno] = _len(code) - skipno\n   else:\n    code[skipyes] = _len(code) - skipyes + 1\n  else:\n   raise ValueError(\"unsupported operand type\", op)\n   \ndef _compile_charset(charset, flags, code, fixup=None):\n\n emit = code.append\n if fixup is None:\n  fixup = _identityfunction\n for op, av in _optimize_charset(charset, fixup):\n  emit(OPCODES[op])\n  if op is NEGATE:\n   pass\n  elif op is LITERAL:\n   emit(fixup(av))\n  elif op is RANGE:\n   emit(fixup(av[0]))\n   emit(fixup(av[1]))\n  elif op is CHARSET:\n   code.extend(av)\n  elif op is BIGCHARSET:\n   code.extend(av)\n  elif op is CATEGORY:\n   if flags & SRE_FLAG_LOCALE:\n    emit(CHCODES[CH_LOCALE[av]])\n   elif flags & SRE_FLAG_UNICODE:\n    emit(CHCODES[CH_UNICODE[av]])\n   else:\n    emit(CHCODES[av])\n  else:\n   raise error(\"internal: unsupported set operator\")\n emit(OPCODES[FAILURE])\n \n \ndef _optimize_charset(charset, fixup):\n\n out = []\n outappend = out.append\n charmap = [0]*256\n try:\n  for op, av in charset:\n   if op is NEGATE:\n    outappend((op, av))\n   elif op is LITERAL:\n    charmap[fixup(av)] = 1\n   elif op is RANGE:\n    for i in range(fixup(av[0]), fixup(av[1])+1):\n     charmap[i] = 1\n   elif op is CATEGORY:\n   \n    return charset \n except IndexError:\n \n  return _optimize_unicode(charset, fixup)\n  \n i = p = n = 0\n runs = []\n runsappend = runs.append\n for c in charmap:\n  if c:\n   if n == 0:\n    p = i\n   n = n + 1\n  elif n:\n   runsappend((p, n))\n   n = 0\n  i = i + 1\n if n:\n  runsappend((p, n))\n if len(runs) <= 2:\n \n  for p, n in runs:\n   if n == 1:\n    outappend((LITERAL, p))\n   else:\n    outappend((RANGE, (p, p+n-1)))\n  if len(out) < len(charset):\n   return out\n else:\n \n  data = _mk_bitmap(charmap)\n  outappend((CHARSET, data))\n  return out\n return charset\n \ndef _mk_bitmap(bits):\n data = []\n dataappend = data.append\n if _sre.CODESIZE == 2:\n  start = (1, 0)\n else:\n  start = (1, 0)\n m, v = start\n for c in bits:\n  if c:\n   v = v + m\n  m = m + m\n  if m > MAXCODE:\n   dataappend(v)\n   m, v = start\n return data\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \ndef _optimize_unicode(charset, fixup):\n try:\n  import array\n except ImportError:\n  return charset\n charmap = [0]*65536\n negate = 0\n try:\n  for op, av in charset:\n   if op is NEGATE:\n    negate = 1\n   elif op is LITERAL:\n    charmap[fixup(av)] = 1\n   elif op is RANGE:\n    for i in range(fixup(av[0]), fixup(av[1])+1):\n     charmap[i] = 1\n   elif op is CATEGORY:\n   \n    return charset \n except IndexError:\n \n  return charset\n if negate:\n  if sys.maxunicode != 65535:\n  \n  \n  \n   return charset\n  for i in range(65536):\n   charmap[i] = not charmap[i]\n comps = {}\n mapping = [0]*256\n block = 0\n data = []\n for i in range(256):\n  chunk = tuple(charmap[i*256:(i+1)*256])\n  new = comps.setdefault(chunk, block)\n  mapping[i] = new\n  if new == block:\n   block = block + 1\n   data = data + _mk_bitmap(chunk)\n header = [block]\n if _sre.CODESIZE == 2:\n  code = 'H'\n else:\n  code = 'I'\n  \n mapping = array.array('b', mapping).tobytes()\n \n mapping = array.array(code, mapping)\n assert mapping.itemsize == _sre.CODESIZE\n assert len(mapping) * mapping.itemsize == 256\n header = header + mapping.tolist()\n data[0:0] = header\n return [(BIGCHARSET, data)]\n \ndef _simple(av):\n\n lo, hi = av[2].getwidth()\n if lo == 0 and hi == MAXREPEAT:\n  raise error(\"nothing to repeat\")\n return lo == hi == 1 and av[2][0][0] != SUBPATTERN\n \ndef _compile_info(code, pattern, flags):\n\n\n\n lo, hi = pattern.getwidth()\n \n if lo == 0:\n  return \n  \n prefix = []\n prefixappend = prefix.append\n prefix_skip = 0\n charset = [] \n charsetappend = charset.append\n if not (flags & SRE_FLAG_IGNORECASE):\n \n  for op, av in pattern.data:\n  \n   if op is LITERAL:\n    if len(prefix) == prefix_skip:\n     prefix_skip = prefix_skip + 1\n    prefixappend(av)\n   elif op is SUBPATTERN and len(av[1]) == 1:\n    op, av = av[1][0]\n    if op is LITERAL:\n     prefixappend(av)\n    else:\n     break\n   else:\n    break\n    \n  if not prefix and pattern.data:\n   op, av = pattern.data[0]\n   if op is SUBPATTERN and av[1]:\n    op, av = av[1][0]\n    if op is LITERAL:\n     charsetappend((op, av))\n    elif op is BRANCH:\n     c = []\n     cappend = c.append\n     for p in av[1]:\n      if not p:\n       break\n      op, av = p[0]\n      if op is LITERAL:\n       cappend((op, av))\n      else:\n       break\n     else:\n      charset = c\n   elif op is BRANCH:\n    c = []\n    cappend = c.append\n    for p in av[1]:\n     if not p:\n      break\n     op, av = p[0]\n     if op is LITERAL:\n      cappend((op, av))\n     else:\n      break\n    else:\n     charset = c\n   elif op is IN:\n    charset = av\n    \n    \n    \n    \n    \n    \n    \n emit = code.append\n emit(OPCODES[INFO])\n skip = len(code); emit(0)\n \n mask = 0\n if prefix:\n  mask = SRE_INFO_PREFIX\n  if len(prefix) == prefix_skip == len(pattern.data):\n   mask = mask + SRE_INFO_LITERAL\n elif charset:\n  mask = mask + SRE_INFO_CHARSET\n emit(mask)\n \n if lo < MAXCODE:\n  emit(lo)\n else:\n  emit(MAXCODE)\n  prefix = prefix[:MAXCODE]\n if hi < MAXCODE:\n  emit(hi)\n else:\n  emit(0)\n  \n  \n if prefix:\n  emit(len(prefix)) \n  emit(prefix_skip) \n  code.extend(prefix)\n  \n  table = [-1] + ([0]*len(prefix))\n  for i in range(len(prefix)):\n   table[i+1] = table[i]+1\n   while table[i+1] > 0 and prefix[i] != prefix[table[i+1]-1]:\n    table[i+1] = table[table[i+1]-1]+1\n  code.extend(table[1:]) \n elif charset:\n  _compile_charset(charset, flags, code)\n code[skip] = len(code) - skip\n \ndef isstring(obj):\n return isinstance(obj, (str, bytes))\n \ndef _code(p, flags):\n\n flags = p.pattern.flags | flags\n code = []\n \n \n _compile_info(code, p, flags)\n \n \n _compile(code, p.data, flags)\n \n code.append(OPCODES[SUCCESS])\n \n return code\n \ndef compile(p, flags=0):\n\n\n\n if isstring(p):\n  pattern = p\n  p = sre_parse.parse(p, flags)\n else:\n  pattern = None\n  \n  \n code = _code(p, flags)\n \n \n \n \n \n if p.pattern.groups > 100:\n  raise AssertionError(\n  \"sorry, but this version only supports 100 named groups\"\n  )\n  \n  \n groupindex = p.pattern.groupdict\n indexgroup = [None] * p.pattern.groups\n for k, i in groupindex.items():\n  indexgroup[i] = k\n  \n return _sre.compile(\n pattern, flags | p.pattern.flags, code,\n p.pattern.groups-1,\n groupindex, indexgroup\n )\n"], "xml.sax": [".py", "\"\"\n\nfrom .xmlreader import InputSource\nfrom .handler import ContentHandler, ErrorHandler\nfrom ._exceptions import SAXException, SAXNotRecognizedException, SAXParseException, SAXNotSupportedException, SAXReaderNotAvailable\n\n\ndef parse(source, handler, errorHandler=ErrorHandler()):\n parser = make_parser()\n parser.setContentHandler(handler)\n parser.setErrorHandler(errorHandler)\n parser.parse(source)\n \ndef parseString(string, handler, errorHandler=ErrorHandler()):\n from io import BytesIO\n \n if errorHandler is None:\n  errorHandler = ErrorHandler()\n parser = make_parser()\n parser.setContentHandler(handler)\n parser.setErrorHandler(errorHandler)\n \n inpsrc = InputSource()\n inpsrc.setByteStream(BytesIO(string))\n parser.parse(inpsrc)\n \n \n \n \ndefault_parser_list = [\"xml.sax.expatreader\"]\n\n\n_false = 0\nif _false:\n import xml.sax.expatreader\n \nimport os, sys\n\n\ndel os\n\n_key = \"python.xml.sax.parser\"\nif sys.platform[:4] == \"java\" and sys.registry.containsKey(_key):\n default_parser_list = sys.registry.getProperty(_key).split(\",\")\n \n \ndef make_parser(parser_list = []):\n \"\"\n \n for parser_name in parser_list + default_parser_list:\n  try:\n   return _create_parser(parser_name)\n  except ImportError as e:\n   import sys\n   if parser_name in sys.modules:\n   \n   \n    raise\n  except SAXReaderNotAvailable:\n  \n  \n   pass\n   \n raise SAXReaderNotAvailable(\"No parsers found\", None)\n \n \n \nif sys.platform[ : 4] == \"java\":\n def _create_parser(parser_name):\n  from org.python.core import imp\n  drv_module = imp.importName(parser_name, 0, globals())\n  return drv_module.create_parser()\n  \nelse:\n def _create_parser(parser_name):\n  drv_module = __import__(parser_name,{},{},['create_parser'])\n  return drv_module.create_parser()\n  \ndel sys\n", 1], "_random": [".py", "from browser import window\n\ndef _randint(a, b):\n return int(window.Math.random()*(b-a+1)+a)\n \ndef _urandom(n):\n \"\"\n randbytes= [_randint(0,255) for i in range(n)]\n return bytes(randbytes)\n \nclass Random:\n \"\"\n \n \n \n \n \n \n VERSION = 3 \n \n def __init__(self, x=None):\n  \"\"\n  \n  self._state=x\n  \n def seed(self, a=None, version=2):\n  \"\"\n  \n  self._state=a\n  self.gauss_next = None\n  \n def getstate(self):\n  \"\"\n  return self._state\n  \n def setstate(self, state):\n  \"\"\n  self._state=state\n  \n def random(self):\n  \"\"\n  return window.Math.random()\n  \n def getrandbits(self, k):\n  \"\"\n  if k <= 0:\n   raise ValueError('number of bits must be greater than zero')\n  if k != int(k):\n   raise TypeError('number of bits should be an integer')\n  numbytes = (k + 7) // 8 \n  x = int.from_bytes(_urandom(numbytes), 'big')\n  return x >> (numbytes * 8 - k) \n"], "browser.timer": [".py", "from browser import window\n\ndef wrap(func):\n\n\n def f(*args, **kw):\n  try:\n   return func(*args, **kw)\n  except Exception as exc:\n   sys.stderr.write(exc)\n return f\n \nclear_interval = window.clearInterval\n\nclear_timeout = window.clearTimeout\n\ndef set_interval(func,interval):\n return window.setInterval(wrap(func),interval)\n \ndef set_timeout(func,interval):\n return int(window.setTimeout(wrap(func),interval))\n \ndef request_animation_frame(func):\n return int(window.requestAnimationFrame(func))\n \ndef cancel_animation_frame(int_id):\n window.cancelAnimationFrame(int_id)\n"], "site": [".py", "import sys\n"], "site-packages.pygame.transform": [".py", "def flip(image, x, y):\n return image\n"], "contextlib": [".py", "\"\"\n\nimport sys\nfrom collections import deque\nfrom functools import wraps\n\n__all__ = [\"contextmanager\", \"closing\", \"ContextDecorator\", \"ExitStack\"]\n\n\nclass ContextDecorator(object):\n \"\"\n \n def _recreate_cm(self):\n  \"\"\n  return self\n  \n def __call__(self, func):\n  @wraps(func)\n  def inner(*args, **kwds):\n   with self._recreate_cm():\n    return func(*args, **kwds)\n  return inner\n  \n  \nclass _GeneratorContextManager(ContextDecorator):\n \"\"\n \n def __init__(self, func, *args, **kwds):\n  self.gen = func(*args, **kwds)\n  self.func, self.args, self.kwds = func, args, kwds\n  \n def _recreate_cm(self):\n \n \n \n  return self.__class__(self.func, *self.args, **self.kwds)\n  \n def __enter__(self):\n  try:\n   return next(self.gen)\n  except StopIteration:\n   raise RuntimeError(\"generator didn't yield\")\n   \n def __exit__(self, type, value, traceback):\n  if type is None:\n   try:\n    next(self.gen)\n   except StopIteration:\n    return\n   else:\n    raise RuntimeError(\"generator didn't stop\")\n  else:\n   if value is None:\n   \n   \n    value = type()\n   try:\n    self.gen.throw(type, value, traceback)\n    raise RuntimeError(\"generator didn't stop after throw()\")\n   except StopIteration as exc:\n   \n   \n   \n    return exc is not value\n   except:\n   \n   \n   \n   \n   \n   \n   \n    if sys.exc_info()[1] is not value:\n     raise\n     \n     \ndef contextmanager(func):\n \"\"\n @wraps(func)\n def helper(*args, **kwds):\n  return _GeneratorContextManager(func, *args, **kwds)\n return helper\n \n \nclass closing(object):\n \"\"\n def __init__(self, thing):\n  self.thing = thing\n def __enter__(self):\n  return self.thing\n def __exit__(self, *exc_info):\n  self.thing.close()\n  \n  \n  \nclass ExitStack(object):\n \"\"\n def __init__(self):\n  self._exit_callbacks = deque()\n  \n def pop_all(self):\n  \"\"\n  new_stack = type(self)()\n  new_stack._exit_callbacks = self._exit_callbacks\n  self._exit_callbacks = deque()\n  return new_stack\n  \n def _push_cm_exit(self, cm, cm_exit):\n  \"\"\n  def _exit_wrapper(*exc_details):\n   return cm_exit(cm, *exc_details)\n  _exit_wrapper.__self__ = cm\n  self.push(_exit_wrapper)\n  \n def push(self, exit):\n  \"\"\n  \n  \n  _cb_type = type(exit)\n  try:\n   exit_method = _cb_type.__exit__\n  except AttributeError:\n  \n   self._exit_callbacks.append(exit)\n  else:\n   self._push_cm_exit(exit, exit_method)\n  return exit \n  \n def callback(self, callback, *args, **kwds):\n  \"\"\n  def _exit_wrapper(exc_type, exc, tb):\n   callback(*args, **kwds)\n   \n   \n  _exit_wrapper.__wrapped__ = callback\n  self.push(_exit_wrapper)\n  return callback \n  \n def enter_context(self, cm):\n  \"\"\n  \n  _cm_type = type(cm)\n  _exit = _cm_type.__exit__\n  result = _cm_type.__enter__(cm)\n  self._push_cm_exit(cm, _exit)\n  return result\n  \n def close(self):\n  \"\"\n  self.__exit__(None, None, None)\n  \n def __enter__(self):\n  return self\n  \n def __exit__(self, *exc_details):\n  received_exc = exc_details[0] is not None\n  \n  \n  \n  frame_exc = sys.exc_info()[1]\n  def _fix_exception_context(new_exc, old_exc):\n   while 1:\n    exc_context = new_exc.__context__\n    if exc_context in (None, frame_exc):\n     break\n    new_exc = exc_context\n   new_exc.__context__ = old_exc\n   \n   \n   \n  suppressed_exc = False\n  pending_raise = False\n  while self._exit_callbacks:\n   cb = self._exit_callbacks.pop()\n   try:\n    if cb(*exc_details):\n     suppressed_exc = True\n     pending_raise = False\n     exc_details = (None, None, None)\n   except:\n    new_exc_details = sys.exc_info()\n    \n    _fix_exception_context(new_exc_details[1], exc_details[1])\n    pending_raise = True\n    exc_details = new_exc_details\n  if pending_raise:\n   try:\n   \n   \n    fixed_ctx = exc_details[1].__context__\n    raise exc_details[1]\n   except BaseException:\n    exc_details[1].__context__ = fixed_ctx\n    raise\n  return received_exc and suppressed_exc\n"], "numbers": [".py", "\n\n\n\"\"\n\nfrom abc import ABCMeta, abstractmethod\n\n__all__ = [\"Number\", \"Complex\", \"Real\", \"Rational\", \"Integral\"]\n\nclass Number(metaclass=ABCMeta):\n \"\"\n __slots__ = ()\n \n \n __hash__ = None\n \n \n \n \n \n \n \n \n \n \nclass Complex(Number):\n \"\"\n \n __slots__ = ()\n \n @abstractmethod\n def __complex__(self):\n  \"\"\n  \n def __bool__(self):\n  \"\"\n  return self != 0\n  \n @property\n @abstractmethod\n def real(self):\n  \"\"\n  raise NotImplementedError\n  \n @property\n @abstractmethod\n def imag(self):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __add__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __radd__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __neg__(self):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __pos__(self):\n  \"\"\n  raise NotImplementedError\n  \n def __sub__(self, other):\n  \"\"\n  return self + -other\n  \n def __rsub__(self, other):\n  \"\"\n  return -self + other\n  \n @abstractmethod\n def __mul__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __rmul__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __truediv__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __rtruediv__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __pow__(self, exponent):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __rpow__(self, base):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __abs__(self):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def conjugate(self):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __eq__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n def __ne__(self, other):\n  \"\"\n  \n  return not (self == other)\n  \nComplex.register(complex)\n\n\nclass Real(Complex):\n \"\"\n \n __slots__ = ()\n \n @abstractmethod\n def __float__(self):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __trunc__(self):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __floor__(self):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __ceil__(self):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __round__(self, ndigits=None):\n  \"\"\n  raise NotImplementedError\n  \n def __divmod__(self, other):\n  \"\"\n  return (self // other, self % other)\n  \n def __rdivmod__(self, other):\n  \"\"\n  return (other // self, other % self)\n  \n @abstractmethod\n def __floordiv__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __rfloordiv__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __mod__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __rmod__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __lt__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __le__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n  \n def __complex__(self):\n  \"\"\n  return complex(float(self))\n  \n @property\n def real(self):\n  \"\"\n  return +self\n  \n @property\n def imag(self):\n  \"\"\n  return 0\n  \n def conjugate(self):\n  \"\"\n  return +self\n  \nReal.register(float)\n\n\nclass Rational(Real):\n \"\"\n \n __slots__ = ()\n \n @property\n @abstractmethod\n def numerator(self):\n  raise NotImplementedError\n  \n @property\n @abstractmethod\n def denominator(self):\n  raise NotImplementedError\n  \n  \n def __float__(self):\n  \"\"\n  return self.numerator / self.denominator\n  \n  \nclass Integral(Rational):\n \"\"\n \n __slots__ = ()\n \n @abstractmethod\n def __int__(self):\n  \"\"\n  raise NotImplementedError\n  \n def __index__(self):\n  \"\"\n  return int(self)\n  \n @abstractmethod\n def __pow__(self, exponent, modulus=None):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __lshift__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __rlshift__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __rshift__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __rrshift__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __and__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __rand__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __xor__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __rxor__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __or__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __ror__(self, other):\n  \"\"\n  raise NotImplementedError\n  \n @abstractmethod\n def __invert__(self):\n  \"\"\n  raise NotImplementedError\n  \n  \n def __float__(self):\n  \"\"\n  return float(int(self))\n  \n @property\n def numerator(self):\n  \"\"\n  return +self\n  \n @property\n def denominator(self):\n  \"\"\n  return 1\n  \nIntegral.register(int)\n"], "io": [".py", "import builtins\n\nopen = builtins.open\n\n\nSEEK_SET = 0\nSEEK_CUR = 1\nSEEK_END = 2\n\n\"\"\ntry:\n from errno import EINVAL\nexcept ImportError:\n EINVAL = 22\n \n__all__ = [\"StringIO\"]\n\ndef _complain_ifclosed(closed):\n if closed:\n  raise ValueError(\"I/O operation on closed file\")\n  \nclass StringIO:\n \"\"\n def __init__(self, buf = ''):\n  self.buf = buf\n  self.len = len(buf)\n  self.buflist = []\n  self.pos = 0\n  self.closed = False\n  self.softspace = 0\n  \n def __iter__(self):\n  return self\n  \n def next(self):\n  \"\"\n  _complain_ifclosed(self.closed)\n  r = self.readline()\n  if not r:\n   raise StopIteration\n  return r\n  \n def close(self):\n  \"\"\n  if not self.closed:\n   self.closed = True\n   del self.buf, self.pos\n   \n def isatty(self):\n  \"\"\n  _complain_ifclosed(self.closed)\n  return False\n  \n def seek(self, pos, mode = 0):\n  \"\"\n  _complain_ifclosed(self.closed)\n  if self.buflist:\n   self.buf += ''.join(self.buflist)\n   self.buflist = []\n  if mode == 1:\n   pos += self.pos\n  elif mode == 2:\n   pos += self.len\n  self.pos = max(0, pos)\n  \n def tell(self):\n  \"\"\n  _complain_ifclosed(self.closed)\n  return self.pos\n  \n def read(self, n = -1):\n  \"\"\n  _complain_ifclosed(self.closed)\n  if self.buflist:\n   self.buf += ''.join(self.buflist)\n   self.buflist = []\n  if n is None or n < 0:\n   newpos = self.len\n  else:\n   newpos = min(self.pos+n, self.len)\n  r = self.buf[self.pos:newpos]\n  self.pos = newpos\n  return r\n  \n def readline(self, length=None):\n  \"\"\n  _complain_ifclosed(self.closed)\n  if self.buflist:\n   self.buf += ''.join(self.buflist)\n   self.buflist = []\n  i = self.buf.find('\\n', self.pos)\n  if i < 0:\n   newpos = self.len\n  else:\n   newpos = i+1\n  if length is not None and length >= 0:\n   if self.pos + length < newpos:\n    newpos = self.pos + length\n  r = self.buf[self.pos:newpos]\n  self.pos = newpos\n  return r\n  \n def readlines(self, sizehint = 0):\n  \"\"\n  total = 0\n  lines = []\n  line = self.readline()\n  while line:\n   lines.append(line)\n   total += len(line)\n   if 0 < sizehint <= total:\n    break\n   line = self.readline()\n  return lines\n  \n def truncate(self, size=None):\n  \"\"\n  _complain_ifclosed(self.closed)\n  if size is None:\n   size = self.pos\n  elif size < 0:\n   raise IOError(EINVAL, \"Negative size not allowed\")\n  elif size < self.pos:\n   self.pos = size\n  self.buf = self.getvalue()[:size]\n  self.len = size\n  \n def write(self, s):\n  \"\"\n  _complain_ifclosed(self.closed)\n  if not s: return\n  spos = self.pos\n  slen = self.len\n  if spos == slen:\n   self.buflist.append(s)\n   self.len = self.pos = spos + len(s)\n   return\n  if spos > slen:\n   self.buflist.append('\\0'*(spos - slen))\n   slen = spos\n  newpos = spos + len(s)\n  if spos < slen:\n   if self.buflist:\n    self.buf += ''.join(self.buflist)\n   self.buflist = [self.buf[:spos], s, self.buf[newpos:]]\n   self.buf = ''\n   if newpos > slen:\n    slen = newpos\n  else:\n   self.buflist.append(s)\n   slen = newpos\n  self.len = slen\n  self.pos = newpos\n  \n def writelines(self, iterable):\n  \"\"\n  write = self.write\n  for line in iterable:\n   write(line)\n   \n def flush(self):\n  \"\"\n  _complain_ifclosed(self.closed)\n  \n def getvalue(self):\n  \"\"\n  _complain_ifclosed(self.closed)\n  if self.buflist:\n   self.buf += ''.join(self.buflist)\n   self.buflist = []\n  return self.buf\n  \n  \nTextIOWrapper = StringIO\n\nclass RawIOBase:\n\n def read(self,n=-1):\n  pass\n def readall(self):\n  pass\n def readinto(self,b):\n  pass\n def write(self,b):\n  pass\n  \nBufferedReader = RawIOBase\n\n\n"], "copyreg": [".py", "\"\"\n\n__all__ = [\"pickle\", \"constructor\",\n\"add_extension\", \"remove_extension\", \"clear_extension_cache\"]\n\ndispatch_table = {}\n\ndef pickle(ob_type, pickle_function, constructor_ob=None):\n if not callable(pickle_function):\n  raise TypeError(\"reduction functions must be callable\")\n dispatch_table[ob_type] = pickle_function\n \n \n \n if constructor_ob is not None:\n  constructor(constructor_ob)\n  \ndef constructor(object):\n if not callable(object):\n  raise TypeError(\"constructors must be callable\")\n  \n  \n  \ntry:\n complex\nexcept NameError:\n pass\nelse:\n\n def pickle_complex(c):\n  return complex, (c.real, c.imag)\n  \n pickle(complex, pickle_complex, complex)\n \n \n \ndef _reconstructor(cls, base, state):\n if base is object:\n  obj = object.__new__(cls)\n else:\n  obj = base.__new__(cls, state)\n  if base.__init__ != object.__init__:\n   base.__init__(obj, state)\n return obj\n \n_HEAPTYPE = 1<<9\n\n\n\ndef _reduce_ex(self, proto):\n assert proto < 2\n for base in self.__class__.__mro__:\n  if hasattr(base, '__flags__') and not base.__flags__ & _HEAPTYPE:\n   break\n else:\n  base = object \n if base is object:\n  state = None\n else:\n  if base is self.__class__:\n   raise TypeError(\"can't pickle %s objects\" % base.__name__)\n  state = base(self)\n args = (self.__class__, base, state)\n try:\n  getstate = self.__getstate__\n except AttributeError:\n  if getattr(self, \"__slots__\", None):\n   raise TypeError(\"a class that defines __slots__ without \"\n   \"defining __getstate__ cannot be pickled\")\n  try:\n   dict = self.__dict__\n  except AttributeError:\n   dict = None\n else:\n  dict = getstate()\n if dict:\n  return _reconstructor, args, dict\n else:\n  return _reconstructor, args\n  \n  \n  \ndef __newobj__(cls, *args):\n return cls.__new__(cls, *args)\n \ndef _slotnames(cls):\n \"\"\n \n \n names = cls.__dict__.get(\"__slotnames__\")\n if names is not None:\n  return names\n  \n  \n names = []\n if not hasattr(cls, \"__slots__\"):\n \n  pass\n else:\n \n  for c in cls.__mro__:\n   if \"__slots__\" in c.__dict__:\n    slots = c.__dict__['__slots__']\n    \n    if isinstance(slots, str):\n     slots = (slots,)\n    for name in slots:\n    \n     if name in (\"__dict__\", \"__weakref__\"):\n      continue\n      \n     elif name.startswith('__') and not name.endswith('__'):\n      names.append('_%s%s' % (c.__name__, name))\n     else:\n      names.append(name)\n      \n      \n try:\n  cls.__slotnames__ = names\n except:\n  pass \n  \n return names\n \n \n \n \n \n \n \n \n \n \n_extension_registry = {} \n_inverted_registry = {} \n_extension_cache = {} \n\n\n\ndef add_extension(module, name, code):\n \"\"\n code = int(code)\n if not 1 <= code <= 0x7fffffff:\n  raise ValueError(\"code out of range\")\n key = (module, name)\n if (_extension_registry.get(key) == code and\n _inverted_registry.get(code) == key):\n  return \n if key in _extension_registry:\n  raise ValueError(\"key %s is already registered with code %s\" %\n  (key, _extension_registry[key]))\n if code in _inverted_registry:\n  raise ValueError(\"code %s is already in use for key %s\" %\n  (code, _inverted_registry[code]))\n _extension_registry[key] = code\n _inverted_registry[code] = key\n \ndef remove_extension(module, name, code):\n \"\"\n key = (module, name)\n if (_extension_registry.get(key) != code or\n _inverted_registry.get(code) != key):\n  raise ValueError(\"key %s is not registered with code %s\" %\n  (key, code))\n del _extension_registry[key]\n del _inverted_registry[code]\n if code in _extension_cache:\n  del _extension_cache[code]\n  \ndef clear_extension_cache():\n _extension_cache.clear()\n \n \n \n \n \n \n \n \n \n \n \n \n \n"], "jqueryui": [".py", "\"\"\nfrom browser import html, document, window\nimport javascript\n\n_path = __file__[:__file__.rfind('/')]+'/'\n\ndocument <= html.LINK(rel=\"stylesheet\",\nhref=_path+'css/smoothness/jquery-ui.css')\n\n\n\n\n\n\n\n\n\n\n\n\njavascript.load(_path+'jquery-1.11.2.js', ['jQuery'])\njavascript.load(_path+'jquery-ui.js')\n\n_jqui = window.jQuery.noConflict(True)\n\n_events = ['abort',\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\",\n\"\"]\n\nclass JQFunction:\n\n def __init__(self, func):\n  self.func = func\n  \n def __call__(self, *args, **kw):\n  if kw:\n  \n   return self.func(*args, kw)\n  else:\n   return self.func(*args)\n   \nclass Element:\n \"\"\n \n def __init__(self, item):\n  self.item = item\n  \n def bind(self, event, callback):\n  \"\"\n  getattr(self.item, event)(callback)\n  \n def __getattr__(self, attr):\n  res = getattr(self.item, attr)\n  if attr in _events:\n  \n   return lambda f:self.bind(attr, f)\n  if callable(res):\n   res = JQFunction(res)\n  return res\n  \nclass jq:\n\n @staticmethod\n def get(**selectors):\n  items = []\n  for k,v in selectors.items():\n   if k=='selector':\n    if isinstance(v,[list, tuple]):\n     values = v\n    else:\n     values = [v]\n    for value in values:\n     items.append(Element(_jqui(value)))\n   elif k=='element':\n    items = Element(_jqui(v))\n  return items\n  \n @staticmethod\n def __getitem__(element_id):\n  return jq.get(selector='#'+element_id)[0]\n", 1], "xml.parsers.expat": [".py", "\"\"\nimport sys\n\nfrom pyexpat import *\n\n\nsys.modules['xml.parsers.expat.model'] = model\nsys.modules['xml.parsers.expat.errors'] = errors\n"], "shutil": [".py", "\"\"\n\nimport os\nimport sys\nimport stat\nfrom os.path import abspath\nimport fnmatch\nimport collections\nimport errno\nimport tarfile\n\ntry:\n import bz2\n del bz2\n _BZ2_SUPPORTED = True\nexcept ImportError:\n _BZ2_SUPPORTED = False\n \ntry:\n from pwd import getpwnam\nexcept ImportError:\n getpwnam = None\n \ntry:\n from grp import getgrnam\nexcept ImportError:\n getgrnam = None\n \n__all__ = [\"copyfileobj\", \"copyfile\", \"copymode\", \"copystat\", \"copy\", \"copy2\",\n\"copytree\", \"move\", \"rmtree\", \"Error\", \"SpecialFileError\",\n\"ExecError\", \"make_archive\", \"get_archive_formats\",\n\"register_archive_format\", \"unregister_archive_format\",\n\"get_unpack_formats\", \"register_unpack_format\",\n\"unregister_unpack_format\", \"unpack_archive\",\n\"ignore_patterns\", \"chown\", \"which\"]\n\n\nclass Error(EnvironmentError):\n pass\n \nclass SpecialFileError(EnvironmentError):\n \"\"\n \nclass ExecError(EnvironmentError):\n \"\"\n \nclass ReadError(EnvironmentError):\n \"\"\n \nclass RegistryError(Exception):\n \"\"\n \n \ntry:\n WindowsError\nexcept NameError:\n WindowsError = None\n \ndef copyfileobj(fsrc, fdst, length=16*1024):\n \"\"\n while 1:\n  buf = fsrc.read(length)\n  if not buf:\n   break\n  fdst.write(buf)\n  \ndef _samefile(src, dst):\n\n if hasattr(os.path, 'samefile'):\n  try:\n   return os.path.samefile(src, dst)\n  except OSError:\n   return False\n   \n   \n return (os.path.normcase(os.path.abspath(src)) ==\n os.path.normcase(os.path.abspath(dst)))\n \ndef copyfile(src, dst, *, follow_symlinks=True):\n \"\"\n if _samefile(src, dst):\n  raise Error(\"`%s` and `%s` are the same file\" % (src, dst))\n  \n for fn in [src, dst]:\n  try:\n   st = os.stat(fn)\n  except OSError:\n  \n   pass\n  else:\n  \n   if stat.S_ISFIFO(st.st_mode):\n    raise SpecialFileError(\"`%s` is a named pipe\" % fn)\n    \n if not follow_symlinks and os.path.islink(src):\n  os.symlink(os.readlink(src), dst)\n else:\n  with open(src, 'rb') as fsrc:\n   with open(dst, 'wb') as fdst:\n    copyfileobj(fsrc, fdst)\n return dst\n \ndef copymode(src, dst, *, follow_symlinks=True):\n \"\"\n if not follow_symlinks and os.path.islink(src) and os.path.islink(dst):\n  if hasattr(os, 'lchmod'):\n   stat_func, chmod_func = os.lstat, os.lchmod\n  else:\n   return\n elif hasattr(os, 'chmod'):\n  stat_func, chmod_func = os.stat, os.chmod\n else:\n  return\n  \n st = stat_func(src)\n chmod_func(dst, stat.S_IMODE(st.st_mode))\n \nif hasattr(os, 'listxattr'):\n def _copyxattr(src, dst, *, follow_symlinks=True):\n  \"\"\n  \n  try:\n   names = os.listxattr(src, follow_symlinks=follow_symlinks)\n  except OSError as e:\n   if e.errno not in (errno.ENOTSUP, errno.ENODATA):\n    raise\n   return\n  for name in names:\n   try:\n    value = os.getxattr(src, name, follow_symlinks=follow_symlinks)\n    os.setxattr(dst, name, value, follow_symlinks=follow_symlinks)\n   except OSError as e:\n    if e.errno not in (errno.EPERM, errno.ENOTSUP, errno.ENODATA):\n     raise\nelse:\n def _copyxattr(*args, **kwargs):\n  pass\n  \ndef copystat(src, dst, *, follow_symlinks=True):\n \"\"\n def _nop(*args, ns=None, follow_symlinks=None):\n  pass\n  \n  \n follow = follow_symlinks or not (os.path.islink(src) and os.path.islink(dst))\n if follow:\n \n  def lookup(name):\n   return getattr(os, name, _nop)\n else:\n \n \n  def lookup(name):\n   fn = getattr(os, name, _nop)\n   if fn in os.supports_follow_symlinks:\n    return fn\n   return _nop\n   \n st = lookup(\"stat\")(src, follow_symlinks=follow)\n mode = stat.S_IMODE(st.st_mode)\n lookup(\"utime\")(dst, ns=(st.st_atime_ns, st.st_mtime_ns),\n follow_symlinks=follow)\n try:\n  lookup(\"chmod\")(dst, mode, follow_symlinks=follow)\n except NotImplementedError:\n \n \n \n \n \n \n \n \n \n \n  pass\n if hasattr(st, 'st_flags'):\n  try:\n   lookup(\"chflags\")(dst, st.st_flags, follow_symlinks=follow)\n  except OSError as why:\n   for err in 'EOPNOTSUPP', 'ENOTSUP':\n    if hasattr(errno, err) and why.errno == getattr(errno, err):\n     break\n   else:\n    raise\n _copyxattr(src, dst, follow_symlinks=follow)\n \ndef copy(src, dst, *, follow_symlinks=True):\n \"\"\n if os.path.isdir(dst):\n  dst = os.path.join(dst, os.path.basename(src))\n copyfile(src, dst, follow_symlinks=follow_symlinks)\n copymode(src, dst, follow_symlinks=follow_symlinks)\n return dst\n \ndef copy2(src, dst, *, follow_symlinks=True):\n \"\"\n if os.path.isdir(dst):\n  dst = os.path.join(dst, os.path.basename(src))\n copyfile(src, dst, follow_symlinks=follow_symlinks)\n copystat(src, dst, follow_symlinks=follow_symlinks)\n return dst\n \ndef ignore_patterns(*patterns):\n \"\"\n def _ignore_patterns(path, names):\n  ignored_names = []\n  for pattern in patterns:\n   ignored_names.extend(fnmatch.filter(names, pattern))\n  return set(ignored_names)\n return _ignore_patterns\n \ndef copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,\nignore_dangling_symlinks=False):\n \"\"\n names = os.listdir(src)\n if ignore is not None:\n  ignored_names = ignore(src, names)\n else:\n  ignored_names = set()\n  \n os.makedirs(dst)\n errors = []\n for name in names:\n  if name in ignored_names:\n   continue\n  srcname = os.path.join(src, name)\n  dstname = os.path.join(dst, name)\n  try:\n   if os.path.islink(srcname):\n    linkto = os.readlink(srcname)\n    if symlinks:\n    \n    \n    \n     os.symlink(linkto, dstname)\n     copystat(srcname, dstname, follow_symlinks=not symlinks)\n    else:\n    \n     if not os.path.exists(linkto) and ignore_dangling_symlinks:\n      continue\n      \n     copy_function(srcname, dstname)\n   elif os.path.isdir(srcname):\n    copytree(srcname, dstname, symlinks, ignore, copy_function)\n   else:\n   \n    copy_function(srcname, dstname)\n    \n    \n  except Error as err:\n   errors.extend(err.args[0])\n  except EnvironmentError as why:\n   errors.append((srcname, dstname, str(why)))\n try:\n  copystat(src, dst)\n except OSError as why:\n  if WindowsError is not None and isinstance(why, WindowsError):\n  \n   pass\n  else:\n   errors.append((src, dst, str(why)))\n if errors:\n  raise Error(errors)\n return dst\n \n \ndef _rmtree_unsafe(path, onerror):\n try:\n  if os.path.islink(path):\n  \n   raise OSError(\"Cannot call rmtree on a symbolic link\")\n except OSError:\n  onerror(os.path.islink, path, sys.exc_info())\n  \n  return\n names = []\n try:\n  names = os.listdir(path)\n except os.error:\n  onerror(os.listdir, path, sys.exc_info())\n for name in names:\n  fullname = os.path.join(path, name)\n  try:\n   mode = os.lstat(fullname).st_mode\n  except os.error:\n   mode = 0\n  if stat.S_ISDIR(mode):\n   _rmtree_unsafe(fullname, onerror)\n  else:\n   try:\n    os.unlink(fullname)\n   except os.error:\n    onerror(os.unlink, fullname, sys.exc_info())\n try:\n  os.rmdir(path)\n except os.error:\n  onerror(os.rmdir, path, sys.exc_info())\n  \n  \ndef _rmtree_safe_fd(topfd, path, onerror):\n names = []\n try:\n  names = os.listdir(topfd)\n except OSError as err:\n  err.filename = path\n  onerror(os.listdir, path, sys.exc_info())\n for name in names:\n  fullname = os.path.join(path, name)\n  try:\n   orig_st = os.stat(name, dir_fd=topfd, follow_symlinks=False)\n   mode = orig_st.st_mode\n  except OSError:\n   mode = 0\n  if stat.S_ISDIR(mode):\n   try:\n    dirfd = os.open(name, os.O_RDONLY, dir_fd=topfd)\n   except OSError:\n    onerror(os.open, fullname, sys.exc_info())\n   else:\n    try:\n     if os.path.samestat(orig_st, os.fstat(dirfd)):\n      _rmtree_safe_fd(dirfd, fullname, onerror)\n      try:\n       os.rmdir(name, dir_fd=topfd)\n      except OSError:\n       onerror(os.rmdir, fullname, sys.exc_info())\n     else:\n      try:\n      \n      \n      \n       raise OSError(\"Cannot call rmtree on a symbolic \"\n       \"link\")\n      except OSError:\n       onerror(os.path.islink, fullname, sys.exc_info())\n    finally:\n     os.close(dirfd)\n  else:\n   try:\n    os.unlink(name, dir_fd=topfd)\n   except OSError:\n    onerror(os.unlink, fullname, sys.exc_info())\n    \n_use_fd_functions = ({os.open, os.stat, os.unlink, os.rmdir} <=\nos.supports_dir_fd and\nos.listdir in os.supports_fd and\nos.stat in os.supports_follow_symlinks)\n\ndef rmtree(path, ignore_errors=False, onerror=None):\n \"\"\n if ignore_errors:\n  def onerror(*args):\n   pass\n elif onerror is None:\n  def onerror(*args):\n   raise\n if _use_fd_functions:\n \n  if isinstance(path, bytes):\n   path = os.fsdecode(path)\n   \n   \n  try:\n   orig_st = os.lstat(path)\n  except Exception:\n   onerror(os.lstat, path, sys.exc_info())\n   return\n  try:\n   fd = os.open(path, os.O_RDONLY)\n  except Exception:\n   onerror(os.lstat, path, sys.exc_info())\n   return\n  try:\n   if os.path.samestat(orig_st, os.fstat(fd)):\n    _rmtree_safe_fd(fd, path, onerror)\n    try:\n     os.rmdir(path)\n    except os.error:\n     onerror(os.rmdir, path, sys.exc_info())\n   else:\n    try:\n    \n     raise OSError(\"Cannot call rmtree on a symbolic link\")\n    except OSError:\n     onerror(os.path.islink, path, sys.exc_info())\n  finally:\n   os.close(fd)\n else:\n  return _rmtree_unsafe(path, onerror)\n  \n  \n  \nrmtree.avoids_symlink_attacks = _use_fd_functions\n\ndef _basename(path):\n\n\n return os.path.basename(path.rstrip(os.path.sep))\n \ndef move(src, dst):\n \"\"\n real_dst = dst\n if os.path.isdir(dst):\n  if _samefile(src, dst):\n  \n  \n   os.rename(src, dst)\n   return\n   \n  real_dst = os.path.join(dst, _basename(src))\n  if os.path.exists(real_dst):\n   raise Error(\"Destination path '%s' already exists\" % real_dst)\n try:\n  os.rename(src, real_dst)\n except OSError:\n  if os.path.islink(src):\n   linkto = os.readlink(src)\n   os.symlink(linkto, real_dst)\n   os.unlink(src)\n  elif os.path.isdir(src):\n   if _destinsrc(src, dst):\n    raise Error(\"Cannot move a directory '%s' into itself '%s'.\" % (src, dst))\n   copytree(src, real_dst, symlinks=True)\n   rmtree(src)\n  else:\n   copy2(src, real_dst)\n   os.unlink(src)\n return real_dst\n \ndef _destinsrc(src, dst):\n src = abspath(src)\n dst = abspath(dst)\n if not src.endswith(os.path.sep):\n  src += os.path.sep\n if not dst.endswith(os.path.sep):\n  dst += os.path.sep\n return dst.startswith(src)\n \ndef _get_gid(name):\n \"\"\n if getgrnam is None or name is None:\n  return None\n try:\n  result = getgrnam(name)\n except KeyError:\n  result = None\n if result is not None:\n  return result[2]\n return None\n \ndef _get_uid(name):\n \"\"\n if getpwnam is None or name is None:\n  return None\n try:\n  result = getpwnam(name)\n except KeyError:\n  result = None\n if result is not None:\n  return result[2]\n return None\n \ndef _make_tarball(base_name, base_dir, compress=\"gzip\", verbose=0, dry_run=0,\nowner=None, group=None, logger=None):\n \"\"\n tar_compression = {'gzip': 'gz', None: ''}\n compress_ext = {'gzip': '.gz'}\n \n if _BZ2_SUPPORTED:\n  tar_compression['bzip2'] = 'bz2'\n  compress_ext['bzip2'] = '.bz2'\n  \n  \n if compress is not None and compress not in compress_ext:\n  raise ValueError(\"bad value for 'compress', or compression format not \"\n  \"supported : {0}\".format(compress))\n  \n archive_name = base_name + '.tar' + compress_ext.get(compress, '')\n archive_dir = os.path.dirname(archive_name)\n \n if not os.path.exists(archive_dir):\n  if logger is not None:\n   logger.info(\"creating %s\", archive_dir)\n  if not dry_run:\n   os.makedirs(archive_dir)\n   \n   \n if logger is not None:\n  logger.info('Creating tar archive')\n  \n uid = _get_uid(owner)\n gid = _get_gid(group)\n \n def _set_uid_gid(tarinfo):\n  if gid is not None:\n   tarinfo.gid = gid\n   tarinfo.gname = group\n  if uid is not None:\n   tarinfo.uid = uid\n   tarinfo.uname = owner\n  return tarinfo\n  \n if not dry_run:\n  tar = tarfile.open(archive_name, 'w|%s' % tar_compression[compress])\n  try:\n   tar.add(base_dir, filter=_set_uid_gid)\n  finally:\n   tar.close()\n   \n return archive_name\n \ndef _call_external_zip(base_dir, zip_filename, verbose=False, dry_run=False):\n\n if verbose:\n  zipoptions = \"-r\"\n else:\n  zipoptions = \"-rq\"\n from distutils.errors import DistutilsExecError\n from distutils.spawn import spawn\n try:\n  spawn([\"zip\", zipoptions, zip_filename, base_dir], dry_run=dry_run)\n except DistutilsExecError:\n \n \n  raise ExecError(\"unable to create zip file '%s': \"\n  \"could neither import the 'zipfile' module nor \"\n  \"find a standalone zip utility\") % zip_filename\n  \ndef _make_zipfile(base_name, base_dir, verbose=0, dry_run=0, logger=None):\n \"\"\n zip_filename = base_name + \".zip\"\n archive_dir = os.path.dirname(base_name)\n \n if not os.path.exists(archive_dir):\n  if logger is not None:\n   logger.info(\"creating %s\", archive_dir)\n  if not dry_run:\n   os.makedirs(archive_dir)\n   \n   \n   \n try:\n  import zipfile\n except ImportError:\n  zipfile = None\n  \n if zipfile is None:\n  _call_external_zip(base_dir, zip_filename, verbose, dry_run)\n else:\n  if logger is not None:\n   logger.info(\"creating '%s' and adding '%s' to it\",\n   zip_filename, base_dir)\n   \n  if not dry_run:\n   zip = zipfile.ZipFile(zip_filename, \"w\",\n   compression=zipfile.ZIP_DEFLATED)\n   \n   for dirpath, dirnames, filenames in os.walk(base_dir):\n    for name in filenames:\n     path = os.path.normpath(os.path.join(dirpath, name))\n     if os.path.isfile(path):\n      zip.write(path, path)\n      if logger is not None:\n       logger.info(\"adding '%s'\", path)\n   zip.close()\n   \n return zip_filename\n \n_ARCHIVE_FORMATS = {\n'gztar': (_make_tarball, [('compress', 'gzip')], \"gzip'ed tar-file\"),\n'tar': (_make_tarball, [('compress', None)], \"uncompressed tar file\"),\n'zip': (_make_zipfile, [], \"ZIP file\")\n}\n\nif _BZ2_SUPPORTED:\n _ARCHIVE_FORMATS['bztar'] = (_make_tarball, [('compress', 'bzip2')],\n \"bzip2'ed tar-file\")\n \ndef get_archive_formats():\n \"\"\n formats = [(name, registry[2]) for name, registry in\n _ARCHIVE_FORMATS.items()]\n formats.sort()\n return formats\n \ndef register_archive_format(name, function, extra_args=None, description=''):\n \"\"\n if extra_args is None:\n  extra_args = []\n if not callable(function):\n  raise TypeError('The %s object is not callable' % function)\n if not isinstance(extra_args, (tuple, list)):\n  raise TypeError('extra_args needs to be a sequence')\n for element in extra_args:\n  if not isinstance(element, (tuple, list)) or len(element) !=2:\n   raise TypeError('extra_args elements are : (arg_name, value)')\n   \n _ARCHIVE_FORMATS[name] = (function, extra_args, description)\n \ndef unregister_archive_format(name):\n del _ARCHIVE_FORMATS[name]\n \ndef make_archive(base_name, format, root_dir=None, base_dir=None, verbose=0,\ndry_run=0, owner=None, group=None, logger=None):\n \"\"\n save_cwd = os.getcwd()\n if root_dir is not None:\n  if logger is not None:\n   logger.debug(\"changing into '%s'\", root_dir)\n  base_name = os.path.abspath(base_name)\n  if not dry_run:\n   os.chdir(root_dir)\n   \n if base_dir is None:\n  base_dir = os.curdir\n  \n kwargs = {'dry_run': dry_run, 'logger': logger}\n \n try:\n  format_info = _ARCHIVE_FORMATS[format]\n except KeyError:\n  raise ValueError(\"unknown archive format '%s'\" % format)\n  \n func = format_info[0]\n for arg, val in format_info[1]:\n  kwargs[arg] = val\n  \n if format != 'zip':\n  kwargs['owner'] = owner\n  kwargs['group'] = group\n  \n try:\n  filename = func(base_name, base_dir, **kwargs)\n finally:\n  if root_dir is not None:\n   if logger is not None:\n    logger.debug(\"changing back to '%s'\", save_cwd)\n   os.chdir(save_cwd)\n   \n return filename\n \n \ndef get_unpack_formats():\n \"\"\n formats = [(name, info[0], info[3]) for name, info in\n _UNPACK_FORMATS.items()]\n formats.sort()\n return formats\n \ndef _check_unpack_options(extensions, function, extra_args):\n \"\"\n \n existing_extensions = {}\n for name, info in _UNPACK_FORMATS.items():\n  for ext in info[0]:\n   existing_extensions[ext] = name\n   \n for extension in extensions:\n  if extension in existing_extensions:\n   msg = '%s is already registered for \"%s\"'\n   raise RegistryError(msg % (extension,\n   existing_extensions[extension]))\n   \n if not callable(function):\n  raise TypeError('The registered function must be a callable')\n  \n  \ndef register_unpack_format(name, extensions, function, extra_args=None,\ndescription=''):\n \"\"\n if extra_args is None:\n  extra_args = []\n _check_unpack_options(extensions, function, extra_args)\n _UNPACK_FORMATS[name] = extensions, function, extra_args, description\n \ndef unregister_unpack_format(name):\n \"\"\n del _UNPACK_FORMATS[name]\n \ndef _ensure_directory(path):\n \"\"\n dirname = os.path.dirname(path)\n if not os.path.isdir(dirname):\n  os.makedirs(dirname)\n  \ndef _unpack_zipfile(filename, extract_dir):\n \"\"\n try:\n  import zipfile\n except ImportError:\n  raise ReadError('zlib not supported, cannot unpack this archive.')\n  \n if not zipfile.is_zipfile(filename):\n  raise ReadError(\"%s is not a zip file\" % filename)\n  \n zip = zipfile.ZipFile(filename)\n try:\n  for info in zip.infolist():\n   name = info.filename\n   \n   \n   if name.startswith('/') or '..' in name:\n    continue\n    \n   target = os.path.join(extract_dir, *name.split('/'))\n   if not target:\n    continue\n    \n   _ensure_directory(target)\n   if not name.endswith('/'):\n   \n    data = zip.read(info.filename)\n    f = open(target, 'wb')\n    try:\n     f.write(data)\n    finally:\n     f.close()\n     del data\n finally:\n  zip.close()\n  \ndef _unpack_tarfile(filename, extract_dir):\n \"\"\n try:\n  tarobj = tarfile.open(filename)\n except tarfile.TarError:\n  raise ReadError(\n  \"%s is not a compressed or uncompressed tar file\" % filename)\n try:\n  tarobj.extractall(extract_dir)\n finally:\n  tarobj.close()\n  \n_UNPACK_FORMATS = {\n'gztar': (['.tar.gz', '.tgz'], _unpack_tarfile, [], \"gzip'ed tar-file\"),\n'tar': (['.tar'], _unpack_tarfile, [], \"uncompressed tar file\"),\n'zip': (['.zip'], _unpack_zipfile, [], \"ZIP file\")\n}\n\nif _BZ2_SUPPORTED:\n _UNPACK_FORMATS['bztar'] = (['.bz2'], _unpack_tarfile, [],\n \"bzip2'ed tar-file\")\n \ndef _find_unpack_format(filename):\n for name, info in _UNPACK_FORMATS.items():\n  for extension in info[0]:\n   if filename.endswith(extension):\n    return name\n return None\n \ndef unpack_archive(filename, extract_dir=None, format=None):\n \"\"\n if extract_dir is None:\n  extract_dir = os.getcwd()\n  \n if format is not None:\n  try:\n   format_info = _UNPACK_FORMATS[format]\n  except KeyError:\n   raise ValueError(\"Unknown unpack format '{0}'\".format(format))\n   \n  func = format_info[1]\n  func(filename, extract_dir, **dict(format_info[2]))\n else:\n \n  format = _find_unpack_format(filename)\n  if format is None:\n   raise ReadError(\"Unknown archive format '{0}'\".format(filename))\n   \n  func = _UNPACK_FORMATS[format][1]\n  kwargs = dict(_UNPACK_FORMATS[format][2])\n  func(filename, extract_dir, **kwargs)\n  \n  \nif hasattr(os, 'statvfs'):\n\n __all__.append('disk_usage')\n _ntuple_diskusage = collections.namedtuple('usage', 'total used free')\n \n def disk_usage(path):\n  \"\"\n  st = os.statvfs(path)\n  free = st.f_bavail * st.f_frsize\n  total = st.f_blocks * st.f_frsize\n  used = (st.f_blocks - st.f_bfree) * st.f_frsize\n  return _ntuple_diskusage(total, used, free)\n  \nelif os.name == 'nt':\n\n import nt\n __all__.append('disk_usage')\n _ntuple_diskusage = collections.namedtuple('usage', 'total used free')\n \n def disk_usage(path):\n  \"\"\n  total, free = nt._getdiskusage(path)\n  used = total - free\n  return _ntuple_diskusage(total, used, free)\n  \n  \ndef chown(path, user=None, group=None):\n \"\"\n \n if user is None and group is None:\n  raise ValueError(\"user and/or group must be set\")\n  \n _user = user\n _group = group\n \n \n if user is None:\n  _user = -1\n  \n elif isinstance(user, str):\n  _user = _get_uid(user)\n  if _user is None:\n   raise LookupError(\"no such user: {!r}\".format(user))\n   \n if group is None:\n  _group = -1\n elif not isinstance(group, int):\n  _group = _get_gid(group)\n  if _group is None:\n   raise LookupError(\"no such group: {!r}\".format(group))\n   \n os.chown(path, _user, _group)\n \ndef get_terminal_size(fallback=(80, 24)):\n \"\"\n \n try:\n  columns = int(os.environ['COLUMNS'])\n except (KeyError, ValueError):\n  columns = 0\n  \n try:\n  lines = int(os.environ['LINES'])\n except (KeyError, ValueError):\n  lines = 0\n  \n  \n if columns <= 0 or lines <= 0:\n  try:\n   size = os.get_terminal_size(sys.__stdout__.fileno())\n  except (NameError, OSError):\n   size = os.terminal_size(fallback)\n  if columns <= 0:\n   columns = size.columns\n  if lines <= 0:\n   lines = size.lines\n   \n return os.terminal_size((columns, lines))\n \ndef which(cmd, mode=os.F_OK | os.X_OK, path=None):\n \"\"\n \n \n \n def _access_check(fn, mode):\n  return (os.path.exists(fn) and os.access(fn, mode)\n  and not os.path.isdir(fn))\n  \n  \n  \n  \n if os.path.dirname(cmd):\n  if _access_check(cmd, mode):\n   return cmd\n  return None\n  \n if path is None:\n  path = os.environ.get(\"PATH\", os.defpath)\n if not path:\n  return None\n path = path.split(os.pathsep)\n \n if sys.platform == \"win32\":\n \n  if not os.curdir in path:\n   path.insert(0, os.curdir)\n   \n   \n  pathext = os.environ.get(\"PATHEXT\", \"\").split(os.pathsep)\n  \n  \n  \n  \n  if any(cmd.lower().endswith(ext.lower()) for ext in pathext):\n   files = [cmd]\n  else:\n   files = [cmd + ext for ext in pathext]\n else:\n \n \n  files = [cmd]\n  \n seen = set()\n for dir in path:\n  normdir = os.path.normcase(dir)\n  if not normdir in seen:\n   seen.add(normdir)\n   for thefile in files:\n    name = os.path.join(dir, thefile)\n    if _access_check(name, mode):\n     return name\n return None\n"], "site-packages.pygame.display": [".py", "\n\n\"\"\n\n__docformat__ = 'restructuredtext'\n__version__ = '$Id$'\n\nimport sys\n\nfrom SDL import *\nimport pygame.base\nimport pygame.pkgdata\nimport pygame.surface\n\n\nimport pygame.constants\nfrom browser import window\n\n\n_display_surface = None\n_icon_was_set = 0\n_icon_defaultname = 'pygame_icon.bmp'\n\n_init_video=False\n\ndef __PYGAMEinit__():\n pygame.base.register_quit(_display_autoquit)\n \ndef _display_autoquit():\n global _display_surface\n _display_surface = None\n \ndef init():\n \"\"\n pygame.base._video_autoinit()\n __PYGAMEinit__()\n \ndef quit():\n \"\"\n pygame.base._video_autoquit()\n _display_autoquit()\n \ndef get_init():\n \"\"\n return SDL_WasInit(SDL_INIT_VIDEO) != 0\n \ndef set_mode(resolution, flags=0, depth=0):\n \"\"\n global _display_surface\n \n w, h = resolution\n if w <= 0 or h <= 0:\n  raise pygame.base.error('Cannot set 0 sized display mode')\n  \n if not SDL_WasInit(SDL_INIT_VIDEO):\n  init()\n  \n if flags & SDL_OPENGL:\n  if flags & SDL_DOUBLEBUF:\n   flags &= ~SDL_DOUBLEBUF\n   SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1)\n  else:\n   SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 0)\n  if depth:\n   SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, depth)\n  surf = SDL_SetVideoMode(w, h, depth, flags)\n  if SDL_GL_GetAttribute(SDL_GL_DOUBLEBUFFER):\n   surf.flags |= SDL_DOUBLEBUF\n else:\n  if not depth:\n   flags |= SDL_ANYFORMAT\n  surf = SDL_SetVideoMode(w, h, depth, flags)\n  title, icontitle = SDL_WM_GetCaption()\n  if not title:\n   SDL_WM_SetCaption('pygame window', 'pygame')\n   \n SDL_PumpEvents()\n \n if _display_surface:\n  _display_surface._surf = surf\n else:\n \n  _display_surface = pygame.surface.Surface(dim=(w,h))\n  \n document['pydiv'] <= _display_surface.canvas\n \n if sys.platform != 'darwin':\n  if not _icon_was_set:\n   try:\n    file = pygame.pkgdata.getResource(_icon_defaultname)\n    iconsurf = pygame.image.load(file)\n    SDL_SetColorKey(iconsurf._surf, SDL_SRCCOLORKEY, 0)\n    set_icon(iconsurf)\n   except IOError:\n   \n    pass\n    \n return _display_surface\n \ndef get_surface():\n \"\"\n return _display_surface\n \ndef flip():\n \"\"\n pass\n _video_init_check()\n screen = SDL_GetVideoSurface()\n if not screen:\n  raise pygame.base.error('Display mode not set')\n  \n if screen.flags & SDL_OPENGL:\n  SDL_GL_SwapBuffers()\n else:\n  SDL_Flip(screen)\n  \ndef _crop_rect(w, h, rect):\n if rect.x >= w or rect.y >= h or rect.x + rect.w <= 0 or rect.y + rect.h <= 0:\n  return None\n rect.x = max(rect.x, 0)\n rect.y = max(rect.y, 0)\n rect.w = min(rect.x + rect.w, w) - rect.x \n rect.h = min(rect.y + rect.h, h) - rect.y \n return rect\n \ndef update(*rectangle):\n \"\"\n \n \n \n _video_init_check()\n screen = SDL_GetVideoSurface()\n if not screen:\n  raise pygame.base.error('Display mode not set')\n  \n if screen.flags & SDL_OPENGL:\n  raise pygame.base.error('Cannot update an OPENGL display')\n  \n if not rectangle:\n  SDL_UpdateRect(screen, 0, 0, 0, 0)\n else:\n  w, h = screen.w, screen.h\n  w, h = screen.width, screen.height\n  try:\n   rect = pygame.rect._rect_from_object(rectangle)._r\n   rect = _crop_rect(w, h, rect)\n   if rect:\n    SDL_UpdateRect(screen, rect.x, rect.y, rect.w, rect.h)\n  except TypeError:\n   rectangle = rectangle[0]\n   rects = [_crop_rect(w, h, pygame.rect._rect_from_object(r)._r) for r in rectangle if r]\n   SDL_UpdateRects(screen, rects) \n   \n   \ndef get_driver():\n \"\"\n _video_init_check()\n return SDL_VideoDriverName()\n \ndef Info():\n \"\"\n _video_init_check()\n return VideoInfo()\n \nclass VideoInfo:\n \"\"\n \n def __init__(self):\n \n \n  info=None\n  if not info:\n   raise pygame.base.error('Could not retrieve video info')\n  self.hw = info.hw_available\n  self.wm = info.wm_available\n  self.blit_hw = info.blit_hw\n  self.blit_hw_CC = info.blit_hw_CC\n  self.blit_hw_A = info.blit_hw_A\n  self.blit_sw = info.blit_sw\n  self.blit_sw_CC = info.blit_sw_CC\n  self.blit_sw_A = info.blit_sw_A\n  self.blit_fill = info.blit_fill\n  self.video_mem = info.video_mem\n  self.bitsize = info.vfmt.BitsPerPixel\n  self.bytesize = info.vfmt.BytesPerPixel\n  self.masks = (info.vfmt.Rmask, info.vfmt.Gmask, \n  info.vfmt.Bmask, info.vfmt.Amask)\n  self.shifts = (info.vfmt.Rshift, info.vfmt.Gshift, \n  info.vfmt.Bshift, info.vfmt.Ashift)\n  self.losses = (info.vfmt.Rloss, info.vfmt.Gloss, \n  info.vfmt.Bloss, info.vfmt.Aloss)\n  \n def __str__(self):\n  return ('<VideoInfo(hw = %d, wm = %d,video_mem = %d\\n' + '           blit_hw = %d, blit_hw_CC = %d, blit_hw_A = %d,\\n'\n  '           blit_sw = %d, blit_sw_CC = %d, blit_sw_A = %d,\\n'\n  '           bitsize  = %d, bytesize = %d,\\n'\n  '           masks =  (%d, %d, %d, %d),\\n'\n  '           shifts = (%d, %d, %d, %d),\\n'\n  '           losses =  (%d, %d, %d, %d)>\\n') % (self.hw, self.wm, self.video_mem,\n  self.blit_hw, self.blit_hw_CC, self.blit_hw_A,\n  self.blit_sw, self.blit_sw_CC, self.blit_sw_A,\n  self.bitsize, self.bytesize,\n  self.masks[0], self.masks[1], self.masks[2], self.masks[3],\n  self.shifts[0], self.shifts[1], self.shifts[2], self.shifts[3],\n  self.losses[0], self.losses[1], self.losses[2], self.losses[3])\n  \n def __repr__(self):\n  return str(self)\n  \ndef get_wm_info():\n \"\"\n _video_init_check()\n return {}\n \ndef list_modes(depth=0, flags=pygame.constants.FULLSCREEN):\n \"\"\n _video_init_check()\n \n \n \n \n \n \n \n \n \n \n \n if rects == -1:\n  return -1\n  \n return [(r.w, r.h) for r in rects]\n \ndef mode_ok(size, flags=0, depth=0):\n \"\"\n _video_init_check()\n if not depth:\n  depth = SDL_GetVideoInfo().vfmt.BitsPerPixel\n return SDL_VideoModeOK(size[0], size[1], depth, flags)\n \ndef gl_set_attribute(flag, value):\n \"\"\n _video_init_check()\n SDL_GL_SetAttribute(flag, value)\n \ndef gl_get_attribute(flag):\n \"\"\n \n _video_init_check()\n return SDL_GL_GetAttribute(flag)\n \ndef get_active():\n \"\"\n brython\n return SDL_GetAppState() & SDL_APPACTIVE != 0\n \ndef iconify():\n \"\"\n _video_init_check()\n try:\n  SDL_WM_IconifyWindow()\n  return True\n except SDL_Exception:\n  return False\n  \n  \ndef toggle_fullscreen():\n \"\"\n _video_init_check()\n screen = SDL_GetVideoSurface()\n try:\n  SDL_WM_ToggleFullScreen(screen)\n  return True\n except SDL_Exception:\n  return False\n  \n return False\n \ndef set_gamma(red, green=None, blue=None):\n \"\"\n brython\n _video_init_check()\n if not green or not blue:\n  green = red\n  blue = red\n  \n try:\n  SDL_SetGamma(red, green, blue)\n  return True\n except SDL_Exception:\n  return False\n  \n  \ndef set_gamma_ramp(red, green, blue):\n \"\"\n _video_init_check()\n try:\n  SDL_SetGammaRamp(red, green, blue)\n  return True\n except SDL_Exception:\n  return False\n  \ndef set_icon(surface):\n \"\"\n global _icon_was_set\n \n pygame.base._video_autoinit()\n SDL_WM_SetIcon(surface._surf, None)\n _icon_was_set = 1\n \ndef set_caption(title, icontitle=None):\n \"\"\n if not icontitle:\n  icontitle = title\n  \n SDL_WM_SetCaption(title, icontitle)\n \ndef get_caption():\n \"\"\n \n \n return \"\", \"\"\n \ndef set_palette(palette=None):\n \"\"\n _video_init_check()\n surf = SDL_GetVideoSurface()\n if not surf:\n  raise pygame.base.error('No display mode is set')\n if surf.format.BytesPerPixel != 1 or not surf.format._palette:\n  raise pygame.base.error('Display mode is not colormapped')\n  \n if not palette:\n  SDL_SetPalette(surf, SDL_PHYSPAL, surf.format.palette.colors, 0)\n  \n length = min(surf.format.palette.ncolors, len(palette))\n colors = [SDL_Color(r, g, b) for r, g, b in palette[:length]]\n SDL_SetPalette(surf, SDL_PHYSPAL, colors, 0)\n \ndef _video_init_check():\n if not SDL_WasInit(SDL_INIT_VIDEO):\n  raise pygame.base.error('video system not initialized')\n"], "configparser": [".py", "\"\"\n\nfrom collections.abc import MutableMapping\nfrom collections import OrderedDict as _default_dict, ChainMap as _ChainMap\nimport functools\nimport io\nimport itertools\nimport re\nimport sys\nimport warnings\n\n__all__ = [\"NoSectionError\", \"DuplicateOptionError\", \"DuplicateSectionError\",\n\"NoOptionError\", \"InterpolationError\", \"InterpolationDepthError\",\n\"InterpolationSyntaxError\", \"ParsingError\",\n\"MissingSectionHeaderError\",\n\"ConfigParser\", \"SafeConfigParser\", \"RawConfigParser\",\n\"DEFAULTSECT\", \"MAX_INTERPOLATION_DEPTH\"]\n\nDEFAULTSECT = \"DEFAULT\"\n\nMAX_INTERPOLATION_DEPTH = 10\n\n\n\n\nclass Error(Exception):\n \"\"\n \n def _get_message(self):\n  \"\"\n  return self.__message\n  \n def _set_message(self, value):\n  \"\"\n  self.__message = value\n  \n  \n  \n  \n message = property(_get_message, _set_message)\n \n def __init__(self, msg=''):\n  self.message = msg\n  Exception.__init__(self, msg)\n  \n def __repr__(self):\n  return self.message\n  \n __str__ = __repr__\n \n \nclass NoSectionError(Error):\n \"\"\n \n def __init__(self, section):\n  Error.__init__(self, 'No section: %r' % (section,))\n  self.section = section\n  self.args = (section, )\n  \n  \nclass DuplicateSectionError(Error):\n \"\"\n \n def __init__(self, section, source=None, lineno=None):\n  msg = [repr(section), \" already exists\"]\n  if source is not None:\n   message = [\"While reading from \", source]\n   if lineno is not None:\n    message.append(\" [line {0:2d}]\".format(lineno))\n   message.append(\": section \")\n   message.extend(msg)\n   msg = message\n  else:\n   msg.insert(0, \"Section \")\n  Error.__init__(self, \"\".join(msg))\n  self.section = section\n  self.source = source\n  self.lineno = lineno\n  self.args = (section, source, lineno)\n  \n  \nclass DuplicateOptionError(Error):\n \"\"\n \n def __init__(self, section, option, source=None, lineno=None):\n  msg = [repr(option), \" in section \", repr(section),\n  \" already exists\"]\n  if source is not None:\n   message = [\"While reading from \", source]\n   if lineno is not None:\n    message.append(\" [line {0:2d}]\".format(lineno))\n   message.append(\": option \")\n   message.extend(msg)\n   msg = message\n  else:\n   msg.insert(0, \"Option \")\n  Error.__init__(self, \"\".join(msg))\n  self.section = section\n  self.option = option\n  self.source = source\n  self.lineno = lineno\n  self.args = (section, option, source, lineno)\n  \n  \nclass NoOptionError(Error):\n \"\"\n \n def __init__(self, option, section):\n  Error.__init__(self, \"No option %r in section: %r\" %\n  (option, section))\n  self.option = option\n  self.section = section\n  self.args = (option, section)\n  \n  \nclass InterpolationError(Error):\n \"\"\n \n def __init__(self, option, section, msg):\n  Error.__init__(self, msg)\n  self.option = option\n  self.section = section\n  self.args = (option, section, msg)\n  \n  \nclass InterpolationMissingOptionError(InterpolationError):\n \"\"\n \n def __init__(self, option, section, rawval, reference):\n  msg = (\"Bad value substitution:\\n\"\n  \"\\tsection: [%s]\\n\"\n  \"\\toption : %s\\n\"\n  \"\\tkey    : %s\\n\"\n  \"\\trawval : %s\\n\"\n  % (section, option, reference, rawval))\n  InterpolationError.__init__(self, option, section, msg)\n  self.reference = reference\n  self.args = (option, section, rawval, reference)\n  \n  \nclass InterpolationSyntaxError(InterpolationError):\n \"\"\n \n \nclass InterpolationDepthError(InterpolationError):\n \"\"\n \n def __init__(self, option, section, rawval):\n  msg = (\"Value interpolation too deeply recursive:\\n\"\n  \"\\tsection: [%s]\\n\"\n  \"\\toption : %s\\n\"\n  \"\\trawval : %s\\n\"\n  % (section, option, rawval))\n  InterpolationError.__init__(self, option, section, msg)\n  self.args = (option, section, rawval)\n  \n  \nclass ParsingError(Error):\n \"\"\n \n def __init__(self, source=None, filename=None):\n \n \n  if filename and source:\n   raise ValueError(\"Cannot specify both `filename' and `source'. \"\n   \"Use `source'.\")\n  elif not filename and not source:\n   raise ValueError(\"Required argument `source' not given.\")\n  elif filename:\n   source = filename\n  Error.__init__(self, 'Source contains parsing errors: %s' % source)\n  self.source = source\n  self.errors = []\n  self.args = (source, )\n  \n @property\n def filename(self):\n  \"\"\n  warnings.warn(\n  \"The 'filename' attribute will be removed in future versions.  \"\n  \"Use 'source' instead.\",\n  DeprecationWarning, stacklevel=2\n  )\n  return self.source\n  \n @filename.setter\n def filename(self, value):\n  \"\"\n  warnings.warn(\n  \"The 'filename' attribute will be removed in future versions.  \"\n  \"Use 'source' instead.\",\n  DeprecationWarning, stacklevel=2\n  )\n  self.source = value\n  \n def append(self, lineno, line):\n  self.errors.append((lineno, line))\n  self.message += '\\n\\t[line %2d]: %s' % (lineno, line)\n  \n  \nclass MissingSectionHeaderError(ParsingError):\n \"\"\n \n def __init__(self, filename, lineno, line):\n  Error.__init__(\n  self,\n  'File contains no section headers.\\nfile: %s, line: %d\\n%r' %\n  (filename, lineno, line))\n  self.source = filename\n  self.lineno = lineno\n  self.line = line\n  self.args = (filename, lineno, line)\n  \n  \n  \n  \n  \n_UNSET = object()\n\n\nclass Interpolation:\n \"\"\n \n def before_get(self, parser, section, option, value, defaults):\n  return value\n  \n def before_set(self, parser, section, option, value):\n  return value\n  \n def before_read(self, parser, section, option, value):\n  return value\n  \n def before_write(self, parser, section, option, value):\n  return value\n  \n  \nclass BasicInterpolation(Interpolation):\n \"\"\n \n _KEYCRE = re.compile(r\"%\\(([^)]+)\\)s\")\n \n def before_get(self, parser, section, option, value, defaults):\n  L = []\n  self._interpolate_some(parser, option, L, value, section, defaults, 1)\n  return ''.join(L)\n  \n def before_set(self, parser, section, option, value):\n  tmp_value = value.replace('%%', '') \n  tmp_value = self._KEYCRE.sub('', tmp_value) \n  if '%' in tmp_value:\n   raise ValueError(\"invalid interpolation syntax in %r at \"\n   \"position %d\" % (value, tmp_value.find('%')))\n  return value\n  \n def _interpolate_some(self, parser, option, accum, rest, section, map,\n depth):\n  if depth > MAX_INTERPOLATION_DEPTH:\n   raise InterpolationDepthError(option, section, rest)\n  while rest:\n   p = rest.find(\"%\")\n   if p < 0:\n    accum.append(rest)\n    return\n   if p > 0:\n    accum.append(rest[:p])\n    rest = rest[p:]\n    \n   c = rest[1:2]\n   if c == \"%\":\n    accum.append(\"%\")\n    rest = rest[2:]\n   elif c == \"(\":\n    m = self._KEYCRE.match(rest)\n    if m is None:\n     raise InterpolationSyntaxError(option, section,\n     \"bad interpolation variable reference %r\" % rest)\n    var = parser.optionxform(m.group(1))\n    rest = rest[m.end():]\n    try:\n     v = map[var]\n    except KeyError:\n     raise InterpolationMissingOptionError(\n     option, section, rest, var)\n    if \"%\" in v:\n     self._interpolate_some(parser, option, accum, v,\n     section, map, depth + 1)\n    else:\n     accum.append(v)\n   else:\n    raise InterpolationSyntaxError(\n    option, section,\n    \"'%%' must be followed by '%%' or '(', \"\n    \"found: %r\" % (rest,))\n    \n    \nclass ExtendedInterpolation(Interpolation):\n \"\"\n \n _KEYCRE = re.compile(r\"\\$\\{([^}]+)\\}\")\n \n def before_get(self, parser, section, option, value, defaults):\n  L = []\n  self._interpolate_some(parser, option, L, value, section, defaults, 1)\n  return ''.join(L)\n  \n def before_set(self, parser, section, option, value):\n  tmp_value = value.replace('$$', '') \n  tmp_value = self._KEYCRE.sub('', tmp_value) \n  if '$' in tmp_value:\n   raise ValueError(\"invalid interpolation syntax in %r at \"\n   \"position %d\" % (value, tmp_value.find('%')))\n  return value\n  \n def _interpolate_some(self, parser, option, accum, rest, section, map,\n depth):\n  if depth > MAX_INTERPOLATION_DEPTH:\n   raise InterpolationDepthError(option, section, rest)\n  while rest:\n   p = rest.find(\"$\")\n   if p < 0:\n    accum.append(rest)\n    return\n   if p > 0:\n    accum.append(rest[:p])\n    rest = rest[p:]\n    \n   c = rest[1:2]\n   if c == \"$\":\n    accum.append(\"$\")\n    rest = rest[2:]\n   elif c == \"{\":\n    m = self._KEYCRE.match(rest)\n    if m is None:\n     raise InterpolationSyntaxError(option, section,\n     \"bad interpolation variable reference %r\" % rest)\n    path = m.group(1).split(':')\n    rest = rest[m.end():]\n    sect = section\n    opt = option\n    try:\n     if len(path) == 1:\n      opt = parser.optionxform(path[0])\n      v = map[opt]\n     elif len(path) == 2:\n      sect = path[0]\n      opt = parser.optionxform(path[1])\n      v = parser.get(sect, opt, raw=True)\n     else:\n      raise InterpolationSyntaxError(\n      option, section,\n      \"More than one ':' found: %r\" % (rest,))\n    except (KeyError, NoSectionError, NoOptionError):\n     raise InterpolationMissingOptionError(\n     option, section, rest, \":\".join(path))\n    if \"$\" in v:\n     self._interpolate_some(parser, opt, accum, v, sect,\n     dict(parser.items(sect, raw=True)),\n     depth + 1)\n    else:\n     accum.append(v)\n   else:\n    raise InterpolationSyntaxError(\n    option, section,\n    \"'$' must be followed by '$' or '{', \"\n    \"found: %r\" % (rest,))\n    \n    \nclass LegacyInterpolation(Interpolation):\n \"\"\n \n _KEYCRE = re.compile(r\"%\\(([^)]*)\\)s|.\")\n \n def before_get(self, parser, section, option, value, vars):\n  rawval = value\n  depth = MAX_INTERPOLATION_DEPTH\n  while depth: \n   depth -= 1\n   if value and \"%(\" in value:\n    replace = functools.partial(self._interpolation_replace,\n    parser=parser)\n    value = self._KEYCRE.sub(replace, value)\n    try:\n     value = value % vars\n    except KeyError as e:\n     raise InterpolationMissingOptionError(\n     option, section, rawval, e.args[0])\n   else:\n    break\n  if value and \"%(\" in value:\n   raise InterpolationDepthError(option, section, rawval)\n  return value\n  \n def before_set(self, parser, section, option, value):\n  return value\n  \n @staticmethod\n def _interpolation_replace(match, parser):\n  s = match.group(1)\n  if s is None:\n   return match.group()\n  else:\n   return \"%%(%s)s\" % parser.optionxform(s)\n   \n   \nclass RawConfigParser(MutableMapping):\n \"\"\n \n \n _SECT_TMPL = r\"\"\"\n        \\[                                 # [\n        (?P<header>[^]]+)                  # very permissive!\n        \\]                                 # ]\n        \"\"\" \n _OPT_TMPL = r\"\"\"\n        (?P<option>.*?)                    # very permissive!\n        \\s*(?P<vi>{delim})\\s*              # any number of space/tab,\n                                           # followed by any of the\n                                           # allowed delimiters,\n                                           # followed by any space/tab\n        (?P<value>.*)$                     # everything up to eol\n        \"\"\" \n _OPT_NV_TMPL = r\"\"\"\n        (?P<option>.*?)                    # very permissive!\n        \\s*(?:                             # any number of space/tab,\n        (?P<vi>{delim})\\s*                 # optionally followed by\n                                           # any of the allowed\n                                           # delimiters, followed by any\n                                           # space/tab\n        (?P<value>.*))?$                   # everything up to eol\n        \"\"\" \n \n _DEFAULT_INTERPOLATION = Interpolation()\n \n SECTCRE = re.compile(_SECT_TMPL, re.VERBOSE)\n \n OPTCRE = re.compile(_OPT_TMPL.format(delim=\"=|:\"), re.VERBOSE)\n \n \n OPTCRE_NV = re.compile(_OPT_NV_TMPL.format(delim=\"=|:\"), re.VERBOSE)\n \n NONSPACECRE = re.compile(r\"\\S\")\n \n BOOLEAN_STATES = {'1': True, 'yes': True, 'true': True, 'on': True,\n '0': False, 'no': False, 'false': False, 'off': False}\n \n def __init__(self, defaults=None, dict_type=_default_dict,\n allow_no_value=False, *, delimiters=('=', ':'),\n comment_prefixes=('#', ';'), inline_comment_prefixes=None,\n strict=True, empty_lines_in_values=True,\n default_section=DEFAULTSECT,\n interpolation=_UNSET):\n \n  self._dict = dict_type\n  self._sections = self._dict()\n  self._defaults = self._dict()\n  self._proxies = self._dict()\n  self._proxies[default_section] = SectionProxy(self, default_section)\n  if defaults:\n   for key, value in defaults.items():\n    self._defaults[self.optionxform(key)] = value\n  self._delimiters = tuple(delimiters)\n  if delimiters == ('=', ':'):\n   self._optcre = self.OPTCRE_NV if allow_no_value else self.OPTCRE\n  else:\n   d = \"|\".join(re.escape(d) for d in delimiters)\n   if allow_no_value:\n    self._optcre = re.compile(self._OPT_NV_TMPL.format(delim=d),\n    re.VERBOSE)\n   else:\n    self._optcre = re.compile(self._OPT_TMPL.format(delim=d),\n    re.VERBOSE)\n  self._comment_prefixes = tuple(comment_prefixes or ())\n  self._inline_comment_prefixes = tuple(inline_comment_prefixes or ())\n  self._strict = strict\n  self._allow_no_value = allow_no_value\n  self._empty_lines_in_values = empty_lines_in_values\n  self.default_section=default_section\n  self._interpolation = interpolation\n  if self._interpolation is _UNSET:\n   self._interpolation = self._DEFAULT_INTERPOLATION\n  if self._interpolation is None:\n   self._interpolation = Interpolation()\n   \n def defaults(self):\n  return self._defaults\n  \n def sections(self):\n  \"\"\n  \n  return list(self._sections.keys())\n  \n def add_section(self, section):\n  \"\"\n  if section == self.default_section:\n   raise ValueError('Invalid section name: %r' % section)\n   \n  if section in self._sections:\n   raise DuplicateSectionError(section)\n  self._sections[section] = self._dict()\n  self._proxies[section] = SectionProxy(self, section)\n  \n def has_section(self, section):\n  \"\"\n  return section in self._sections\n  \n def options(self, section):\n  \"\"\n  try:\n   opts = self._sections[section].copy()\n  except KeyError:\n   raise NoSectionError(section)\n  opts.update(self._defaults)\n  return list(opts.keys())\n  \n def read(self, filenames, encoding=None):\n  \"\"\n  if isinstance(filenames, str):\n   filenames = [filenames]\n  read_ok = []\n  for filename in filenames:\n   try:\n    with open(filename, encoding=encoding) as fp:\n     self._read(fp, filename)\n   except IOError:\n    continue\n   read_ok.append(filename)\n  return read_ok\n  \n def read_file(self, f, source=None):\n  \"\"\n  if source is None:\n   try:\n    source = f.name\n   except AttributeError:\n    source = '<???>'\n  self._read(f, source)\n  \n def read_string(self, string, source='<string>'):\n  \"\"\n  sfile = io.StringIO(string)\n  self.read_file(sfile, source)\n  \n def read_dict(self, dictionary, source='<dict>'):\n  \"\"\n  elements_added = set()\n  for section, keys in dictionary.items():\n   section = str(section)\n   try:\n    self.add_section(section)\n   except (DuplicateSectionError, ValueError):\n    if self._strict and section in elements_added:\n     raise\n   elements_added.add(section)\n   for key, value in keys.items():\n    key = self.optionxform(str(key))\n    if value is not None:\n     value = str(value)\n    if self._strict and (section, key) in elements_added:\n     raise DuplicateOptionError(section, key, source)\n    elements_added.add((section, key))\n    self.set(section, key, value)\n    \n def readfp(self, fp, filename=None):\n  \"\"\n  warnings.warn(\n  \"This method will be removed in future versions.  \"\n  \"Use 'parser.read_file()' instead.\",\n  DeprecationWarning, stacklevel=2\n  )\n  self.read_file(fp, source=filename)\n  \n def get(self, section, option, *, raw=False, vars=None, fallback=_UNSET):\n  \"\"\n  try:\n   d = self._unify_values(section, vars)\n  except NoSectionError:\n   if fallback is _UNSET:\n    raise\n   else:\n    return fallback\n  option = self.optionxform(option)\n  try:\n   value = d[option]\n  except KeyError:\n   if fallback is _UNSET:\n    raise NoOptionError(option, section)\n   else:\n    return fallback\n    \n  if raw or value is None:\n   return value\n  else:\n   return self._interpolation.before_get(self, section, option, value,\n   d)\n   \n def _get(self, section, conv, option, **kwargs):\n  return conv(self.get(section, option, **kwargs))\n  \n def getint(self, section, option, *, raw=False, vars=None,\n fallback=_UNSET):\n  try:\n   return self._get(section, int, option, raw=raw, vars=vars)\n  except (NoSectionError, NoOptionError):\n   if fallback is _UNSET:\n    raise\n   else:\n    return fallback\n    \n def getfloat(self, section, option, *, raw=False, vars=None,\n fallback=_UNSET):\n  try:\n   return self._get(section, float, option, raw=raw, vars=vars)\n  except (NoSectionError, NoOptionError):\n   if fallback is _UNSET:\n    raise\n   else:\n    return fallback\n    \n def getboolean(self, section, option, *, raw=False, vars=None,\n fallback=_UNSET):\n  try:\n   return self._get(section, self._convert_to_boolean, option,\n   raw=raw, vars=vars)\n  except (NoSectionError, NoOptionError):\n   if fallback is _UNSET:\n    raise\n   else:\n    return fallback\n    \n def items(self, section=_UNSET, raw=False, vars=None):\n  \"\"\n  if section is _UNSET:\n   return super().items()\n  d = self._defaults.copy()\n  try:\n   d.update(self._sections[section])\n  except KeyError:\n   if section != self.default_section:\n    raise NoSectionError(section)\n    \n  if vars:\n   for key, value in vars.items():\n    d[self.optionxform(key)] = value\n  value_getter = lambda option: self._interpolation.before_get(self,\n  section, option, d[option], d)\n  if raw:\n   value_getter = lambda option: d[option]\n  return [(option, value_getter(option)) for option in d.keys()]\n  \n def popitem(self):\n  \"\"\n  for key in self.sections():\n   value = self[key]\n   del self[key]\n   return key, value\n  raise KeyError\n  \n def optionxform(self, optionstr):\n  return optionstr.lower()\n  \n def has_option(self, section, option):\n  \"\"\n  if not section or section == self.default_section:\n   option = self.optionxform(option)\n   return option in self._defaults\n  elif section not in self._sections:\n   return False\n  else:\n   option = self.optionxform(option)\n   return (option in self._sections[section]\n   or option in self._defaults)\n   \n def set(self, section, option, value=None):\n  \"\"\n  if value:\n   value = self._interpolation.before_set(self, section, option,\n   value)\n  if not section or section == self.default_section:\n   sectdict = self._defaults\n  else:\n   try:\n    sectdict = self._sections[section]\n   except KeyError:\n    raise NoSectionError(section)\n  sectdict[self.optionxform(option)] = value\n  \n def write(self, fp, space_around_delimiters=True):\n  \"\"\n  if space_around_delimiters:\n   d = \" {} \".format(self._delimiters[0])\n  else:\n   d = self._delimiters[0]\n  if self._defaults:\n   self._write_section(fp, self.default_section,\n   self._defaults.items(), d)\n  for section in self._sections:\n   self._write_section(fp, section,\n   self._sections[section].items(), d)\n   \n def _write_section(self, fp, section_name, section_items, delimiter):\n  \"\"\n  fp.write(\"[{}]\\n\".format(section_name))\n  for key, value in section_items:\n   value = self._interpolation.before_write(self, section_name, key,\n   value)\n   if value is not None or not self._allow_no_value:\n    value = delimiter + str(value).replace('\\n', '\\n\\t')\n   else:\n    value = \"\"\n   fp.write(\"{}{}\\n\".format(key, value))\n  fp.write(\"\\n\")\n  \n def remove_option(self, section, option):\n  \"\"\n  if not section or section == self.default_section:\n   sectdict = self._defaults\n  else:\n   try:\n    sectdict = self._sections[section]\n   except KeyError:\n    raise NoSectionError(section)\n  option = self.optionxform(option)\n  existed = option in sectdict\n  if existed:\n   del sectdict[option]\n  return existed\n  \n def remove_section(self, section):\n  \"\"\n  existed = section in self._sections\n  if existed:\n   del self._sections[section]\n   del self._proxies[section]\n  return existed\n  \n def __getitem__(self, key):\n  if key != self.default_section and not self.has_section(key):\n   raise KeyError(key)\n  return self._proxies[key]\n  \n def __setitem__(self, key, value):\n \n \n \n \n \n  if key == self.default_section:\n   self._defaults.clear()\n  elif key in self._sections:\n   self._sections[key].clear()\n  self.read_dict({key: value})\n  \n def __delitem__(self, key):\n  if key == self.default_section:\n   raise ValueError(\"Cannot remove the default section.\")\n  if not self.has_section(key):\n   raise KeyError(key)\n  self.remove_section(key)\n  \n def __contains__(self, key):\n  return key == self.default_section or self.has_section(key)\n  \n def __len__(self):\n  return len(self._sections) + 1 \n  \n def __iter__(self):\n \n  return itertools.chain((self.default_section,), self._sections.keys())\n  \n def _read(self, fp, fpname):\n  \"\"\n  elements_added = set()\n  cursect = None \n  sectname = None\n  optname = None\n  lineno = 0\n  indent_level = 0\n  e = None \n  for lineno, line in enumerate(fp, start=1):\n   comment_start = sys.maxsize\n   \n   inline_prefixes = {p: -1 for p in self._inline_comment_prefixes}\n   while comment_start == sys.maxsize and inline_prefixes:\n    next_prefixes = {}\n    for prefix, index in inline_prefixes.items():\n     index = line.find(prefix, index+1)\n     if index == -1:\n      continue\n     next_prefixes[prefix] = index\n     if index == 0 or (index > 0 and line[index-1].isspace()):\n      comment_start = min(comment_start, index)\n    inline_prefixes = next_prefixes\n    \n   for prefix in self._comment_prefixes:\n    if line.strip().startswith(prefix):\n     comment_start = 0\n     break\n   if comment_start == sys.maxsize:\n    comment_start = None\n   value = line[:comment_start].strip()\n   if not value:\n    if self._empty_lines_in_values:\n    \n    \n     if (comment_start is None and\n     cursect is not None and\n     optname and\n     cursect[optname] is not None):\n      cursect[optname].append('') \n    else:\n    \n     indent_level = sys.maxsize\n    continue\n    \n   first_nonspace = self.NONSPACECRE.search(line)\n   cur_indent_level = first_nonspace.start() if first_nonspace else 0\n   if (cursect is not None and optname and\n   cur_indent_level > indent_level):\n    cursect[optname].append(value)\n    \n   else:\n    indent_level = cur_indent_level\n    \n    mo = self.SECTCRE.match(value)\n    if mo:\n     sectname = mo.group('header')\n     if sectname in self._sections:\n      if self._strict and sectname in elements_added:\n       raise DuplicateSectionError(sectname, fpname,\n       lineno)\n      cursect = self._sections[sectname]\n      elements_added.add(sectname)\n     elif sectname == self.default_section:\n      cursect = self._defaults\n     else:\n      cursect = self._dict()\n      self._sections[sectname] = cursect\n      self._proxies[sectname] = SectionProxy(self, sectname)\n      elements_added.add(sectname)\n      \n     optname = None\n     \n    elif cursect is None:\n     raise MissingSectionHeaderError(fpname, lineno, line)\n     \n    else:\n     mo = self._optcre.match(value)\n     if mo:\n      optname, vi, optval = mo.group('option', 'vi', 'value')\n      if not optname:\n       e = self._handle_error(e, fpname, lineno, line)\n      optname = self.optionxform(optname.rstrip())\n      if (self._strict and\n      (sectname, optname) in elements_added):\n       raise DuplicateOptionError(sectname, optname,\n       fpname, lineno)\n      elements_added.add((sectname, optname))\n      \n      \n      if optval is not None:\n       optval = optval.strip()\n       cursect[optname] = [optval]\n      else:\n      \n       cursect[optname] = None\n     else:\n     \n     \n     \n     \n      e = self._handle_error(e, fpname, lineno, line)\n      \n  if e:\n   raise e\n  self._join_multiline_values()\n  \n def _join_multiline_values(self):\n  defaults = self.default_section, self._defaults\n  all_sections = itertools.chain((defaults,),\n  self._sections.items())\n  for section, options in all_sections:\n   for name, val in options.items():\n    if isinstance(val, list):\n     val = '\\n'.join(val).rstrip()\n    options[name] = self._interpolation.before_read(self,\n    section,\n    name, val)\n    \n def _handle_error(self, exc, fpname, lineno, line):\n  if not exc:\n   exc = ParsingError(fpname)\n  exc.append(lineno, repr(line))\n  return exc\n  \n def _unify_values(self, section, vars):\n  \"\"\n  sectiondict = {}\n  try:\n   sectiondict = self._sections[section]\n  except KeyError:\n   if section != self.default_section:\n    raise NoSectionError(section)\n    \n  vardict = {}\n  if vars:\n   for key, value in vars.items():\n    if value is not None:\n     value = str(value)\n    vardict[self.optionxform(key)] = value\n  return _ChainMap(vardict, sectiondict, self._defaults)\n  \n def _convert_to_boolean(self, value):\n  \"\"\n  if value.lower() not in self.BOOLEAN_STATES:\n   raise ValueError('Not a boolean: %s' % value)\n  return self.BOOLEAN_STATES[value.lower()]\n  \n def _validate_value_types(self, *, section=\"\", option=\"\", value=\"\"):\n  \"\"\n  if not isinstance(section, str):\n   raise TypeError(\"section names must be strings\")\n  if not isinstance(option, str):\n   raise TypeError(\"option keys must be strings\")\n  if not self._allow_no_value or value:\n   if not isinstance(value, str):\n    raise TypeError(\"option values must be strings\")\n    \n    \nclass ConfigParser(RawConfigParser):\n \"\"\n \n _DEFAULT_INTERPOLATION = BasicInterpolation()\n \n def set(self, section, option, value=None):\n  \"\"\n  self._validate_value_types(option=option, value=value)\n  super().set(section, option, value)\n  \n def add_section(self, section):\n  \"\"\n  self._validate_value_types(section=section)\n  super().add_section(section)\n  \n  \nclass SafeConfigParser(ConfigParser):\n \"\"\n \n def __init__(self, *args, **kwargs):\n  super().__init__(*args, **kwargs)\n  warnings.warn(\n  \"The SafeConfigParser class has been renamed to ConfigParser \"\n  \"in Python 3.2. This alias will be removed in future versions.\"\n  \" Use ConfigParser directly instead.\",\n  DeprecationWarning, stacklevel=2\n  )\n  \n  \nclass SectionProxy(MutableMapping):\n \"\"\n \n def __init__(self, parser, name):\n  \"\"\n  self._parser = parser\n  self._name = name\n  \n def __repr__(self):\n  return '<Section: {}>'.format(self._name)\n  \n def __getitem__(self, key):\n  if not self._parser.has_option(self._name, key):\n   raise KeyError(key)\n  return self._parser.get(self._name, key)\n  \n def __setitem__(self, key, value):\n  self._parser._validate_value_types(option=key, value=value)\n  return self._parser.set(self._name, key, value)\n  \n def __delitem__(self, key):\n  if not (self._parser.has_option(self._name, key) and\n  self._parser.remove_option(self._name, key)):\n   raise KeyError(key)\n   \n def __contains__(self, key):\n  return self._parser.has_option(self._name, key)\n  \n def __len__(self):\n  return len(self._options())\n  \n def __iter__(self):\n  return self._options().__iter__()\n  \n def _options(self):\n  if self._name != self._parser.default_section:\n   return self._parser.options(self._name)\n  else:\n   return self._parser.defaults()\n   \n def get(self, option, fallback=None, *, raw=False, vars=None):\n  return self._parser.get(self._name, option, raw=raw, vars=vars,\n  fallback=fallback)\n  \n def getint(self, option, fallback=None, *, raw=False, vars=None):\n  return self._parser.getint(self._name, option, raw=raw, vars=vars,\n  fallback=fallback)\n  \n def getfloat(self, option, fallback=None, *, raw=False, vars=None):\n  return self._parser.getfloat(self._name, option, raw=raw, vars=vars,\n  fallback=fallback)\n  \n def getboolean(self, option, fallback=None, *, raw=False, vars=None):\n  return self._parser.getboolean(self._name, option, raw=raw, vars=vars,\n  fallback=fallback)\n  \n @property\n def parser(self):\n \n  return self._parser\n  \n @property\n def name(self):\n \n  return self._name\n"], "weakref": [".py", "\"\"\n\n\n\n\n\nfrom _weakref import (\ngetweakrefcount,\ngetweakrefs,\nref,\nproxy,\nCallableProxyType,\nProxyType,\nReferenceType)\n\nfrom _weakrefset import WeakSet, _IterationGuard\n\nimport collections \n\nProxyTypes = (ProxyType, CallableProxyType)\n\n__all__ = [\"ref\", \"proxy\", \"getweakrefcount\", \"getweakrefs\",\n\"WeakKeyDictionary\", \"ReferenceType\", \"ProxyType\",\n\"CallableProxyType\", \"ProxyTypes\", \"WeakValueDictionary\",\n\"WeakSet\"]\n\n\nclass WeakValueDictionary(collections.MutableMapping):\n \"\"\n \n \n \n \n \n \n def __init__(self, *args, **kw):\n  def remove(wr, selfref=ref(self)):\n   self = selfref()\n   if self is not None:\n    if self._iterating:\n     self._pending_removals.append(wr.key)\n    else:\n     del self.data[wr.key]\n  self._remove = remove\n  \n  self._pending_removals = []\n  self._iterating = set()\n  self.data = d = {}\n  self.update(*args, **kw)\n  \n def _commit_removals(self):\n  l = self._pending_removals\n  d = self.data\n  \n  \n  while l:\n   del d[l.pop()]\n   \n def __getitem__(self, key):\n  o = self.data[key]()\n  if o is None:\n   raise KeyError(key)\n  else:\n   return o\n   \n def __delitem__(self, key):\n  if self._pending_removals:\n   self._commit_removals()\n  del self.data[key]\n  \n def __len__(self):\n  return len(self.data) - len(self._pending_removals)\n  \n def __contains__(self, key):\n  try:\n   o = self.data[key]()\n  except KeyError:\n   return False\n  return o is not None\n  \n def __repr__(self):\n  return \"<WeakValueDictionary at %s>\" % id(self)\n  \n def __setitem__(self, key, value):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data[key] = KeyedRef(value, self._remove, key)\n  \n def copy(self):\n  new = WeakValueDictionary()\n  for key, wr in self.data.items():\n   o = wr()\n   if o is not None:\n    new[key] = o\n  return new\n  \n __copy__ = copy\n \n def __deepcopy__(self, memo):\n  from copy import deepcopy\n  new = self.__class__()\n  for key, wr in self.data.items():\n   o = wr()\n   if o is not None:\n    new[deepcopy(key, memo)] = o\n  return new\n  \n def get(self, key, default=None):\n  try:\n   wr = self.data[key]\n  except KeyError:\n   return default\n  else:\n   o = wr()\n   if o is None:\n   \n    return default\n   else:\n    return o\n    \n def items(self):\n  with _IterationGuard(self):\n   for k, wr in self.data.items():\n    v = wr()\n    if v is not None:\n     yield k, v\n     \n def keys(self):\n  with _IterationGuard(self):\n   for k, wr in self.data.items():\n    if wr() is not None:\n     yield k\n     \n __iter__ = keys\n \n def itervaluerefs(self):\n  \"\"\n  with _IterationGuard(self):\n   for wr in self.data.values():\n    yield wr\n    \n def values(self):\n  with _IterationGuard(self):\n   for wr in self.data.values():\n    obj = wr()\n    if obj is not None:\n     yield obj\n     \n def popitem(self):\n  if self._pending_removals:\n   self._commit_removals()\n  while True:\n   key, wr = self.data.popitem()\n   o = wr()\n   if o is not None:\n    return key, o\n    \n def pop(self, key, *args):\n  if self._pending_removals:\n   self._commit_removals()\n  try:\n   o = self.data.pop(key)()\n  except KeyError:\n   if args:\n    return args[0]\n   raise\n  if o is None:\n   raise KeyError(key)\n  else:\n   return o\n   \n def setdefault(self, key, default=None):\n  try:\n   wr = self.data[key]\n  except KeyError:\n   if self._pending_removals:\n    self._commit_removals()\n   self.data[key] = KeyedRef(default, self._remove, key)\n   return default\n  else:\n   return wr()\n   \n def update(self, dict=None, **kwargs):\n  if self._pending_removals:\n   self._commit_removals()\n  d = self.data\n  if dict is not None:\n   if not hasattr(dict, \"items\"):\n    dict = type({})(dict)\n   for key, o in dict.items():\n    d[key] = KeyedRef(o, self._remove, key)\n  if len(kwargs):\n   self.update(kwargs)\n   \n def valuerefs(self):\n  \"\"\n  return list(self.data.values())\n  \n  \nclass KeyedRef(ref):\n \"\"\n \n __slots__ = \"key\",\n \n def __new__(type, ob, callback, key):\n  self = ref.__new__(type, ob, callback)\n  self.key = key\n  return self\n  \n def __init__(self, ob, callback, key):\n  super().__init__(ob, callback)\n  \n  \nclass WeakKeyDictionary(collections.MutableMapping):\n \"\"\n \n def __init__(self, dict=None):\n  self.data = {}\n  def remove(k, selfref=ref(self)):\n   self = selfref()\n   if self is not None:\n    if self._iterating:\n     self._pending_removals.append(k)\n    else:\n     del self.data[k]\n  self._remove = remove\n  \n  self._pending_removals = []\n  self._iterating = set()\n  if dict is not None:\n   self.update(dict)\n   \n def _commit_removals(self):\n \n \n \n \n  l = self._pending_removals\n  d = self.data\n  while l:\n   try:\n    del d[l.pop()]\n   except KeyError:\n    pass\n    \n def __delitem__(self, key):\n  del self.data[ref(key)]\n  \n def __getitem__(self, key):\n  return self.data[ref(key)]\n  \n def __len__(self):\n  return len(self.data) - len(self._pending_removals)\n  \n def __repr__(self):\n  return \"<WeakKeyDictionary at %s>\" % id(self)\n  \n def __setitem__(self, key, value):\n  self.data[ref(key, self._remove)] = value\n  \n def copy(self):\n  new = WeakKeyDictionary()\n  for key, value in self.data.items():\n   o = key()\n   if o is not None:\n    new[o] = value\n  return new\n  \n __copy__ = copy\n \n def __deepcopy__(self, memo):\n  from copy import deepcopy\n  new = self.__class__()\n  for key, value in self.data.items():\n   o = key()\n   if o is not None:\n    new[o] = deepcopy(value, memo)\n  return new\n  \n def get(self, key, default=None):\n  return self.data.get(ref(key),default)\n  \n def __contains__(self, key):\n  try:\n   wr = ref(key)\n  except TypeError:\n   return False\n  return wr in self.data\n  \n def items(self):\n  with _IterationGuard(self):\n   for wr, value in self.data.items():\n    key = wr()\n    if key is not None:\n     yield key, value\n     \n def keys(self):\n  with _IterationGuard(self):\n   for wr in self.data:\n    obj = wr()\n    if obj is not None:\n     yield obj\n     \n __iter__ = keys\n \n def values(self):\n  with _IterationGuard(self):\n   for wr, value in self.data.items():\n    if wr() is not None:\n     yield value\n     \n def keyrefs(self):\n  \"\"\n  return list(self.data)\n  \n def popitem(self):\n  while True:\n   key, value = self.data.popitem()\n   o = key()\n   if o is not None:\n    return o, value\n    \n def pop(self, key, *args):\n  return self.data.pop(ref(key), *args)\n  \n def setdefault(self, key, default=None):\n  return self.data.setdefault(ref(key, self._remove),default)\n  \n def update(self, dict=None, **kwargs):\n  d = self.data\n  if dict is not None:\n   if not hasattr(dict, \"items\"):\n    dict = type({})(dict)\n   for key, value in dict.items():\n    d[ref(key, self._remove)] = value\n  if len(kwargs):\n   self.update(kwargs)\n"], "xml.etree.ElementPath": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport re\n\nxpath_tokenizer_re = re.compile(\n\"(\"\n\"'[^']*'|\\\"[^\\\"]*\\\"|\"\n\"::|\"\n\"//?|\"\n\"\\.\\.|\"\n\"\\(\\)|\"\n\"[/.*:\\[\\]\\(\\)@=])|\"\n\"((?:\\{[^}]+\\})?[^/\\[\\]\\(\\)@=\\s]+)|\"\n\"\\s+\"\n)\n\ndef xpath_tokenizer(pattern, namespaces=None):\n for token in xpath_tokenizer_re.findall(pattern):\n  tag = token[1]\n  if tag and tag[0] != \"{\" and \":\" in tag:\n   try:\n    prefix, uri = tag.split(\":\", 1)\n    if not namespaces:\n     raise KeyError\n    yield token[0], \"{%s}%s\" % (namespaces[prefix], uri)\n   except KeyError:\n    raise SyntaxError(\"prefix %r not found in prefix map\" % prefix)\n  else:\n   yield token\n   \ndef get_parent_map(context):\n parent_map = context.parent_map\n if parent_map is None:\n  context.parent_map = parent_map = {}\n  for p in context.root.iter():\n   for e in p:\n    parent_map[e] = p\n return parent_map\n \ndef prepare_child(next, token):\n tag = token[1]\n def select(context, result):\n  for elem in result:\n   for e in elem:\n    if e.tag == tag:\n     yield e\n return select\n \ndef prepare_star(next, token):\n def select(context, result):\n  for elem in result:\n   for e in elem:\n    yield e\n return select\n \ndef prepare_self(next, token):\n def select(context, result):\n  for elem in result:\n   yield elem\n return select\n \ndef prepare_descendant(next, token):\n token = next()\n if token[0] == \"*\":\n  tag = \"*\"\n elif not token[0]:\n  tag = token[1]\n else:\n  raise SyntaxError(\"invalid descendant\")\n def select(context, result):\n  for elem in result:\n   for e in elem.iter(tag):\n    if e is not elem:\n     yield e\n return select\n \ndef prepare_parent(next, token):\n def select(context, result):\n \n  parent_map = get_parent_map(context)\n  result_map = {}\n  for elem in result:\n   if elem in parent_map:\n    parent = parent_map[elem]\n    if parent not in result_map:\n     result_map[parent] = None\n     yield parent\n return select\n \ndef prepare_predicate(next, token):\n\n\n\n signature = []\n predicate = []\n while 1:\n  token = next()\n  if token[0] == \"]\":\n   break\n  if token[0] and token[0][:1] in \"'\\\"\":\n   token = \"'\", token[0][1:-1]\n  signature.append(token[0] or \"-\")\n  predicate.append(token[1])\n signature = \"\".join(signature)\n \n if signature == \"@-\":\n \n  key = predicate[1]\n  def select(context, result):\n   for elem in result:\n    if elem.get(key) is not None:\n     yield elem\n  return select\n if signature == \"@-='\":\n \n  key = predicate[1]\n  value = predicate[-1]\n  def select(context, result):\n   for elem in result:\n    if elem.get(key) == value:\n     yield elem\n  return select\n if signature == \"-\" and not re.match(\"\\d+$\", predicate[0]):\n \n  tag = predicate[0]\n  def select(context, result):\n   for elem in result:\n    if elem.find(tag) is not None:\n     yield elem\n  return select\n if signature == \"-='\" and not re.match(\"\\d+$\", predicate[0]):\n \n  tag = predicate[0]\n  value = predicate[-1]\n  def select(context, result):\n   for elem in result:\n    for e in elem.findall(tag):\n     if \"\".join(e.itertext()) == value:\n      yield elem\n      break\n  return select\n if signature == \"-\" or signature == \"-()\" or signature == \"-()-\":\n \n  if signature == \"-\":\n   index = int(predicate[0]) - 1\n  else:\n   if predicate[0] != \"last\":\n    raise SyntaxError(\"unsupported function\")\n   if signature == \"-()-\":\n    try:\n     index = int(predicate[2]) - 1\n    except ValueError:\n     raise SyntaxError(\"unsupported expression\")\n   else:\n    index = -1\n  def select(context, result):\n   parent_map = get_parent_map(context)\n   for elem in result:\n    try:\n     parent = parent_map[elem]\n     \n     elems = list(parent.findall(elem.tag))\n     if elems[index] is elem:\n      yield elem\n    except (IndexError, KeyError):\n     pass\n  return select\n raise SyntaxError(\"invalid predicate\")\n \nops = {\n\"\": prepare_child,\n\"*\": prepare_star,\n\".\": prepare_self,\n\"..\": prepare_parent,\n\"//\": prepare_descendant,\n\"[\": prepare_predicate,\n}\n\n_cache = {}\n\nclass _SelectorContext:\n parent_map = None\n def __init__(self, root):\n  self.root = root\n  \n  \n  \n  \n  \n  \ndef iterfind(elem, path, namespaces=None):\n\n if path[-1:] == \"/\":\n  path = path + \"*\" \n try:\n  selector = _cache[path]\n except KeyError:\n  if len(_cache) > 100:\n   _cache.clear()\n  if path[:1] == \"/\":\n   raise SyntaxError(\"cannot use absolute path on element\")\n  next = iter(xpath_tokenizer(path, namespaces)).__next__\n  token = next()\n  selector = []\n  while 1:\n   try:\n    selector.append(ops[token[0]](next, token))\n   except StopIteration:\n    raise SyntaxError(\"invalid path\")\n   try:\n    token = next()\n    if token[0] == \"/\":\n     token = next()\n   except StopIteration:\n    break\n  _cache[path] = selector\n  \n result = [elem]\n context = _SelectorContext(elem)\n for select in selector:\n  result = select(context, result)\n return result\n \n \n \n \ndef find(elem, path, namespaces=None):\n try:\n  return next(iterfind(elem, path, namespaces))\n except StopIteration:\n  return None\n  \n  \n  \n  \ndef findall(elem, path, namespaces=None):\n return list(iterfind(elem, path, namespaces))\n \n \n \n \ndef findtext(elem, path, default=None, namespaces=None):\n try:\n  elem = next(iterfind(elem, path, namespaces))\n  return elem.text or \"\"\n except StopIteration:\n  return default\n"], "_weakrefset": [".py", "\n\n\n\nfrom _weakref import ref\n\n__all__ = ['WeakSet']\n\n\nclass _IterationGuard:\n\n\n\n\n\n def __init__(self, weakcontainer):\n \n  self.weakcontainer = ref(weakcontainer)\n  \n def __enter__(self):\n  w = self.weakcontainer()\n  if w is not None:\n   w._iterating.add(self)\n  return self\n  \n def __exit__(self, e, t, b):\n  w = self.weakcontainer()\n  if w is not None:\n   s = w._iterating\n   s.remove(self)\n   if not s:\n    w._commit_removals()\n    \n    \nclass WeakSet:\n def __init__(self, data=None):\n  self.data = set()\n  def _remove(item, selfref=ref(self)):\n   self = selfref()\n   if self is not None:\n    if self._iterating:\n     self._pending_removals.append(item)\n    else:\n     self.data.discard(item)\n  self._remove = _remove\n  \n  self._pending_removals = []\n  self._iterating = set()\n  if data is not None:\n   self.update(data)\n   \n def _commit_removals(self):\n  l = self._pending_removals\n  discard = self.data.discard\n  while l:\n   discard(l.pop())\n   \n def __iter__(self):\n  with _IterationGuard(self):\n   for itemref in self.data:\n    item = itemref()\n    if item is not None:\n     yield item\n     \n def __len__(self):\n  return len(self.data) - len(self._pending_removals)\n  \n def __contains__(self, item):\n  try:\n   wr = ref(item)\n  except TypeError:\n   return False\n  return wr in self.data\n  \n def __reduce__(self):\n  return (self.__class__, (list(self),),\n  getattr(self, '__dict__', None))\n  \n def add(self, item):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.add(ref(item, self._remove))\n  \n def clear(self):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.clear()\n  \n def copy(self):\n  return self.__class__(self)\n  \n def pop(self):\n  if self._pending_removals:\n   self._commit_removals()\n  while True:\n   try:\n    itemref = self.data.pop()\n   except KeyError:\n    raise KeyError('pop from empty WeakSet')\n   item = itemref()\n   if item is not None:\n    return item\n    \n def remove(self, item):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.remove(ref(item))\n  \n def discard(self, item):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.discard(ref(item))\n  \n def update(self, other):\n  if self._pending_removals:\n   self._commit_removals()\n  for element in other:\n   self.add(element)\n   \n def __ior__(self, other):\n  self.update(other)\n  return self\n  \n def difference(self, other):\n  newset = self.copy()\n  newset.difference_update(other)\n  return newset\n __sub__ = difference\n \n def difference_update(self, other):\n  self.__isub__(other)\n def __isub__(self, other):\n  if self._pending_removals:\n   self._commit_removals()\n  if self is other:\n   self.data.clear()\n  else:\n   self.data.difference_update(ref(item) for item in other)\n  return self\n  \n def intersection(self, other):\n  return self.__class__(item for item in other if item in self)\n __and__ = intersection\n \n def intersection_update(self, other):\n  self.__iand__(other)\n def __iand__(self, other):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.intersection_update(ref(item) for item in other)\n  return self\n  \n def issubset(self, other):\n  return self.data.issubset(ref(item) for item in other)\n __le__ = issubset\n \n def __lt__(self, other):\n  return self.data < set(ref(item) for item in other)\n  \n def issuperset(self, other):\n  return self.data.issuperset(ref(item) for item in other)\n __ge__ = issuperset\n \n def __gt__(self, other):\n  return self.data > set(ref(item) for item in other)\n  \n def __eq__(self, other):\n  if not isinstance(other, self.__class__):\n   return NotImplemented\n  return self.data == set(ref(item) for item in other)\n  \n def symmetric_difference(self, other):\n  newset = self.copy()\n  newset.symmetric_difference_update(other)\n  return newset\n __xor__ = symmetric_difference\n \n def symmetric_difference_update(self, other):\n  self.__ixor__(other)\n def __ixor__(self, other):\n  if self._pending_removals:\n   self._commit_removals()\n  if self is other:\n   self.data.clear()\n  else:\n   self.data.symmetric_difference_update(ref(item, self._remove) for item in other)\n  return self\n  \n def union(self, other):\n  return self.__class__(e for s in (self, other) for e in s)\n __or__ = union\n \n def isdisjoint(self, other):\n  return len(self.intersection(other)) == 0\n"], "importlib._bootstrap": [".py", "\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_CASE_INSENSITIVE_PLATFORMS = 'win', 'cygwin', 'darwin'\n\n\ndef _make_relax_case():\n if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):\n  def _relax_case():\n   \"\"\n   return b'PYTHONCASEOK' in _os.environ\n else:\n  def _relax_case():\n   \"\"\n   return False\n return _relax_case\n \n \n \ndef _w_long(x):\n \"\"\n x = int(x)\n int_bytes = []\n int_bytes.append(x & 0xFF)\n int_bytes.append((x >> 8) & 0xFF)\n int_bytes.append((x >> 16) & 0xFF)\n int_bytes.append((x >> 24) & 0xFF)\n return bytearray(int_bytes)\n \n \n \ndef _r_long(int_bytes):\n \"\"\n x = int_bytes[0]\n x |= int_bytes[1] << 8\n x |= int_bytes[2] << 16\n x |= int_bytes[3] << 24\n return x\n \n \ndef _path_join(*path_parts):\n \"\"\n new_parts = []\n for part in path_parts:\n  if not part:\n   continue\n  new_parts.append(part)\n  if part[-1] not in path_separators:\n   new_parts.append(path_sep)\n return ''.join(new_parts[:-1]) \n \n \ndef _path_split(path):\n \"\"\n for x in reversed(path):\n  if x in path_separators:\n   sep = x\n   break\n else:\n  sep = path_sep\n front, _, tail = path.rpartition(sep)\n return front, tail\n \n \ndef _path_is_mode_type(path, mode):\n \"\"\n try:\n  stat_info = _os.stat(path)\n except OSError:\n  return False\n return (stat_info.st_mode & 0o170000) == mode\n \n \n \ndef _path_isfile(path):\n \"\"\n return _path_is_mode_type(path, 0o100000)\n \n \n \ndef _path_isdir(path):\n \"\"\n if not path:\n  path = _os.getcwd()\n return _path_is_mode_type(path, 0o040000)\n \n \ndef _write_atomic(path, data, mode=0o666):\n \"\"\n \n path_tmp = '{}.{}'.format(path, id(path))\n fd = _os.open(path_tmp,\n _os.O_EXCL | _os.O_CREAT | _os.O_WRONLY, mode & 0o666)\n try:\n \n \n  with _io.FileIO(fd, 'wb') as file:\n   file.write(data)\n  _os.replace(path_tmp, path)\n except OSError:\n  try:\n   _os.unlink(path_tmp)\n  except OSError:\n   pass\n  raise\n  \n  \ndef _wrap(new, old):\n \"\"\n for replace in ['__module__', '__name__', '__qualname__', '__doc__']:\n  if hasattr(old, replace):\n   setattr(new, replace, getattr(old, replace))\n new.__dict__.update(old.__dict__)\n \n \n_code_type = type(_wrap.__code__)\n\n\ndef new_module(name):\n \"\"\n return type(_io)(name)\n \n \n \n \n \n_module_locks = {}\n\n_blocking_on = {}\n\n\nclass _DeadlockError(RuntimeError):\n pass\n \n \nclass _ModuleLock:\n \"\"\n \n def __init__(self, name):\n  self.lock = _thread.allocate_lock()\n  self.wakeup = _thread.allocate_lock()\n  self.name = name\n  self.owner = None\n  self.count = 0\n  self.waiters = 0\n  \n def has_deadlock(self):\n \n  me = _thread.get_ident()\n  tid = self.owner\n  while True:\n   lock = _blocking_on.get(tid)\n   if lock is None:\n    return False\n   tid = lock.owner\n   if tid == me:\n    return True\n    \n def acquire(self):\n  \"\"\n  tid = _thread.get_ident()\n  _blocking_on[tid] = self\n  try:\n   while True:\n    with self.lock:\n     if self.count == 0 or self.owner == tid:\n      self.owner = tid\n      self.count += 1\n      return True\n     if self.has_deadlock():\n      raise _DeadlockError(\"deadlock detected by %r\" % self)\n     if self.wakeup.acquire(False):\n      self.waiters += 1\n      \n    self.wakeup.acquire()\n    self.wakeup.release()\n  finally:\n   del _blocking_on[tid]\n   \n def release(self):\n  tid = _thread.get_ident()\n  with self.lock:\n   if self.owner != tid:\n    raise RuntimeError(\"cannot release un-acquired lock\")\n   assert self.count > 0\n   self.count -= 1\n   if self.count == 0:\n    self.owner = None\n    if self.waiters:\n     self.waiters -= 1\n     self.wakeup.release()\n     \n def __repr__(self):\n  return \"_ModuleLock(%r) at %d\" % (self.name, id(self))\n  \n  \nclass _DummyModuleLock:\n \"\"\n \n def __init__(self, name):\n  self.name = name\n  self.count = 0\n  \n def acquire(self):\n  self.count += 1\n  return True\n  \n def release(self):\n  if self.count == 0:\n   raise RuntimeError(\"cannot release un-acquired lock\")\n  self.count -= 1\n  \n def __repr__(self):\n  return \"_DummyModuleLock(%r) at %d\" % (self.name, id(self))\n  \n  \n  \n  \ndef _get_module_lock(name):\n \"\"\n lock = None\n try:\n  lock = _module_locks[name]()\n except KeyError:\n  pass\n if lock is None:\n  if _thread is None:\n   lock = _DummyModuleLock(name)\n  else:\n   lock = _ModuleLock(name)\n  def cb(_):\n   del _module_locks[name]\n  _module_locks[name] = _weakref.ref(lock, cb)\n return lock\n \ndef _lock_unlock_module(name):\n \"\"\n lock = _get_module_lock(name)\n _imp.release_lock()\n try:\n  lock.acquire()\n except _DeadlockError:\n \n \n  pass\n else:\n  lock.release()\n  \n  \n  \ndef _call_with_frames_removed(f, *args, **kwds):\n \"\"\n return f(*args, **kwds)\n \n \n \n \n\"\"\n_RAW_MAGIC_NUMBER = 3230 | ord('\\r') << 16 | ord('\\n') << 24\n_MAGIC_BYTES = bytes(_RAW_MAGIC_NUMBER >> n & 0xff for n in range(0, 25, 8))\n\n_PYCACHE = '__pycache__'\n\nSOURCE_SUFFIXES = ['.py'] \n\nDEBUG_BYTECODE_SUFFIXES = ['.pyc']\nOPTIMIZED_BYTECODE_SUFFIXES = ['.pyo']\n\ndef cache_from_source(path, debug_override=None):\n \"\"\n debug = not sys.flags.optimize if debug_override is None else debug_override\n if debug:\n  suffixes = DEBUG_BYTECODE_SUFFIXES\n else:\n  suffixes = OPTIMIZED_BYTECODE_SUFFIXES\n head, tail = _path_split(path)\n base_filename, sep, _ = tail.partition('.')\n tag = sys.implementation.cache_tag\n if tag is None:\n  raise NotImplementedError('sys.implementation.cache_tag is None')\n filename = ''.join([base_filename, sep, tag, suffixes[0]])\n return _path_join(head, _PYCACHE, filename)\n \n \ndef source_from_cache(path):\n \"\"\n if sys.implementation.cache_tag is None:\n  raise NotImplementedError('sys.implementation.cache_tag is None')\n head, pycache_filename = _path_split(path)\n head, pycache = _path_split(head)\n if pycache != _PYCACHE:\n  raise ValueError('{} not bottom-level directory in '\n  '{!r}'.format(_PYCACHE, path))\n if pycache_filename.count('.') != 2:\n  raise ValueError('expected only 2 dots in '\n  '{!r}'.format(pycache_filename))\n base_filename = pycache_filename.partition('.')[0]\n return _path_join(head, base_filename + SOURCE_SUFFIXES[0])\n \n \ndef _get_sourcefile(bytecode_path):\n \"\"\n if len(bytecode_path) == 0:\n  return None\n rest, _, extension = bytecode_path.rpartition('.')\n if not rest or extension.lower()[-3:-1] != 'py':\n  return bytecode_path\n try:\n  source_path = source_from_cache(bytecode_path)\n except (NotImplementedError, ValueError):\n  source_path = bytecode_path[:-1]\n return source_path if _path_isfile(source_path) else bytecode_path\n \n \ndef _verbose_message(message, *args, verbosity=1):\n \"\"\n if sys.flags.verbose >= verbosity:\n  if not message.startswith(('#', 'import ')):\n   message = '# ' + message\n  print(message.format(*args), file=sys.stderr)\n  \n  \ndef set_package(fxn):\n \"\"\n def set_package_wrapper(*args, **kwargs):\n  module = fxn(*args, **kwargs)\n  if getattr(module, '__package__', None) is None:\n   module.__package__ = module.__name__\n   if not hasattr(module, '__path__'):\n    module.__package__ = module.__package__.rpartition('.')[0]\n  return module\n _wrap(set_package_wrapper, fxn)\n return set_package_wrapper\n \n \ndef set_loader(fxn):\n \"\"\n def set_loader_wrapper(self, *args, **kwargs):\n  module = fxn(self, *args, **kwargs)\n  if not hasattr(module, '__loader__'):\n   module.__loader__ = self\n  return module\n _wrap(set_loader_wrapper, fxn)\n return set_loader_wrapper\n \n \ndef module_for_loader(fxn):\n \"\"\n def module_for_loader_wrapper(self, fullname, *args, **kwargs):\n  module = sys.modules.get(fullname)\n  is_reload = module is not None\n  if not is_reload:\n  \n  \n  \n   module = new_module(fullname)\n   \n   \n   module.__initializing__ = True\n   sys.modules[fullname] = module\n   module.__loader__ = self\n   try:\n    is_package = self.is_package(fullname)\n   except (ImportError, AttributeError):\n    pass\n   else:\n    if is_package:\n     module.__package__ = fullname\n    else:\n     module.__package__ = fullname.rpartition('.')[0]\n  else:\n   module.__initializing__ = True\n  try:\n  \n   return fxn(self, module, *args, **kwargs)\n  except:\n   if not is_reload:\n    del sys.modules[fullname]\n   raise\n  finally:\n   module.__initializing__ = False\n _wrap(module_for_loader_wrapper, fxn)\n return module_for_loader_wrapper\n \n \ndef _check_name(method):\n \"\"\n def _check_name_wrapper(self, name=None, *args, **kwargs):\n  if name is None:\n   name = self.name\n  elif self.name != name:\n   raise ImportError(\"loader cannot handle %s\" % name, name=name)\n  return method(self, name, *args, **kwargs)\n _wrap(_check_name_wrapper, method)\n return _check_name_wrapper\n \n \ndef _requires_builtin(fxn):\n \"\"\n def _requires_builtin_wrapper(self, fullname):\n  if fullname not in sys.builtin_module_names:\n   raise ImportError(\"{} is not a built-in module\".format(fullname),\n   name=fullname)\n  return fxn(self, fullname)\n _wrap(_requires_builtin_wrapper, fxn)\n return _requires_builtin_wrapper\n \n \ndef _requires_frozen(fxn):\n \"\"\n def _requires_frozen_wrapper(self, fullname):\n  if not _imp.is_frozen(fullname):\n   raise ImportError(\"{} is not a frozen module\".format(fullname),\n   name=fullname)\n  return fxn(self, fullname)\n _wrap(_requires_frozen_wrapper, fxn)\n return _requires_frozen_wrapper\n \n \ndef _find_module_shim(self, fullname):\n \"\"\n \n \n \n loader, portions = self.find_loader(fullname)\n if loader is None and len(portions):\n  msg = \"Not importing directory {}: missing __init__\"\n  _warnings.warn(msg.format(portions[0]), ImportWarning)\n return loader\n \n \n \n \n \n \nclass BuiltinImporter:\n\n \"\"\n \n @classmethod\n def module_repr(cls, module):\n  return \"<module '{}' (built-in)>\".format(module.__name__)\n  \n @classmethod\n def find_module(cls, fullname, path=None):\n  \"\"\n  if path is not None:\n   return None\n  return cls if _imp.is_builtin(fullname) else None\n  \n @classmethod\n @set_package\n @set_loader\n @_requires_builtin\n def load_module(cls, fullname):\n  \"\"\n  is_reload = fullname in sys.modules\n  try:\n   return _call_with_frames_removed(_imp.init_builtin, fullname)\n  except:\n   if not is_reload and fullname in sys.modules:\n    del sys.modules[fullname]\n   raise\n   \n @classmethod\n @_requires_builtin\n def get_code(cls, fullname):\n  \"\"\n  return None\n  \n @classmethod\n @_requires_builtin\n def get_source(cls, fullname):\n  \"\"\n  return None\n  \n @classmethod\n @_requires_builtin\n def is_package(cls, fullname):\n  \"\"\n  return False\n  \n  \nclass FrozenImporter:\n\n \"\"\n \n @classmethod\n def module_repr(cls, m):\n  return \"<module '{}' (frozen)>\".format(m.__name__)\n  \n @classmethod\n def find_module(cls, fullname, path=None):\n  \"\"\n  return cls if _imp.is_frozen(fullname) else None\n  \n @classmethod\n @set_package\n @set_loader\n @_requires_frozen\n def load_module(cls, fullname):\n  \"\"\n  is_reload = fullname in sys.modules\n  try:\n   m = _call_with_frames_removed(_imp.init_frozen, fullname)\n   \n   del m.__file__\n   return m\n  except:\n   if not is_reload and fullname in sys.modules:\n    del sys.modules[fullname]\n   raise\n   \n @classmethod\n @_requires_frozen\n def get_code(cls, fullname):\n  \"\"\n  return _imp.get_frozen_object(fullname)\n  \n @classmethod\n @_requires_frozen\n def get_source(cls, fullname):\n  \"\"\n  return None\n  \n @classmethod\n @_requires_frozen\n def is_package(cls, fullname):\n  \"\"\n  return _imp.is_frozen_package(fullname)\n  \n  \nclass WindowsRegistryFinder:\n\n \"\"\n \n REGISTRY_KEY = (\n \"Software\\\\Python\\\\PythonCore\\\\{sys_version}\"\n \"\\\\Modules\\\\{fullname}\")\n REGISTRY_KEY_DEBUG = (\n \"Software\\\\Python\\\\PythonCore\\\\{sys_version}\"\n \"\\\\Modules\\\\{fullname}\\\\Debug\")\n DEBUG_BUILD = False \n \n @classmethod\n def _open_registry(cls, key):\n  try:\n   return _winreg.OpenKey(_winreg.HKEY_CURRENT_USER, key)\n  except WindowsError:\n   return _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, key)\n   \n @classmethod\n def _search_registry(cls, fullname):\n  if cls.DEBUG_BUILD:\n   registry_key = cls.REGISTRY_KEY_DEBUG\n  else:\n   registry_key = cls.REGISTRY_KEY\n  key = registry_key.format(fullname=fullname,\n  sys_version=sys.version[:3])\n  try:\n   with cls._open_registry(key) as hkey:\n    filepath = _winreg.QueryValue(hkey, \"\")\n  except WindowsError:\n   return None\n  return filepath\n  \n @classmethod\n def find_module(cls, fullname, path=None):\n  \"\"\n  filepath = cls._search_registry(fullname)\n  if filepath is None:\n   return None\n  try:\n   _os.stat(filepath)\n  except OSError:\n   return None\n  for loader, suffixes in _get_supported_file_loaders():\n   if filepath.endswith(tuple(suffixes)):\n    return loader(fullname, filepath)\n    \n    \nclass _LoaderBasics:\n\n \"\"\n \n def is_package(self, fullname):\n  \"\"\n  filename = _path_split(self.get_filename(fullname))[1]\n  filename_base = filename.rsplit('.', 1)[0]\n  tail_name = fullname.rpartition('.')[2]\n  return filename_base == '__init__' and tail_name != '__init__'\n  \n def _bytes_from_bytecode(self, fullname, data, bytecode_path, source_stats):\n  \"\"\n  magic = data[:4]\n  raw_timestamp = data[4:8]\n  raw_size = data[8:12]\n  if magic != _MAGIC_BYTES:\n   msg = 'bad magic number in {!r}: {!r}'.format(fullname, magic)\n   _verbose_message(msg)\n   raise ImportError(msg, name=fullname, path=bytecode_path)\n  elif len(raw_timestamp) != 4:\n   message = 'bad timestamp in {}'.format(fullname)\n   _verbose_message(message)\n   raise EOFError(message)\n  elif len(raw_size) != 4:\n   message = 'bad size in {}'.format(fullname)\n   _verbose_message(message)\n   raise EOFError(message)\n  if source_stats is not None:\n   try:\n    source_mtime = int(source_stats['mtime'])\n   except KeyError:\n    pass\n   else:\n    if _r_long(raw_timestamp) != source_mtime:\n     message = 'bytecode is stale for {}'.format(fullname)\n     _verbose_message(message)\n     raise ImportError(message, name=fullname,\n     path=bytecode_path)\n   try:\n    source_size = source_stats['size'] & 0xFFFFFFFF\n   except KeyError:\n    pass\n   else:\n    if _r_long(raw_size) != source_size:\n     raise ImportError(\n     \"bytecode is stale for {}\".format(fullname),\n     name=fullname, path=bytecode_path)\n     \n     \n  return data[12:]\n  \n @module_for_loader\n def _load_module(self, module, *, sourceless=False):\n  \"\"\n  name = module.__name__\n  code_object = self.get_code(name)\n  module.__file__ = self.get_filename(name)\n  if not sourceless:\n   try:\n    module.__cached__ = cache_from_source(module.__file__)\n   except NotImplementedError:\n    module.__cached__ = module.__file__\n  else:\n   module.__cached__ = module.__file__\n  module.__package__ = name\n  if self.is_package(name):\n   module.__path__ = [_path_split(module.__file__)[0]]\n  else:\n   module.__package__ = module.__package__.rpartition('.')[0]\n  module.__loader__ = self\n  _call_with_frames_removed(exec, code_object, module.__dict__)\n  return module\n  \n  \nclass SourceLoader(_LoaderBasics):\n\n def path_mtime(self, path):\n  \"\"\n  raise NotImplementedError\n  \n def path_stats(self, path):\n  \"\"\n  return {'mtime': self.path_mtime(path)}\n  \n def _cache_bytecode(self, source_path, cache_path, data):\n  \"\"\n  \n  return self.set_data(cache_path, data)\n  \n def set_data(self, path, data):\n  \"\"\n  raise NotImplementedError\n  \n  \n def get_source(self, fullname):\n  \"\"\n  import tokenize\n  path = self.get_filename(fullname)\n  try:\n   source_bytes = self.get_data(path)\n  except IOError as exc:\n   raise ImportError(\"source not available through get_data()\",\n   name=fullname) from exc\n  readsource = _io.BytesIO(source_bytes).readline\n  try:\n   encoding = tokenize.detect_encoding(readsource)\n  except SyntaxError as exc:\n   raise ImportError(\"Failed to detect encoding\",\n   name=fullname) from exc\n  newline_decoder = _io.IncrementalNewlineDecoder(None, True)\n  try:\n   return newline_decoder.decode(source_bytes.decode(encoding[0]))\n  except UnicodeDecodeError as exc:\n   raise ImportError(\"Failed to decode source file\",\n   name=fullname) from exc\n   \n def get_code(self, fullname):\n  \"\"\n  source_path = self.get_filename(fullname)\n  source_mtime = None\n  try:\n   bytecode_path = cache_from_source(source_path)\n  except NotImplementedError:\n   bytecode_path = None\n  else:\n   try:\n    st = self.path_stats(source_path)\n   except NotImplementedError:\n    pass\n   else:\n    source_mtime = int(st['mtime'])\n    try:\n     data = self.get_data(bytecode_path)\n    except IOError:\n     pass\n    else:\n     try:\n      bytes_data = self._bytes_from_bytecode(fullname, data,\n      bytecode_path,\n      st)\n     except (ImportError, EOFError):\n      pass\n     else:\n      _verbose_message('{} matches {}', bytecode_path,\n      source_path)\n      found = marshal.loads(bytes_data)\n      if isinstance(found, _code_type):\n       _imp._fix_co_filename(found, source_path)\n       _verbose_message('code object from {}',\n       bytecode_path)\n       return found\n      else:\n       msg = \"Non-code object in {}\"\n       raise ImportError(msg.format(bytecode_path),\n       name=fullname, path=bytecode_path)\n  source_bytes = self.get_data(source_path)\n  code_object = _call_with_frames_removed(compile,\n  source_bytes, source_path, 'exec',\n  dont_inherit=True)\n  _verbose_message('code object from {}', source_path)\n  if (not sys.dont_write_bytecode and bytecode_path is not None and\n  source_mtime is not None):\n   data = bytearray(_MAGIC_BYTES)\n   data.extend(_w_long(source_mtime))\n   data.extend(_w_long(len(source_bytes)))\n   data.extend(marshal.dumps(code_object))\n   try:\n    self._cache_bytecode(source_path, bytecode_path, data)\n    _verbose_message('wrote {!r}', bytecode_path)\n   except NotImplementedError:\n    pass\n  return code_object\n  \n def load_module(self, fullname):\n  \"\"\n  return self._load_module(fullname)\n  \n  \nclass FileLoader:\n\n \"\"\n \n def __init__(self, fullname, path):\n  \"\"\n  self.name = fullname\n  self.path = path\n  \n @_check_name\n def load_module(self, fullname):\n  \"\"\n  \n  \n  return super(FileLoader, self).load_module(fullname)\n  \n @_check_name\n def get_filename(self, fullname):\n  \"\"\n  return self.path\n  \n def get_data(self, path):\n  \"\"\n  with _io.FileIO(path, 'r') as file:\n   return file.read()\n   \n   \nclass SourceFileLoader(FileLoader, SourceLoader):\n\n \"\"\n \n def path_stats(self, path):\n  \"\"\n  st = _os.stat(path)\n  return {'mtime': st.st_mtime, 'size': st.st_size}\n  \n def _cache_bytecode(self, source_path, bytecode_path, data):\n \n  try:\n   mode = _os.stat(source_path).st_mode\n  except OSError:\n   mode = 0o666\n   \n   \n  mode |= 0o200\n  return self.set_data(bytecode_path, data, _mode=mode)\n  \n def set_data(self, path, data, *, _mode=0o666):\n  \"\"\n  parent, filename = _path_split(path)\n  path_parts = []\n  \n  while parent and not _path_isdir(parent):\n   parent, part = _path_split(parent)\n   path_parts.append(part)\n   \n  for part in reversed(path_parts):\n   parent = _path_join(parent, part)\n   try:\n    _os.mkdir(parent)\n   except FileExistsError:\n   \n    continue\n   except OSError as exc:\n   \n   \n    _verbose_message('could not create {!r}: {!r}', parent, exc)\n    return\n  try:\n   _write_atomic(path, data, _mode)\n   _verbose_message('created {!r}', path)\n  except OSError as exc:\n  \n   _verbose_message('could not create {!r}: {!r}', path, exc)\n   \n   \nclass SourcelessFileLoader(FileLoader, _LoaderBasics):\n\n \"\"\n \n def load_module(self, fullname):\n  return self._load_module(fullname, sourceless=True)\n  \n def get_code(self, fullname):\n  path = self.get_filename(fullname)\n  data = self.get_data(path)\n  bytes_data = self._bytes_from_bytecode(fullname, data, path, None)\n  found = marshal.loads(bytes_data)\n  if isinstance(found, _code_type):\n   _verbose_message('code object from {!r}', path)\n   return found\n  else:\n   raise ImportError(\"Non-code object in {}\".format(path),\n   name=fullname, path=path)\n   \n def get_source(self, fullname):\n  \"\"\n  return None\n  \n  \n  \nEXTENSION_SUFFIXES = []\n\n\nclass ExtensionFileLoader:\n\n \"\"\n \n def __init__(self, name, path):\n  self.name = name\n  self.path = path\n  \n @_check_name\n @set_package\n @set_loader\n def load_module(self, fullname):\n  \"\"\n  is_reload = fullname in sys.modules\n  try:\n   module = _call_with_frames_removed(_imp.load_dynamic,\n   fullname, self.path)\n   _verbose_message('extension module loaded from {!r}', self.path)\n   if self.is_package(fullname) and not hasattr(module, '__path__'):\n    module.__path__ = [_path_split(self.path)[0]]\n   return module\n  except:\n   if not is_reload and fullname in sys.modules:\n    del sys.modules[fullname]\n   raise\n   \n def is_package(self, fullname):\n  \"\"\n  file_name = _path_split(self.path)[1]\n  return any(file_name == '__init__' + suffix\n  for suffix in EXTENSION_SUFFIXES)\n  \n def get_code(self, fullname):\n  \"\"\n  return None\n  \n def get_source(self, fullname):\n  \"\"\n  return None\n  \n  \nclass _NamespacePath:\n \"\"\n \n def __init__(self, name, path, path_finder):\n  self._name = name\n  self._path = path\n  self._last_parent_path = tuple(self._get_parent_path())\n  self._path_finder = path_finder\n  \n def _find_parent_path_names(self):\n  \"\"\n  parent, dot, me = self._name.rpartition('.')\n  if dot == '':\n  \n   return 'sys', 'path'\n   \n   \n  return parent, '__path__'\n  \n def _get_parent_path(self):\n  parent_module_name, path_attr_name = self._find_parent_path_names()\n  return getattr(sys.modules[parent_module_name], path_attr_name)\n  \n def _recalculate(self):\n \n  parent_path = tuple(self._get_parent_path()) \n  if parent_path != self._last_parent_path:\n   loader, new_path = self._path_finder(self._name, parent_path)\n   \n   \n   if loader is None:\n    self._path = new_path\n   self._last_parent_path = parent_path \n  return self._path\n  \n def __iter__(self):\n  return iter(self._recalculate())\n  \n def __len__(self):\n  return len(self._recalculate())\n  \n def __repr__(self):\n  return \"_NamespacePath({!r})\".format(self._path)\n  \n def __contains__(self, item):\n  return item in self._recalculate()\n  \n def append(self, item):\n  self._path.append(item)\n  \n  \nclass NamespaceLoader:\n def __init__(self, name, path, path_finder):\n  self._path = _NamespacePath(name, path, path_finder)\n  \n @classmethod\n def module_repr(cls, module):\n  return \"<module '{}' (namespace)>\".format(module.__name__)\n  \n @module_for_loader\n def load_module(self, module):\n  \"\"\n  _verbose_message('namespace module loaded with path {!r}', self._path)\n  module.__path__ = self._path\n  return module\n  \n  \n  \n  \nclass PathFinder:\n\n \"\"\n \n @classmethod\n def invalidate_caches(cls):\n  \"\"\n  for finder in sys.path_importer_cache.values():\n   if hasattr(finder, 'invalidate_caches'):\n    finder.invalidate_caches()\n    \n @classmethod\n def _path_hooks(cls, path):\n  \"\"\n  if not sys.path_hooks:\n   _warnings.warn('sys.path_hooks is empty', ImportWarning)\n  for hook in sys.path_hooks:\n   try:\n    return hook(path)\n   except ImportError:\n    continue\n  else:\n   return None\n   \n @classmethod\n def _path_importer_cache(cls, path):\n  \"\"\n  if path == '':\n   path = '.'\n  try:\n   finder = sys.path_importer_cache[path]\n  except KeyError:\n   finder = cls._path_hooks(path)\n   sys.path_importer_cache[path] = finder\n  return finder\n  \n @classmethod\n def _get_loader(cls, fullname, path):\n  \"\"\n  \n  \n  namespace_path = []\n  for entry in path:\n   if not isinstance(entry, (str, bytes)):\n    continue\n   finder = cls._path_importer_cache(entry)\n   if finder is not None:\n    if hasattr(finder, 'find_loader'):\n     loader, portions = finder.find_loader(fullname)\n    else:\n     loader = finder.find_module(fullname)\n     portions = []\n    if loader is not None:\n    \n     return loader, namespace_path\n     \n     \n     \n     \n    namespace_path.extend(portions)\n  else:\n   return None, namespace_path\n   \n @classmethod\n def find_module(cls, fullname, path=None):\n  \"\"\n  if path is None:\n   path = sys.path\n  loader, namespace_path = cls._get_loader(fullname, path)\n  if loader is not None:\n   return loader\n  else:\n   if namespace_path:\n   \n   \n    return NamespaceLoader(fullname, namespace_path, cls._get_loader)\n   else:\n    return None\n    \n    \nclass FileFinder:\n\n \"\"\n \n def __init__(self, path, *loader_details):\n  \"\"\n  loaders = []\n  for loader, suffixes in loader_details:\n   loaders.extend((suffix, loader) for suffix in suffixes)\n  self._loaders = loaders\n  \n  self.path = path or '.'\n  self._path_mtime = -1\n  self._path_cache = set()\n  self._relaxed_path_cache = set()\n  \n def invalidate_caches(self):\n  \"\"\n  self._path_mtime = -1\n  \n find_module = _find_module_shim\n \n def find_loader(self, fullname):\n  \"\"\n  is_namespace = False\n  tail_module = fullname.rpartition('.')[2]\n  try:\n   mtime = _os.stat(self.path).st_mtime\n  except OSError:\n   mtime = -1\n  if mtime != self._path_mtime:\n   self._fill_cache()\n   self._path_mtime = mtime\n   \n  if _relax_case():\n   cache = self._relaxed_path_cache\n   cache_module = tail_module.lower()\n  else:\n   cache = self._path_cache\n   cache_module = tail_module\n   \n  if cache_module in cache:\n   base_path = _path_join(self.path, tail_module)\n   if _path_isdir(base_path):\n    for suffix, loader in self._loaders:\n     init_filename = '__init__' + suffix\n     full_path = _path_join(base_path, init_filename)\n     if _path_isfile(full_path):\n      return (loader(fullname, full_path), [base_path])\n    else:\n    \n    \n     is_namespace = True\n     \n  for suffix, loader in self._loaders:\n   full_path = _path_join(self.path, tail_module + suffix)\n   _verbose_message('trying {}'.format(full_path), verbosity=2)\n   if cache_module + suffix in cache:\n    if _path_isfile(full_path):\n     return (loader(fullname, full_path), [])\n  if is_namespace:\n   _verbose_message('possible namespace for {}'.format(base_path))\n   return (None, [base_path])\n  return (None, [])\n  \n def _fill_cache(self):\n  \"\"\n  path = self.path\n  try:\n   contents = _os.listdir(path)\n  except (FileNotFoundError, PermissionError, NotADirectoryError):\n  \n  \n   contents = []\n   \n   \n  if not sys.platform.startswith('win'):\n   self._path_cache = set(contents)\n  else:\n  \n  \n  \n  \n  \n   lower_suffix_contents = set()\n   for item in contents:\n    name, dot, suffix = item.partition('.')\n    if dot:\n     new_name = '{}.{}'.format(name, suffix.lower())\n    else:\n     new_name = name\n    lower_suffix_contents.add(new_name)\n   self._path_cache = lower_suffix_contents\n  if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):\n   self._relaxed_path_cache = set(fn.lower() for fn in contents)\n   \n @classmethod\n def path_hook(cls, *loader_details):\n  \"\"\n  def path_hook_for_FileFinder(path):\n   \"\"\n   if not _path_isdir(path):\n    raise ImportError(\"only directories are supported\", path=path)\n   return cls(path, *loader_details)\n   \n  return path_hook_for_FileFinder\n  \n def __repr__(self):\n  return \"FileFinder(%r)\" % (self.path,)\n  \n  \n  \n  \nclass _ImportLockContext:\n\n \"\"\n \n def __enter__(self):\n  \"\"\n  _imp.acquire_lock()\n  \n def __exit__(self, exc_type, exc_value, exc_traceback):\n  \"\"\n  _imp.release_lock()\n  \n  \ndef _resolve_name(name, package, level):\n \"\"\n bits = package.rsplit('.', level - 1)\n if len(bits) < level:\n  raise ValueError('attempted relative import beyond top-level package')\n base = bits[0]\n return '{}.{}'.format(base, name) if name else base\n \n \ndef _find_module(name, path):\n \"\"\n if not sys.meta_path:\n  _warnings.warn('sys.meta_path is empty', ImportWarning)\n for finder in sys.meta_path:\n \n \n  loader = finder.find_module(name, path)\n  \n  if loader is not None:\n  \n   if name not in sys.modules:\n    return loader\n   else:\n    return sys.modules[name].__loader__\n else:\n  return None\n  \n  \ndef _sanity_check(name, package, level):\n \"\"\n if not isinstance(name, str):\n  raise TypeError(\"module name must be str, not {}\".format(type(name)))\n if level < 0:\n  raise ValueError('level must be >= 0')\n if package:\n  if not isinstance(package, str):\n   raise TypeError(\"__package__ not set to a string\")\n  elif package not in sys.modules:\n   msg = (\"Parent module {!r} not loaded, cannot perform relative \"\n   \"import\")\n   raise SystemError(msg.format(package))\n if not name and level == 0:\n  raise ValueError(\"Empty module name\")\n  \n  \n_ERR_MSG = 'No module named {!r}'\n\ndef _find_and_load_unlocked(name, import_):\n path = None\n parent = name.rpartition('.')[0]\n if parent:\n  if parent not in sys.modules:\n   _call_with_frames_removed(import_, parent)\n   \n  if name in sys.modules:\n   return sys.modules[name]\n   \n  parent_module = sys.modules[parent]\n  try:\n   path = parent_module.__path__\n  except AttributeError:\n   msg = (_ERR_MSG + '; {} is not a package').format(name, parent)\n   raise ImportError(msg, name=name)\n loader = _find_module(name, path)\n if loader is None:\n  exc = ImportError(_ERR_MSG.format(name), name=name)\n  \n  \n  exc._not_found = True\n  raise exc\n elif name not in sys.modules:\n \n  loader.load_module(name)\n  _verbose_message('import {!r} # {!r}', name, loader)\n  \n module = sys.modules[name]\n if parent:\n \n  parent_module = sys.modules[parent]\n  setattr(parent_module, name.rpartition('.')[2], module)\n  \n if getattr(module, '__package__', None) is None:\n  try:\n   module.__package__ = module.__name__\n   if not hasattr(module, '__path__'):\n    module.__package__ = module.__package__.rpartition('.')[0]\n  except AttributeError:\n   pass\n   \n if not hasattr(module, '__loader__'):\n  try:\n   module.__loader__ = loader\n  except AttributeError:\n   pass\n return module\n \n \ndef _find_and_load(name, import_):\n \"\"\n try:\n  lock = _get_module_lock(name)\n finally:\n  _imp.release_lock()\n lock.acquire()\n try:\n  return _find_and_load_unlocked(name, import_)\n finally:\n  lock.release()\n  \n  \ndef _gcd_import(name, package=None, level=0):\n \"\"\n _sanity_check(name, package, level)\n if level > 0:\n  name = _resolve_name(name, package, level)\n _imp.acquire_lock()\n if name not in sys.modules:\n  return _find_and_load(name, _gcd_import)\n module = sys.modules[name]\n if module is None:\n  _imp.release_lock()\n  message = (\"import of {} halted; \"\n  \"None in sys.modules\".format(name))\n  raise ImportError(message, name=name)\n _lock_unlock_module(name)\n return module\n \ndef _handle_fromlist(module, fromlist, import_):\n \"\"\n \n \n if hasattr(module, '__path__'):\n  if '*' in fromlist:\n   fromlist = list(fromlist)\n   fromlist.remove('*')\n   if hasattr(module, '__all__'):\n    fromlist.extend(module.__all__)\n  for x in fromlist:\n   if not hasattr(module, x):\n    from_name = '{}.{}'.format(module.__name__, x)\n    try:\n     _call_with_frames_removed(import_, from_name)\n    except ImportError as exc:\n    \n    \n    \n    \n    \n     if getattr(exc, '_not_found', False):\n      if exc.name == from_name:\n       continue\n     raise\n return module\n \n \ndef _calc___package__(globals):\n \"\"\n package = globals.get('__package__')\n if package is None:\n  package = globals['__name__']\n  if '__path__' not in globals:\n   package = package.rpartition('.')[0]\n return package\n \n \ndef _get_supported_file_loaders():\n \"\"\n extensions = ExtensionFileLoader, _imp.extension_suffixes()\n source = SourceFileLoader, SOURCE_SUFFIXES\n bytecode = SourcelessFileLoader, BYTECODE_SUFFIXES\n return [extensions, source, bytecode]\n \n \ndef __import__(name, globals=None, locals=None, fromlist=(), level=0):\n \"\"\n if level == 0:\n  module = _gcd_import(name)\n else:\n  globals_ = globals if globals is not None else {}\n  package = _calc___package__(globals_)\n  module = _gcd_import(name, package, level)\n if not fromlist:\n \n \n  if level == 0:\n   return _gcd_import(name.partition('.')[0])\n  elif not name:\n   return module\n  else:\n  \n  \n   cut_off = len(name) - len(name.partition('.')[0])\n   \n   \n   return sys.modules[module.__name__[:len(module.__name__)-cut_off]]\n else:\n  return _handle_fromlist(module, fromlist, _gcd_import)\n  \n  \n  \ndef _setup(sys_module, _imp_module):\n \"\"\n \n global _imp, sys, BYTECODE_SUFFIXES\n _imp = _imp_module\n sys = sys_module\n \n if sys.flags.optimize:\n  BYTECODE_SUFFIXES = OPTIMIZED_BYTECODE_SUFFIXES\n else:\n  BYTECODE_SUFFIXES = DEBUG_BYTECODE_SUFFIXES\n  \n module_type = type(sys)\n for name, module in sys.modules.items():\n  if isinstance(module, module_type):\n   if not hasattr(module, '__loader__'):\n    if name in sys.builtin_module_names:\n     module.__loader__ = BuiltinImporter\n     \n     \n     \n     \n self_module = sys.modules[__name__]\n for builtin_name in ('_io', '_warnings', 'builtins'): \n  if builtin_name not in sys.modules:\n   builtin_module = BuiltinImporter.load_module(builtin_name)\n  else:\n   builtin_module = sys.modules[builtin_name]\n  setattr(self_module, builtin_name, builtin_module)\n  \n os_details = ('posix', ['/']), ('nt', ['\\\\', '/']), ('os2', ['\\\\', '/'])\n for builtin_os, path_separators in os_details:\n \n  assert all(len(sep) == 1 for sep in path_separators)\n  path_sep = path_separators[0]\n  if builtin_os in sys.modules:\n   os_module = sys.modules[builtin_os]\n   break\n  else:\n   try:\n    os_module = BuiltinImporter.load_module(builtin_os)\n    \n    if builtin_os == 'os2' and 'EMX GCC' in sys.version:\n     path_sep = path_separators[1]\n    break\n   except ImportError:\n    continue\n else:\n  raise ImportError('importlib requires posix or nt')\n  \n try:\n  thread_module = BuiltinImporter.load_module('_thread')\n except ImportError:\n \n  thread_module = None\n weakref_module = BuiltinImporter.load_module('_weakref')\n \n if builtin_os == 'nt':\n  winreg_module = BuiltinImporter.load_module('winreg')\n  setattr(self_module, '_winreg', winreg_module)\n  \n setattr(self_module, '_os', os_module)\n setattr(self_module, '_thread', thread_module)\n setattr(self_module, '_weakref', weakref_module)\n setattr(self_module, 'path_sep', path_sep)\n setattr(self_module, 'path_separators', set(path_separators))\n \n setattr(self_module, '_relax_case', _make_relax_case())\n EXTENSION_SUFFIXES.extend(_imp.extension_suffixes())\n if builtin_os == 'nt':\n  SOURCE_SUFFIXES.append('.pyw')\n  if '_d.pyd' in EXTENSION_SUFFIXES:\n   WindowsRegistryFinder.DEBUG_BUILD = True\n   \ndef _install(sys_module, _imp_module):\n \"\"\n _setup(sys_module, _imp_module)\n supported_loaders = _get_supported_file_loaders()\n sys.path_hooks.extend([FileFinder.path_hook(*supported_loaders)])\n sys.meta_path.append(BuiltinImporter)\n sys.meta_path.append(FrozenImporter)\n if _os.__name__ == 'nt':\n  sys.meta_path.append(WindowsRegistryFinder)\n sys.meta_path.append(PathFinder)\n"], "_abcoll": [".py", "\n\n\n\"\"\n\nfrom abc import ABCMeta, abstractmethod\nimport sys\n\n__all__ = [\"Hashable\", \"Iterable\", \"Iterator\",\n\"Sized\", \"Container\", \"Callable\",\n\"Set\", \"MutableSet\",\n\"Mapping\", \"MutableMapping\",\n\"MappingView\", \"KeysView\", \"ItemsView\", \"ValuesView\",\n\"Sequence\", \"MutableSequence\",\n\"ByteString\",\n]\n\n\"\"\n\ndef abstractmethod(self):\n return self\n \n \n \n \n \nclass Iterable:\n\n @abstractmethod\n def __iter__(self):\n  while False:\n   yield None\n   \n @classmethod\n def __subclasshook__(cls, C):\n  if cls is Iterable:\n   if any(\"__iter__\" in B.__dict__ for B in C.__mro__):\n    return True\n  return NotImplemented\n  \n  \n  \nclass Sized:\n\n @abstractmethod\n def __len__(self):\n  return 0\n  \n @classmethod\n def __subclasshook__(cls, C):\n  if cls is Sized:\n   if any(\"__len__\" in B.__dict__ for B in C.__mro__):\n    return True\n  return NotImplemented\n  \n  \n  \nclass Container:\n\n @abstractmethod\n def __contains__(self, x):\n  return False\n  \n @classmethod\n def __subclasshook__(cls, C):\n  if cls is Container:\n   if any(\"__contains__\" in B.__dict__ for B in C.__mro__):\n    return True\n  return NotImplemented\n  \n  \n  \n  \nclass Mapping(Sized, Iterable, Container):\n\n @abstractmethod\n def __getitem__(self, key):\n  raise KeyError\n  \n def get(self, key, default=None):\n  try:\n   return self[key]\n  except KeyError:\n   return default\n   \n def __contains__(self, key):\n  try:\n   self[key]\n  except KeyError:\n   return False\n  else:\n   return True\n   \n def keys(self):\n  return KeysView(self)\n  \n def items(self):\n  return ItemsView(self)\n  \n def values(self):\n  return ValuesView(self)\n  \n def __eq__(self, other):\n  if not isinstance(other, Mapping):\n   return NotImplemented\n  return dict(self.items()) == dict(other.items())\n  \n def __ne__(self, other):\n  return not (self == other)\n  \n  \nclass MutableMapping(Mapping):\n\n @abstractmethod\n def __setitem__(self, key, value):\n  raise KeyError\n  \n @abstractmethod\n def __delitem__(self, key):\n  raise KeyError\n  \n __marker = object()\n \n def pop(self, key, default=__marker):\n  try:\n   value = self[key]\n  except KeyError:\n   if default is self.__marker:\n    raise\n   return default\n  else:\n   del self[key]\n   return value\n   \n def popitem(self):\n  try:\n   key = next(iter(self))\n  except StopIteration:\n   raise KeyError\n  value = self[key]\n  del self[key]\n  return key, value\n  \n def clear(self):\n  try:\n   while True:\n    self.popitem()\n  except KeyError:\n   pass\n   \n def update(*args, **kwds):\n  if len(args) > 2:\n   raise TypeError(\"update() takes at most 2 positional \"\n   \"arguments ({} given)\".format(len(args)))\n  elif not args:\n   raise TypeError(\"update() takes at least 1 argument (0 given)\")\n  self = args[0]\n  other = args[1] if len(args) >= 2 else ()\n  \n  if isinstance(other, Mapping):\n   for key in other:\n    self[key] = other[key]\n  elif hasattr(other, \"keys\"):\n   for key in other.keys():\n    self[key] = other[key]\n  else:\n   for key, value in other:\n    self[key] = value\n  for key, value in kwds.items():\n   self[key] = value\n   \n def setdefault(self, key, default=None):\n  try:\n   return self[key]\n  except KeyError:\n   self[key] = default\n  return default\n  \n  \n"], "xml.dom.minicompat": [".py", "\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__ = [\"NodeList\", \"EmptyNodeList\", \"StringTypes\", \"defproperty\"]\n\nimport xml.dom\n\nStringTypes = (str,)\n\n\nclass NodeList(list):\n __slots__ = ()\n \n def item(self, index):\n  if 0 <= index < len(self):\n   return self[index]\n   \n def _get_length(self):\n  return len(self)\n  \n def _set_length(self, value):\n  raise xml.dom.NoModificationAllowedErr(\n  \"attempt to modify read-only attribute 'length'\")\n  \n length = property(_get_length, _set_length,\n doc=\"The number of nodes in the NodeList.\")\n \n def __getstate__(self):\n  return list(self)\n  \n def __setstate__(self, state):\n  self[:] = state\n  \n  \nclass EmptyNodeList(tuple):\n __slots__ = ()\n \n def __add__(self, other):\n  NL = NodeList()\n  NL.extend(other)\n  return NL\n  \n def __radd__(self, other):\n  NL = NodeList()\n  NL.extend(other)\n  return NL\n  \n def item(self, index):\n  return None\n  \n def _get_length(self):\n  return 0\n  \n def _set_length(self, value):\n  raise xml.dom.NoModificationAllowedErr(\n  \"attempt to modify read-only attribute 'length'\")\n  \n length = property(_get_length, _set_length,\n doc=\"The number of nodes in the NodeList.\")\n \n \ndef defproperty(klass, name, doc):\n get = getattr(klass, (\"_get_\" + name))\n def set(self, value, name=name):\n  raise xml.dom.NoModificationAllowedErr(\n  \"attempt to modify read-only attribute \" + repr(name))\n assert not hasattr(klass, \"_set_\" + name), \"expected not to find _set_\" + name\n prop = property(get, set, doc=doc)\n setattr(klass, name, prop)\n"], "getopt": [".py", "\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__ = [\"GetoptError\",\"error\",\"getopt\",\"gnu_getopt\"]\n\nimport os\ntry:\n from gettext import gettext as _\nexcept ImportError:\n\n def _(s): return s\n \nclass GetoptError(Exception):\n opt = ''\n msg = ''\n def __init__(self, msg, opt=''):\n  self.msg = msg\n  self.opt = opt\n  Exception.__init__(self, msg, opt)\n  \n def __str__(self):\n  return self.msg\n  \nerror = GetoptError \n\ndef getopt(args, shortopts, longopts = []):\n \"\"\n \n opts = []\n if type(longopts) == type(\"\"):\n  longopts = [longopts]\n else:\n  longopts = list(longopts)\n while args and args[0].startswith('-') and args[0] != '-':\n  if args[0] == '--':\n   args = args[1:]\n   break\n  if args[0].startswith('--'):\n   opts, args = do_longs(opts, args[0][2:], longopts, args[1:])\n  else:\n   opts, args = do_shorts(opts, args[0][1:], shortopts, args[1:])\n   \n return opts, args\n \ndef gnu_getopt(args, shortopts, longopts = []):\n \"\"\n \n opts = []\n prog_args = []\n if isinstance(longopts, str):\n  longopts = [longopts]\n else:\n  longopts = list(longopts)\n  \n  \n if shortopts.startswith('+'):\n  shortopts = shortopts[1:]\n  all_options_first = True\n elif os.environ.get(\"POSIXLY_CORRECT\"):\n  all_options_first = True\n else:\n  all_options_first = False\n  \n while args:\n  if args[0] == '--':\n   prog_args += args[1:]\n   break\n   \n  if args[0][:2] == '--':\n   opts, args = do_longs(opts, args[0][2:], longopts, args[1:])\n  elif args[0][:1] == '-' and args[0] != '-':\n   opts, args = do_shorts(opts, args[0][1:], shortopts, args[1:])\n  else:\n   if all_options_first:\n    prog_args += args\n    break\n   else:\n    prog_args.append(args[0])\n    args = args[1:]\n    \n return opts, prog_args\n \ndef do_longs(opts, opt, longopts, args):\n try:\n  i = opt.index('=')\n except ValueError:\n  optarg = None\n else:\n  opt, optarg = opt[:i], opt[i+1:]\n  \n has_arg, opt = long_has_args(opt, longopts)\n if has_arg:\n  if optarg is None:\n   if not args:\n    raise GetoptError(_('option --%s requires argument') % opt, opt)\n   optarg, args = args[0], args[1:]\n elif optarg is not None:\n  raise GetoptError(_('option --%s must not have an argument') % opt, opt)\n opts.append(('--' + opt, optarg or ''))\n return opts, args\n \n \n \n \ndef long_has_args(opt, longopts):\n possibilities = [o for o in longopts if o.startswith(opt)]\n if not possibilities:\n  raise GetoptError(_('option --%s not recognized') % opt, opt)\n  \n if opt in possibilities:\n  return False, opt\n elif opt + '=' in possibilities:\n  return True, opt\n  \n if len(possibilities) > 1:\n \n \n  raise GetoptError(_('option --%s not a unique prefix') % opt, opt)\n assert len(possibilities) == 1\n unique_match = possibilities[0]\n has_arg = unique_match.endswith('=')\n if has_arg:\n  unique_match = unique_match[:-1]\n return has_arg, unique_match\n \ndef do_shorts(opts, optstring, shortopts, args):\n while optstring != '':\n  opt, optstring = optstring[0], optstring[1:]\n  if short_has_arg(opt, shortopts):\n   if optstring == '':\n    if not args:\n     raise GetoptError(_('option -%s requires argument') % opt,\n     opt)\n    optstring, args = args[0], args[1:]\n   optarg, optstring = optstring, ''\n  else:\n   optarg = ''\n  opts.append(('-' + opt, optarg))\n return opts, args\n \ndef short_has_arg(opt, shortopts):\n for i in range(len(shortopts)):\n  if opt == shortopts[i] != ':':\n   return shortopts.startswith(':', i+1)\n raise GetoptError(_('option -%s not recognized') % opt, opt)\n \nif __name__ == '__main__':\n import sys\n print(getopt(sys.argv[1:], \"a:b\", [\"alpha=\", \"beta\"]))\n"], "csv": [".py", "\n\"\"\n\nimport re\nfrom _csv import Error, __version__, writer, reader, register_dialect, unregister_dialect, get_dialect, list_dialects, field_size_limit, QUOTE_MINIMAL, QUOTE_ALL, QUOTE_NONNUMERIC, QUOTE_NONE, __doc__\nfrom _csv import Dialect as _Dialect\n\nfrom io import StringIO\n\n__all__ = [ \"QUOTE_MINIMAL\", \"QUOTE_ALL\", \"QUOTE_NONNUMERIC\", \"QUOTE_NONE\",\n\"Error\", \"Dialect\", \"__doc__\", \"excel\", \"excel_tab\",\n\"field_size_limit\", \"reader\", \"writer\",\n\"register_dialect\", \"get_dialect\", \"list_dialects\", \"Sniffer\",\n\"unregister_dialect\", \"__version__\", \"DictReader\", \"DictWriter\" ]\n\nclass Dialect:\n \"\"\n _name = \"\"\n _valid = False\n \n delimiter = None\n quotechar = None\n escapechar = None\n doublequote = None\n skipinitialspace = None\n lineterminator = None\n quoting = None\n \n def __init__(self):\n  if self.__class__ != Dialect:\n   self._valid = True\n  self._validate()\n  \n def _validate(self):\n  try:\n   _Dialect(self)\n  except TypeError as e:\n  \n   raise Error(str(e))\n   \nclass excel(Dialect):\n \"\"\n delimiter = ','\n quotechar = '\"'\n doublequote = True\n skipinitialspace = False\n lineterminator = '\\r\\n'\n quoting = QUOTE_MINIMAL\nregister_dialect(\"excel\", excel)\n\nclass excel_tab(excel):\n \"\"\n delimiter = '\\t'\nregister_dialect(\"excel-tab\", excel_tab)\n\nclass unix_dialect(Dialect):\n \"\"\n delimiter = ','\n quotechar = '\"'\n doublequote = True\n skipinitialspace = False\n lineterminator = '\\n'\n quoting = QUOTE_ALL\nregister_dialect(\"unix\", unix_dialect)\n\n\nclass DictReader:\n def __init__(self, f, fieldnames=None, restkey=None, restval=None,\n dialect=\"excel\", *args, **kwds):\n  self._fieldnames = fieldnames \n  self.restkey = restkey \n  self.restval = restval \n  self.reader = reader(f, dialect, *args, **kwds)\n  self.dialect = dialect\n  self.line_num = 0\n  \n def __iter__(self):\n  return self\n  \n @property\n def fieldnames(self):\n  if self._fieldnames is None:\n   try:\n    self._fieldnames = next(self.reader)\n   except StopIteration:\n    pass\n  self.line_num = self.reader.line_num\n  return self._fieldnames\n  \n @fieldnames.setter\n def fieldnames(self, value):\n  self._fieldnames = value\n  \n def __next__(self):\n  if self.line_num == 0:\n  \n   self.fieldnames\n  row = next(self.reader)\n  self.line_num = self.reader.line_num\n  \n  \n  \n  \n  while row == []:\n   row = next(self.reader)\n  d = dict(zip(self.fieldnames, row))\n  lf = len(self.fieldnames)\n  lr = len(row)\n  if lf < lr:\n   d[self.restkey] = row[lf:]\n  elif lf > lr:\n   for key in self.fieldnames[lr:]:\n    d[key] = self.restval\n  return d\n  \n  \nclass DictWriter:\n def __init__(self, f, fieldnames, restval=\"\", extrasaction=\"raise\",\n dialect=\"excel\", *args, **kwds):\n  self.fieldnames = fieldnames \n  self.restval = restval \n  if extrasaction.lower() not in (\"raise\", \"ignore\"):\n   raise ValueError(\"extrasaction (%s) must be 'raise' or 'ignore'\"\n   % extrasaction)\n  self.extrasaction = extrasaction\n  self.writer = writer(f, dialect, *args, **kwds)\n  \n def writeheader(self):\n  header = dict(zip(self.fieldnames, self.fieldnames))\n  self.writerow(header)\n  \n def _dict_to_list(self, rowdict):\n  if self.extrasaction == \"raise\":\n   wrong_fields = [k for k in rowdict if k not in self.fieldnames]\n   if wrong_fields:\n    raise ValueError(\"dict contains fields not in fieldnames: \"\n    + \", \".join(wrong_fields))\n  return [rowdict.get(key, self.restval) for key in self.fieldnames]\n  \n def writerow(self, rowdict):\n  return self.writer.writerow(self._dict_to_list(rowdict))\n  \n def writerows(self, rowdicts):\n  rows = []\n  for rowdict in rowdicts:\n   rows.append(self._dict_to_list(rowdict))\n  return self.writer.writerows(rows)\n  \n  \ntry:\n complex\nexcept NameError:\n complex = float\n \nclass Sniffer:\n \"\"\n def __init__(self):\n \n  self.preferred = [',', '\\t', ';', ' ', ':']\n  \n  \n def sniff(self, sample, delimiters=None):\n  \"\"\n  \n  quotechar, doublequote, delimiter, skipinitialspace = self._guess_quote_and_delimiter(sample, delimiters)\n  if not delimiter:\n   delimiter, skipinitialspace = self._guess_delimiter(sample,\n   delimiters)\n   \n  if not delimiter:\n   raise Error(\"Could not determine delimiter\")\n   \n  class dialect(Dialect):\n   _name = \"sniffed\"\n   lineterminator = '\\r\\n'\n   quoting = QUOTE_MINIMAL\n   \n   \n  dialect.doublequote = doublequote\n  dialect.delimiter = delimiter\n  \n  dialect.quotechar = quotechar or '\"'\n  dialect.skipinitialspace = skipinitialspace\n  \n  return dialect\n  \n  \n def _guess_quote_and_delimiter(self, data, delimiters):\n  \"\"\n  \n  matches = []\n  for restr in ('(?P<delim>[^\\w\\n\"\\'])(?P<space> ?)(?P<quote>[\"\\']).*?(?P=quote)(?P=delim)', \n  '(?:^|\\n)(?P<quote>[\"\\']).*?(?P=quote)(?P<delim>[^\\w\\n\"\\'])(?P<space> ?)', \n  '(?P<delim>>[^\\w\\n\"\\'])(?P<space> ?)(?P<quote>[\"\\']).*?(?P=quote)(?:$|\\n)', \n  '(?:^|\\n)(?P<quote>[\"\\']).*?(?P=quote)(?:$|\\n)'): \n   regexp = re.compile(restr, re.DOTALL | re.MULTILINE)\n   matches = regexp.findall(data)\n   if matches:\n    break\n    \n  if not matches:\n  \n   return ('', False, None, 0)\n  quotes = {}\n  delims = {}\n  spaces = 0\n  for m in matches:\n   n = regexp.groupindex['quote'] - 1\n   key = m[n]\n   if key:\n    quotes[key] = quotes.get(key, 0) + 1\n   try:\n    n = regexp.groupindex['delim'] - 1\n    key = m[n]\n   except KeyError:\n    continue\n   if key and (delimiters is None or key in delimiters):\n    delims[key] = delims.get(key, 0) + 1\n   try:\n    n = regexp.groupindex['space'] - 1\n   except KeyError:\n    continue\n   if m[n]:\n    spaces += 1\n    \n  quotechar = max(quotes, key=quotes.get)\n  \n  if delims:\n   delim = max(delims, key=delims.get)\n   skipinitialspace = delims[delim] == spaces\n   if delim == '\\n': \n    delim = ''\n  else:\n  \n   delim = ''\n   skipinitialspace = 0\n   \n   \n   \n  dq_regexp = re.compile(\n  r\"((%(delim)s)|^)\\W*%(quote)s[^%(delim)s\\n]*%(quote)s[^%(delim)s\\n]*%(quote)s\\W*((%(delim)s)|$)\" % {'delim':re.escape(delim), 'quote':quotechar}, re.MULTILINE)\n  \n  \n  \n  if dq_regexp.search(data):\n   doublequote = True\n  else:\n   doublequote = False\n   \n  return (quotechar, doublequote, delim, skipinitialspace)\n  \n  \n def _guess_delimiter(self, data, delimiters):\n  \"\"\n  \n  data = list(filter(None, data.split('\\n')))\n  \n  ascii = [chr(c) for c in range(127)] \n  \n  \n  chunkLength = min(10, len(data))\n  iteration = 0\n  charFrequency = {}\n  modes = {}\n  delims = {}\n  start, end = 0, min(chunkLength, len(data))\n  while start < len(data):\n   iteration += 1\n   for line in data[start:end]:\n    for char in ascii:\n     metaFrequency = charFrequency.get(char, {})\n     \n     freq = line.count(char)\n     \n     metaFrequency[freq] = metaFrequency.get(freq, 0) + 1\n     charFrequency[char] = metaFrequency\n     \n   for char in charFrequency.keys():\n    items = list(charFrequency[char].items())\n    if len(items) == 1 and items[0][0] == 0:\n     continue\n     \n    if len(items) > 1:\n     modes[char] = max(items, key=lambda x: x[1])\n     \n     \n     items.remove(modes[char])\n     modes[char] = (modes[char][0], modes[char][1]\n     - sum(item[1] for item in items))\n    else:\n     modes[char] = items[0]\n     \n     \n   modeList = modes.items()\n   total = float(chunkLength * iteration)\n   \n   consistency = 1.0\n   \n   threshold = 0.9\n   while len(delims) == 0 and consistency >= threshold:\n    for k, v in modeList:\n     if v[0] > 0 and v[1] > 0:\n      if ((v[1]/total) >= consistency and\n      (delimiters is None or k in delimiters)):\n       delims[k] = v\n    consistency -= 0.01\n    \n   if len(delims) == 1:\n    delim = list(delims.keys())[0]\n    skipinitialspace = (data[0].count(delim) ==\n    data[0].count(\"%c \" % delim))\n    return (delim, skipinitialspace)\n    \n    \n   start = end\n   end += chunkLength\n   \n  if not delims:\n   return ('', 0)\n   \n   \n  if len(delims) > 1:\n   for d in self.preferred:\n    if d in delims.keys():\n     skipinitialspace = (data[0].count(d) ==\n     data[0].count(\"%c \" % d))\n     return (d, skipinitialspace)\n     \n     \n     \n  items = [(v,k) for (k,v) in delims.items()]\n  items.sort()\n  delim = items[-1][1]\n  \n  skipinitialspace = (data[0].count(delim) ==\n  data[0].count(\"%c \" % delim))\n  return (delim, skipinitialspace)\n  \n  \n def has_header(self, sample):\n \n \n \n \n \n \n \n \n \n  rdr = reader(StringIO(sample), self.sniff(sample))\n  \n  header = next(rdr) \n  \n  columns = len(header)\n  columnTypes = {}\n  for i in range(columns): columnTypes[i] = None\n  \n  checked = 0\n  for row in rdr:\n  \n   if checked > 20:\n    break\n   checked += 1\n   \n   if len(row) != columns:\n    continue \n    \n   for col in list(columnTypes.keys()):\n   \n    for thisType in [int, float, complex]:\n     try:\n      thisType(row[col])\n      break\n     except (ValueError, OverflowError):\n      pass\n    else:\n    \n     thisType = len(row[col])\n     \n    if thisType != columnTypes[col]:\n     if columnTypes[col] is None: \n      columnTypes[col] = thisType\n     else:\n     \n     \n      del columnTypes[col]\n      \n      \n      \n  hasHeader = 0\n  for col, colType in columnTypes.items():\n   if type(colType) == type(0): \n    if len(header[col]) != colType:\n     hasHeader += 1\n    else:\n     hasHeader -= 1\n   else: \n    try:\n     colType(header[col])\n    except (ValueError, TypeError):\n     hasHeader += 1\n    else:\n     hasHeader -= 1\n     \n  return hasHeader > 0\n"], "crypto_js.rollups.sha3": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(v,p){var d={},u=d.lib={},r=function(){},f=u.Base={extend:function(a){r.prototype=this;var b=new r;a&&b.mixIn(a);b.hasOwnProperty(\"init\")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\ns=u.WordArray=f.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=p?b:4*a.length},toString:function(a){return(a||y).stringify(this)},concat:function(a){var b=this.words,c=a.words,j=this.sigBytes;a=a.sigBytes;this.clamp();if(j%4)for(var n=0;n<a;n++)b[j+n>>>2]|=(c[n>>>2]>>>24-8*(n%4)&255)<<24-8*((j+n)%4);else if(65535<c.length)for(n=0;n<a;n+=4)b[j+n>>>2]=c[n>>>2];else b.push.apply(b,c);this.sigBytes+=a;return this},clamp:function(){var a=this.words,b=this.sigBytes;a[b>>>2]&=4294967295<<\n32-8*(b%4);a.length=v.ceil(b/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var b=[],c=0;c<a;c+=4)b.push(4294967296*v.random()|0);return new s.init(b,a)}}),x=d.enc={},y=x.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var c=[],j=0;j<a;j++){var n=b[j>>>2]>>>24-8*(j%4)&255;c.push((n>>>4).toString(16));c.push((n&15).toString(16))}return c.join(\"\")},parse:function(a){for(var b=a.length,c=[],j=0;j<b;j+=2)c[j>>>3]|=parseInt(a.substr(j,\n2),16)<<24-4*(j%8);return new s.init(c,b/2)}},e=x.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var c=[],j=0;j<a;j++)c.push(String.fromCharCode(b[j>>>2]>>>24-8*(j%4)&255));return c.join(\"\")},parse:function(a){for(var b=a.length,c=[],j=0;j<b;j++)c[j>>>2]|=(a.charCodeAt(j)&255)<<24-8*(j%4);return new s.init(c,b)}},q=x.Utf8={stringify:function(a){try{return decodeURIComponent(escape(e.stringify(a)))}catch(b){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return e.parse(unescape(encodeURIComponent(a)))}},\nt=u.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new s.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=q.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var b=this._data,c=b.words,j=b.sigBytes,n=this.blockSize,e=j/(4*n),e=a?v.ceil(e):v.max((e|0)-this._minBufferSize,0);a=e*n;j=v.min(4*a,j);if(a){for(var f=0;f<a;f+=n)this._doProcessBlock(c,f);f=c.splice(0,a);b.sigBytes-=j}return new s.init(f,j)},clone:function(){var a=f.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});u.Hasher=t.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){t.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,c){return(new a.init(c)).finalize(b)}},_createHmacHelper:function(a){return function(b,c){return(new w.HMAC.init(a,\nc)).finalize(b)}}});var w=d.algo={};return d}(Math);\n(function(v){var p=CryptoJS,d=p.lib,u=d.Base,r=d.WordArray,p=p.x64={};p.Word=u.extend({init:function(f,s){this.high=f;this.low=s}});p.WordArray=u.extend({init:function(f,s){f=this.words=f||[];this.sigBytes=s!=v?s:8*f.length},toX32:function(){for(var f=this.words,s=f.length,d=[],p=0;p<s;p++){var e=f[p];d.push(e.high);d.push(e.low)}return r.create(d,this.sigBytes)},clone:function(){for(var f=u.clone.call(this),d=f.words=this.words.slice(0),p=d.length,r=0;r<p;r++)d[r]=d[r].clone();return f}})})();\n(function(v){for(var p=CryptoJS,d=p.lib,u=d.WordArray,r=d.Hasher,f=p.x64.Word,d=p.algo,s=[],x=[],y=[],e=1,q=0,t=0;24>t;t++){s[e+5*q]=(t+1)*(t+2)/2%64;var w=(2*e+3*q)%5,e=q%5,q=w}for(e=0;5>e;e++)for(q=0;5>q;q++)x[e+5*q]=q+5*((2*e+3*q)%5);e=1;for(q=0;24>q;q++){for(var a=w=t=0;7>a;a++){if(e&1){var b=(1<<a)-1;32>b?w^=1<<b:t^=1<<b-32}e=e&128?e<<1^113:e<<1}y[q]=f.create(t,w)}for(var c=[],e=0;25>e;e++)c[e]=f.create();d=d.SHA3=r.extend({cfg:r.cfg.extend({outputLength:512}),_doReset:function(){for(var a=this._state=\n[],b=0;25>b;b++)a[b]=new f.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(a,b){for(var e=this._state,f=this.blockSize/2,h=0;h<f;h++){var l=a[b+2*h],m=a[b+2*h+1],l=(l<<8|l>>>24)&16711935|(l<<24|l>>>8)&4278255360,m=(m<<8|m>>>24)&16711935|(m<<24|m>>>8)&4278255360,g=e[h];g.high^=m;g.low^=l}for(f=0;24>f;f++){for(h=0;5>h;h++){for(var d=l=0,k=0;5>k;k++)g=e[h+5*k],l^=g.high,d^=g.low;g=c[h];g.high=l;g.low=d}for(h=0;5>h;h++){g=c[(h+4)%5];l=c[(h+1)%5];m=l.high;k=l.low;l=g.high^\n(m<<1|k>>>31);d=g.low^(k<<1|m>>>31);for(k=0;5>k;k++)g=e[h+5*k],g.high^=l,g.low^=d}for(m=1;25>m;m++)g=e[m],h=g.high,g=g.low,k=s[m],32>k?(l=h<<k|g>>>32-k,d=g<<k|h>>>32-k):(l=g<<k-32|h>>>64-k,d=h<<k-32|g>>>64-k),g=c[x[m]],g.high=l,g.low=d;g=c[0];h=e[0];g.high=h.high;g.low=h.low;for(h=0;5>h;h++)for(k=0;5>k;k++)m=h+5*k,g=e[m],l=c[m],m=c[(h+1)%5+5*k],d=c[(h+2)%5+5*k],g.high=l.high^~m.high&d.high,g.low=l.low^~m.low&d.low;g=e[0];h=y[f];g.high^=h.high;g.low^=h.low}},_doFinalize:function(){var a=this._data,\nb=a.words,c=8*a.sigBytes,e=32*this.blockSize;b[c>>>5]|=1<<24-c%32;b[(v.ceil((c+1)/e)*e>>>5)-1]|=128;a.sigBytes=4*b.length;this._process();for(var a=this._state,b=this.cfg.outputLength/8,c=b/8,e=[],h=0;h<c;h++){var d=a[h],f=d.high,d=d.low,f=(f<<8|f>>>24)&16711935|(f<<24|f>>>8)&4278255360,d=(d<<8|d>>>24)&16711935|(d<<24|d>>>8)&4278255360;e.push(d);e.push(f)}return new u.init(e,b)},clone:function(){for(var a=r.clone.call(this),b=a._state=this._state.slice(0),c=0;25>c;c++)b[c]=b[c].clone();return a}});\np.SHA3=r._createHelper(d);p.HmacSHA3=r._createHmacHelper(d)})(Math);\n"], "crypto_js.rollups.sha1": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(e,m){var p={},j=p.lib={},l=function(){},f=j.Base={extend:function(a){l.prototype=this;var c=new l;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nn=j.WordArray=f.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=m?c:4*a.length},toString:function(a){return(a||h).stringify(this)},concat:function(a){var c=this.words,q=a.words,d=this.sigBytes;a=a.sigBytes;this.clamp();if(d%4)for(var b=0;b<a;b++)c[d+b>>>2]|=(q[b>>>2]>>>24-8*(b%4)&255)<<24-8*((d+b)%4);else if(65535<q.length)for(b=0;b<a;b+=4)c[d+b>>>2]=q[b>>>2];else c.push.apply(c,q);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=e.ceil(c/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],b=0;b<a;b+=4)c.push(4294967296*e.random()|0);return new n.init(c,a)}}),b=p.enc={},h=b.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++){var f=c[d>>>2]>>>24-8*(d%4)&255;b.push((f>>>4).toString(16));b.push((f&15).toString(16))}return b.join(\"\")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d+=2)b[d>>>3]|=parseInt(a.substr(d,\n2),16)<<24-4*(d%8);return new n.init(b,c/2)}},g=b.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++)b.push(String.fromCharCode(c[d>>>2]>>>24-8*(d%4)&255));return b.join(\"\")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d++)b[d>>>2]|=(a.charCodeAt(d)&255)<<24-8*(d%4);return new n.init(b,c)}},r=b.Utf8={stringify:function(a){try{return decodeURIComponent(escape(g.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return g.parse(unescape(encodeURIComponent(a)))}},\nk=j.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new n.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=r.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,b=c.words,d=c.sigBytes,f=this.blockSize,h=d/(4*f),h=a?e.ceil(h):e.max((h|0)-this._minBufferSize,0);a=h*f;d=e.min(4*a,d);if(a){for(var g=0;g<a;g+=f)this._doProcessBlock(b,g);g=b.splice(0,a);c.sigBytes-=d}return new n.init(g,d)},clone:function(){var a=f.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=k.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){k.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,b){return(new a.init(b)).finalize(c)}},_createHmacHelper:function(a){return function(b,f){return(new s.HMAC.init(a,\nf)).finalize(b)}}});var s=p.algo={};return p}(Math);\n(function(){var e=CryptoJS,m=e.lib,p=m.WordArray,j=m.Hasher,l=[],m=e.algo.SHA1=j.extend({_doReset:function(){this._hash=new p.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(f,n){for(var b=this._hash.words,h=b[0],g=b[1],e=b[2],k=b[3],j=b[4],a=0;80>a;a++){if(16>a)l[a]=f[n+a]|0;else{var c=l[a-3]^l[a-8]^l[a-14]^l[a-16];l[a]=c<<1|c>>>31}c=(h<<5|h>>>27)+j+l[a];c=20>a?c+((g&e|~g&k)+1518500249):40>a?c+((g^e^k)+1859775393):60>a?c+((g&e|g&k|e&k)-1894007588):c+((g^e^\nk)-899497514);j=k;k=e;e=g<<30|g>>>2;g=h;h=c}b[0]=b[0]+h|0;b[1]=b[1]+g|0;b[2]=b[2]+e|0;b[3]=b[3]+k|0;b[4]=b[4]+j|0},_doFinalize:function(){var f=this._data,e=f.words,b=8*this._nDataBytes,h=8*f.sigBytes;e[h>>>5]|=128<<24-h%32;e[(h+64>>>9<<4)+14]=Math.floor(b/4294967296);e[(h+64>>>9<<4)+15]=b;f.sigBytes=4*e.length;this._process();return this._hash},clone:function(){var e=j.clone.call(this);e._hash=this._hash.clone();return e}});e.SHA1=j._createHelper(m);e.HmacSHA1=j._createHmacHelper(m)})();\n"], "genericpath": [".py", "\"\"\nimport os\nimport stat\n\n__all__ = ['commonprefix', 'exists', 'getatime', 'getctime', 'getmtime',\n'getsize', 'isdir', 'isfile']\n\n\n\n\ndef exists(path):\n \"\"\n try:\n  os.stat(path)\n except os.error:\n  return False\n return True\n \n \n \n \ndef isfile(path):\n \"\"\n try:\n  st = os.stat(path)\n except os.error:\n  return False\n return stat.S_ISREG(st.st_mode)\n \n \n \n \n \ndef isdir(s):\n \"\"\n try:\n  st = os.stat(s)\n except os.error:\n  return False\n return stat.S_ISDIR(st.st_mode)\n \n \ndef getsize(filename):\n \"\"\n return os.stat(filename).st_size\n \n \ndef getmtime(filename):\n \"\"\n return os.stat(filename).st_mtime\n \n \ndef getatime(filename):\n \"\"\n return os.stat(filename).st_atime\n \n \ndef getctime(filename):\n \"\"\n return os.stat(filename).st_ctime\n \n \n \ndef commonprefix(m):\n \"\"\n if not m: return ''\n s1 = min(m)\n s2 = max(m)\n for i, c in enumerate(s1):\n  if c != s2[i]:\n   return s1[:i]\n return s1\n \n \n \n \n \n \n \n \ndef _splitext(p, sep, altsep, extsep):\n \"\"\n \n \n sepIndex = p.rfind(sep)\n if altsep:\n  altsepIndex = p.rfind(altsep)\n  sepIndex = max(sepIndex, altsepIndex)\n  \n dotIndex = p.rfind(extsep)\n if dotIndex > sepIndex:\n \n  filenameIndex = sepIndex + 1\n  while filenameIndex < dotIndex:\n   if p[filenameIndex:filenameIndex+1] != extsep:\n    return p[:dotIndex], p[dotIndex:]\n   filenameIndex += 1\n   \n return p, p[:0]\n"], "stat": [".py", "\"\"\n\n\n\nST_MODE = 0\nST_INO = 1\nST_DEV = 2\nST_NLINK = 3\nST_UID = 4\nST_GID = 5\nST_SIZE = 6\nST_ATIME = 7\nST_MTIME = 8\nST_CTIME = 9\n\n\n\ndef S_IMODE(mode):\n \"\"\n return mode & 0o7777\n \ndef S_IFMT(mode):\n \"\"\n return mode & 0o170000\n \n \n \n \nS_IFDIR = 0o040000 \nS_IFCHR = 0o020000 \nS_IFBLK = 0o060000 \nS_IFREG = 0o100000 \nS_IFIFO = 0o010000 \nS_IFLNK = 0o120000 \nS_IFSOCK = 0o140000 \n\n\n\ndef S_ISDIR(mode):\n \"\"\n return S_IFMT(mode) == S_IFDIR\n \ndef S_ISCHR(mode):\n \"\"\n return S_IFMT(mode) == S_IFCHR\n \ndef S_ISBLK(mode):\n \"\"\n return S_IFMT(mode) == S_IFBLK\n \ndef S_ISREG(mode):\n \"\"\n return S_IFMT(mode) == S_IFREG\n \ndef S_ISFIFO(mode):\n \"\"\n return S_IFMT(mode) == S_IFIFO\n \ndef S_ISLNK(mode):\n \"\"\n return S_IFMT(mode) == S_IFLNK\n \ndef S_ISSOCK(mode):\n \"\"\n return S_IFMT(mode) == S_IFSOCK\n \n \n \nS_ISUID = 0o4000 \nS_ISGID = 0o2000 \nS_ENFMT = S_ISGID \nS_ISVTX = 0o1000 \nS_IREAD = 0o0400 \nS_IWRITE = 0o0200 \nS_IEXEC = 0o0100 \nS_IRWXU = 0o0700 \nS_IRUSR = 0o0400 \nS_IWUSR = 0o0200 \nS_IXUSR = 0o0100 \nS_IRWXG = 0o0070 \nS_IRGRP = 0o0040 \nS_IWGRP = 0o0020 \nS_IXGRP = 0o0010 \nS_IRWXO = 0o0007 \nS_IROTH = 0o0004 \nS_IWOTH = 0o0002 \nS_IXOTH = 0o0001 \n\n\n\nUF_NODUMP = 0x00000001 \nUF_IMMUTABLE = 0x00000002 \nUF_APPEND = 0x00000004 \nUF_OPAQUE = 0x00000008 \nUF_NOUNLINK = 0x00000010 \nUF_COMPRESSED = 0x00000020 \nUF_HIDDEN = 0x00008000 \nSF_ARCHIVED = 0x00010000 \nSF_IMMUTABLE = 0x00020000 \nSF_APPEND = 0x00040000 \nSF_NOUNLINK = 0x00100000 \nSF_SNAPSHOT = 0x00200000 \n\n\n_filemode_table = (\n((S_IFLNK, \"l\"),\n(S_IFREG, \"-\"),\n(S_IFBLK, \"b\"),\n(S_IFDIR, \"d\"),\n(S_IFCHR, \"c\"),\n(S_IFIFO, \"p\")),\n\n((S_IRUSR, \"r\"),),\n((S_IWUSR, \"w\"),),\n((S_IXUSR|S_ISUID, \"s\"),\n(S_ISUID, \"S\"),\n(S_IXUSR, \"x\")),\n\n((S_IRGRP, \"r\"),),\n((S_IWGRP, \"w\"),),\n((S_IXGRP|S_ISGID, \"s\"),\n(S_ISGID, \"S\"),\n(S_IXGRP, \"x\")),\n\n((S_IROTH, \"r\"),),\n((S_IWOTH, \"w\"),),\n((S_IXOTH|S_ISVTX, \"t\"),\n(S_ISVTX, \"T\"),\n(S_IXOTH, \"x\"))\n)\n\ndef filemode(mode):\n \"\"\n perm = []\n for table in _filemode_table:\n  for bit, char in table:\n   if mode & bit == bit:\n    perm.append(char)\n    break\n  else:\n   perm.append(\"-\")\n return \"\".join(perm)\n"], "http": [".py", "\n", 1], "site-packages.header": [".py", "from browser import document as doc\nfrom browser.html import *\n\ntrans_menu = { \n'menu_console':{'en':'Console','es':'Consola','fr':'Console', 'pt':'Console'},\n'menu_editor':{'en':'Editor','es':'Editor','fr':'Editeur', 'pt':'Editor'},\n'menu_gallery':{'en':'Gallery','es':'Galer\u00eda','fr':'Galerie', 'pt':'Galeria'},\n'menu_doc':{'en':'Documentation','es':'Documentaci\u00f3n','fr':'Documentation', 'pt':'Documenta\u00e7\u00e3o'},\n'menu_download':{'en':'Download','es':'Descargas','fr':'T\u00e9l\u00e9chargement', 'pt':'Download'},\n'menu_dev':{'en':'Development','es':'Desarrollo','fr':'D\u00e9veloppement', 'pt':'Desenvolvimento'},\n'menu_groups':{'en':'Groups','es':'Grupos','fr':'Groupes', 'pt':'Grupos'}\n}\nlinks = {'home':'index.html',\n'console':'tests/console.html',\n'editor':'tests/editor.html',\n'gallery':'gallery/gallery_%s.html',\n'doc':'static_doc/%s/intro.html',\n'download':'https://github.com/brython-dev/brython/releases',\n'dev':'https://github.com/brython-dev/brython',\n'groups':'groups.html'\n}\n\ndef show(prefix='', language=None):\n\n has_req = False\n \n if language is None:\n  qs_lang = doc.query.getfirst(\"lang\")\n  if qs_lang and qs_lang in [\"en\",\"fr\",\"es\",\"pt\"]:\n   has_req = True\n   language = qs_lang\n  else:\n   import locale\n   try:\n    lang,enc = locale.getdefaultlocale()\n    lang = lang[:2]\n    if lang in [\"en\",\"fr\",\"es\",\"pt\"]:\n     language = lang\n   except:\n    pass\n    \n _banner = doc['banner_row']\n \n for key in ['console','editor','gallery','doc','download','dev','groups']:\n  if key in ['download','dev']:\n   href = links[key]\n  else:\n   href = prefix+links[key]\n  if key in ['doc','gallery']:\n   href = href %language\n  if key not in ['download','dev']:\n  \n   href += '?lang=%s' %language\n  if key == 'home':\n   img = IMG(src=\"/brython.svg\",Class=\"logo\")\n   link = A(img,href=href)\n   cell = TD(link,Class=\"logo\")\n  else:\n   link = A(trans_menu['menu_%s'%key][language],href=href,Class=\"banner\")\n   cell = TD(link)\n  if key in ['download','dev']:\n   link.target = \"_blank\" \n  _banner <= cell\n  \n return qs_lang,language\n"], "warnings": [".py", "\"\"\n\n\n\n\nimport linecache\nimport sys\n\n__all__ = [\"warn\", \"showwarning\", \"formatwarning\", \"filterwarnings\",\n\"resetwarnings\", \"catch_warnings\"]\n\n\ndef showwarning(message, category, filename, lineno, file=None, line=None):\n \"\"\n if file is None:\n  file = sys.stderr\n try:\n  file.write(formatwarning(message, category, filename, lineno, line))\n except IOError:\n  pass \n  \ndef formatwarning(message, category, filename, lineno, line=None):\n \"\"\n s = \"%s:%s: %s: %s\\n\" % (filename, lineno, category.__name__, message)\n line = linecache.getline(filename, lineno) if line is None else line\n if line:\n  line = line.strip()\n  s += \"  %s\\n\" % line\n return s\n \ndef filterwarnings(action, message=\"\", category=Warning, module=\"\", lineno=0,\nappend=False):\n \"\"\n import re\n assert action in (\"error\", \"ignore\", \"always\", \"default\", \"module\",\n \"once\"), \"invalid action: %r\" % (action,)\n assert isinstance(message, str), \"message must be a string\"\n assert isinstance(category, type), \"category must be a class\"\n assert issubclass(category, Warning), \"category must be a Warning subclass\"\n assert isinstance(module, str), \"module must be a string\"\n assert isinstance(lineno, int) and lineno >= 0, \"lineno must be an int >= 0\"\n item = (action, re.compile(message, re.I), category,\n re.compile(module), lineno)\n if append:\n  filters.append(item)\n else:\n  filters.insert(0, item)\n  \ndef simplefilter(action, category=Warning, lineno=0, append=False):\n \"\"\n assert action in (\"error\", \"ignore\", \"always\", \"default\", \"module\",\n \"once\"), \"invalid action: %r\" % (action,)\n assert isinstance(lineno, int) and lineno >= 0, \"lineno must be an int >= 0\"\n item = (action, None, category, None, lineno)\n if append:\n  filters.append(item)\n else:\n  filters.insert(0, item)\n  \ndef resetwarnings():\n \"\"\n filters[:] = []\n \nclass _OptionError(Exception):\n \"\"\n pass\n \n \ndef _processoptions(args):\n for arg in args:\n  try:\n   _setoption(arg)\n  except _OptionError as msg:\n   print(\"Invalid -W option ignored:\", msg, file=sys.stderr)\n   \n   \ndef _setoption(arg):\n import re\n parts = arg.split(':')\n if len(parts) > 5:\n  raise _OptionError(\"too many fields (max 5): %r\" % (arg,))\n while len(parts) < 5:\n  parts.append('')\n action, message, category, module, lineno = [s.strip()\n for s in parts]\n action = _getaction(action)\n message = re.escape(message)\n category = _getcategory(category)\n module = re.escape(module)\n if module:\n  module = module + '$'\n if lineno:\n  try:\n   lineno = int(lineno)\n   if lineno < 0:\n    raise ValueError\n  except (ValueError, OverflowError):\n   raise _OptionError(\"invalid lineno %r\" % (lineno,))\n else:\n  lineno = 0\n filterwarnings(action, message, category, module, lineno)\n \n \ndef _getaction(action):\n if not action:\n  return \"default\"\n if action == \"all\": return \"always\" \n for a in ('default', 'always', 'ignore', 'module', 'once', 'error'):\n  if a.startswith(action):\n   return a\n raise _OptionError(\"invalid action: %r\" % (action,))\n \n \ndef _getcategory(category):\n import re\n if not category:\n  return Warning\n if re.match(\"^[a-zA-Z0-9_]+$\", category):\n  try:\n   cat = eval(category)\n  except NameError:\n   raise _OptionError(\"unknown warning category: %r\" % (category,))\n else:\n  i = category.rfind(\".\")\n  module = category[:i]\n  klass = category[i+1:]\n  try:\n   m = __import__(module, None, None, [klass])\n  except ImportError:\n   raise _OptionError(\"invalid module name: %r\" % (module,))\n  try:\n   cat = getattr(m, klass)\n  except AttributeError:\n   raise _OptionError(\"unknown warning category: %r\" % (category,))\n if not issubclass(cat, Warning):\n  raise _OptionError(\"invalid warning category: %r\" % (category,))\n return cat\n \n \n \ndef warn(message, category=None, stacklevel=1):\n \"\"\n \n if isinstance(message, Warning):\n  category = message.__class__\n  \n if category is None:\n  category = UserWarning\n assert issubclass(category, Warning)\n \n try:\n  caller = sys._getframe(stacklevel)\n except ValueError:\n  globals = sys.__dict__\n  lineno = 1\n else:\n  globals = caller.f_globals\n  lineno = caller.f_lineno\n if '__name__' in globals:\n  module = globals['__name__']\n else:\n  module = \"<string>\"\n filename = globals.get('__file__')\n if filename:\n  fnl = filename.lower()\n  if fnl.endswith((\".pyc\", \".pyo\")):\n   filename = filename[:-1]\n else:\n  if module == \"__main__\":\n   try:\n    filename = sys.argv[0]\n   except AttributeError:\n   \n    filename = '__main__'\n  if not filename:\n   filename = module\n registry = globals.setdefault(\"__warningregistry__\", {})\n warn_explicit(message, category, filename, lineno, module, registry,\n globals)\n \ndef warn_explicit(message, category, filename, lineno,\nmodule=None, registry=None, module_globals=None):\n lineno = int(lineno)\n if module is None:\n  module = filename or \"<unknown>\"\n  if module[-3:].lower() == \".py\":\n   module = module[:-3] \n if registry is None:\n  registry = {}\n if isinstance(message, Warning):\n  text = str(message)\n  category = message.__class__\n else:\n  text = message\n  message = category(message)\n key = (text, category, lineno)\n \n if registry.get(key):\n  return\n  \n for item in filters:\n  action, msg, cat, mod, ln = item\n  if ((msg is None or msg.match(text)) and\n  issubclass(category, cat) and\n  (mod is None or mod.match(module)) and\n  (ln == 0 or lineno == ln)):\n   break\n else:\n  action = defaultaction\n  \n if action == \"ignore\":\n  registry[key] = 1\n  return\n  \n  \n  \n linecache.getlines(filename, module_globals)\n \n if action == \"error\":\n  raise message\n  \n if action == \"once\":\n  registry[key] = 1\n  oncekey = (text, category)\n  if onceregistry.get(oncekey):\n   return\n  onceregistry[oncekey] = 1\n elif action == \"always\":\n  pass\n elif action == \"module\":\n  registry[key] = 1\n  altkey = (text, category, 0)\n  if registry.get(altkey):\n   return\n  registry[altkey] = 1\n elif action == \"default\":\n  registry[key] = 1\n else:\n \n  raise RuntimeError(\n  \"Unrecognized action (%r) in warnings.filters:\\n %s\" %\n  (action, item))\n if not callable(showwarning):\n  raise TypeError(\"warnings.showwarning() must be set to a \"\n  \"function or method\")\n  \n showwarning(message, category, filename, lineno)\n \n \nclass WarningMessage(object):\n\n \"\"\n \n _WARNING_DETAILS = (\"message\", \"category\", \"filename\", \"lineno\", \"file\",\n \"line\")\n \n def __init__(self, message, category, filename, lineno, file=None,\n line=None):\n  local_values = locals()\n  for attr in self._WARNING_DETAILS:\n   setattr(self, attr, local_values[attr])\n  self._category_name = category.__name__ if category else None\n  \n def __str__(self):\n  return (\"{message : %r, category : %r, filename : %r, lineno : %s, \"\n  \"line : %r}\" % (self.message, self._category_name,\n  self.filename, self.lineno, self.line))\n  \n  \nclass catch_warnings(object):\n\n \"\"\n \n def __init__(self, *, record=False, module=None):\n  \"\"\n  self._record = record\n  self._module = sys.modules['warnings'] if module is None else module\n  self._entered = False\n  \n def __repr__(self):\n  args = []\n  if self._record:\n   args.append(\"record=True\")\n  if self._module is not sys.modules['warnings']:\n   args.append(\"module=%r\" % self._module)\n  name = type(self).__name__\n  return \"%s(%s)\" % (name, \", \".join(args))\n  \n def __enter__(self):\n  if self._entered:\n   raise RuntimeError(\"Cannot enter %r twice\" % self)\n  self._entered = True\n  self._filters = self._module.filters\n  self._module.filters = self._filters[:]\n  self._showwarning = self._module.showwarning\n  if self._record:\n   log = []\n   def showwarning(*args, **kwargs):\n    log.append(WarningMessage(*args, **kwargs))\n   self._module.showwarning = showwarning\n   return log\n  else:\n   return None\n   \n def __exit__(self, *exc_info):\n  if not self._entered:\n   raise RuntimeError(\"Cannot exit %r without entering first\" % self)\n  self._module.filters = self._filters\n  self._module.showwarning = self._showwarning\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n_warnings_defaults = False\ntry:\n from _warnings import (filters, _defaultaction, _onceregistry,\n warn, warn_explicit)\n defaultaction = _defaultaction\n onceregistry = _onceregistry\n _warnings_defaults = True\nexcept ImportError:\n filters = []\n defaultaction = \"default\"\n onceregistry = {}\n \n \n \n_processoptions(sys.warnoptions)\nif not _warnings_defaults:\n silence = [ImportWarning, PendingDeprecationWarning]\n silence.append(DeprecationWarning)\n for cls in silence:\n  simplefilter(\"ignore\", category=cls)\n bytes_warning = sys.flags.bytes_warning\n if bytes_warning > 1:\n  bytes_action = \"error\"\n elif bytes_warning:\n  bytes_action = \"default\"\n else:\n  bytes_action = \"ignore\"\n simplefilter(bytes_action, category=BytesWarning, append=1)\n \n if hasattr(sys, 'gettotalrefcount'):\n  resource_action = \"always\"\n else:\n  resource_action = \"ignore\"\n simplefilter(resource_action, category=ResourceWarning, append=1)\n \ndel _warnings_defaults\n"], "html.entities": [".py", "\"\"\n\n\nname2codepoint = {\n'AElig': 0x00c6, \n'Aacute': 0x00c1, \n'Acirc': 0x00c2, \n'Agrave': 0x00c0, \n'Alpha': 0x0391, \n'Aring': 0x00c5, \n'Atilde': 0x00c3, \n'Auml': 0x00c4, \n'Beta': 0x0392, \n'Ccedil': 0x00c7, \n'Chi': 0x03a7, \n'Dagger': 0x2021, \n'Delta': 0x0394, \n'ETH': 0x00d0, \n'Eacute': 0x00c9, \n'Ecirc': 0x00ca, \n'Egrave': 0x00c8, \n'Epsilon': 0x0395, \n'Eta': 0x0397, \n'Euml': 0x00cb, \n'Gamma': 0x0393, \n'Iacute': 0x00cd, \n'Icirc': 0x00ce, \n'Igrave': 0x00cc, \n'Iota': 0x0399, \n'Iuml': 0x00cf, \n'Kappa': 0x039a, \n'Lambda': 0x039b, \n'Mu': 0x039c, \n'Ntilde': 0x00d1, \n'Nu': 0x039d, \n'OElig': 0x0152, \n'Oacute': 0x00d3, \n'Ocirc': 0x00d4, \n'Ograve': 0x00d2, \n'Omega': 0x03a9, \n'Omicron': 0x039f, \n'Oslash': 0x00d8, \n'Otilde': 0x00d5, \n'Ouml': 0x00d6, \n'Phi': 0x03a6, \n'Pi': 0x03a0, \n'Prime': 0x2033, \n'Psi': 0x03a8, \n'Rho': 0x03a1, \n'Scaron': 0x0160, \n'Sigma': 0x03a3, \n'THORN': 0x00de, \n'Tau': 0x03a4, \n'Theta': 0x0398, \n'Uacute': 0x00da, \n'Ucirc': 0x00db, \n'Ugrave': 0x00d9, \n'Upsilon': 0x03a5, \n'Uuml': 0x00dc, \n'Xi': 0x039e, \n'Yacute': 0x00dd, \n'Yuml': 0x0178, \n'Zeta': 0x0396, \n'aacute': 0x00e1, \n'acirc': 0x00e2, \n'acute': 0x00b4, \n'aelig': 0x00e6, \n'agrave': 0x00e0, \n'alefsym': 0x2135, \n'alpha': 0x03b1, \n'amp': 0x0026, \n'and': 0x2227, \n'ang': 0x2220, \n'aring': 0x00e5, \n'asymp': 0x2248, \n'atilde': 0x00e3, \n'auml': 0x00e4, \n'bdquo': 0x201e, \n'beta': 0x03b2, \n'brvbar': 0x00a6, \n'bull': 0x2022, \n'cap': 0x2229, \n'ccedil': 0x00e7, \n'cedil': 0x00b8, \n'cent': 0x00a2, \n'chi': 0x03c7, \n'circ': 0x02c6, \n'clubs': 0x2663, \n'cong': 0x2245, \n'copy': 0x00a9, \n'crarr': 0x21b5, \n'cup': 0x222a, \n'curren': 0x00a4, \n'dArr': 0x21d3, \n'dagger': 0x2020, \n'darr': 0x2193, \n'deg': 0x00b0, \n'delta': 0x03b4, \n'diams': 0x2666, \n'divide': 0x00f7, \n'eacute': 0x00e9, \n'ecirc': 0x00ea, \n'egrave': 0x00e8, \n'empty': 0x2205, \n'emsp': 0x2003, \n'ensp': 0x2002, \n'epsilon': 0x03b5, \n'equiv': 0x2261, \n'eta': 0x03b7, \n'eth': 0x00f0, \n'euml': 0x00eb, \n'euro': 0x20ac, \n'exist': 0x2203, \n'fnof': 0x0192, \n'forall': 0x2200, \n'frac12': 0x00bd, \n'frac14': 0x00bc, \n'frac34': 0x00be, \n'frasl': 0x2044, \n'gamma': 0x03b3, \n'ge': 0x2265, \n'gt': 0x003e, \n'hArr': 0x21d4, \n'harr': 0x2194, \n'hearts': 0x2665, \n'hellip': 0x2026, \n'iacute': 0x00ed, \n'icirc': 0x00ee, \n'iexcl': 0x00a1, \n'igrave': 0x00ec, \n'image': 0x2111, \n'infin': 0x221e, \n'int': 0x222b, \n'iota': 0x03b9, \n'iquest': 0x00bf, \n'isin': 0x2208, \n'iuml': 0x00ef, \n'kappa': 0x03ba, \n'lArr': 0x21d0, \n'lambda': 0x03bb, \n'lang': 0x2329, \n'laquo': 0x00ab, \n'larr': 0x2190, \n'lceil': 0x2308, \n'ldquo': 0x201c, \n'le': 0x2264, \n'lfloor': 0x230a, \n'lowast': 0x2217, \n'loz': 0x25ca, \n'lrm': 0x200e, \n'lsaquo': 0x2039, \n'lsquo': 0x2018, \n'lt': 0x003c, \n'macr': 0x00af, \n'mdash': 0x2014, \n'micro': 0x00b5, \n'middot': 0x00b7, \n'minus': 0x2212, \n'mu': 0x03bc, \n'nabla': 0x2207, \n'nbsp': 0x00a0, \n'ndash': 0x2013, \n'ne': 0x2260, \n'ni': 0x220b, \n'not': 0x00ac, \n'notin': 0x2209, \n'nsub': 0x2284, \n'ntilde': 0x00f1, \n'nu': 0x03bd, \n'oacute': 0x00f3, \n'ocirc': 0x00f4, \n'oelig': 0x0153, \n'ograve': 0x00f2, \n'oline': 0x203e, \n'omega': 0x03c9, \n'omicron': 0x03bf, \n'oplus': 0x2295, \n'or': 0x2228, \n'ordf': 0x00aa, \n'ordm': 0x00ba, \n'oslash': 0x00f8, \n'otilde': 0x00f5, \n'otimes': 0x2297, \n'ouml': 0x00f6, \n'para': 0x00b6, \n'part': 0x2202, \n'permil': 0x2030, \n'perp': 0x22a5, \n'phi': 0x03c6, \n'pi': 0x03c0, \n'piv': 0x03d6, \n'plusmn': 0x00b1, \n'pound': 0x00a3, \n'prime': 0x2032, \n'prod': 0x220f, \n'prop': 0x221d, \n'psi': 0x03c8, \n'quot': 0x0022, \n'rArr': 0x21d2, \n'radic': 0x221a, \n'rang': 0x232a, \n'raquo': 0x00bb, \n'rarr': 0x2192, \n'rceil': 0x2309, \n'rdquo': 0x201d, \n'real': 0x211c, \n'reg': 0x00ae, \n'rfloor': 0x230b, \n'rho': 0x03c1, \n'rlm': 0x200f, \n'rsaquo': 0x203a, \n'rsquo': 0x2019, \n'sbquo': 0x201a, \n'scaron': 0x0161, \n'sdot': 0x22c5, \n'sect': 0x00a7, \n'shy': 0x00ad, \n'sigma': 0x03c3, \n'sigmaf': 0x03c2, \n'sim': 0x223c, \n'spades': 0x2660, \n'sub': 0x2282, \n'sube': 0x2286, \n'sum': 0x2211, \n'sup': 0x2283, \n'sup1': 0x00b9, \n'sup2': 0x00b2, \n'sup3': 0x00b3, \n'supe': 0x2287, \n'szlig': 0x00df, \n'tau': 0x03c4, \n'there4': 0x2234, \n'theta': 0x03b8, \n'thetasym': 0x03d1, \n'thinsp': 0x2009, \n'thorn': 0x00fe, \n'tilde': 0x02dc, \n'times': 0x00d7, \n'trade': 0x2122, \n'uArr': 0x21d1, \n'uacute': 0x00fa, \n'uarr': 0x2191, \n'ucirc': 0x00fb, \n'ugrave': 0x00f9, \n'uml': 0x00a8, \n'upsih': 0x03d2, \n'upsilon': 0x03c5, \n'uuml': 0x00fc, \n'weierp': 0x2118, \n'xi': 0x03be, \n'yacute': 0x00fd, \n'yen': 0x00a5, \n'yuml': 0x00ff, \n'zeta': 0x03b6, \n'zwj': 0x200d, \n'zwnj': 0x200c, \n}\n\n\n\nhtml5 = {\n'Aacute': '\\xc1',\n'aacute': '\\xe1',\n'Aacute;': '\\xc1',\n'aacute;': '\\xe1',\n'Abreve;': '\\u0102',\n'abreve;': '\\u0103',\n'ac;': '\\u223e',\n'acd;': '\\u223f',\n'acE;': '\\u223e\\u0333',\n'Acirc': '\\xc2',\n'acirc': '\\xe2',\n'Acirc;': '\\xc2',\n'acirc;': '\\xe2',\n'acute': '\\xb4',\n'acute;': '\\xb4',\n'Acy;': '\\u0410',\n'acy;': '\\u0430',\n'AElig': '\\xc6',\n'aelig': '\\xe6',\n'AElig;': '\\xc6',\n'aelig;': '\\xe6',\n'af;': '\\u2061',\n'Afr;': '\\U0001d504',\n'afr;': '\\U0001d51e',\n'Agrave': '\\xc0',\n'agrave': '\\xe0',\n'Agrave;': '\\xc0',\n'agrave;': '\\xe0',\n'alefsym;': '\\u2135',\n'aleph;': '\\u2135',\n'Alpha;': '\\u0391',\n'alpha;': '\\u03b1',\n'Amacr;': '\\u0100',\n'amacr;': '\\u0101',\n'amalg;': '\\u2a3f',\n'AMP': '&',\n'amp': '&',\n'AMP;': '&',\n'amp;': '&',\n'And;': '\\u2a53',\n'and;': '\\u2227',\n'andand;': '\\u2a55',\n'andd;': '\\u2a5c',\n'andslope;': '\\u2a58',\n'andv;': '\\u2a5a',\n'ang;': '\\u2220',\n'ange;': '\\u29a4',\n'angle;': '\\u2220',\n'angmsd;': '\\u2221',\n'angmsdaa;': '\\u29a8',\n'angmsdab;': '\\u29a9',\n'angmsdac;': '\\u29aa',\n'angmsdad;': '\\u29ab',\n'angmsdae;': '\\u29ac',\n'angmsdaf;': '\\u29ad',\n'angmsdag;': '\\u29ae',\n'angmsdah;': '\\u29af',\n'angrt;': '\\u221f',\n'angrtvb;': '\\u22be',\n'angrtvbd;': '\\u299d',\n'angsph;': '\\u2222',\n'angst;': '\\xc5',\n'angzarr;': '\\u237c',\n'Aogon;': '\\u0104',\n'aogon;': '\\u0105',\n'Aopf;': '\\U0001d538',\n'aopf;': '\\U0001d552',\n'ap;': '\\u2248',\n'apacir;': '\\u2a6f',\n'apE;': '\\u2a70',\n'ape;': '\\u224a',\n'apid;': '\\u224b',\n'apos;': \"'\",\n'ApplyFunction;': '\\u2061',\n'approx;': '\\u2248',\n'approxeq;': '\\u224a',\n'Aring': '\\xc5',\n'aring': '\\xe5',\n'Aring;': '\\xc5',\n'aring;': '\\xe5',\n'Ascr;': '\\U0001d49c',\n'ascr;': '\\U0001d4b6',\n'Assign;': '\\u2254',\n'ast;': '*',\n'asymp;': '\\u2248',\n'asympeq;': '\\u224d',\n'Atilde': '\\xc3',\n'atilde': '\\xe3',\n'Atilde;': '\\xc3',\n'atilde;': '\\xe3',\n'Auml': '\\xc4',\n'auml': '\\xe4',\n'Auml;': '\\xc4',\n'auml;': '\\xe4',\n'awconint;': '\\u2233',\n'awint;': '\\u2a11',\n'backcong;': '\\u224c',\n'backepsilon;': '\\u03f6',\n'backprime;': '\\u2035',\n'backsim;': '\\u223d',\n'backsimeq;': '\\u22cd',\n'Backslash;': '\\u2216',\n'Barv;': '\\u2ae7',\n'barvee;': '\\u22bd',\n'Barwed;': '\\u2306',\n'barwed;': '\\u2305',\n'barwedge;': '\\u2305',\n'bbrk;': '\\u23b5',\n'bbrktbrk;': '\\u23b6',\n'bcong;': '\\u224c',\n'Bcy;': '\\u0411',\n'bcy;': '\\u0431',\n'bdquo;': '\\u201e',\n'becaus;': '\\u2235',\n'Because;': '\\u2235',\n'because;': '\\u2235',\n'bemptyv;': '\\u29b0',\n'bepsi;': '\\u03f6',\n'bernou;': '\\u212c',\n'Bernoullis;': '\\u212c',\n'Beta;': '\\u0392',\n'beta;': '\\u03b2',\n'beth;': '\\u2136',\n'between;': '\\u226c',\n'Bfr;': '\\U0001d505',\n'bfr;': '\\U0001d51f',\n'bigcap;': '\\u22c2',\n'bigcirc;': '\\u25ef',\n'bigcup;': '\\u22c3',\n'bigodot;': '\\u2a00',\n'bigoplus;': '\\u2a01',\n'bigotimes;': '\\u2a02',\n'bigsqcup;': '\\u2a06',\n'bigstar;': '\\u2605',\n'bigtriangledown;': '\\u25bd',\n'bigtriangleup;': '\\u25b3',\n'biguplus;': '\\u2a04',\n'bigvee;': '\\u22c1',\n'bigwedge;': '\\u22c0',\n'bkarow;': '\\u290d',\n'blacklozenge;': '\\u29eb',\n'blacksquare;': '\\u25aa',\n'blacktriangle;': '\\u25b4',\n'blacktriangledown;': '\\u25be',\n'blacktriangleleft;': '\\u25c2',\n'blacktriangleright;': '\\u25b8',\n'blank;': '\\u2423',\n'blk12;': '\\u2592',\n'blk14;': '\\u2591',\n'blk34;': '\\u2593',\n'block;': '\\u2588',\n'bne;': '=\\u20e5',\n'bnequiv;': '\\u2261\\u20e5',\n'bNot;': '\\u2aed',\n'bnot;': '\\u2310',\n'Bopf;': '\\U0001d539',\n'bopf;': '\\U0001d553',\n'bot;': '\\u22a5',\n'bottom;': '\\u22a5',\n'bowtie;': '\\u22c8',\n'boxbox;': '\\u29c9',\n'boxDL;': '\\u2557',\n'boxDl;': '\\u2556',\n'boxdL;': '\\u2555',\n'boxdl;': '\\u2510',\n'boxDR;': '\\u2554',\n'boxDr;': '\\u2553',\n'boxdR;': '\\u2552',\n'boxdr;': '\\u250c',\n'boxH;': '\\u2550',\n'boxh;': '\\u2500',\n'boxHD;': '\\u2566',\n'boxHd;': '\\u2564',\n'boxhD;': '\\u2565',\n'boxhd;': '\\u252c',\n'boxHU;': '\\u2569',\n'boxHu;': '\\u2567',\n'boxhU;': '\\u2568',\n'boxhu;': '\\u2534',\n'boxminus;': '\\u229f',\n'boxplus;': '\\u229e',\n'boxtimes;': '\\u22a0',\n'boxUL;': '\\u255d',\n'boxUl;': '\\u255c',\n'boxuL;': '\\u255b',\n'boxul;': '\\u2518',\n'boxUR;': '\\u255a',\n'boxUr;': '\\u2559',\n'boxuR;': '\\u2558',\n'boxur;': '\\u2514',\n'boxV;': '\\u2551',\n'boxv;': '\\u2502',\n'boxVH;': '\\u256c',\n'boxVh;': '\\u256b',\n'boxvH;': '\\u256a',\n'boxvh;': '\\u253c',\n'boxVL;': '\\u2563',\n'boxVl;': '\\u2562',\n'boxvL;': '\\u2561',\n'boxvl;': '\\u2524',\n'boxVR;': '\\u2560',\n'boxVr;': '\\u255f',\n'boxvR;': '\\u255e',\n'boxvr;': '\\u251c',\n'bprime;': '\\u2035',\n'Breve;': '\\u02d8',\n'breve;': '\\u02d8',\n'brvbar': '\\xa6',\n'brvbar;': '\\xa6',\n'Bscr;': '\\u212c',\n'bscr;': '\\U0001d4b7',\n'bsemi;': '\\u204f',\n'bsim;': '\\u223d',\n'bsime;': '\\u22cd',\n'bsol;': '\\\\',\n'bsolb;': '\\u29c5',\n'bsolhsub;': '\\u27c8',\n'bull;': '\\u2022',\n'bullet;': '\\u2022',\n'bump;': '\\u224e',\n'bumpE;': '\\u2aae',\n'bumpe;': '\\u224f',\n'Bumpeq;': '\\u224e',\n'bumpeq;': '\\u224f',\n'Cacute;': '\\u0106',\n'cacute;': '\\u0107',\n'Cap;': '\\u22d2',\n'cap;': '\\u2229',\n'capand;': '\\u2a44',\n'capbrcup;': '\\u2a49',\n'capcap;': '\\u2a4b',\n'capcup;': '\\u2a47',\n'capdot;': '\\u2a40',\n'CapitalDifferentialD;': '\\u2145',\n'caps;': '\\u2229\\ufe00',\n'caret;': '\\u2041',\n'caron;': '\\u02c7',\n'Cayleys;': '\\u212d',\n'ccaps;': '\\u2a4d',\n'Ccaron;': '\\u010c',\n'ccaron;': '\\u010d',\n'Ccedil': '\\xc7',\n'ccedil': '\\xe7',\n'Ccedil;': '\\xc7',\n'ccedil;': '\\xe7',\n'Ccirc;': '\\u0108',\n'ccirc;': '\\u0109',\n'Cconint;': '\\u2230',\n'ccups;': '\\u2a4c',\n'ccupssm;': '\\u2a50',\n'Cdot;': '\\u010a',\n'cdot;': '\\u010b',\n'cedil': '\\xb8',\n'cedil;': '\\xb8',\n'Cedilla;': '\\xb8',\n'cemptyv;': '\\u29b2',\n'cent': '\\xa2',\n'cent;': '\\xa2',\n'CenterDot;': '\\xb7',\n'centerdot;': '\\xb7',\n'Cfr;': '\\u212d',\n'cfr;': '\\U0001d520',\n'CHcy;': '\\u0427',\n'chcy;': '\\u0447',\n'check;': '\\u2713',\n'checkmark;': '\\u2713',\n'Chi;': '\\u03a7',\n'chi;': '\\u03c7',\n'cir;': '\\u25cb',\n'circ;': '\\u02c6',\n'circeq;': '\\u2257',\n'circlearrowleft;': '\\u21ba',\n'circlearrowright;': '\\u21bb',\n'circledast;': '\\u229b',\n'circledcirc;': '\\u229a',\n'circleddash;': '\\u229d',\n'CircleDot;': '\\u2299',\n'circledR;': '\\xae',\n'circledS;': '\\u24c8',\n'CircleMinus;': '\\u2296',\n'CirclePlus;': '\\u2295',\n'CircleTimes;': '\\u2297',\n'cirE;': '\\u29c3',\n'cire;': '\\u2257',\n'cirfnint;': '\\u2a10',\n'cirmid;': '\\u2aef',\n'cirscir;': '\\u29c2',\n'ClockwiseContourIntegral;': '\\u2232',\n'CloseCurlyDoubleQuote;': '\\u201d',\n'CloseCurlyQuote;': '\\u2019',\n'clubs;': '\\u2663',\n'clubsuit;': '\\u2663',\n'Colon;': '\\u2237',\n'colon;': ':',\n'Colone;': '\\u2a74',\n'colone;': '\\u2254',\n'coloneq;': '\\u2254',\n'comma;': ',',\n'commat;': '@',\n'comp;': '\\u2201',\n'compfn;': '\\u2218',\n'complement;': '\\u2201',\n'complexes;': '\\u2102',\n'cong;': '\\u2245',\n'congdot;': '\\u2a6d',\n'Congruent;': '\\u2261',\n'Conint;': '\\u222f',\n'conint;': '\\u222e',\n'ContourIntegral;': '\\u222e',\n'Copf;': '\\u2102',\n'copf;': '\\U0001d554',\n'coprod;': '\\u2210',\n'Coproduct;': '\\u2210',\n'COPY': '\\xa9',\n'copy': '\\xa9',\n'COPY;': '\\xa9',\n'copy;': '\\xa9',\n'copysr;': '\\u2117',\n'CounterClockwiseContourIntegral;': '\\u2233',\n'crarr;': '\\u21b5',\n'Cross;': '\\u2a2f',\n'cross;': '\\u2717',\n'Cscr;': '\\U0001d49e',\n'cscr;': '\\U0001d4b8',\n'csub;': '\\u2acf',\n'csube;': '\\u2ad1',\n'csup;': '\\u2ad0',\n'csupe;': '\\u2ad2',\n'ctdot;': '\\u22ef',\n'cudarrl;': '\\u2938',\n'cudarrr;': '\\u2935',\n'cuepr;': '\\u22de',\n'cuesc;': '\\u22df',\n'cularr;': '\\u21b6',\n'cularrp;': '\\u293d',\n'Cup;': '\\u22d3',\n'cup;': '\\u222a',\n'cupbrcap;': '\\u2a48',\n'CupCap;': '\\u224d',\n'cupcap;': '\\u2a46',\n'cupcup;': '\\u2a4a',\n'cupdot;': '\\u228d',\n'cupor;': '\\u2a45',\n'cups;': '\\u222a\\ufe00',\n'curarr;': '\\u21b7',\n'curarrm;': '\\u293c',\n'curlyeqprec;': '\\u22de',\n'curlyeqsucc;': '\\u22df',\n'curlyvee;': '\\u22ce',\n'curlywedge;': '\\u22cf',\n'curren': '\\xa4',\n'curren;': '\\xa4',\n'curvearrowleft;': '\\u21b6',\n'curvearrowright;': '\\u21b7',\n'cuvee;': '\\u22ce',\n'cuwed;': '\\u22cf',\n'cwconint;': '\\u2232',\n'cwint;': '\\u2231',\n'cylcty;': '\\u232d',\n'Dagger;': '\\u2021',\n'dagger;': '\\u2020',\n'daleth;': '\\u2138',\n'Darr;': '\\u21a1',\n'dArr;': '\\u21d3',\n'darr;': '\\u2193',\n'dash;': '\\u2010',\n'Dashv;': '\\u2ae4',\n'dashv;': '\\u22a3',\n'dbkarow;': '\\u290f',\n'dblac;': '\\u02dd',\n'Dcaron;': '\\u010e',\n'dcaron;': '\\u010f',\n'Dcy;': '\\u0414',\n'dcy;': '\\u0434',\n'DD;': '\\u2145',\n'dd;': '\\u2146',\n'ddagger;': '\\u2021',\n'ddarr;': '\\u21ca',\n'DDotrahd;': '\\u2911',\n'ddotseq;': '\\u2a77',\n'deg': '\\xb0',\n'deg;': '\\xb0',\n'Del;': '\\u2207',\n'Delta;': '\\u0394',\n'delta;': '\\u03b4',\n'demptyv;': '\\u29b1',\n'dfisht;': '\\u297f',\n'Dfr;': '\\U0001d507',\n'dfr;': '\\U0001d521',\n'dHar;': '\\u2965',\n'dharl;': '\\u21c3',\n'dharr;': '\\u21c2',\n'DiacriticalAcute;': '\\xb4',\n'DiacriticalDot;': '\\u02d9',\n'DiacriticalDoubleAcute;': '\\u02dd',\n'DiacriticalGrave;': '`',\n'DiacriticalTilde;': '\\u02dc',\n'diam;': '\\u22c4',\n'Diamond;': '\\u22c4',\n'diamond;': '\\u22c4',\n'diamondsuit;': '\\u2666',\n'diams;': '\\u2666',\n'die;': '\\xa8',\n'DifferentialD;': '\\u2146',\n'digamma;': '\\u03dd',\n'disin;': '\\u22f2',\n'div;': '\\xf7',\n'divide': '\\xf7',\n'divide;': '\\xf7',\n'divideontimes;': '\\u22c7',\n'divonx;': '\\u22c7',\n'DJcy;': '\\u0402',\n'djcy;': '\\u0452',\n'dlcorn;': '\\u231e',\n'dlcrop;': '\\u230d',\n'dollar;': '$',\n'Dopf;': '\\U0001d53b',\n'dopf;': '\\U0001d555',\n'Dot;': '\\xa8',\n'dot;': '\\u02d9',\n'DotDot;': '\\u20dc',\n'doteq;': '\\u2250',\n'doteqdot;': '\\u2251',\n'DotEqual;': '\\u2250',\n'dotminus;': '\\u2238',\n'dotplus;': '\\u2214',\n'dotsquare;': '\\u22a1',\n'doublebarwedge;': '\\u2306',\n'DoubleContourIntegral;': '\\u222f',\n'DoubleDot;': '\\xa8',\n'DoubleDownArrow;': '\\u21d3',\n'DoubleLeftArrow;': '\\u21d0',\n'DoubleLeftRightArrow;': '\\u21d4',\n'DoubleLeftTee;': '\\u2ae4',\n'DoubleLongLeftArrow;': '\\u27f8',\n'DoubleLongLeftRightArrow;': '\\u27fa',\n'DoubleLongRightArrow;': '\\u27f9',\n'DoubleRightArrow;': '\\u21d2',\n'DoubleRightTee;': '\\u22a8',\n'DoubleUpArrow;': '\\u21d1',\n'DoubleUpDownArrow;': '\\u21d5',\n'DoubleVerticalBar;': '\\u2225',\n'DownArrow;': '\\u2193',\n'Downarrow;': '\\u21d3',\n'downarrow;': '\\u2193',\n'DownArrowBar;': '\\u2913',\n'DownArrowUpArrow;': '\\u21f5',\n'DownBreve;': '\\u0311',\n'downdownarrows;': '\\u21ca',\n'downharpoonleft;': '\\u21c3',\n'downharpoonright;': '\\u21c2',\n'DownLeftRightVector;': '\\u2950',\n'DownLeftTeeVector;': '\\u295e',\n'DownLeftVector;': '\\u21bd',\n'DownLeftVectorBar;': '\\u2956',\n'DownRightTeeVector;': '\\u295f',\n'DownRightVector;': '\\u21c1',\n'DownRightVectorBar;': '\\u2957',\n'DownTee;': '\\u22a4',\n'DownTeeArrow;': '\\u21a7',\n'drbkarow;': '\\u2910',\n'drcorn;': '\\u231f',\n'drcrop;': '\\u230c',\n'Dscr;': '\\U0001d49f',\n'dscr;': '\\U0001d4b9',\n'DScy;': '\\u0405',\n'dscy;': '\\u0455',\n'dsol;': '\\u29f6',\n'Dstrok;': '\\u0110',\n'dstrok;': '\\u0111',\n'dtdot;': '\\u22f1',\n'dtri;': '\\u25bf',\n'dtrif;': '\\u25be',\n'duarr;': '\\u21f5',\n'duhar;': '\\u296f',\n'dwangle;': '\\u29a6',\n'DZcy;': '\\u040f',\n'dzcy;': '\\u045f',\n'dzigrarr;': '\\u27ff',\n'Eacute': '\\xc9',\n'eacute': '\\xe9',\n'Eacute;': '\\xc9',\n'eacute;': '\\xe9',\n'easter;': '\\u2a6e',\n'Ecaron;': '\\u011a',\n'ecaron;': '\\u011b',\n'ecir;': '\\u2256',\n'Ecirc': '\\xca',\n'ecirc': '\\xea',\n'Ecirc;': '\\xca',\n'ecirc;': '\\xea',\n'ecolon;': '\\u2255',\n'Ecy;': '\\u042d',\n'ecy;': '\\u044d',\n'eDDot;': '\\u2a77',\n'Edot;': '\\u0116',\n'eDot;': '\\u2251',\n'edot;': '\\u0117',\n'ee;': '\\u2147',\n'efDot;': '\\u2252',\n'Efr;': '\\U0001d508',\n'efr;': '\\U0001d522',\n'eg;': '\\u2a9a',\n'Egrave': '\\xc8',\n'egrave': '\\xe8',\n'Egrave;': '\\xc8',\n'egrave;': '\\xe8',\n'egs;': '\\u2a96',\n'egsdot;': '\\u2a98',\n'el;': '\\u2a99',\n'Element;': '\\u2208',\n'elinters;': '\\u23e7',\n'ell;': '\\u2113',\n'els;': '\\u2a95',\n'elsdot;': '\\u2a97',\n'Emacr;': '\\u0112',\n'emacr;': '\\u0113',\n'empty;': '\\u2205',\n'emptyset;': '\\u2205',\n'EmptySmallSquare;': '\\u25fb',\n'emptyv;': '\\u2205',\n'EmptyVerySmallSquare;': '\\u25ab',\n'emsp13;': '\\u2004',\n'emsp14;': '\\u2005',\n'emsp;': '\\u2003',\n'ENG;': '\\u014a',\n'eng;': '\\u014b',\n'ensp;': '\\u2002',\n'Eogon;': '\\u0118',\n'eogon;': '\\u0119',\n'Eopf;': '\\U0001d53c',\n'eopf;': '\\U0001d556',\n'epar;': '\\u22d5',\n'eparsl;': '\\u29e3',\n'eplus;': '\\u2a71',\n'epsi;': '\\u03b5',\n'Epsilon;': '\\u0395',\n'epsilon;': '\\u03b5',\n'epsiv;': '\\u03f5',\n'eqcirc;': '\\u2256',\n'eqcolon;': '\\u2255',\n'eqsim;': '\\u2242',\n'eqslantgtr;': '\\u2a96',\n'eqslantless;': '\\u2a95',\n'Equal;': '\\u2a75',\n'equals;': '=',\n'EqualTilde;': '\\u2242',\n'equest;': '\\u225f',\n'Equilibrium;': '\\u21cc',\n'equiv;': '\\u2261',\n'equivDD;': '\\u2a78',\n'eqvparsl;': '\\u29e5',\n'erarr;': '\\u2971',\n'erDot;': '\\u2253',\n'Escr;': '\\u2130',\n'escr;': '\\u212f',\n'esdot;': '\\u2250',\n'Esim;': '\\u2a73',\n'esim;': '\\u2242',\n'Eta;': '\\u0397',\n'eta;': '\\u03b7',\n'ETH': '\\xd0',\n'eth': '\\xf0',\n'ETH;': '\\xd0',\n'eth;': '\\xf0',\n'Euml': '\\xcb',\n'euml': '\\xeb',\n'Euml;': '\\xcb',\n'euml;': '\\xeb',\n'euro;': '\\u20ac',\n'excl;': '!',\n'exist;': '\\u2203',\n'Exists;': '\\u2203',\n'expectation;': '\\u2130',\n'ExponentialE;': '\\u2147',\n'exponentiale;': '\\u2147',\n'fallingdotseq;': '\\u2252',\n'Fcy;': '\\u0424',\n'fcy;': '\\u0444',\n'female;': '\\u2640',\n'ffilig;': '\\ufb03',\n'fflig;': '\\ufb00',\n'ffllig;': '\\ufb04',\n'Ffr;': '\\U0001d509',\n'ffr;': '\\U0001d523',\n'filig;': '\\ufb01',\n'FilledSmallSquare;': '\\u25fc',\n'FilledVerySmallSquare;': '\\u25aa',\n'fjlig;': 'fj',\n'flat;': '\\u266d',\n'fllig;': '\\ufb02',\n'fltns;': '\\u25b1',\n'fnof;': '\\u0192',\n'Fopf;': '\\U0001d53d',\n'fopf;': '\\U0001d557',\n'ForAll;': '\\u2200',\n'forall;': '\\u2200',\n'fork;': '\\u22d4',\n'forkv;': '\\u2ad9',\n'Fouriertrf;': '\\u2131',\n'fpartint;': '\\u2a0d',\n'frac12': '\\xbd',\n'frac12;': '\\xbd',\n'frac13;': '\\u2153',\n'frac14': '\\xbc',\n'frac14;': '\\xbc',\n'frac15;': '\\u2155',\n'frac16;': '\\u2159',\n'frac18;': '\\u215b',\n'frac23;': '\\u2154',\n'frac25;': '\\u2156',\n'frac34': '\\xbe',\n'frac34;': '\\xbe',\n'frac35;': '\\u2157',\n'frac38;': '\\u215c',\n'frac45;': '\\u2158',\n'frac56;': '\\u215a',\n'frac58;': '\\u215d',\n'frac78;': '\\u215e',\n'frasl;': '\\u2044',\n'frown;': '\\u2322',\n'Fscr;': '\\u2131',\n'fscr;': '\\U0001d4bb',\n'gacute;': '\\u01f5',\n'Gamma;': '\\u0393',\n'gamma;': '\\u03b3',\n'Gammad;': '\\u03dc',\n'gammad;': '\\u03dd',\n'gap;': '\\u2a86',\n'Gbreve;': '\\u011e',\n'gbreve;': '\\u011f',\n'Gcedil;': '\\u0122',\n'Gcirc;': '\\u011c',\n'gcirc;': '\\u011d',\n'Gcy;': '\\u0413',\n'gcy;': '\\u0433',\n'Gdot;': '\\u0120',\n'gdot;': '\\u0121',\n'gE;': '\\u2267',\n'ge;': '\\u2265',\n'gEl;': '\\u2a8c',\n'gel;': '\\u22db',\n'geq;': '\\u2265',\n'geqq;': '\\u2267',\n'geqslant;': '\\u2a7e',\n'ges;': '\\u2a7e',\n'gescc;': '\\u2aa9',\n'gesdot;': '\\u2a80',\n'gesdoto;': '\\u2a82',\n'gesdotol;': '\\u2a84',\n'gesl;': '\\u22db\\ufe00',\n'gesles;': '\\u2a94',\n'Gfr;': '\\U0001d50a',\n'gfr;': '\\U0001d524',\n'Gg;': '\\u22d9',\n'gg;': '\\u226b',\n'ggg;': '\\u22d9',\n'gimel;': '\\u2137',\n'GJcy;': '\\u0403',\n'gjcy;': '\\u0453',\n'gl;': '\\u2277',\n'gla;': '\\u2aa5',\n'glE;': '\\u2a92',\n'glj;': '\\u2aa4',\n'gnap;': '\\u2a8a',\n'gnapprox;': '\\u2a8a',\n'gnE;': '\\u2269',\n'gne;': '\\u2a88',\n'gneq;': '\\u2a88',\n'gneqq;': '\\u2269',\n'gnsim;': '\\u22e7',\n'Gopf;': '\\U0001d53e',\n'gopf;': '\\U0001d558',\n'grave;': '`',\n'GreaterEqual;': '\\u2265',\n'GreaterEqualLess;': '\\u22db',\n'GreaterFullEqual;': '\\u2267',\n'GreaterGreater;': '\\u2aa2',\n'GreaterLess;': '\\u2277',\n'GreaterSlantEqual;': '\\u2a7e',\n'GreaterTilde;': '\\u2273',\n'Gscr;': '\\U0001d4a2',\n'gscr;': '\\u210a',\n'gsim;': '\\u2273',\n'gsime;': '\\u2a8e',\n'gsiml;': '\\u2a90',\n'GT': '>',\n'gt': '>',\n'GT;': '>',\n'Gt;': '\\u226b',\n'gt;': '>',\n'gtcc;': '\\u2aa7',\n'gtcir;': '\\u2a7a',\n'gtdot;': '\\u22d7',\n'gtlPar;': '\\u2995',\n'gtquest;': '\\u2a7c',\n'gtrapprox;': '\\u2a86',\n'gtrarr;': '\\u2978',\n'gtrdot;': '\\u22d7',\n'gtreqless;': '\\u22db',\n'gtreqqless;': '\\u2a8c',\n'gtrless;': '\\u2277',\n'gtrsim;': '\\u2273',\n'gvertneqq;': '\\u2269\\ufe00',\n'gvnE;': '\\u2269\\ufe00',\n'Hacek;': '\\u02c7',\n'hairsp;': '\\u200a',\n'half;': '\\xbd',\n'hamilt;': '\\u210b',\n'HARDcy;': '\\u042a',\n'hardcy;': '\\u044a',\n'hArr;': '\\u21d4',\n'harr;': '\\u2194',\n'harrcir;': '\\u2948',\n'harrw;': '\\u21ad',\n'Hat;': '^',\n'hbar;': '\\u210f',\n'Hcirc;': '\\u0124',\n'hcirc;': '\\u0125',\n'hearts;': '\\u2665',\n'heartsuit;': '\\u2665',\n'hellip;': '\\u2026',\n'hercon;': '\\u22b9',\n'Hfr;': '\\u210c',\n'hfr;': '\\U0001d525',\n'HilbertSpace;': '\\u210b',\n'hksearow;': '\\u2925',\n'hkswarow;': '\\u2926',\n'hoarr;': '\\u21ff',\n'homtht;': '\\u223b',\n'hookleftarrow;': '\\u21a9',\n'hookrightarrow;': '\\u21aa',\n'Hopf;': '\\u210d',\n'hopf;': '\\U0001d559',\n'horbar;': '\\u2015',\n'HorizontalLine;': '\\u2500',\n'Hscr;': '\\u210b',\n'hscr;': '\\U0001d4bd',\n'hslash;': '\\u210f',\n'Hstrok;': '\\u0126',\n'hstrok;': '\\u0127',\n'HumpDownHump;': '\\u224e',\n'HumpEqual;': '\\u224f',\n'hybull;': '\\u2043',\n'hyphen;': '\\u2010',\n'Iacute': '\\xcd',\n'iacute': '\\xed',\n'Iacute;': '\\xcd',\n'iacute;': '\\xed',\n'ic;': '\\u2063',\n'Icirc': '\\xce',\n'icirc': '\\xee',\n'Icirc;': '\\xce',\n'icirc;': '\\xee',\n'Icy;': '\\u0418',\n'icy;': '\\u0438',\n'Idot;': '\\u0130',\n'IEcy;': '\\u0415',\n'iecy;': '\\u0435',\n'iexcl': '\\xa1',\n'iexcl;': '\\xa1',\n'iff;': '\\u21d4',\n'Ifr;': '\\u2111',\n'ifr;': '\\U0001d526',\n'Igrave': '\\xcc',\n'igrave': '\\xec',\n'Igrave;': '\\xcc',\n'igrave;': '\\xec',\n'ii;': '\\u2148',\n'iiiint;': '\\u2a0c',\n'iiint;': '\\u222d',\n'iinfin;': '\\u29dc',\n'iiota;': '\\u2129',\n'IJlig;': '\\u0132',\n'ijlig;': '\\u0133',\n'Im;': '\\u2111',\n'Imacr;': '\\u012a',\n'imacr;': '\\u012b',\n'image;': '\\u2111',\n'ImaginaryI;': '\\u2148',\n'imagline;': '\\u2110',\n'imagpart;': '\\u2111',\n'imath;': '\\u0131',\n'imof;': '\\u22b7',\n'imped;': '\\u01b5',\n'Implies;': '\\u21d2',\n'in;': '\\u2208',\n'incare;': '\\u2105',\n'infin;': '\\u221e',\n'infintie;': '\\u29dd',\n'inodot;': '\\u0131',\n'Int;': '\\u222c',\n'int;': '\\u222b',\n'intcal;': '\\u22ba',\n'integers;': '\\u2124',\n'Integral;': '\\u222b',\n'intercal;': '\\u22ba',\n'Intersection;': '\\u22c2',\n'intlarhk;': '\\u2a17',\n'intprod;': '\\u2a3c',\n'InvisibleComma;': '\\u2063',\n'InvisibleTimes;': '\\u2062',\n'IOcy;': '\\u0401',\n'iocy;': '\\u0451',\n'Iogon;': '\\u012e',\n'iogon;': '\\u012f',\n'Iopf;': '\\U0001d540',\n'iopf;': '\\U0001d55a',\n'Iota;': '\\u0399',\n'iota;': '\\u03b9',\n'iprod;': '\\u2a3c',\n'iquest': '\\xbf',\n'iquest;': '\\xbf',\n'Iscr;': '\\u2110',\n'iscr;': '\\U0001d4be',\n'isin;': '\\u2208',\n'isindot;': '\\u22f5',\n'isinE;': '\\u22f9',\n'isins;': '\\u22f4',\n'isinsv;': '\\u22f3',\n'isinv;': '\\u2208',\n'it;': '\\u2062',\n'Itilde;': '\\u0128',\n'itilde;': '\\u0129',\n'Iukcy;': '\\u0406',\n'iukcy;': '\\u0456',\n'Iuml': '\\xcf',\n'iuml': '\\xef',\n'Iuml;': '\\xcf',\n'iuml;': '\\xef',\n'Jcirc;': '\\u0134',\n'jcirc;': '\\u0135',\n'Jcy;': '\\u0419',\n'jcy;': '\\u0439',\n'Jfr;': '\\U0001d50d',\n'jfr;': '\\U0001d527',\n'jmath;': '\\u0237',\n'Jopf;': '\\U0001d541',\n'jopf;': '\\U0001d55b',\n'Jscr;': '\\U0001d4a5',\n'jscr;': '\\U0001d4bf',\n'Jsercy;': '\\u0408',\n'jsercy;': '\\u0458',\n'Jukcy;': '\\u0404',\n'jukcy;': '\\u0454',\n'Kappa;': '\\u039a',\n'kappa;': '\\u03ba',\n'kappav;': '\\u03f0',\n'Kcedil;': '\\u0136',\n'kcedil;': '\\u0137',\n'Kcy;': '\\u041a',\n'kcy;': '\\u043a',\n'Kfr;': '\\U0001d50e',\n'kfr;': '\\U0001d528',\n'kgreen;': '\\u0138',\n'KHcy;': '\\u0425',\n'khcy;': '\\u0445',\n'KJcy;': '\\u040c',\n'kjcy;': '\\u045c',\n'Kopf;': '\\U0001d542',\n'kopf;': '\\U0001d55c',\n'Kscr;': '\\U0001d4a6',\n'kscr;': '\\U0001d4c0',\n'lAarr;': '\\u21da',\n'Lacute;': '\\u0139',\n'lacute;': '\\u013a',\n'laemptyv;': '\\u29b4',\n'lagran;': '\\u2112',\n'Lambda;': '\\u039b',\n'lambda;': '\\u03bb',\n'Lang;': '\\u27ea',\n'lang;': '\\u27e8',\n'langd;': '\\u2991',\n'langle;': '\\u27e8',\n'lap;': '\\u2a85',\n'Laplacetrf;': '\\u2112',\n'laquo': '\\xab',\n'laquo;': '\\xab',\n'Larr;': '\\u219e',\n'lArr;': '\\u21d0',\n'larr;': '\\u2190',\n'larrb;': '\\u21e4',\n'larrbfs;': '\\u291f',\n'larrfs;': '\\u291d',\n'larrhk;': '\\u21a9',\n'larrlp;': '\\u21ab',\n'larrpl;': '\\u2939',\n'larrsim;': '\\u2973',\n'larrtl;': '\\u21a2',\n'lat;': '\\u2aab',\n'lAtail;': '\\u291b',\n'latail;': '\\u2919',\n'late;': '\\u2aad',\n'lates;': '\\u2aad\\ufe00',\n'lBarr;': '\\u290e',\n'lbarr;': '\\u290c',\n'lbbrk;': '\\u2772',\n'lbrace;': '{',\n'lbrack;': '[',\n'lbrke;': '\\u298b',\n'lbrksld;': '\\u298f',\n'lbrkslu;': '\\u298d',\n'Lcaron;': '\\u013d',\n'lcaron;': '\\u013e',\n'Lcedil;': '\\u013b',\n'lcedil;': '\\u013c',\n'lceil;': '\\u2308',\n'lcub;': '{',\n'Lcy;': '\\u041b',\n'lcy;': '\\u043b',\n'ldca;': '\\u2936',\n'ldquo;': '\\u201c',\n'ldquor;': '\\u201e',\n'ldrdhar;': '\\u2967',\n'ldrushar;': '\\u294b',\n'ldsh;': '\\u21b2',\n'lE;': '\\u2266',\n'le;': '\\u2264',\n'LeftAngleBracket;': '\\u27e8',\n'LeftArrow;': '\\u2190',\n'Leftarrow;': '\\u21d0',\n'leftarrow;': '\\u2190',\n'LeftArrowBar;': '\\u21e4',\n'LeftArrowRightArrow;': '\\u21c6',\n'leftarrowtail;': '\\u21a2',\n'LeftCeiling;': '\\u2308',\n'LeftDoubleBracket;': '\\u27e6',\n'LeftDownTeeVector;': '\\u2961',\n'LeftDownVector;': '\\u21c3',\n'LeftDownVectorBar;': '\\u2959',\n'LeftFloor;': '\\u230a',\n'leftharpoondown;': '\\u21bd',\n'leftharpoonup;': '\\u21bc',\n'leftleftarrows;': '\\u21c7',\n'LeftRightArrow;': '\\u2194',\n'Leftrightarrow;': '\\u21d4',\n'leftrightarrow;': '\\u2194',\n'leftrightarrows;': '\\u21c6',\n'leftrightharpoons;': '\\u21cb',\n'leftrightsquigarrow;': '\\u21ad',\n'LeftRightVector;': '\\u294e',\n'LeftTee;': '\\u22a3',\n'LeftTeeArrow;': '\\u21a4',\n'LeftTeeVector;': '\\u295a',\n'leftthreetimes;': '\\u22cb',\n'LeftTriangle;': '\\u22b2',\n'LeftTriangleBar;': '\\u29cf',\n'LeftTriangleEqual;': '\\u22b4',\n'LeftUpDownVector;': '\\u2951',\n'LeftUpTeeVector;': '\\u2960',\n'LeftUpVector;': '\\u21bf',\n'LeftUpVectorBar;': '\\u2958',\n'LeftVector;': '\\u21bc',\n'LeftVectorBar;': '\\u2952',\n'lEg;': '\\u2a8b',\n'leg;': '\\u22da',\n'leq;': '\\u2264',\n'leqq;': '\\u2266',\n'leqslant;': '\\u2a7d',\n'les;': '\\u2a7d',\n'lescc;': '\\u2aa8',\n'lesdot;': '\\u2a7f',\n'lesdoto;': '\\u2a81',\n'lesdotor;': '\\u2a83',\n'lesg;': '\\u22da\\ufe00',\n'lesges;': '\\u2a93',\n'lessapprox;': '\\u2a85',\n'lessdot;': '\\u22d6',\n'lesseqgtr;': '\\u22da',\n'lesseqqgtr;': '\\u2a8b',\n'LessEqualGreater;': '\\u22da',\n'LessFullEqual;': '\\u2266',\n'LessGreater;': '\\u2276',\n'lessgtr;': '\\u2276',\n'LessLess;': '\\u2aa1',\n'lesssim;': '\\u2272',\n'LessSlantEqual;': '\\u2a7d',\n'LessTilde;': '\\u2272',\n'lfisht;': '\\u297c',\n'lfloor;': '\\u230a',\n'Lfr;': '\\U0001d50f',\n'lfr;': '\\U0001d529',\n'lg;': '\\u2276',\n'lgE;': '\\u2a91',\n'lHar;': '\\u2962',\n'lhard;': '\\u21bd',\n'lharu;': '\\u21bc',\n'lharul;': '\\u296a',\n'lhblk;': '\\u2584',\n'LJcy;': '\\u0409',\n'ljcy;': '\\u0459',\n'Ll;': '\\u22d8',\n'll;': '\\u226a',\n'llarr;': '\\u21c7',\n'llcorner;': '\\u231e',\n'Lleftarrow;': '\\u21da',\n'llhard;': '\\u296b',\n'lltri;': '\\u25fa',\n'Lmidot;': '\\u013f',\n'lmidot;': '\\u0140',\n'lmoust;': '\\u23b0',\n'lmoustache;': '\\u23b0',\n'lnap;': '\\u2a89',\n'lnapprox;': '\\u2a89',\n'lnE;': '\\u2268',\n'lne;': '\\u2a87',\n'lneq;': '\\u2a87',\n'lneqq;': '\\u2268',\n'lnsim;': '\\u22e6',\n'loang;': '\\u27ec',\n'loarr;': '\\u21fd',\n'lobrk;': '\\u27e6',\n'LongLeftArrow;': '\\u27f5',\n'Longleftarrow;': '\\u27f8',\n'longleftarrow;': '\\u27f5',\n'LongLeftRightArrow;': '\\u27f7',\n'Longleftrightarrow;': '\\u27fa',\n'longleftrightarrow;': '\\u27f7',\n'longmapsto;': '\\u27fc',\n'LongRightArrow;': '\\u27f6',\n'Longrightarrow;': '\\u27f9',\n'longrightarrow;': '\\u27f6',\n'looparrowleft;': '\\u21ab',\n'looparrowright;': '\\u21ac',\n'lopar;': '\\u2985',\n'Lopf;': '\\U0001d543',\n'lopf;': '\\U0001d55d',\n'loplus;': '\\u2a2d',\n'lotimes;': '\\u2a34',\n'lowast;': '\\u2217',\n'lowbar;': '_',\n'LowerLeftArrow;': '\\u2199',\n'LowerRightArrow;': '\\u2198',\n'loz;': '\\u25ca',\n'lozenge;': '\\u25ca',\n'lozf;': '\\u29eb',\n'lpar;': '(',\n'lparlt;': '\\u2993',\n'lrarr;': '\\u21c6',\n'lrcorner;': '\\u231f',\n'lrhar;': '\\u21cb',\n'lrhard;': '\\u296d',\n'lrm;': '\\u200e',\n'lrtri;': '\\u22bf',\n'lsaquo;': '\\u2039',\n'Lscr;': '\\u2112',\n'lscr;': '\\U0001d4c1',\n'Lsh;': '\\u21b0',\n'lsh;': '\\u21b0',\n'lsim;': '\\u2272',\n'lsime;': '\\u2a8d',\n'lsimg;': '\\u2a8f',\n'lsqb;': '[',\n'lsquo;': '\\u2018',\n'lsquor;': '\\u201a',\n'Lstrok;': '\\u0141',\n'lstrok;': '\\u0142',\n'LT': '<',\n'lt': '<',\n'LT;': '<',\n'Lt;': '\\u226a',\n'lt;': '<',\n'ltcc;': '\\u2aa6',\n'ltcir;': '\\u2a79',\n'ltdot;': '\\u22d6',\n'lthree;': '\\u22cb',\n'ltimes;': '\\u22c9',\n'ltlarr;': '\\u2976',\n'ltquest;': '\\u2a7b',\n'ltri;': '\\u25c3',\n'ltrie;': '\\u22b4',\n'ltrif;': '\\u25c2',\n'ltrPar;': '\\u2996',\n'lurdshar;': '\\u294a',\n'luruhar;': '\\u2966',\n'lvertneqq;': '\\u2268\\ufe00',\n'lvnE;': '\\u2268\\ufe00',\n'macr': '\\xaf',\n'macr;': '\\xaf',\n'male;': '\\u2642',\n'malt;': '\\u2720',\n'maltese;': '\\u2720',\n'Map;': '\\u2905',\n'map;': '\\u21a6',\n'mapsto;': '\\u21a6',\n'mapstodown;': '\\u21a7',\n'mapstoleft;': '\\u21a4',\n'mapstoup;': '\\u21a5',\n'marker;': '\\u25ae',\n'mcomma;': '\\u2a29',\n'Mcy;': '\\u041c',\n'mcy;': '\\u043c',\n'mdash;': '\\u2014',\n'mDDot;': '\\u223a',\n'measuredangle;': '\\u2221',\n'MediumSpace;': '\\u205f',\n'Mellintrf;': '\\u2133',\n'Mfr;': '\\U0001d510',\n'mfr;': '\\U0001d52a',\n'mho;': '\\u2127',\n'micro': '\\xb5',\n'micro;': '\\xb5',\n'mid;': '\\u2223',\n'midast;': '*',\n'midcir;': '\\u2af0',\n'middot': '\\xb7',\n'middot;': '\\xb7',\n'minus;': '\\u2212',\n'minusb;': '\\u229f',\n'minusd;': '\\u2238',\n'minusdu;': '\\u2a2a',\n'MinusPlus;': '\\u2213',\n'mlcp;': '\\u2adb',\n'mldr;': '\\u2026',\n'mnplus;': '\\u2213',\n'models;': '\\u22a7',\n'Mopf;': '\\U0001d544',\n'mopf;': '\\U0001d55e',\n'mp;': '\\u2213',\n'Mscr;': '\\u2133',\n'mscr;': '\\U0001d4c2',\n'mstpos;': '\\u223e',\n'Mu;': '\\u039c',\n'mu;': '\\u03bc',\n'multimap;': '\\u22b8',\n'mumap;': '\\u22b8',\n'nabla;': '\\u2207',\n'Nacute;': '\\u0143',\n'nacute;': '\\u0144',\n'nang;': '\\u2220\\u20d2',\n'nap;': '\\u2249',\n'napE;': '\\u2a70\\u0338',\n'napid;': '\\u224b\\u0338',\n'napos;': '\\u0149',\n'napprox;': '\\u2249',\n'natur;': '\\u266e',\n'natural;': '\\u266e',\n'naturals;': '\\u2115',\n'nbsp': '\\xa0',\n'nbsp;': '\\xa0',\n'nbump;': '\\u224e\\u0338',\n'nbumpe;': '\\u224f\\u0338',\n'ncap;': '\\u2a43',\n'Ncaron;': '\\u0147',\n'ncaron;': '\\u0148',\n'Ncedil;': '\\u0145',\n'ncedil;': '\\u0146',\n'ncong;': '\\u2247',\n'ncongdot;': '\\u2a6d\\u0338',\n'ncup;': '\\u2a42',\n'Ncy;': '\\u041d',\n'ncy;': '\\u043d',\n'ndash;': '\\u2013',\n'ne;': '\\u2260',\n'nearhk;': '\\u2924',\n'neArr;': '\\u21d7',\n'nearr;': '\\u2197',\n'nearrow;': '\\u2197',\n'nedot;': '\\u2250\\u0338',\n'NegativeMediumSpace;': '\\u200b',\n'NegativeThickSpace;': '\\u200b',\n'NegativeThinSpace;': '\\u200b',\n'NegativeVeryThinSpace;': '\\u200b',\n'nequiv;': '\\u2262',\n'nesear;': '\\u2928',\n'nesim;': '\\u2242\\u0338',\n'NestedGreaterGreater;': '\\u226b',\n'NestedLessLess;': '\\u226a',\n'NewLine;': '\\n',\n'nexist;': '\\u2204',\n'nexists;': '\\u2204',\n'Nfr;': '\\U0001d511',\n'nfr;': '\\U0001d52b',\n'ngE;': '\\u2267\\u0338',\n'nge;': '\\u2271',\n'ngeq;': '\\u2271',\n'ngeqq;': '\\u2267\\u0338',\n'ngeqslant;': '\\u2a7e\\u0338',\n'nges;': '\\u2a7e\\u0338',\n'nGg;': '\\u22d9\\u0338',\n'ngsim;': '\\u2275',\n'nGt;': '\\u226b\\u20d2',\n'ngt;': '\\u226f',\n'ngtr;': '\\u226f',\n'nGtv;': '\\u226b\\u0338',\n'nhArr;': '\\u21ce',\n'nharr;': '\\u21ae',\n'nhpar;': '\\u2af2',\n'ni;': '\\u220b',\n'nis;': '\\u22fc',\n'nisd;': '\\u22fa',\n'niv;': '\\u220b',\n'NJcy;': '\\u040a',\n'njcy;': '\\u045a',\n'nlArr;': '\\u21cd',\n'nlarr;': '\\u219a',\n'nldr;': '\\u2025',\n'nlE;': '\\u2266\\u0338',\n'nle;': '\\u2270',\n'nLeftarrow;': '\\u21cd',\n'nleftarrow;': '\\u219a',\n'nLeftrightarrow;': '\\u21ce',\n'nleftrightarrow;': '\\u21ae',\n'nleq;': '\\u2270',\n'nleqq;': '\\u2266\\u0338',\n'nleqslant;': '\\u2a7d\\u0338',\n'nles;': '\\u2a7d\\u0338',\n'nless;': '\\u226e',\n'nLl;': '\\u22d8\\u0338',\n'nlsim;': '\\u2274',\n'nLt;': '\\u226a\\u20d2',\n'nlt;': '\\u226e',\n'nltri;': '\\u22ea',\n'nltrie;': '\\u22ec',\n'nLtv;': '\\u226a\\u0338',\n'nmid;': '\\u2224',\n'NoBreak;': '\\u2060',\n'NonBreakingSpace;': '\\xa0',\n'Nopf;': '\\u2115',\n'nopf;': '\\U0001d55f',\n'not': '\\xac',\n'Not;': '\\u2aec',\n'not;': '\\xac',\n'NotCongruent;': '\\u2262',\n'NotCupCap;': '\\u226d',\n'NotDoubleVerticalBar;': '\\u2226',\n'NotElement;': '\\u2209',\n'NotEqual;': '\\u2260',\n'NotEqualTilde;': '\\u2242\\u0338',\n'NotExists;': '\\u2204',\n'NotGreater;': '\\u226f',\n'NotGreaterEqual;': '\\u2271',\n'NotGreaterFullEqual;': '\\u2267\\u0338',\n'NotGreaterGreater;': '\\u226b\\u0338',\n'NotGreaterLess;': '\\u2279',\n'NotGreaterSlantEqual;': '\\u2a7e\\u0338',\n'NotGreaterTilde;': '\\u2275',\n'NotHumpDownHump;': '\\u224e\\u0338',\n'NotHumpEqual;': '\\u224f\\u0338',\n'notin;': '\\u2209',\n'notindot;': '\\u22f5\\u0338',\n'notinE;': '\\u22f9\\u0338',\n'notinva;': '\\u2209',\n'notinvb;': '\\u22f7',\n'notinvc;': '\\u22f6',\n'NotLeftTriangle;': '\\u22ea',\n'NotLeftTriangleBar;': '\\u29cf\\u0338',\n'NotLeftTriangleEqual;': '\\u22ec',\n'NotLess;': '\\u226e',\n'NotLessEqual;': '\\u2270',\n'NotLessGreater;': '\\u2278',\n'NotLessLess;': '\\u226a\\u0338',\n'NotLessSlantEqual;': '\\u2a7d\\u0338',\n'NotLessTilde;': '\\u2274',\n'NotNestedGreaterGreater;': '\\u2aa2\\u0338',\n'NotNestedLessLess;': '\\u2aa1\\u0338',\n'notni;': '\\u220c',\n'notniva;': '\\u220c',\n'notnivb;': '\\u22fe',\n'notnivc;': '\\u22fd',\n'NotPrecedes;': '\\u2280',\n'NotPrecedesEqual;': '\\u2aaf\\u0338',\n'NotPrecedesSlantEqual;': '\\u22e0',\n'NotReverseElement;': '\\u220c',\n'NotRightTriangle;': '\\u22eb',\n'NotRightTriangleBar;': '\\u29d0\\u0338',\n'NotRightTriangleEqual;': '\\u22ed',\n'NotSquareSubset;': '\\u228f\\u0338',\n'NotSquareSubsetEqual;': '\\u22e2',\n'NotSquareSuperset;': '\\u2290\\u0338',\n'NotSquareSupersetEqual;': '\\u22e3',\n'NotSubset;': '\\u2282\\u20d2',\n'NotSubsetEqual;': '\\u2288',\n'NotSucceeds;': '\\u2281',\n'NotSucceedsEqual;': '\\u2ab0\\u0338',\n'NotSucceedsSlantEqual;': '\\u22e1',\n'NotSucceedsTilde;': '\\u227f\\u0338',\n'NotSuperset;': '\\u2283\\u20d2',\n'NotSupersetEqual;': '\\u2289',\n'NotTilde;': '\\u2241',\n'NotTildeEqual;': '\\u2244',\n'NotTildeFullEqual;': '\\u2247',\n'NotTildeTilde;': '\\u2249',\n'NotVerticalBar;': '\\u2224',\n'npar;': '\\u2226',\n'nparallel;': '\\u2226',\n'nparsl;': '\\u2afd\\u20e5',\n'npart;': '\\u2202\\u0338',\n'npolint;': '\\u2a14',\n'npr;': '\\u2280',\n'nprcue;': '\\u22e0',\n'npre;': '\\u2aaf\\u0338',\n'nprec;': '\\u2280',\n'npreceq;': '\\u2aaf\\u0338',\n'nrArr;': '\\u21cf',\n'nrarr;': '\\u219b',\n'nrarrc;': '\\u2933\\u0338',\n'nrarrw;': '\\u219d\\u0338',\n'nRightarrow;': '\\u21cf',\n'nrightarrow;': '\\u219b',\n'nrtri;': '\\u22eb',\n'nrtrie;': '\\u22ed',\n'nsc;': '\\u2281',\n'nsccue;': '\\u22e1',\n'nsce;': '\\u2ab0\\u0338',\n'Nscr;': '\\U0001d4a9',\n'nscr;': '\\U0001d4c3',\n'nshortmid;': '\\u2224',\n'nshortparallel;': '\\u2226',\n'nsim;': '\\u2241',\n'nsime;': '\\u2244',\n'nsimeq;': '\\u2244',\n'nsmid;': '\\u2224',\n'nspar;': '\\u2226',\n'nsqsube;': '\\u22e2',\n'nsqsupe;': '\\u22e3',\n'nsub;': '\\u2284',\n'nsubE;': '\\u2ac5\\u0338',\n'nsube;': '\\u2288',\n'nsubset;': '\\u2282\\u20d2',\n'nsubseteq;': '\\u2288',\n'nsubseteqq;': '\\u2ac5\\u0338',\n'nsucc;': '\\u2281',\n'nsucceq;': '\\u2ab0\\u0338',\n'nsup;': '\\u2285',\n'nsupE;': '\\u2ac6\\u0338',\n'nsupe;': '\\u2289',\n'nsupset;': '\\u2283\\u20d2',\n'nsupseteq;': '\\u2289',\n'nsupseteqq;': '\\u2ac6\\u0338',\n'ntgl;': '\\u2279',\n'Ntilde': '\\xd1',\n'ntilde': '\\xf1',\n'Ntilde;': '\\xd1',\n'ntilde;': '\\xf1',\n'ntlg;': '\\u2278',\n'ntriangleleft;': '\\u22ea',\n'ntrianglelefteq;': '\\u22ec',\n'ntriangleright;': '\\u22eb',\n'ntrianglerighteq;': '\\u22ed',\n'Nu;': '\\u039d',\n'nu;': '\\u03bd',\n'num;': '#',\n'numero;': '\\u2116',\n'numsp;': '\\u2007',\n'nvap;': '\\u224d\\u20d2',\n'nVDash;': '\\u22af',\n'nVdash;': '\\u22ae',\n'nvDash;': '\\u22ad',\n'nvdash;': '\\u22ac',\n'nvge;': '\\u2265\\u20d2',\n'nvgt;': '>\\u20d2',\n'nvHarr;': '\\u2904',\n'nvinfin;': '\\u29de',\n'nvlArr;': '\\u2902',\n'nvle;': '\\u2264\\u20d2',\n'nvlt;': '<\\u20d2',\n'nvltrie;': '\\u22b4\\u20d2',\n'nvrArr;': '\\u2903',\n'nvrtrie;': '\\u22b5\\u20d2',\n'nvsim;': '\\u223c\\u20d2',\n'nwarhk;': '\\u2923',\n'nwArr;': '\\u21d6',\n'nwarr;': '\\u2196',\n'nwarrow;': '\\u2196',\n'nwnear;': '\\u2927',\n'Oacute': '\\xd3',\n'oacute': '\\xf3',\n'Oacute;': '\\xd3',\n'oacute;': '\\xf3',\n'oast;': '\\u229b',\n'ocir;': '\\u229a',\n'Ocirc': '\\xd4',\n'ocirc': '\\xf4',\n'Ocirc;': '\\xd4',\n'ocirc;': '\\xf4',\n'Ocy;': '\\u041e',\n'ocy;': '\\u043e',\n'odash;': '\\u229d',\n'Odblac;': '\\u0150',\n'odblac;': '\\u0151',\n'odiv;': '\\u2a38',\n'odot;': '\\u2299',\n'odsold;': '\\u29bc',\n'OElig;': '\\u0152',\n'oelig;': '\\u0153',\n'ofcir;': '\\u29bf',\n'Ofr;': '\\U0001d512',\n'ofr;': '\\U0001d52c',\n'ogon;': '\\u02db',\n'Ograve': '\\xd2',\n'ograve': '\\xf2',\n'Ograve;': '\\xd2',\n'ograve;': '\\xf2',\n'ogt;': '\\u29c1',\n'ohbar;': '\\u29b5',\n'ohm;': '\\u03a9',\n'oint;': '\\u222e',\n'olarr;': '\\u21ba',\n'olcir;': '\\u29be',\n'olcross;': '\\u29bb',\n'oline;': '\\u203e',\n'olt;': '\\u29c0',\n'Omacr;': '\\u014c',\n'omacr;': '\\u014d',\n'Omega;': '\\u03a9',\n'omega;': '\\u03c9',\n'Omicron;': '\\u039f',\n'omicron;': '\\u03bf',\n'omid;': '\\u29b6',\n'ominus;': '\\u2296',\n'Oopf;': '\\U0001d546',\n'oopf;': '\\U0001d560',\n'opar;': '\\u29b7',\n'OpenCurlyDoubleQuote;': '\\u201c',\n'OpenCurlyQuote;': '\\u2018',\n'operp;': '\\u29b9',\n'oplus;': '\\u2295',\n'Or;': '\\u2a54',\n'or;': '\\u2228',\n'orarr;': '\\u21bb',\n'ord;': '\\u2a5d',\n'order;': '\\u2134',\n'orderof;': '\\u2134',\n'ordf': '\\xaa',\n'ordf;': '\\xaa',\n'ordm': '\\xba',\n'ordm;': '\\xba',\n'origof;': '\\u22b6',\n'oror;': '\\u2a56',\n'orslope;': '\\u2a57',\n'orv;': '\\u2a5b',\n'oS;': '\\u24c8',\n'Oscr;': '\\U0001d4aa',\n'oscr;': '\\u2134',\n'Oslash': '\\xd8',\n'oslash': '\\xf8',\n'Oslash;': '\\xd8',\n'oslash;': '\\xf8',\n'osol;': '\\u2298',\n'Otilde': '\\xd5',\n'otilde': '\\xf5',\n'Otilde;': '\\xd5',\n'otilde;': '\\xf5',\n'Otimes;': '\\u2a37',\n'otimes;': '\\u2297',\n'otimesas;': '\\u2a36',\n'Ouml': '\\xd6',\n'ouml': '\\xf6',\n'Ouml;': '\\xd6',\n'ouml;': '\\xf6',\n'ovbar;': '\\u233d',\n'OverBar;': '\\u203e',\n'OverBrace;': '\\u23de',\n'OverBracket;': '\\u23b4',\n'OverParenthesis;': '\\u23dc',\n'par;': '\\u2225',\n'para': '\\xb6',\n'para;': '\\xb6',\n'parallel;': '\\u2225',\n'parsim;': '\\u2af3',\n'parsl;': '\\u2afd',\n'part;': '\\u2202',\n'PartialD;': '\\u2202',\n'Pcy;': '\\u041f',\n'pcy;': '\\u043f',\n'percnt;': '%',\n'period;': '.',\n'permil;': '\\u2030',\n'perp;': '\\u22a5',\n'pertenk;': '\\u2031',\n'Pfr;': '\\U0001d513',\n'pfr;': '\\U0001d52d',\n'Phi;': '\\u03a6',\n'phi;': '\\u03c6',\n'phiv;': '\\u03d5',\n'phmmat;': '\\u2133',\n'phone;': '\\u260e',\n'Pi;': '\\u03a0',\n'pi;': '\\u03c0',\n'pitchfork;': '\\u22d4',\n'piv;': '\\u03d6',\n'planck;': '\\u210f',\n'planckh;': '\\u210e',\n'plankv;': '\\u210f',\n'plus;': '+',\n'plusacir;': '\\u2a23',\n'plusb;': '\\u229e',\n'pluscir;': '\\u2a22',\n'plusdo;': '\\u2214',\n'plusdu;': '\\u2a25',\n'pluse;': '\\u2a72',\n'PlusMinus;': '\\xb1',\n'plusmn': '\\xb1',\n'plusmn;': '\\xb1',\n'plussim;': '\\u2a26',\n'plustwo;': '\\u2a27',\n'pm;': '\\xb1',\n'Poincareplane;': '\\u210c',\n'pointint;': '\\u2a15',\n'Popf;': '\\u2119',\n'popf;': '\\U0001d561',\n'pound': '\\xa3',\n'pound;': '\\xa3',\n'Pr;': '\\u2abb',\n'pr;': '\\u227a',\n'prap;': '\\u2ab7',\n'prcue;': '\\u227c',\n'prE;': '\\u2ab3',\n'pre;': '\\u2aaf',\n'prec;': '\\u227a',\n'precapprox;': '\\u2ab7',\n'preccurlyeq;': '\\u227c',\n'Precedes;': '\\u227a',\n'PrecedesEqual;': '\\u2aaf',\n'PrecedesSlantEqual;': '\\u227c',\n'PrecedesTilde;': '\\u227e',\n'preceq;': '\\u2aaf',\n'precnapprox;': '\\u2ab9',\n'precneqq;': '\\u2ab5',\n'precnsim;': '\\u22e8',\n'precsim;': '\\u227e',\n'Prime;': '\\u2033',\n'prime;': '\\u2032',\n'primes;': '\\u2119',\n'prnap;': '\\u2ab9',\n'prnE;': '\\u2ab5',\n'prnsim;': '\\u22e8',\n'prod;': '\\u220f',\n'Product;': '\\u220f',\n'profalar;': '\\u232e',\n'profline;': '\\u2312',\n'profsurf;': '\\u2313',\n'prop;': '\\u221d',\n'Proportion;': '\\u2237',\n'Proportional;': '\\u221d',\n'propto;': '\\u221d',\n'prsim;': '\\u227e',\n'prurel;': '\\u22b0',\n'Pscr;': '\\U0001d4ab',\n'pscr;': '\\U0001d4c5',\n'Psi;': '\\u03a8',\n'psi;': '\\u03c8',\n'puncsp;': '\\u2008',\n'Qfr;': '\\U0001d514',\n'qfr;': '\\U0001d52e',\n'qint;': '\\u2a0c',\n'Qopf;': '\\u211a',\n'qopf;': '\\U0001d562',\n'qprime;': '\\u2057',\n'Qscr;': '\\U0001d4ac',\n'qscr;': '\\U0001d4c6',\n'quaternions;': '\\u210d',\n'quatint;': '\\u2a16',\n'quest;': '?',\n'questeq;': '\\u225f',\n'QUOT': '\"',\n'quot': '\"',\n'QUOT;': '\"',\n'quot;': '\"',\n'rAarr;': '\\u21db',\n'race;': '\\u223d\\u0331',\n'Racute;': '\\u0154',\n'racute;': '\\u0155',\n'radic;': '\\u221a',\n'raemptyv;': '\\u29b3',\n'Rang;': '\\u27eb',\n'rang;': '\\u27e9',\n'rangd;': '\\u2992',\n'range;': '\\u29a5',\n'rangle;': '\\u27e9',\n'raquo': '\\xbb',\n'raquo;': '\\xbb',\n'Rarr;': '\\u21a0',\n'rArr;': '\\u21d2',\n'rarr;': '\\u2192',\n'rarrap;': '\\u2975',\n'rarrb;': '\\u21e5',\n'rarrbfs;': '\\u2920',\n'rarrc;': '\\u2933',\n'rarrfs;': '\\u291e',\n'rarrhk;': '\\u21aa',\n'rarrlp;': '\\u21ac',\n'rarrpl;': '\\u2945',\n'rarrsim;': '\\u2974',\n'Rarrtl;': '\\u2916',\n'rarrtl;': '\\u21a3',\n'rarrw;': '\\u219d',\n'rAtail;': '\\u291c',\n'ratail;': '\\u291a',\n'ratio;': '\\u2236',\n'rationals;': '\\u211a',\n'RBarr;': '\\u2910',\n'rBarr;': '\\u290f',\n'rbarr;': '\\u290d',\n'rbbrk;': '\\u2773',\n'rbrace;': '}',\n'rbrack;': ']',\n'rbrke;': '\\u298c',\n'rbrksld;': '\\u298e',\n'rbrkslu;': '\\u2990',\n'Rcaron;': '\\u0158',\n'rcaron;': '\\u0159',\n'Rcedil;': '\\u0156',\n'rcedil;': '\\u0157',\n'rceil;': '\\u2309',\n'rcub;': '}',\n'Rcy;': '\\u0420',\n'rcy;': '\\u0440',\n'rdca;': '\\u2937',\n'rdldhar;': '\\u2969',\n'rdquo;': '\\u201d',\n'rdquor;': '\\u201d',\n'rdsh;': '\\u21b3',\n'Re;': '\\u211c',\n'real;': '\\u211c',\n'realine;': '\\u211b',\n'realpart;': '\\u211c',\n'reals;': '\\u211d',\n'rect;': '\\u25ad',\n'REG': '\\xae',\n'reg': '\\xae',\n'REG;': '\\xae',\n'reg;': '\\xae',\n'ReverseElement;': '\\u220b',\n'ReverseEquilibrium;': '\\u21cb',\n'ReverseUpEquilibrium;': '\\u296f',\n'rfisht;': '\\u297d',\n'rfloor;': '\\u230b',\n'Rfr;': '\\u211c',\n'rfr;': '\\U0001d52f',\n'rHar;': '\\u2964',\n'rhard;': '\\u21c1',\n'rharu;': '\\u21c0',\n'rharul;': '\\u296c',\n'Rho;': '\\u03a1',\n'rho;': '\\u03c1',\n'rhov;': '\\u03f1',\n'RightAngleBracket;': '\\u27e9',\n'RightArrow;': '\\u2192',\n'Rightarrow;': '\\u21d2',\n'rightarrow;': '\\u2192',\n'RightArrowBar;': '\\u21e5',\n'RightArrowLeftArrow;': '\\u21c4',\n'rightarrowtail;': '\\u21a3',\n'RightCeiling;': '\\u2309',\n'RightDoubleBracket;': '\\u27e7',\n'RightDownTeeVector;': '\\u295d',\n'RightDownVector;': '\\u21c2',\n'RightDownVectorBar;': '\\u2955',\n'RightFloor;': '\\u230b',\n'rightharpoondown;': '\\u21c1',\n'rightharpoonup;': '\\u21c0',\n'rightleftarrows;': '\\u21c4',\n'rightleftharpoons;': '\\u21cc',\n'rightrightarrows;': '\\u21c9',\n'rightsquigarrow;': '\\u219d',\n'RightTee;': '\\u22a2',\n'RightTeeArrow;': '\\u21a6',\n'RightTeeVector;': '\\u295b',\n'rightthreetimes;': '\\u22cc',\n'RightTriangle;': '\\u22b3',\n'RightTriangleBar;': '\\u29d0',\n'RightTriangleEqual;': '\\u22b5',\n'RightUpDownVector;': '\\u294f',\n'RightUpTeeVector;': '\\u295c',\n'RightUpVector;': '\\u21be',\n'RightUpVectorBar;': '\\u2954',\n'RightVector;': '\\u21c0',\n'RightVectorBar;': '\\u2953',\n'ring;': '\\u02da',\n'risingdotseq;': '\\u2253',\n'rlarr;': '\\u21c4',\n'rlhar;': '\\u21cc',\n'rlm;': '\\u200f',\n'rmoust;': '\\u23b1',\n'rmoustache;': '\\u23b1',\n'rnmid;': '\\u2aee',\n'roang;': '\\u27ed',\n'roarr;': '\\u21fe',\n'robrk;': '\\u27e7',\n'ropar;': '\\u2986',\n'Ropf;': '\\u211d',\n'ropf;': '\\U0001d563',\n'roplus;': '\\u2a2e',\n'rotimes;': '\\u2a35',\n'RoundImplies;': '\\u2970',\n'rpar;': ')',\n'rpargt;': '\\u2994',\n'rppolint;': '\\u2a12',\n'rrarr;': '\\u21c9',\n'Rrightarrow;': '\\u21db',\n'rsaquo;': '\\u203a',\n'Rscr;': '\\u211b',\n'rscr;': '\\U0001d4c7',\n'Rsh;': '\\u21b1',\n'rsh;': '\\u21b1',\n'rsqb;': ']',\n'rsquo;': '\\u2019',\n'rsquor;': '\\u2019',\n'rthree;': '\\u22cc',\n'rtimes;': '\\u22ca',\n'rtri;': '\\u25b9',\n'rtrie;': '\\u22b5',\n'rtrif;': '\\u25b8',\n'rtriltri;': '\\u29ce',\n'RuleDelayed;': '\\u29f4',\n'ruluhar;': '\\u2968',\n'rx;': '\\u211e',\n'Sacute;': '\\u015a',\n'sacute;': '\\u015b',\n'sbquo;': '\\u201a',\n'Sc;': '\\u2abc',\n'sc;': '\\u227b',\n'scap;': '\\u2ab8',\n'Scaron;': '\\u0160',\n'scaron;': '\\u0161',\n'sccue;': '\\u227d',\n'scE;': '\\u2ab4',\n'sce;': '\\u2ab0',\n'Scedil;': '\\u015e',\n'scedil;': '\\u015f',\n'Scirc;': '\\u015c',\n'scirc;': '\\u015d',\n'scnap;': '\\u2aba',\n'scnE;': '\\u2ab6',\n'scnsim;': '\\u22e9',\n'scpolint;': '\\u2a13',\n'scsim;': '\\u227f',\n'Scy;': '\\u0421',\n'scy;': '\\u0441',\n'sdot;': '\\u22c5',\n'sdotb;': '\\u22a1',\n'sdote;': '\\u2a66',\n'searhk;': '\\u2925',\n'seArr;': '\\u21d8',\n'searr;': '\\u2198',\n'searrow;': '\\u2198',\n'sect': '\\xa7',\n'sect;': '\\xa7',\n'semi;': ';',\n'seswar;': '\\u2929',\n'setminus;': '\\u2216',\n'setmn;': '\\u2216',\n'sext;': '\\u2736',\n'Sfr;': '\\U0001d516',\n'sfr;': '\\U0001d530',\n'sfrown;': '\\u2322',\n'sharp;': '\\u266f',\n'SHCHcy;': '\\u0429',\n'shchcy;': '\\u0449',\n'SHcy;': '\\u0428',\n'shcy;': '\\u0448',\n'ShortDownArrow;': '\\u2193',\n'ShortLeftArrow;': '\\u2190',\n'shortmid;': '\\u2223',\n'shortparallel;': '\\u2225',\n'ShortRightArrow;': '\\u2192',\n'ShortUpArrow;': '\\u2191',\n'shy': '\\xad',\n'shy;': '\\xad',\n'Sigma;': '\\u03a3',\n'sigma;': '\\u03c3',\n'sigmaf;': '\\u03c2',\n'sigmav;': '\\u03c2',\n'sim;': '\\u223c',\n'simdot;': '\\u2a6a',\n'sime;': '\\u2243',\n'simeq;': '\\u2243',\n'simg;': '\\u2a9e',\n'simgE;': '\\u2aa0',\n'siml;': '\\u2a9d',\n'simlE;': '\\u2a9f',\n'simne;': '\\u2246',\n'simplus;': '\\u2a24',\n'simrarr;': '\\u2972',\n'slarr;': '\\u2190',\n'SmallCircle;': '\\u2218',\n'smallsetminus;': '\\u2216',\n'smashp;': '\\u2a33',\n'smeparsl;': '\\u29e4',\n'smid;': '\\u2223',\n'smile;': '\\u2323',\n'smt;': '\\u2aaa',\n'smte;': '\\u2aac',\n'smtes;': '\\u2aac\\ufe00',\n'SOFTcy;': '\\u042c',\n'softcy;': '\\u044c',\n'sol;': '/',\n'solb;': '\\u29c4',\n'solbar;': '\\u233f',\n'Sopf;': '\\U0001d54a',\n'sopf;': '\\U0001d564',\n'spades;': '\\u2660',\n'spadesuit;': '\\u2660',\n'spar;': '\\u2225',\n'sqcap;': '\\u2293',\n'sqcaps;': '\\u2293\\ufe00',\n'sqcup;': '\\u2294',\n'sqcups;': '\\u2294\\ufe00',\n'Sqrt;': '\\u221a',\n'sqsub;': '\\u228f',\n'sqsube;': '\\u2291',\n'sqsubset;': '\\u228f',\n'sqsubseteq;': '\\u2291',\n'sqsup;': '\\u2290',\n'sqsupe;': '\\u2292',\n'sqsupset;': '\\u2290',\n'sqsupseteq;': '\\u2292',\n'squ;': '\\u25a1',\n'Square;': '\\u25a1',\n'square;': '\\u25a1',\n'SquareIntersection;': '\\u2293',\n'SquareSubset;': '\\u228f',\n'SquareSubsetEqual;': '\\u2291',\n'SquareSuperset;': '\\u2290',\n'SquareSupersetEqual;': '\\u2292',\n'SquareUnion;': '\\u2294',\n'squarf;': '\\u25aa',\n'squf;': '\\u25aa',\n'srarr;': '\\u2192',\n'Sscr;': '\\U0001d4ae',\n'sscr;': '\\U0001d4c8',\n'ssetmn;': '\\u2216',\n'ssmile;': '\\u2323',\n'sstarf;': '\\u22c6',\n'Star;': '\\u22c6',\n'star;': '\\u2606',\n'starf;': '\\u2605',\n'straightepsilon;': '\\u03f5',\n'straightphi;': '\\u03d5',\n'strns;': '\\xaf',\n'Sub;': '\\u22d0',\n'sub;': '\\u2282',\n'subdot;': '\\u2abd',\n'subE;': '\\u2ac5',\n'sube;': '\\u2286',\n'subedot;': '\\u2ac3',\n'submult;': '\\u2ac1',\n'subnE;': '\\u2acb',\n'subne;': '\\u228a',\n'subplus;': '\\u2abf',\n'subrarr;': '\\u2979',\n'Subset;': '\\u22d0',\n'subset;': '\\u2282',\n'subseteq;': '\\u2286',\n'subseteqq;': '\\u2ac5',\n'SubsetEqual;': '\\u2286',\n'subsetneq;': '\\u228a',\n'subsetneqq;': '\\u2acb',\n'subsim;': '\\u2ac7',\n'subsub;': '\\u2ad5',\n'subsup;': '\\u2ad3',\n'succ;': '\\u227b',\n'succapprox;': '\\u2ab8',\n'succcurlyeq;': '\\u227d',\n'Succeeds;': '\\u227b',\n'SucceedsEqual;': '\\u2ab0',\n'SucceedsSlantEqual;': '\\u227d',\n'SucceedsTilde;': '\\u227f',\n'succeq;': '\\u2ab0',\n'succnapprox;': '\\u2aba',\n'succneqq;': '\\u2ab6',\n'succnsim;': '\\u22e9',\n'succsim;': '\\u227f',\n'SuchThat;': '\\u220b',\n'Sum;': '\\u2211',\n'sum;': '\\u2211',\n'sung;': '\\u266a',\n'sup1': '\\xb9',\n'sup1;': '\\xb9',\n'sup2': '\\xb2',\n'sup2;': '\\xb2',\n'sup3': '\\xb3',\n'sup3;': '\\xb3',\n'Sup;': '\\u22d1',\n'sup;': '\\u2283',\n'supdot;': '\\u2abe',\n'supdsub;': '\\u2ad8',\n'supE;': '\\u2ac6',\n'supe;': '\\u2287',\n'supedot;': '\\u2ac4',\n'Superset;': '\\u2283',\n'SupersetEqual;': '\\u2287',\n'suphsol;': '\\u27c9',\n'suphsub;': '\\u2ad7',\n'suplarr;': '\\u297b',\n'supmult;': '\\u2ac2',\n'supnE;': '\\u2acc',\n'supne;': '\\u228b',\n'supplus;': '\\u2ac0',\n'Supset;': '\\u22d1',\n'supset;': '\\u2283',\n'supseteq;': '\\u2287',\n'supseteqq;': '\\u2ac6',\n'supsetneq;': '\\u228b',\n'supsetneqq;': '\\u2acc',\n'supsim;': '\\u2ac8',\n'supsub;': '\\u2ad4',\n'supsup;': '\\u2ad6',\n'swarhk;': '\\u2926',\n'swArr;': '\\u21d9',\n'swarr;': '\\u2199',\n'swarrow;': '\\u2199',\n'swnwar;': '\\u292a',\n'szlig': '\\xdf',\n'szlig;': '\\xdf',\n'Tab;': '\\t',\n'target;': '\\u2316',\n'Tau;': '\\u03a4',\n'tau;': '\\u03c4',\n'tbrk;': '\\u23b4',\n'Tcaron;': '\\u0164',\n'tcaron;': '\\u0165',\n'Tcedil;': '\\u0162',\n'tcedil;': '\\u0163',\n'Tcy;': '\\u0422',\n'tcy;': '\\u0442',\n'tdot;': '\\u20db',\n'telrec;': '\\u2315',\n'Tfr;': '\\U0001d517',\n'tfr;': '\\U0001d531',\n'there4;': '\\u2234',\n'Therefore;': '\\u2234',\n'therefore;': '\\u2234',\n'Theta;': '\\u0398',\n'theta;': '\\u03b8',\n'thetasym;': '\\u03d1',\n'thetav;': '\\u03d1',\n'thickapprox;': '\\u2248',\n'thicksim;': '\\u223c',\n'ThickSpace;': '\\u205f\\u200a',\n'thinsp;': '\\u2009',\n'ThinSpace;': '\\u2009',\n'thkap;': '\\u2248',\n'thksim;': '\\u223c',\n'THORN': '\\xde',\n'thorn': '\\xfe',\n'THORN;': '\\xde',\n'thorn;': '\\xfe',\n'Tilde;': '\\u223c',\n'tilde;': '\\u02dc',\n'TildeEqual;': '\\u2243',\n'TildeFullEqual;': '\\u2245',\n'TildeTilde;': '\\u2248',\n'times': '\\xd7',\n'times;': '\\xd7',\n'timesb;': '\\u22a0',\n'timesbar;': '\\u2a31',\n'timesd;': '\\u2a30',\n'tint;': '\\u222d',\n'toea;': '\\u2928',\n'top;': '\\u22a4',\n'topbot;': '\\u2336',\n'topcir;': '\\u2af1',\n'Topf;': '\\U0001d54b',\n'topf;': '\\U0001d565',\n'topfork;': '\\u2ada',\n'tosa;': '\\u2929',\n'tprime;': '\\u2034',\n'TRADE;': '\\u2122',\n'trade;': '\\u2122',\n'triangle;': '\\u25b5',\n'triangledown;': '\\u25bf',\n'triangleleft;': '\\u25c3',\n'trianglelefteq;': '\\u22b4',\n'triangleq;': '\\u225c',\n'triangleright;': '\\u25b9',\n'trianglerighteq;': '\\u22b5',\n'tridot;': '\\u25ec',\n'trie;': '\\u225c',\n'triminus;': '\\u2a3a',\n'TripleDot;': '\\u20db',\n'triplus;': '\\u2a39',\n'trisb;': '\\u29cd',\n'tritime;': '\\u2a3b',\n'trpezium;': '\\u23e2',\n'Tscr;': '\\U0001d4af',\n'tscr;': '\\U0001d4c9',\n'TScy;': '\\u0426',\n'tscy;': '\\u0446',\n'TSHcy;': '\\u040b',\n'tshcy;': '\\u045b',\n'Tstrok;': '\\u0166',\n'tstrok;': '\\u0167',\n'twixt;': '\\u226c',\n'twoheadleftarrow;': '\\u219e',\n'twoheadrightarrow;': '\\u21a0',\n'Uacute': '\\xda',\n'uacute': '\\xfa',\n'Uacute;': '\\xda',\n'uacute;': '\\xfa',\n'Uarr;': '\\u219f',\n'uArr;': '\\u21d1',\n'uarr;': '\\u2191',\n'Uarrocir;': '\\u2949',\n'Ubrcy;': '\\u040e',\n'ubrcy;': '\\u045e',\n'Ubreve;': '\\u016c',\n'ubreve;': '\\u016d',\n'Ucirc': '\\xdb',\n'ucirc': '\\xfb',\n'Ucirc;': '\\xdb',\n'ucirc;': '\\xfb',\n'Ucy;': '\\u0423',\n'ucy;': '\\u0443',\n'udarr;': '\\u21c5',\n'Udblac;': '\\u0170',\n'udblac;': '\\u0171',\n'udhar;': '\\u296e',\n'ufisht;': '\\u297e',\n'Ufr;': '\\U0001d518',\n'ufr;': '\\U0001d532',\n'Ugrave': '\\xd9',\n'ugrave': '\\xf9',\n'Ugrave;': '\\xd9',\n'ugrave;': '\\xf9',\n'uHar;': '\\u2963',\n'uharl;': '\\u21bf',\n'uharr;': '\\u21be',\n'uhblk;': '\\u2580',\n'ulcorn;': '\\u231c',\n'ulcorner;': '\\u231c',\n'ulcrop;': '\\u230f',\n'ultri;': '\\u25f8',\n'Umacr;': '\\u016a',\n'umacr;': '\\u016b',\n'uml': '\\xa8',\n'uml;': '\\xa8',\n'UnderBar;': '_',\n'UnderBrace;': '\\u23df',\n'UnderBracket;': '\\u23b5',\n'UnderParenthesis;': '\\u23dd',\n'Union;': '\\u22c3',\n'UnionPlus;': '\\u228e',\n'Uogon;': '\\u0172',\n'uogon;': '\\u0173',\n'Uopf;': '\\U0001d54c',\n'uopf;': '\\U0001d566',\n'UpArrow;': '\\u2191',\n'Uparrow;': '\\u21d1',\n'uparrow;': '\\u2191',\n'UpArrowBar;': '\\u2912',\n'UpArrowDownArrow;': '\\u21c5',\n'UpDownArrow;': '\\u2195',\n'Updownarrow;': '\\u21d5',\n'updownarrow;': '\\u2195',\n'UpEquilibrium;': '\\u296e',\n'upharpoonleft;': '\\u21bf',\n'upharpoonright;': '\\u21be',\n'uplus;': '\\u228e',\n'UpperLeftArrow;': '\\u2196',\n'UpperRightArrow;': '\\u2197',\n'Upsi;': '\\u03d2',\n'upsi;': '\\u03c5',\n'upsih;': '\\u03d2',\n'Upsilon;': '\\u03a5',\n'upsilon;': '\\u03c5',\n'UpTee;': '\\u22a5',\n'UpTeeArrow;': '\\u21a5',\n'upuparrows;': '\\u21c8',\n'urcorn;': '\\u231d',\n'urcorner;': '\\u231d',\n'urcrop;': '\\u230e',\n'Uring;': '\\u016e',\n'uring;': '\\u016f',\n'urtri;': '\\u25f9',\n'Uscr;': '\\U0001d4b0',\n'uscr;': '\\U0001d4ca',\n'utdot;': '\\u22f0',\n'Utilde;': '\\u0168',\n'utilde;': '\\u0169',\n'utri;': '\\u25b5',\n'utrif;': '\\u25b4',\n'uuarr;': '\\u21c8',\n'Uuml': '\\xdc',\n'uuml': '\\xfc',\n'Uuml;': '\\xdc',\n'uuml;': '\\xfc',\n'uwangle;': '\\u29a7',\n'vangrt;': '\\u299c',\n'varepsilon;': '\\u03f5',\n'varkappa;': '\\u03f0',\n'varnothing;': '\\u2205',\n'varphi;': '\\u03d5',\n'varpi;': '\\u03d6',\n'varpropto;': '\\u221d',\n'vArr;': '\\u21d5',\n'varr;': '\\u2195',\n'varrho;': '\\u03f1',\n'varsigma;': '\\u03c2',\n'varsubsetneq;': '\\u228a\\ufe00',\n'varsubsetneqq;': '\\u2acb\\ufe00',\n'varsupsetneq;': '\\u228b\\ufe00',\n'varsupsetneqq;': '\\u2acc\\ufe00',\n'vartheta;': '\\u03d1',\n'vartriangleleft;': '\\u22b2',\n'vartriangleright;': '\\u22b3',\n'Vbar;': '\\u2aeb',\n'vBar;': '\\u2ae8',\n'vBarv;': '\\u2ae9',\n'Vcy;': '\\u0412',\n'vcy;': '\\u0432',\n'VDash;': '\\u22ab',\n'Vdash;': '\\u22a9',\n'vDash;': '\\u22a8',\n'vdash;': '\\u22a2',\n'Vdashl;': '\\u2ae6',\n'Vee;': '\\u22c1',\n'vee;': '\\u2228',\n'veebar;': '\\u22bb',\n'veeeq;': '\\u225a',\n'vellip;': '\\u22ee',\n'Verbar;': '\\u2016',\n'verbar;': '|',\n'Vert;': '\\u2016',\n'vert;': '|',\n'VerticalBar;': '\\u2223',\n'VerticalLine;': '|',\n'VerticalSeparator;': '\\u2758',\n'VerticalTilde;': '\\u2240',\n'VeryThinSpace;': '\\u200a',\n'Vfr;': '\\U0001d519',\n'vfr;': '\\U0001d533',\n'vltri;': '\\u22b2',\n'vnsub;': '\\u2282\\u20d2',\n'vnsup;': '\\u2283\\u20d2',\n'Vopf;': '\\U0001d54d',\n'vopf;': '\\U0001d567',\n'vprop;': '\\u221d',\n'vrtri;': '\\u22b3',\n'Vscr;': '\\U0001d4b1',\n'vscr;': '\\U0001d4cb',\n'vsubnE;': '\\u2acb\\ufe00',\n'vsubne;': '\\u228a\\ufe00',\n'vsupnE;': '\\u2acc\\ufe00',\n'vsupne;': '\\u228b\\ufe00',\n'Vvdash;': '\\u22aa',\n'vzigzag;': '\\u299a',\n'Wcirc;': '\\u0174',\n'wcirc;': '\\u0175',\n'wedbar;': '\\u2a5f',\n'Wedge;': '\\u22c0',\n'wedge;': '\\u2227',\n'wedgeq;': '\\u2259',\n'weierp;': '\\u2118',\n'Wfr;': '\\U0001d51a',\n'wfr;': '\\U0001d534',\n'Wopf;': '\\U0001d54e',\n'wopf;': '\\U0001d568',\n'wp;': '\\u2118',\n'wr;': '\\u2240',\n'wreath;': '\\u2240',\n'Wscr;': '\\U0001d4b2',\n'wscr;': '\\U0001d4cc',\n'xcap;': '\\u22c2',\n'xcirc;': '\\u25ef',\n'xcup;': '\\u22c3',\n'xdtri;': '\\u25bd',\n'Xfr;': '\\U0001d51b',\n'xfr;': '\\U0001d535',\n'xhArr;': '\\u27fa',\n'xharr;': '\\u27f7',\n'Xi;': '\\u039e',\n'xi;': '\\u03be',\n'xlArr;': '\\u27f8',\n'xlarr;': '\\u27f5',\n'xmap;': '\\u27fc',\n'xnis;': '\\u22fb',\n'xodot;': '\\u2a00',\n'Xopf;': '\\U0001d54f',\n'xopf;': '\\U0001d569',\n'xoplus;': '\\u2a01',\n'xotime;': '\\u2a02',\n'xrArr;': '\\u27f9',\n'xrarr;': '\\u27f6',\n'Xscr;': '\\U0001d4b3',\n'xscr;': '\\U0001d4cd',\n'xsqcup;': '\\u2a06',\n'xuplus;': '\\u2a04',\n'xutri;': '\\u25b3',\n'xvee;': '\\u22c1',\n'xwedge;': '\\u22c0',\n'Yacute': '\\xdd',\n'yacute': '\\xfd',\n'Yacute;': '\\xdd',\n'yacute;': '\\xfd',\n'YAcy;': '\\u042f',\n'yacy;': '\\u044f',\n'Ycirc;': '\\u0176',\n'ycirc;': '\\u0177',\n'Ycy;': '\\u042b',\n'ycy;': '\\u044b',\n'yen': '\\xa5',\n'yen;': '\\xa5',\n'Yfr;': '\\U0001d51c',\n'yfr;': '\\U0001d536',\n'YIcy;': '\\u0407',\n'yicy;': '\\u0457',\n'Yopf;': '\\U0001d550',\n'yopf;': '\\U0001d56a',\n'Yscr;': '\\U0001d4b4',\n'yscr;': '\\U0001d4ce',\n'YUcy;': '\\u042e',\n'yucy;': '\\u044e',\n'yuml': '\\xff',\n'Yuml;': '\\u0178',\n'yuml;': '\\xff',\n'Zacute;': '\\u0179',\n'zacute;': '\\u017a',\n'Zcaron;': '\\u017d',\n'zcaron;': '\\u017e',\n'Zcy;': '\\u0417',\n'zcy;': '\\u0437',\n'Zdot;': '\\u017b',\n'zdot;': '\\u017c',\n'zeetrf;': '\\u2128',\n'ZeroWidthSpace;': '\\u200b',\n'Zeta;': '\\u0396',\n'zeta;': '\\u03b6',\n'Zfr;': '\\u2128',\n'zfr;': '\\U0001d537',\n'ZHcy;': '\\u0416',\n'zhcy;': '\\u0436',\n'zigrarr;': '\\u21dd',\n'Zopf;': '\\u2124',\n'zopf;': '\\U0001d56b',\n'Zscr;': '\\U0001d4b5',\n'zscr;': '\\U0001d4cf',\n'zwj;': '\\u200d',\n'zwnj;': '\\u200c',\n}\n\n\ncodepoint2name = {}\n\n\n\nentitydefs = {}\n\nfor (name, codepoint) in name2codepoint.items():\n codepoint2name[codepoint] = name\n entitydefs[name] = chr(codepoint)\n \ndel name, codepoint\n"], "urllib.request": [".py", "from browser import ajax\n\nclass FileIO:\n def __init__(self, data):\n  self._data=data\n  \n def read(self):\n  return self._data\n  \ndef urlopen(url, data=None, timeout=None):\n global result\n result=None\n \n def on_complete(req):\n  global result\n  result=req\n  \n _ajax=ajax.ajax()\n _ajax.bind('complete', on_complete)\n if timeout is not None:\n  _ajax.set_timeout(timeout)\n  \n if data is None:\n  _ajax.open('GET', url, False)\n  _ajax.send()\n else:\n  _ajax.open('POST', url, False)\n  _ajax.send(data)\n  \n if isinstance(result.text, str):\n  return FileIO(result.text), url, {'status': result.status}\n  \n return FileIO(result.text()), url, {'status': result.status}\n"], "encodings.utf_8": [".py", "\"\"\nimport codecs\n\n\n\nencode = codecs.utf_8_encode\n\ndef decode(input, errors='strict'):\n return codecs.utf_8_decode(input, errors, True)\n \nclass IncrementalEncoder(codecs.IncrementalEncoder):\n def encode(self, input, final=False):\n  return codecs.utf_8_encode(input, self.errors)[0]\n  \nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n _buffer_decode = codecs.utf_8_decode\n \nclass StreamWriter(codecs.StreamWriter):\n encode = codecs.utf_8_encode\n \nclass StreamReader(codecs.StreamReader):\n decode = codecs.utf_8_decode\n \n \n \ndef getregentry():\n return codecs.CodecInfo(\n name='utf-8',\n encode=encode,\n decode=decode,\n incrementalencoder=IncrementalEncoder,\n incrementaldecoder=IncrementalDecoder,\n streamreader=StreamReader,\n streamwriter=StreamWriter,\n )\n"], "sys": [".py", "\nfrom _sys import *\nfrom javascript import JSObject\n\nhas_local_storage=__BRYTHON__.has_local_storage\nhas_session_storage = __BRYTHON__.has_session_storage\nhas_json=__BRYTHON__.has_json\n\nargv = ['__main__']\n\nbase_exec_prefix = __BRYTHON__.brython_path\n\nbase_prefix = __BRYTHON__.brython_path\n\nbuiltin_module_names=__BRYTHON__.builtin_module_names\n\nbyteorder='little'\n\ndef exc_info():\n exc = __BRYTHON__.exception_stack[-1]\n return (exc.__class__,exc,exc.traceback)\n \nexec_prefix = __BRYTHON__.brython_path\n\nexecutable = __BRYTHON__.brython_path+'/brython.js'\n\ndef exit(i=None):\n raise SystemExit('')\n \nclass flag_class:\n def __init__(self):\n  self.debug=0\n  self.inspect=0\n  self.interactive=0\n  self.optimize=0\n  self.dont_write_bytecode=0\n  self.no_user_site=0\n  self.no_site=0\n  self.ignore_environment=0\n  self.verbose=0\n  self.bytes_warning=0\n  self.quiet=0\n  self.hash_randomization=1\n  \nflags=flag_class()\n\ndef getfilesystemencoding(*args,**kw):\n \"\"\n return 'utf-8'\n \nmaxsize=2147483647\n\nmaxunicode=1114111\n\npath = __BRYTHON__.path\n\n\nmeta_path=__BRYTHON__.meta_path\n\nplatform=\"brython\"\n\nprefix = __BRYTHON__.brython_path\n\nversion = '.'.join(str(x) for x in __BRYTHON__.version_info[:3])\nversion += \" (default, %s) \\n[Javascript 1.5] on Brython\" % __BRYTHON__.compiled_date\nhexversion = 0x03000000 \n\nclass __version_info(object):\n def __init__(self, version_info):\n  self.version_info = version_info\n  self.major = version_info[0]\n  self.minor = version_info[1]\n  self.micro = version_info[2]\n  self.releaselevel = version_info[3]\n  self.serial = version_info[4]\n  \n def __getitem__(self, index):\n  if isinstance(self.version_info[index], list):\n   return tuple(self.version_info[index])\n  return self.version_info[index]\n  \n def hexversion(self):\n  try:\n   return '0%d0%d0%d' % (self.major, self.minor, self.micro)\n  finally: \n   return '0%d0000' % (self.major)\n   \n def __str__(self):\n  _s=\"sys.version(major=%d, minor=%d, micro=%d, releaselevel='%s', serial=%d)\"\n  return _s % (self.major, self.minor, self.micro, \n  self.releaselevel, self.serial)\n  \n  \n def __eq__(self,other):\n  if isinstance(other, tuple):\n   return (self.major, self.minor, self.micro) == other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ge__(self,other):\n  if isinstance(other, tuple):\n   return (self.major, self.minor, self.micro) >= other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __gt__(self,other):\n  if isinstance(other, tuple):\n   return (self.major, self.minor, self.micro) > other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __le__(self,other):\n  if isinstance(other, tuple):\n   return (self.major, self.minor, self.micro) <= other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __lt__(self,other):\n  if isinstance(other, tuple):\n   return (self.major, self.minor, self.micro) < other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n def __ne__(self,other):\n  if isinstance(other, tuple):\n   return (self.major, self.minor, self.micro) != other\n   \n  raise Error(\"Error! I don't know how to compare!\")\n  \n  \n  \nversion_info=__version_info(__BRYTHON__.version_info)\n\nclass _implementation:\n def __init__(self):\n  self.name='brython'\n  self.version = __version_info(__BRYTHON__.implementation)\n  self.hexversion = self.version.hexversion()\n  self.cache_tag=None\n  \n def __repr__(self):\n  return \"namespace(name='%s' version=%s hexversion='%s')\" % (self.name, self.version, self.hexversion)\n  \n def __str__(self):\n  return \"namespace(name='%s' version=%s hexversion='%s')\" % (self.name, self.version, self.hexversion)\n  \nimplementation=_implementation()\n\nclass _hash_info:\n def __init__(self):\n  self.width=32, \n  self.modulus=2147483647\n  self.inf=314159 \n  self.nan=0\n  self.imag=1000003\n  self.algorithm='siphash24' \n  self.hash_bits=64 \n  self.seed_bits=128 \n  cutoff=0\n  \n def __repr(self):\n \n  return \"sys.hash_info(width=32, modulus=2147483647, inf=314159, nan=0, imag=1000003, algorithm='siphash24', hash_bits=64, seed_bits=128, cutoff=0)\"\n  \nhash_info=_hash_info()\n\nwarnoptions=[]\n\ndef getfilesystemencoding():\n return 'utf-8'\n \n \ndel JSObject\ndel _implementation\n"], "browser.svg": [".py", "from _svg import *"], "site-packages.pygame.compat": [".py", "\"\"\n\nimport sys\n\n__all__ = ['geterror', 'long_', 'xrange_', 'ord_', 'unichr_',\n'unicode_', 'raw_input_', 'as_bytes', 'as_unicode']\n\ndef geterror ():\n return sys.exc_info()[1]\n \ntry:\n long_ = long\nexcept NameError:\n long_ = int\n \ntry:\n xrange_ = xrange\nexcept NameError:\n xrange_ = range\n \ndef get_BytesIO():\n try:\n  from cStringIO import StringIO as BytesIO\n except ImportError:\n  from io import BytesIO\n return BytesIO\n \ndef get_StringIO():\n try:\n  from cStringIO import StringIO\n except ImportError:\n  from io import StringIO\n return StringIO\n \ndef ord_(o):\n try:\n  return ord(o)\n except TypeError:\n  return o\n  \ntry:\n unichr_ = unichr\nexcept NameError:\n unichr_ = chr\n \ntry:\n unicode_ = unicode\nexcept NameError:\n unicode_ = str\n \ntry:\n bytes_ = bytes\nexcept NameError:\n bytes_ = str\n \ntry:\n raw_input_ = raw_input\nexcept NameError:\n raw_input_ = input\n \nif sys.platform == 'win32':\n filesystem_errors = \"replace\"\nelif sys.version_info >= (3, 0, 0):\n filesystem_errors = \"surrogateescape\"\nelse:\n filesystem_errors = \"strict\"\n \ndef filesystem_encode(u):\n fsencoding = sys.getfilesystemencoding()\n if (fsencoding.lower() == 'ascii') and sys.platform.startswith('linux'):\n \n \n  fsencoding = 'utf-8'\n return u.encode(fsencoding, filesystem_errors)\n \n \n \n \n \n \n \n \n \ntry:\n unicode\n def as_bytes(string):\n  \"\"\n  return string\n  \n def as_unicode(rstring):\n  \"\"\n  return rstring.decode('unicode_escape', 'strict')\nexcept NameError:\n def as_bytes(string):\n  \"\"\n  return string.encode('latin-1', 'strict')\n  \n def as_unicode(rstring):\n  \"\"\n  return rstring.encode('ascii', 'strict').decode('unicode_escape',\n  'stict')\n  \ntry:\n next_ = next\nexcept NameError:\n def next_(i, *args):\n  try:\n   return i.next()\n  except StopIteration:\n   if args:\n    return args[0]\n   raise\n   \n   \ntry:\n import itertools.imap as imap_\nexcept ImportError:\n imap_ = map\n"], "pydoc_data.topics": [".py", "\n\ntopics = {'assert': '\\nThe ``assert`` statement\\n************************\\n\\nAssert statements are a convenient way to insert debugging assertions\\ninto a program:\\n\\n   assert_stmt ::= \"assert\" expression [\",\" expression]\\n\\nThe simple form, ``assert expression``, is equivalent to\\n\\n   if __debug__:\\n      if not expression: raise AssertionError\\n\\nThe extended form, ``assert expression1, expression2``, is equivalent\\nto\\n\\n   if __debug__:\\n      if not expression1: raise AssertionError(expression2)\\n\\nThese equivalences assume that ``__debug__`` and ``AssertionError``\\nrefer to the built-in variables with those names.  In the current\\nimplementation, the built-in variable ``__debug__`` is ``True`` under\\nnormal circumstances, ``False`` when optimization is requested\\n(command line option -O).  The current code generator emits no code\\nfor an assert statement when optimization is requested at compile\\ntime.  Note that it is unnecessary to include the source code for the\\nexpression that failed in the error message; it will be displayed as\\npart of the stack trace.\\n\\nAssignments to ``__debug__`` are illegal.  The value for the built-in\\nvariable is determined when the interpreter starts.\\n',\n'assignment': '\\nAssignment statements\\n*********************\\n\\nAssignment statements are used to (re)bind names to values and to\\nmodify attributes or items of mutable objects:\\n\\n   assignment_stmt ::= (target_list \"=\")+ (expression_list | yield_expression)\\n   target_list     ::= target (\",\" target)* [\",\"]\\n   target          ::= identifier\\n              | \"(\" target_list \")\"\\n              | \"[\" target_list \"]\"\\n              | attributeref\\n              | subscription\\n              | slicing\\n              | \"*\" target\\n\\n(See section *Primaries* for the syntax definitions for the last three\\nsymbols.)\\n\\nAn assignment statement evaluates the expression list (remember that\\nthis can be a single expression or a comma-separated list, the latter\\nyielding a tuple) and assigns the single resulting object to each of\\nthe target lists, from left to right.\\n\\nAssignment is defined recursively depending on the form of the target\\n(list). When a target is part of a mutable object (an attribute\\nreference, subscription or slicing), the mutable object must\\nultimately perform the assignment and decide about its validity, and\\nmay raise an exception if the assignment is unacceptable.  The rules\\nobserved by various types and the exceptions raised are given with the\\ndefinition of the object types (see section *The standard type\\nhierarchy*).\\n\\nAssignment of an object to a target list, optionally enclosed in\\nparentheses or square brackets, is recursively defined as follows.\\n\\n* If the target list is a single target: The object is assigned to\\n  that target.\\n\\n* If the target list is a comma-separated list of targets: The object\\n  must be an iterable with the same number of items as there are\\n  targets in the target list, and the items are assigned, from left to\\n  right, to the corresponding targets.\\n\\n  * If the target list contains one target prefixed with an asterisk,\\n    called a \"starred\" target: The object must be a sequence with at\\n    least as many items as there are targets in the target list, minus\\n    one.  The first items of the sequence are assigned, from left to\\n    right, to the targets before the starred target.  The final items\\n    of the sequence are assigned to the targets after the starred\\n    target.  A list of the remaining items in the sequence is then\\n    assigned to the starred target (the list can be empty).\\n\\n  * Else: The object must be a sequence with the same number of items\\n    as there are targets in the target list, and the items are\\n    assigned, from left to right, to the corresponding targets.\\n\\nAssignment of an object to a single target is recursively defined as\\nfollows.\\n\\n* If the target is an identifier (name):\\n\\n  * If the name does not occur in a ``global`` or ``nonlocal``\\n    statement in the current code block: the name is bound to the\\n    object in the current local namespace.\\n\\n  * Otherwise: the name is bound to the object in the global namespace\\n    or the outer namespace determined by ``nonlocal``, respectively.\\n\\n  The name is rebound if it was already bound.  This may cause the\\n  reference count for the object previously bound to the name to reach\\n  zero, causing the object to be deallocated and its destructor (if it\\n  has one) to be called.\\n\\n* If the target is a target list enclosed in parentheses or in square\\n  brackets: The object must be an iterable with the same number of\\n  items as there are targets in the target list, and its items are\\n  assigned, from left to right, to the corresponding targets.\\n\\n* If the target is an attribute reference: The primary expression in\\n  the reference is evaluated.  It should yield an object with\\n  assignable attributes; if this is not the case, ``TypeError`` is\\n  raised.  That object is then asked to assign the assigned object to\\n  the given attribute; if it cannot perform the assignment, it raises\\n  an exception (usually but not necessarily ``AttributeError``).\\n\\n  Note: If the object is a class instance and the attribute reference\\n  occurs on both sides of the assignment operator, the RHS expression,\\n  ``a.x`` can access either an instance attribute or (if no instance\\n  attribute exists) a class attribute.  The LHS target ``a.x`` is\\n  always set as an instance attribute, creating it if necessary.\\n  Thus, the two occurrences of ``a.x`` do not necessarily refer to the\\n  same attribute: if the RHS expression refers to a class attribute,\\n  the LHS creates a new instance attribute as the target of the\\n  assignment:\\n\\n     class Cls:\\n         x = 3             # class variable\\n     inst = Cls()\\n     inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3\\n\\n  This description does not necessarily apply to descriptor\\n  attributes, such as properties created with ``property()``.\\n\\n* If the target is a subscription: The primary expression in the\\n  reference is evaluated.  It should yield either a mutable sequence\\n  object (such as a list) or a mapping object (such as a dictionary).\\n  Next, the subscript expression is evaluated.\\n\\n  If the primary is a mutable sequence object (such as a list), the\\n  subscript must yield an integer.  If it is negative, the sequence\\'s\\n  length is added to it.  The resulting value must be a nonnegative\\n  integer less than the sequence\\'s length, and the sequence is asked\\n  to assign the assigned object to its item with that index.  If the\\n  index is out of range, ``IndexError`` is raised (assignment to a\\n  subscripted sequence cannot add new items to a list).\\n\\n  If the primary is a mapping object (such as a dictionary), the\\n  subscript must have a type compatible with the mapping\\'s key type,\\n  and the mapping is then asked to create a key/datum pair which maps\\n  the subscript to the assigned object.  This can either replace an\\n  existing key/value pair with the same key value, or insert a new\\n  key/value pair (if no key with the same value existed).\\n\\n  For user-defined objects, the ``__setitem__()`` method is called\\n  with appropriate arguments.\\n\\n* If the target is a slicing: The primary expression in the reference\\n  is evaluated.  It should yield a mutable sequence object (such as a\\n  list).  The assigned object should be a sequence object of the same\\n  type.  Next, the lower and upper bound expressions are evaluated,\\n  insofar they are present; defaults are zero and the sequence\\'s\\n  length.  The bounds should evaluate to integers. If either bound is\\n  negative, the sequence\\'s length is added to it.  The resulting\\n  bounds are clipped to lie between zero and the sequence\\'s length,\\n  inclusive.  Finally, the sequence object is asked to replace the\\n  slice with the items of the assigned sequence.  The length of the\\n  slice may be different from the length of the assigned sequence,\\n  thus changing the length of the target sequence, if the object\\n  allows it.\\n\\n**CPython implementation detail:** In the current implementation, the\\nsyntax for targets is taken to be the same as for expressions, and\\ninvalid syntax is rejected during the code generation phase, causing\\nless detailed error messages.\\n\\nWARNING: Although the definition of assignment implies that overlaps\\nbetween the left-hand side and the right-hand side are \\'safe\\' (for\\nexample ``a, b = b, a`` swaps two variables), overlaps *within* the\\ncollection of assigned-to variables are not safe!  For instance, the\\nfollowing program prints ``[0, 2]``:\\n\\n   x = [0, 1]\\n   i = 0\\n   i, x[i] = 1, 2\\n   print(x)\\n\\nSee also:\\n\\n   **PEP 3132** - Extended Iterable Unpacking\\n      The specification for the ``*target`` feature.\\n\\n\\nAugmented assignment statements\\n===============================\\n\\nAugmented assignment is the combination, in a single statement, of a\\nbinary operation and an assignment statement:\\n\\n   augmented_assignment_stmt ::= augtarget augop (expression_list | yield_expression)\\n   augtarget                 ::= identifier | attributeref | subscription | slicing\\n   augop                     ::= \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"//=\" | \"%=\" | \"**=\"\\n             | \">>=\" | \"<<=\" | \"&=\" | \"^=\" | \"|=\"\\n\\n(See section *Primaries* for the syntax definitions for the last three\\nsymbols.)\\n\\nAn augmented assignment evaluates the target (which, unlike normal\\nassignment statements, cannot be an unpacking) and the expression\\nlist, performs the binary operation specific to the type of assignment\\non the two operands, and assigns the result to the original target.\\nThe target is only evaluated once.\\n\\nAn augmented assignment expression like ``x += 1`` can be rewritten as\\n``x = x + 1`` to achieve a similar, but not exactly equal effect. In\\nthe augmented version, ``x`` is only evaluated once. Also, when\\npossible, the actual operation is performed *in-place*, meaning that\\nrather than creating a new object and assigning that to the target,\\nthe old object is modified instead.\\n\\nWith the exception of assigning to tuples and multiple targets in a\\nsingle statement, the assignment done by augmented assignment\\nstatements is handled the same way as normal assignments. Similarly,\\nwith the exception of the possible *in-place* behavior, the binary\\noperation performed by augmented assignment is the same as the normal\\nbinary operations.\\n\\nFor targets which are attribute references, the same *caveat about\\nclass and instance attributes* applies as for regular assignments.\\n',\n'atom-identifiers': '\\nIdentifiers (Names)\\n*******************\\n\\nAn identifier occurring as an atom is a name.  See section\\n*Identifiers and keywords* for lexical definition and section *Naming\\nand binding* for documentation of naming and binding.\\n\\nWhen the name is bound to an object, evaluation of the atom yields\\nthat object. When a name is not bound, an attempt to evaluate it\\nraises a ``NameError`` exception.\\n\\n**Private name mangling:** When an identifier that textually occurs in\\na class definition begins with two or more underscore characters and\\ndoes not end in two or more underscores, it is considered a *private\\nname* of that class. Private names are transformed to a longer form\\nbefore code is generated for them.  The transformation inserts the\\nclass name in front of the name, with leading underscores removed, and\\na single underscore inserted in front of the class name.  For example,\\nthe identifier ``__spam`` occurring in a class named ``Ham`` will be\\ntransformed to ``_Ham__spam``.  This transformation is independent of\\nthe syntactical context in which the identifier is used.  If the\\ntransformed name is extremely long (longer than 255 characters),\\nimplementation defined truncation may happen.  If the class name\\nconsists only of underscores, no transformation is done.\\n',\n'atom-literals': \"\\nLiterals\\n********\\n\\nPython supports string and bytes literals and various numeric\\nliterals:\\n\\n   literal ::= stringliteral | bytesliteral\\n               | integer | floatnumber | imagnumber\\n\\nEvaluation of a literal yields an object of the given type (string,\\nbytes, integer, floating point number, complex number) with the given\\nvalue.  The value may be approximated in the case of floating point\\nand imaginary (complex) literals.  See section *Literals* for details.\\n\\nAll literals correspond to immutable data types, and hence the\\nobject's identity is less important than its value.  Multiple\\nevaluations of literals with the same value (either the same\\noccurrence in the program text or a different occurrence) may obtain\\nthe same object or a different object with the same value.\\n\",\n'attribute-access': '\\nCustomizing attribute access\\n****************************\\n\\nThe following methods can be defined to customize the meaning of\\nattribute access (use of, assignment to, or deletion of ``x.name``)\\nfor class instances.\\n\\nobject.__getattr__(self, name)\\n\\n   Called when an attribute lookup has not found the attribute in the\\n   usual places (i.e. it is not an instance attribute nor is it found\\n   in the class tree for ``self``).  ``name`` is the attribute name.\\n   This method should return the (computed) attribute value or raise\\n   an ``AttributeError`` exception.\\n\\n   Note that if the attribute is found through the normal mechanism,\\n   ``__getattr__()`` is not called.  (This is an intentional asymmetry\\n   between ``__getattr__()`` and ``__setattr__()``.) This is done both\\n   for efficiency reasons and because otherwise ``__getattr__()``\\n   would have no way to access other attributes of the instance.  Note\\n   that at least for instance variables, you can fake total control by\\n   not inserting any values in the instance attribute dictionary (but\\n   instead inserting them in another object).  See the\\n   ``__getattribute__()`` method below for a way to actually get total\\n   control over attribute access.\\n\\nobject.__getattribute__(self, name)\\n\\n   Called unconditionally to implement attribute accesses for\\n   instances of the class. If the class also defines\\n   ``__getattr__()``, the latter will not be called unless\\n   ``__getattribute__()`` either calls it explicitly or raises an\\n   ``AttributeError``. This method should return the (computed)\\n   attribute value or raise an ``AttributeError`` exception. In order\\n   to avoid infinite recursion in this method, its implementation\\n   should always call the base class method with the same name to\\n   access any attributes it needs, for example,\\n   ``object.__getattribute__(self, name)``.\\n\\n   Note: This method may still be bypassed when looking up special methods\\n     as the result of implicit invocation via language syntax or\\n     built-in functions. See *Special method lookup*.\\n\\nobject.__setattr__(self, name, value)\\n\\n   Called when an attribute assignment is attempted.  This is called\\n   instead of the normal mechanism (i.e. store the value in the\\n   instance dictionary). *name* is the attribute name, *value* is the\\n   value to be assigned to it.\\n\\n   If ``__setattr__()`` wants to assign to an instance attribute, it\\n   should call the base class method with the same name, for example,\\n   ``object.__setattr__(self, name, value)``.\\n\\nobject.__delattr__(self, name)\\n\\n   Like ``__setattr__()`` but for attribute deletion instead of\\n   assignment.  This should only be implemented if ``del obj.name`` is\\n   meaningful for the object.\\n\\nobject.__dir__(self)\\n\\n   Called when ``dir()`` is called on the object. A sequence must be\\n   returned. ``dir()`` converts the returned sequence to a list and\\n   sorts it.\\n\\n\\nImplementing Descriptors\\n========================\\n\\nThe following methods only apply when an instance of the class\\ncontaining the method (a so-called *descriptor* class) appears in an\\n*owner* class (the descriptor must be in either the owner\\'s class\\ndictionary or in the class dictionary for one of its parents).  In the\\nexamples below, \"the attribute\" refers to the attribute whose name is\\nthe key of the property in the owner class\\' ``__dict__``.\\n\\nobject.__get__(self, instance, owner)\\n\\n   Called to get the attribute of the owner class (class attribute\\n   access) or of an instance of that class (instance attribute\\n   access). *owner* is always the owner class, while *instance* is the\\n   instance that the attribute was accessed through, or ``None`` when\\n   the attribute is accessed through the *owner*.  This method should\\n   return the (computed) attribute value or raise an\\n   ``AttributeError`` exception.\\n\\nobject.__set__(self, instance, value)\\n\\n   Called to set the attribute on an instance *instance* of the owner\\n   class to a new value, *value*.\\n\\nobject.__delete__(self, instance)\\n\\n   Called to delete the attribute on an instance *instance* of the\\n   owner class.\\n\\n\\nInvoking Descriptors\\n====================\\n\\nIn general, a descriptor is an object attribute with \"binding\\nbehavior\", one whose attribute access has been overridden by methods\\nin the descriptor protocol:  ``__get__()``, ``__set__()``, and\\n``__delete__()``. If any of those methods are defined for an object,\\nit is said to be a descriptor.\\n\\nThe default behavior for attribute access is to get, set, or delete\\nthe attribute from an object\\'s dictionary. For instance, ``a.x`` has a\\nlookup chain starting with ``a.__dict__[\\'x\\']``, then\\n``type(a).__dict__[\\'x\\']``, and continuing through the base classes of\\n``type(a)`` excluding metaclasses.\\n\\nHowever, if the looked-up value is an object defining one of the\\ndescriptor methods, then Python may override the default behavior and\\ninvoke the descriptor method instead.  Where this occurs in the\\nprecedence chain depends on which descriptor methods were defined and\\nhow they were called.\\n\\nThe starting point for descriptor invocation is a binding, ``a.x``.\\nHow the arguments are assembled depends on ``a``:\\n\\nDirect Call\\n   The simplest and least common call is when user code directly\\n   invokes a descriptor method:    ``x.__get__(a)``.\\n\\nInstance Binding\\n   If binding to an object instance, ``a.x`` is transformed into the\\n   call: ``type(a).__dict__[\\'x\\'].__get__(a, type(a))``.\\n\\nClass Binding\\n   If binding to a class, ``A.x`` is transformed into the call:\\n   ``A.__dict__[\\'x\\'].__get__(None, A)``.\\n\\nSuper Binding\\n   If ``a`` is an instance of ``super``, then the binding ``super(B,\\n   obj).m()`` searches ``obj.__class__.__mro__`` for the base class\\n   ``A`` immediately preceding ``B`` and then invokes the descriptor\\n   with the call: ``A.__dict__[\\'m\\'].__get__(obj, obj.__class__)``.\\n\\nFor instance bindings, the precedence of descriptor invocation depends\\non the which descriptor methods are defined.  A descriptor can define\\nany combination of ``__get__()``, ``__set__()`` and ``__delete__()``.\\nIf it does not define ``__get__()``, then accessing the attribute will\\nreturn the descriptor object itself unless there is a value in the\\nobject\\'s instance dictionary.  If the descriptor defines ``__set__()``\\nand/or ``__delete__()``, it is a data descriptor; if it defines\\nneither, it is a non-data descriptor.  Normally, data descriptors\\ndefine both ``__get__()`` and ``__set__()``, while non-data\\ndescriptors have just the ``__get__()`` method.  Data descriptors with\\n``__set__()`` and ``__get__()`` defined always override a redefinition\\nin an instance dictionary.  In contrast, non-data descriptors can be\\noverridden by instances.\\n\\nPython methods (including ``staticmethod()`` and ``classmethod()``)\\nare implemented as non-data descriptors.  Accordingly, instances can\\nredefine and override methods.  This allows individual instances to\\nacquire behaviors that differ from other instances of the same class.\\n\\nThe ``property()`` function is implemented as a data descriptor.\\nAccordingly, instances cannot override the behavior of a property.\\n\\n\\n__slots__\\n=========\\n\\nBy default, instances of classes have a dictionary for attribute\\nstorage.  This wastes space for objects having very few instance\\nvariables.  The space consumption can become acute when creating large\\nnumbers of instances.\\n\\nThe default can be overridden by defining *__slots__* in a class\\ndefinition. The *__slots__* declaration takes a sequence of instance\\nvariables and reserves just enough space in each instance to hold a\\nvalue for each variable.  Space is saved because *__dict__* is not\\ncreated for each instance.\\n\\nobject.__slots__\\n\\n   This class variable can be assigned a string, iterable, or sequence\\n   of strings with variable names used by instances.  If defined in a\\n   class, *__slots__* reserves space for the declared variables and\\n   prevents the automatic creation of *__dict__* and *__weakref__* for\\n   each instance.\\n\\n\\nNotes on using *__slots__*\\n--------------------------\\n\\n* When inheriting from a class without *__slots__*, the *__dict__*\\n  attribute of that class will always be accessible, so a *__slots__*\\n  definition in the subclass is meaningless.\\n\\n* Without a *__dict__* variable, instances cannot be assigned new\\n  variables not listed in the *__slots__* definition.  Attempts to\\n  assign to an unlisted variable name raises ``AttributeError``. If\\n  dynamic assignment of new variables is desired, then add\\n  ``\\'__dict__\\'`` to the sequence of strings in the *__slots__*\\n  declaration.\\n\\n* Without a *__weakref__* variable for each instance, classes defining\\n  *__slots__* do not support weak references to its instances. If weak\\n  reference support is needed, then add ``\\'__weakref__\\'`` to the\\n  sequence of strings in the *__slots__* declaration.\\n\\n* *__slots__* are implemented at the class level by creating\\n  descriptors (*Implementing Descriptors*) for each variable name.  As\\n  a result, class attributes cannot be used to set default values for\\n  instance variables defined by *__slots__*; otherwise, the class\\n  attribute would overwrite the descriptor assignment.\\n\\n* The action of a *__slots__* declaration is limited to the class\\n  where it is defined.  As a result, subclasses will have a *__dict__*\\n  unless they also define *__slots__* (which must only contain names\\n  of any *additional* slots).\\n\\n* If a class defines a slot also defined in a base class, the instance\\n  variable defined by the base class slot is inaccessible (except by\\n  retrieving its descriptor directly from the base class). This\\n  renders the meaning of the program undefined.  In the future, a\\n  check may be added to prevent this.\\n\\n* Nonempty *__slots__* does not work for classes derived from\\n  \"variable-length\" built-in types such as ``int``, ``str`` and\\n  ``tuple``.\\n\\n* Any non-string iterable may be assigned to *__slots__*. Mappings may\\n  also be used; however, in the future, special meaning may be\\n  assigned to the values corresponding to each key.\\n\\n* *__class__* assignment works only if both classes have the same\\n  *__slots__*.\\n',\n'attribute-references': '\\nAttribute references\\n********************\\n\\nAn attribute reference is a primary followed by a period and a name:\\n\\n   attributeref ::= primary \".\" identifier\\n\\nThe primary must evaluate to an object of a type that supports\\nattribute references, which most objects do.  This object is then\\nasked to produce the attribute whose name is the identifier (which can\\nbe customized by overriding the ``__getattr__()`` method).  If this\\nattribute is not available, the exception ``AttributeError`` is\\nraised.  Otherwise, the type and value of the object produced is\\ndetermined by the object.  Multiple evaluations of the same attribute\\nreference may yield different objects.\\n',\n'augassign': '\\nAugmented assignment statements\\n*******************************\\n\\nAugmented assignment is the combination, in a single statement, of a\\nbinary operation and an assignment statement:\\n\\n   augmented_assignment_stmt ::= augtarget augop (expression_list | yield_expression)\\n   augtarget                 ::= identifier | attributeref | subscription | slicing\\n   augop                     ::= \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"//=\" | \"%=\" | \"**=\"\\n             | \">>=\" | \"<<=\" | \"&=\" | \"^=\" | \"|=\"\\n\\n(See section *Primaries* for the syntax definitions for the last three\\nsymbols.)\\n\\nAn augmented assignment evaluates the target (which, unlike normal\\nassignment statements, cannot be an unpacking) and the expression\\nlist, performs the binary operation specific to the type of assignment\\non the two operands, and assigns the result to the original target.\\nThe target is only evaluated once.\\n\\nAn augmented assignment expression like ``x += 1`` can be rewritten as\\n``x = x + 1`` to achieve a similar, but not exactly equal effect. In\\nthe augmented version, ``x`` is only evaluated once. Also, when\\npossible, the actual operation is performed *in-place*, meaning that\\nrather than creating a new object and assigning that to the target,\\nthe old object is modified instead.\\n\\nWith the exception of assigning to tuples and multiple targets in a\\nsingle statement, the assignment done by augmented assignment\\nstatements is handled the same way as normal assignments. Similarly,\\nwith the exception of the possible *in-place* behavior, the binary\\noperation performed by augmented assignment is the same as the normal\\nbinary operations.\\n\\nFor targets which are attribute references, the same *caveat about\\nclass and instance attributes* applies as for regular assignments.\\n',\n'binary': '\\nBinary arithmetic operations\\n****************************\\n\\nThe binary arithmetic operations have the conventional priority\\nlevels.  Note that some of these operations also apply to certain non-\\nnumeric types.  Apart from the power operator, there are only two\\nlevels, one for multiplicative operators and one for additive\\noperators:\\n\\n   m_expr ::= u_expr | m_expr \"*\" u_expr | m_expr \"//\" u_expr | m_expr \"/\" u_expr\\n              | m_expr \"%\" u_expr\\n   a_expr ::= m_expr | a_expr \"+\" m_expr | a_expr \"-\" m_expr\\n\\nThe ``*`` (multiplication) operator yields the product of its\\narguments.  The arguments must either both be numbers, or one argument\\nmust be an integer and the other must be a sequence. In the former\\ncase, the numbers are converted to a common type and then multiplied\\ntogether.  In the latter case, sequence repetition is performed; a\\nnegative repetition factor yields an empty sequence.\\n\\nThe ``/`` (division) and ``//`` (floor division) operators yield the\\nquotient of their arguments.  The numeric arguments are first\\nconverted to a common type. Integer division yields a float, while\\nfloor division of integers results in an integer; the result is that\\nof mathematical division with the \\'floor\\' function applied to the\\nresult.  Division by zero raises the ``ZeroDivisionError`` exception.\\n\\nThe ``%`` (modulo) operator yields the remainder from the division of\\nthe first argument by the second.  The numeric arguments are first\\nconverted to a common type.  A zero right argument raises the\\n``ZeroDivisionError`` exception.  The arguments may be floating point\\nnumbers, e.g., ``3.14%0.7`` equals ``0.34`` (since ``3.14`` equals\\n``4*0.7 + 0.34``.)  The modulo operator always yields a result with\\nthe same sign as its second operand (or zero); the absolute value of\\nthe result is strictly smaller than the absolute value of the second\\noperand [1].\\n\\nThe floor division and modulo operators are connected by the following\\nidentity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are\\nalso connected with the built-in function ``divmod()``: ``divmod(x, y)\\n== (x//y, x%y)``. [2].\\n\\nIn addition to performing the modulo operation on numbers, the ``%``\\noperator is also overloaded by string objects to perform old-style\\nstring formatting (also known as interpolation).  The syntax for\\nstring formatting is described in the Python Library Reference,\\nsection *printf-style String Formatting*.\\n\\nThe floor division operator, the modulo operator, and the ``divmod()``\\nfunction are not defined for complex numbers.  Instead, convert to a\\nfloating point number using the ``abs()`` function if appropriate.\\n\\nThe ``+`` (addition) operator yields the sum of its arguments.  The\\narguments must either both be numbers or both sequences of the same\\ntype.  In the former case, the numbers are converted to a common type\\nand then added together.  In the latter case, the sequences are\\nconcatenated.\\n\\nThe ``-`` (subtraction) operator yields the difference of its\\narguments.  The numeric arguments are first converted to a common\\ntype.\\n',\n'bitwise': '\\nBinary bitwise operations\\n*************************\\n\\nEach of the three bitwise operations has a different priority level:\\n\\n   and_expr ::= shift_expr | and_expr \"&\" shift_expr\\n   xor_expr ::= and_expr | xor_expr \"^\" and_expr\\n   or_expr  ::= xor_expr | or_expr \"|\" xor_expr\\n\\nThe ``&`` operator yields the bitwise AND of its arguments, which must\\nbe integers.\\n\\nThe ``^`` operator yields the bitwise XOR (exclusive OR) of its\\narguments, which must be integers.\\n\\nThe ``|`` operator yields the bitwise (inclusive) OR of its arguments,\\nwhich must be integers.\\n',\n'bltin-code-objects': '\\nCode Objects\\n************\\n\\nCode objects are used by the implementation to represent \"pseudo-\\ncompiled\" executable Python code such as a function body. They differ\\nfrom function objects because they don\\'t contain a reference to their\\nglobal execution environment.  Code objects are returned by the built-\\nin ``compile()`` function and can be extracted from function objects\\nthrough their ``__code__`` attribute. See also the ``code`` module.\\n\\nA code object can be executed or evaluated by passing it (instead of a\\nsource string) to the ``exec()`` or ``eval()``  built-in functions.\\n\\nSee *The standard type hierarchy* for more information.\\n',\n'bltin-ellipsis-object': '\\nThe Ellipsis Object\\n*******************\\n\\nThis object is commonly used by slicing (see *Slicings*).  It supports\\nno special operations.  There is exactly one ellipsis object, named\\n``Ellipsis`` (a built-in name).  ``type(Ellipsis)()`` produces the\\n``Ellipsis`` singleton.\\n\\nIt is written as ``Ellipsis`` or ``...``.\\n',\n'bltin-null-object': \"\\nThe Null Object\\n***************\\n\\nThis object is returned by functions that don't explicitly return a\\nvalue.  It supports no special operations.  There is exactly one null\\nobject, named ``None`` (a built-in name).  ``type(None)()`` produces\\nthe same singleton.\\n\\nIt is written as ``None``.\\n\",\n'bltin-type-objects': \"\\nType Objects\\n************\\n\\nType objects represent the various object types.  An object's type is\\naccessed by the built-in function ``type()``.  There are no special\\noperations on types.  The standard module ``types`` defines names for\\nall standard built-in types.\\n\\nTypes are written like this: ``<class 'int'>``.\\n\",\n'booleans': '\\nBoolean operations\\n******************\\n\\n   or_test  ::= and_test | or_test \"or\" and_test\\n   and_test ::= not_test | and_test \"and\" not_test\\n   not_test ::= comparison | \"not\" not_test\\n\\nIn the context of Boolean operations, and also when expressions are\\nused by control flow statements, the following values are interpreted\\nas false: ``False``, ``None``, numeric zero of all types, and empty\\nstrings and containers (including strings, tuples, lists,\\ndictionaries, sets and frozensets).  All other values are interpreted\\nas true.  User-defined objects can customize their truth value by\\nproviding a ``__bool__()`` method.\\n\\nThe operator ``not`` yields ``True`` if its argument is false,\\n``False`` otherwise.\\n\\nThe expression ``x and y`` first evaluates *x*; if *x* is false, its\\nvalue is returned; otherwise, *y* is evaluated and the resulting value\\nis returned.\\n\\nThe expression ``x or y`` first evaluates *x*; if *x* is true, its\\nvalue is returned; otherwise, *y* is evaluated and the resulting value\\nis returned.\\n\\n(Note that neither ``and`` nor ``or`` restrict the value and type they\\nreturn to ``False`` and ``True``, but rather return the last evaluated\\nargument.  This is sometimes useful, e.g., if ``s`` is a string that\\nshould be replaced by a default value if it is empty, the expression\\n``s or \\'foo\\'`` yields the desired value.  Because ``not`` has to\\ninvent a value anyway, it does not bother to return a value of the\\nsame type as its argument, so e.g., ``not \\'foo\\'`` yields ``False``,\\nnot ``\\'\\'``.)\\n',\n'break': '\\nThe ``break`` statement\\n***********************\\n\\n   break_stmt ::= \"break\"\\n\\n``break`` may only occur syntactically nested in a ``for`` or\\n``while`` loop, but not nested in a function or class definition\\nwithin that loop.\\n\\nIt terminates the nearest enclosing loop, skipping the optional\\n``else`` clause if the loop has one.\\n\\nIf a ``for`` loop is terminated by ``break``, the loop control target\\nkeeps its current value.\\n\\nWhen ``break`` passes control out of a ``try`` statement with a\\n``finally`` clause, that ``finally`` clause is executed before really\\nleaving the loop.\\n',\n'callable-types': '\\nEmulating callable objects\\n**************************\\n\\nobject.__call__(self[, args...])\\n\\n   Called when the instance is \"called\" as a function; if this method\\n   is defined, ``x(arg1, arg2, ...)`` is a shorthand for\\n   ``x.__call__(arg1, arg2, ...)``.\\n',\n'calls': '\\nCalls\\n*****\\n\\nA call calls a callable object (e.g., a *function*) with a possibly\\nempty series of *arguments*:\\n\\n   call                 ::= primary \"(\" [argument_list [\",\"] | comprehension] \")\"\\n   argument_list        ::= positional_arguments [\",\" keyword_arguments]\\n                       [\",\" \"*\" expression] [\",\" keyword_arguments]\\n                       [\",\" \"**\" expression]\\n                     | keyword_arguments [\",\" \"*\" expression]\\n                       [\",\" keyword_arguments] [\",\" \"**\" expression]\\n                     | \"*\" expression [\",\" keyword_arguments] [\",\" \"**\" expression]\\n                     | \"**\" expression\\n   positional_arguments ::= expression (\",\" expression)*\\n   keyword_arguments    ::= keyword_item (\",\" keyword_item)*\\n   keyword_item         ::= identifier \"=\" expression\\n\\nA trailing comma may be present after the positional and keyword\\narguments but does not affect the semantics.\\n\\nThe primary must evaluate to a callable object (user-defined\\nfunctions, built-in functions, methods of built-in objects, class\\nobjects, methods of class instances, and all objects having a\\n``__call__()`` method are callable).  All argument expressions are\\nevaluated before the call is attempted.  Please refer to section\\n*Function definitions* for the syntax of formal *parameter* lists.\\n\\nIf keyword arguments are present, they are first converted to\\npositional arguments, as follows.  First, a list of unfilled slots is\\ncreated for the formal parameters.  If there are N positional\\narguments, they are placed in the first N slots.  Next, for each\\nkeyword argument, the identifier is used to determine the\\ncorresponding slot (if the identifier is the same as the first formal\\nparameter name, the first slot is used, and so on).  If the slot is\\nalready filled, a ``TypeError`` exception is raised. Otherwise, the\\nvalue of the argument is placed in the slot, filling it (even if the\\nexpression is ``None``, it fills the slot).  When all arguments have\\nbeen processed, the slots that are still unfilled are filled with the\\ncorresponding default value from the function definition.  (Default\\nvalues are calculated, once, when the function is defined; thus, a\\nmutable object such as a list or dictionary used as default value will\\nbe shared by all calls that don\\'t specify an argument value for the\\ncorresponding slot; this should usually be avoided.)  If there are any\\nunfilled slots for which no default value is specified, a\\n``TypeError`` exception is raised.  Otherwise, the list of filled\\nslots is used as the argument list for the call.\\n\\n**CPython implementation detail:** An implementation may provide\\nbuilt-in functions whose positional parameters do not have names, even\\nif they are \\'named\\' for the purpose of documentation, and which\\ntherefore cannot be supplied by keyword.  In CPython, this is the case\\nfor functions implemented in C that use ``PyArg_ParseTuple()`` to\\nparse their arguments.\\n\\nIf there are more positional arguments than there are formal parameter\\nslots, a ``TypeError`` exception is raised, unless a formal parameter\\nusing the syntax ``*identifier`` is present; in this case, that formal\\nparameter receives a tuple containing the excess positional arguments\\n(or an empty tuple if there were no excess positional arguments).\\n\\nIf any keyword argument does not correspond to a formal parameter\\nname, a ``TypeError`` exception is raised, unless a formal parameter\\nusing the syntax ``**identifier`` is present; in this case, that\\nformal parameter receives a dictionary containing the excess keyword\\narguments (using the keywords as keys and the argument values as\\ncorresponding values), or a (new) empty dictionary if there were no\\nexcess keyword arguments.\\n\\nIf the syntax ``*expression`` appears in the function call,\\n``expression`` must evaluate to an iterable.  Elements from this\\niterable are treated as if they were additional positional arguments;\\nif there are positional arguments *x1*, ..., *xN*, and ``expression``\\nevaluates to a sequence *y1*, ..., *yM*, this is equivalent to a call\\nwith M+N positional arguments *x1*, ..., *xN*, *y1*, ..., *yM*.\\n\\nA consequence of this is that although the ``*expression`` syntax may\\nappear *after* some keyword arguments, it is processed *before* the\\nkeyword arguments (and the ``**expression`` argument, if any -- see\\nbelow).  So:\\n\\n   >>> def f(a, b):\\n   ...  print(a, b)\\n   ...\\n   >>> f(b=1, *(2,))\\n   2 1\\n   >>> f(a=1, *(2,))\\n   Traceback (most recent call last):\\n     File \"<stdin>\", line 1, in ?\\n   TypeError: f() got multiple values for keyword argument \\'a\\'\\n   >>> f(1, *(2,))\\n   1 2\\n\\nIt is unusual for both keyword arguments and the ``*expression``\\nsyntax to be used in the same call, so in practice this confusion does\\nnot arise.\\n\\nIf the syntax ``**expression`` appears in the function call,\\n``expression`` must evaluate to a mapping, the contents of which are\\ntreated as additional keyword arguments.  In the case of a keyword\\nappearing in both ``expression`` and as an explicit keyword argument,\\na ``TypeError`` exception is raised.\\n\\nFormal parameters using the syntax ``*identifier`` or ``**identifier``\\ncannot be used as positional argument slots or as keyword argument\\nnames.\\n\\nA call always returns some value, possibly ``None``, unless it raises\\nan exception.  How this value is computed depends on the type of the\\ncallable object.\\n\\nIf it is---\\n\\na user-defined function:\\n   The code block for the function is executed, passing it the\\n   argument list.  The first thing the code block will do is bind the\\n   formal parameters to the arguments; this is described in section\\n   *Function definitions*.  When the code block executes a ``return``\\n   statement, this specifies the return value of the function call.\\n\\na built-in function or method:\\n   The result is up to the interpreter; see *Built-in Functions* for\\n   the descriptions of built-in functions and methods.\\n\\na class object:\\n   A new instance of that class is returned.\\n\\na class instance method:\\n   The corresponding user-defined function is called, with an argument\\n   list that is one longer than the argument list of the call: the\\n   instance becomes the first argument.\\n\\na class instance:\\n   The class must define a ``__call__()`` method; the effect is then\\n   the same as if that method was called.\\n',\n'class': '\\nClass definitions\\n*****************\\n\\nA class definition defines a class object (see section *The standard\\ntype hierarchy*):\\n\\n   classdef    ::= [decorators] \"class\" classname [inheritance] \":\" suite\\n   inheritance ::= \"(\" [parameter_list] \")\"\\n   classname   ::= identifier\\n\\nA class definition is an executable statement.  The inheritance list\\nusually gives a list of base classes (see *Customizing class creation*\\nfor more advanced uses), so each item in the list should evaluate to a\\nclass object which allows subclassing.  Classes without an inheritance\\nlist inherit, by default, from the base class ``object``; hence,\\n\\n   class Foo:\\n       pass\\n\\nis equivalent to\\n\\n   class Foo(object):\\n       pass\\n\\nThe class\\'s suite is then executed in a new execution frame (see\\n*Naming and binding*), using a newly created local namespace and the\\noriginal global namespace. (Usually, the suite contains mostly\\nfunction definitions.)  When the class\\'s suite finishes execution, its\\nexecution frame is discarded but its local namespace is saved. [4] A\\nclass object is then created using the inheritance list for the base\\nclasses and the saved local namespace for the attribute dictionary.\\nThe class name is bound to this class object in the original local\\nnamespace.\\n\\nClass creation can be customized heavily using *metaclasses*.\\n\\nClasses can also be decorated: just like when decorating functions,\\n\\n   @f1(arg)\\n   @f2\\n   class Foo: pass\\n\\nis equivalent to\\n\\n   class Foo: pass\\n   Foo = f1(arg)(f2(Foo))\\n\\nThe evaluation rules for the decorator expressions are the same as for\\nfunction decorators.  The result must be a class object, which is then\\nbound to the class name.\\n\\n**Programmer\\'s note:** Variables defined in the class definition are\\nclass attributes; they are shared by instances.  Instance attributes\\ncan be set in a method with ``self.name = value``.  Both class and\\ninstance attributes are accessible through the notation\\n\"``self.name``\", and an instance attribute hides a class attribute\\nwith the same name when accessed in this way.  Class attributes can be\\nused as defaults for instance attributes, but using mutable values\\nthere can lead to unexpected results.  *Descriptors* can be used to\\ncreate instance variables with different implementation details.\\n\\nSee also:\\n\\n   **PEP 3115** - Metaclasses in Python 3 **PEP 3129** - Class\\n   Decorators\\n\\n-[ Footnotes ]-\\n\\n[1] The exception is propagated to the invocation stack unless there\\n    is a ``finally`` clause which happens to raise another exception.\\n    That new exception causes the old one to be lost.\\n\\n[2] Currently, control \"flows off the end\" except in the case of an\\n    exception or the execution of a ``return``, ``continue``, or\\n    ``break`` statement.\\n\\n[3] A string literal appearing as the first statement in the function\\n    body is transformed into the function\\'s ``__doc__`` attribute and\\n    therefore the function\\'s *docstring*.\\n\\n[4] A string literal appearing as the first statement in the class\\n    body is transformed into the namespace\\'s ``__doc__`` item and\\n    therefore the class\\'s *docstring*.\\n',\n'comparisons': '\\nComparisons\\n***********\\n\\nUnlike C, all comparison operations in Python have the same priority,\\nwhich is lower than that of any arithmetic, shifting or bitwise\\noperation.  Also unlike C, expressions like ``a < b < c`` have the\\ninterpretation that is conventional in mathematics:\\n\\n   comparison    ::= or_expr ( comp_operator or_expr )*\\n   comp_operator ::= \"<\" | \">\" | \"==\" | \">=\" | \"<=\" | \"!=\"\\n                     | \"is\" [\"not\"] | [\"not\"] \"in\"\\n\\nComparisons yield boolean values: ``True`` or ``False``.\\n\\nComparisons can be chained arbitrarily, e.g., ``x < y <= z`` is\\nequivalent to ``x < y and y <= z``, except that ``y`` is evaluated\\nonly once (but in both cases ``z`` is not evaluated at all when ``x <\\ny`` is found to be false).\\n\\nFormally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*,\\n*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y\\nopN z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``,\\nexcept that each expression is evaluated at most once.\\n\\nNote that ``a op1 b op2 c`` doesn\\'t imply any kind of comparison\\nbetween *a* and *c*, so that, e.g., ``x < y > z`` is perfectly legal\\n(though perhaps not pretty).\\n\\nThe operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare\\nthe values of two objects.  The objects need not have the same type.\\nIf both are numbers, they are converted to a common type.  Otherwise,\\nthe ``==`` and ``!=`` operators *always* consider objects of different\\ntypes to be unequal, while the ``<``, ``>``, ``>=`` and ``<=``\\noperators raise a ``TypeError`` when comparing objects of different\\ntypes that do not implement these operators for the given pair of\\ntypes.  You can control comparison behavior of objects of non-built-in\\ntypes by defining rich comparison methods like ``__gt__()``, described\\nin section *Basic customization*.\\n\\nComparison of objects of the same type depends on the type:\\n\\n* Numbers are compared arithmetically.\\n\\n* The values ``float(\\'NaN\\')`` and ``Decimal(\\'NaN\\')`` are special. The\\n  are identical to themselves, ``x is x`` but are not equal to\\n  themselves, ``x != x``.  Additionally, comparing any value to a\\n  not-a-number value will return ``False``.  For example, both ``3 <\\n  float(\\'NaN\\')`` and ``float(\\'NaN\\') < 3`` will return ``False``.\\n\\n* Bytes objects are compared lexicographically using the numeric\\n  values of their elements.\\n\\n* Strings are compared lexicographically using the numeric equivalents\\n  (the result of the built-in function ``ord()``) of their characters.\\n  [3] String and bytes object can\\'t be compared!\\n\\n* Tuples and lists are compared lexicographically using comparison of\\n  corresponding elements.  This means that to compare equal, each\\n  element must compare equal and the two sequences must be of the same\\n  type and have the same length.\\n\\n  If not equal, the sequences are ordered the same as their first\\n  differing elements.  For example, ``[1,2,x] <= [1,2,y]`` has the\\n  same value as ``x <= y``.  If the corresponding element does not\\n  exist, the shorter sequence is ordered first (for example, ``[1,2] <\\n  [1,2,3]``).\\n\\n* Mappings (dictionaries) compare equal if and only if they have the\\n  same ``(key, value)`` pairs. Order comparisons ``(\\'<\\', \\'<=\\', \\'>=\\',\\n  \\'>\\')`` raise ``TypeError``.\\n\\n* Sets and frozensets define comparison operators to mean subset and\\n  superset tests.  Those relations do not define total orderings (the\\n  two sets ``{1,2}`` and {2,3} are not equal, nor subsets of one\\n  another, nor supersets of one another).  Accordingly, sets are not\\n  appropriate arguments for functions which depend on total ordering.\\n  For example, ``min()``, ``max()``, and ``sorted()`` produce\\n  undefined results given a list of sets as inputs.\\n\\n* Most other objects of built-in types compare unequal unless they are\\n  the same object; the choice whether one object is considered smaller\\n  or larger than another one is made arbitrarily but consistently\\n  within one execution of a program.\\n\\nComparison of objects of the differing types depends on whether either\\nof the types provide explicit support for the comparison.  Most\\nnumeric types can be compared with one another.  When cross-type\\ncomparison is not supported, the comparison method returns\\n``NotImplemented``.\\n\\nThe operators ``in`` and ``not in`` test for membership.  ``x in s``\\nevaluates to true if *x* is a member of *s*, and false otherwise.  ``x\\nnot in s`` returns the negation of ``x in s``.  All built-in sequences\\nand set types support this as well as dictionary, for which ``in``\\ntests whether a the dictionary has a given key. For container types\\nsuch as list, tuple, set, frozenset, dict, or collections.deque, the\\nexpression ``x in y`` is equivalent to ``any(x is e or x == e for e in\\ny)``.\\n\\nFor the string and bytes types, ``x in y`` is true if and only if *x*\\nis a substring of *y*.  An equivalent test is ``y.find(x) != -1``.\\nEmpty strings are always considered to be a substring of any other\\nstring, so ``\"\" in \"abc\"`` will return ``True``.\\n\\nFor user-defined classes which define the ``__contains__()`` method,\\n``x in y`` is true if and only if ``y.__contains__(x)`` is true.\\n\\nFor user-defined classes which do not define ``__contains__()`` but do\\ndefine ``__iter__()``, ``x in y`` is true if some value ``z`` with ``x\\n== z`` is produced while iterating over ``y``.  If an exception is\\nraised during the iteration, it is as if ``in`` raised that exception.\\n\\nLastly, the old-style iteration protocol is tried: if a class defines\\n``__getitem__()``, ``x in y`` is true if and only if there is a non-\\nnegative integer index *i* such that ``x == y[i]``, and all lower\\ninteger indices do not raise ``IndexError`` exception.  (If any other\\nexception is raised, it is as if ``in`` raised that exception).\\n\\nThe operator ``not in`` is defined to have the inverse true value of\\n``in``.\\n\\nThe operators ``is`` and ``is not`` test for object identity: ``x is\\ny`` is true if and only if *x* and *y* are the same object.  ``x is\\nnot y`` yields the inverse truth value. [4]\\n',\n'compound': '\\nCompound statements\\n*******************\\n\\nCompound statements contain (groups of) other statements; they affect\\nor control the execution of those other statements in some way.  In\\ngeneral, compound statements span multiple lines, although in simple\\nincarnations a whole compound statement may be contained in one line.\\n\\nThe ``if``, ``while`` and ``for`` statements implement traditional\\ncontrol flow constructs.  ``try`` specifies exception handlers and/or\\ncleanup code for a group of statements, while the ``with`` statement\\nallows the execution of initialization and finalization code around a\\nblock of code.  Function and class definitions are also syntactically\\ncompound statements.\\n\\nCompound statements consist of one or more \\'clauses.\\'  A clause\\nconsists of a header and a \\'suite.\\'  The clause headers of a\\nparticular compound statement are all at the same indentation level.\\nEach clause header begins with a uniquely identifying keyword and ends\\nwith a colon.  A suite is a group of statements controlled by a\\nclause.  A suite can be one or more semicolon-separated simple\\nstatements on the same line as the header, following the header\\'s\\ncolon, or it can be one or more indented statements on subsequent\\nlines.  Only the latter form of suite can contain nested compound\\nstatements; the following is illegal, mostly because it wouldn\\'t be\\nclear to which ``if`` clause a following ``else`` clause would belong:\\n\\n   if test1: if test2: print(x)\\n\\nAlso note that the semicolon binds tighter than the colon in this\\ncontext, so that in the following example, either all or none of the\\n``print()`` calls are executed:\\n\\n   if x < y < z: print(x); print(y); print(z)\\n\\nSummarizing:\\n\\n   compound_stmt ::= if_stmt\\n                     | while_stmt\\n                     | for_stmt\\n                     | try_stmt\\n                     | with_stmt\\n                     | funcdef\\n                     | classdef\\n   suite         ::= stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT\\n   statement     ::= stmt_list NEWLINE | compound_stmt\\n   stmt_list     ::= simple_stmt (\";\" simple_stmt)* [\";\"]\\n\\nNote that statements always end in a ``NEWLINE`` possibly followed by\\na ``DEDENT``.  Also note that optional continuation clauses always\\nbegin with a keyword that cannot start a statement, thus there are no\\nambiguities (the \\'dangling ``else``\\' problem is solved in Python by\\nrequiring nested ``if`` statements to be indented).\\n\\nThe formatting of the grammar rules in the following sections places\\neach clause on a separate line for clarity.\\n\\n\\nThe ``if`` statement\\n====================\\n\\nThe ``if`` statement is used for conditional execution:\\n\\n   if_stmt ::= \"if\" expression \":\" suite\\n               ( \"elif\" expression \":\" suite )*\\n               [\"else\" \":\" suite]\\n\\nIt selects exactly one of the suites by evaluating the expressions one\\nby one until one is found to be true (see section *Boolean operations*\\nfor the definition of true and false); then that suite is executed\\n(and no other part of the ``if`` statement is executed or evaluated).\\nIf all expressions are false, the suite of the ``else`` clause, if\\npresent, is executed.\\n\\n\\nThe ``while`` statement\\n=======================\\n\\nThe ``while`` statement is used for repeated execution as long as an\\nexpression is true:\\n\\n   while_stmt ::= \"while\" expression \":\" suite\\n                  [\"else\" \":\" suite]\\n\\nThis repeatedly tests the expression and, if it is true, executes the\\nfirst suite; if the expression is false (which may be the first time\\nit is tested) the suite of the ``else`` clause, if present, is\\nexecuted and the loop terminates.\\n\\nA ``break`` statement executed in the first suite terminates the loop\\nwithout executing the ``else`` clause\\'s suite.  A ``continue``\\nstatement executed in the first suite skips the rest of the suite and\\ngoes back to testing the expression.\\n\\n\\nThe ``for`` statement\\n=====================\\n\\nThe ``for`` statement is used to iterate over the elements of a\\nsequence (such as a string, tuple or list) or other iterable object:\\n\\n   for_stmt ::= \"for\" target_list \"in\" expression_list \":\" suite\\n                [\"else\" \":\" suite]\\n\\nThe expression list is evaluated once; it should yield an iterable\\nobject.  An iterator is created for the result of the\\n``expression_list``.  The suite is then executed once for each item\\nprovided by the iterator, in the order of ascending indices.  Each\\nitem in turn is assigned to the target list using the standard rules\\nfor assignments (see *Assignment statements*), and then the suite is\\nexecuted.  When the items are exhausted (which is immediately when the\\nsequence is empty or an iterator raises a ``StopIteration``\\nexception), the suite in the ``else`` clause, if present, is executed,\\nand the loop terminates.\\n\\nA ``break`` statement executed in the first suite terminates the loop\\nwithout executing the ``else`` clause\\'s suite.  A ``continue``\\nstatement executed in the first suite skips the rest of the suite and\\ncontinues with the next item, or with the ``else`` clause if there was\\nno next item.\\n\\nThe suite may assign to the variable(s) in the target list; this does\\nnot affect the next item assigned to it.\\n\\nNames in the target list are not deleted when the loop is finished,\\nbut if the sequence is empty, it will not have been assigned to at all\\nby the loop.  Hint: the built-in function ``range()`` returns an\\niterator of integers suitable to emulate the effect of Pascal\\'s ``for\\ni := a to b do``; e.g., ``list(range(3))`` returns the list ``[0, 1,\\n2]``.\\n\\nNote: There is a subtlety when the sequence is being modified by the loop\\n  (this can only occur for mutable sequences, i.e. lists).  An\\n  internal counter is used to keep track of which item is used next,\\n  and this is incremented on each iteration.  When this counter has\\n  reached the length of the sequence the loop terminates.  This means\\n  that if the suite deletes the current (or a previous) item from the\\n  sequence, the next item will be skipped (since it gets the index of\\n  the current item which has already been treated).  Likewise, if the\\n  suite inserts an item in the sequence before the current item, the\\n  current item will be treated again the next time through the loop.\\n  This can lead to nasty bugs that can be avoided by making a\\n  temporary copy using a slice of the whole sequence, e.g.,\\n\\n     for x in a[:]:\\n         if x < 0: a.remove(x)\\n\\n\\nThe ``try`` statement\\n=====================\\n\\nThe ``try`` statement specifies exception handlers and/or cleanup code\\nfor a group of statements:\\n\\n   try_stmt  ::= try1_stmt | try2_stmt\\n   try1_stmt ::= \"try\" \":\" suite\\n                 (\"except\" [expression [\"as\" target]] \":\" suite)+\\n                 [\"else\" \":\" suite]\\n                 [\"finally\" \":\" suite]\\n   try2_stmt ::= \"try\" \":\" suite\\n                 \"finally\" \":\" suite\\n\\nThe ``except`` clause(s) specify one or more exception handlers. When\\nno exception occurs in the ``try`` clause, no exception handler is\\nexecuted. When an exception occurs in the ``try`` suite, a search for\\nan exception handler is started.  This search inspects the except\\nclauses in turn until one is found that matches the exception.  An\\nexpression-less except clause, if present, must be last; it matches\\nany exception.  For an except clause with an expression, that\\nexpression is evaluated, and the clause matches the exception if the\\nresulting object is \"compatible\" with the exception.  An object is\\ncompatible with an exception if it is the class or a base class of the\\nexception object or a tuple containing an item compatible with the\\nexception.\\n\\nIf no except clause matches the exception, the search for an exception\\nhandler continues in the surrounding code and on the invocation stack.\\n[1]\\n\\nIf the evaluation of an expression in the header of an except clause\\nraises an exception, the original search for a handler is canceled and\\na search starts for the new exception in the surrounding code and on\\nthe call stack (it is treated as if the entire ``try`` statement\\nraised the exception).\\n\\nWhen a matching except clause is found, the exception is assigned to\\nthe target specified after the ``as`` keyword in that except clause,\\nif present, and the except clause\\'s suite is executed.  All except\\nclauses must have an executable block.  When the end of this block is\\nreached, execution continues normally after the entire try statement.\\n(This means that if two nested handlers exist for the same exception,\\nand the exception occurs in the try clause of the inner handler, the\\nouter handler will not handle the exception.)\\n\\nWhen an exception has been assigned using ``as target``, it is cleared\\nat the end of the except clause.  This is as if\\n\\n   except E as N:\\n       foo\\n\\nwas translated to\\n\\n   except E as N:\\n       try:\\n           foo\\n       finally:\\n           del N\\n\\nThis means the exception must be assigned to a different name to be\\nable to refer to it after the except clause.  Exceptions are cleared\\nbecause with the traceback attached to them, they form a reference\\ncycle with the stack frame, keeping all locals in that frame alive\\nuntil the next garbage collection occurs.\\n\\nBefore an except clause\\'s suite is executed, details about the\\nexception are stored in the ``sys`` module and can be access via\\n``sys.exc_info()``. ``sys.exc_info()`` returns a 3-tuple consisting of\\nthe exception class, the exception instance and a traceback object\\n(see section *The standard type hierarchy*) identifying the point in\\nthe program where the exception occurred.  ``sys.exc_info()`` values\\nare restored to their previous values (before the call) when returning\\nfrom a function that handled an exception.\\n\\nThe optional ``else`` clause is executed if and when control flows off\\nthe end of the ``try`` clause. [2] Exceptions in the ``else`` clause\\nare not handled by the preceding ``except`` clauses.\\n\\nIf ``finally`` is present, it specifies a \\'cleanup\\' handler.  The\\n``try`` clause is executed, including any ``except`` and ``else``\\nclauses.  If an exception occurs in any of the clauses and is not\\nhandled, the exception is temporarily saved. The ``finally`` clause is\\nexecuted.  If there is a saved exception it is re-raised at the end of\\nthe ``finally`` clause.  If the ``finally`` clause raises another\\nexception, the saved exception is set as the context of the new\\nexception. If the ``finally`` clause executes a ``return`` or\\n``break`` statement, the saved exception is discarded:\\n\\n   def f():\\n       try:\\n           1/0\\n       finally:\\n           return 42\\n\\n   >>> f()\\n   42\\n\\nThe exception information is not available to the program during\\nexecution of the ``finally`` clause.\\n\\nWhen a ``return``, ``break`` or ``continue`` statement is executed in\\nthe ``try`` suite of a ``try``...``finally`` statement, the\\n``finally`` clause is also executed \\'on the way out.\\' A ``continue``\\nstatement is illegal in the ``finally`` clause. (The reason is a\\nproblem with the current implementation --- this restriction may be\\nlifted in the future).\\n\\nAdditional information on exceptions can be found in section\\n*Exceptions*, and information on using the ``raise`` statement to\\ngenerate exceptions may be found in section *The raise statement*.\\n\\n\\nThe ``with`` statement\\n======================\\n\\nThe ``with`` statement is used to wrap the execution of a block with\\nmethods defined by a context manager (see section *With Statement\\nContext Managers*). This allows common\\n``try``...``except``...``finally`` usage patterns to be encapsulated\\nfor convenient reuse.\\n\\n   with_stmt ::= \"with\" with_item (\",\" with_item)* \":\" suite\\n   with_item ::= expression [\"as\" target]\\n\\nThe execution of the ``with`` statement with one \"item\" proceeds as\\nfollows:\\n\\n1. The context expression (the expression given in the ``with_item``)\\n   is evaluated to obtain a context manager.\\n\\n2. The context manager\\'s ``__exit__()`` is loaded for later use.\\n\\n3. The context manager\\'s ``__enter__()`` method is invoked.\\n\\n4. If a target was included in the ``with`` statement, the return\\n   value from ``__enter__()`` is assigned to it.\\n\\n   Note: The ``with`` statement guarantees that if the ``__enter__()``\\n     method returns without an error, then ``__exit__()`` will always\\n     be called. Thus, if an error occurs during the assignment to the\\n     target list, it will be treated the same as an error occurring\\n     within the suite would be. See step 6 below.\\n\\n5. The suite is executed.\\n\\n6. The context manager\\'s ``__exit__()`` method is invoked.  If an\\n   exception caused the suite to be exited, its type, value, and\\n   traceback are passed as arguments to ``__exit__()``. Otherwise,\\n   three ``None`` arguments are supplied.\\n\\n   If the suite was exited due to an exception, and the return value\\n   from the ``__exit__()`` method was false, the exception is\\n   reraised.  If the return value was true, the exception is\\n   suppressed, and execution continues with the statement following\\n   the ``with`` statement.\\n\\n   If the suite was exited for any reason other than an exception, the\\n   return value from ``__exit__()`` is ignored, and execution proceeds\\n   at the normal location for the kind of exit that was taken.\\n\\nWith more than one item, the context managers are processed as if\\nmultiple ``with`` statements were nested:\\n\\n   with A() as a, B() as b:\\n       suite\\n\\nis equivalent to\\n\\n   with A() as a:\\n       with B() as b:\\n           suite\\n\\nChanged in version 3.1: Support for multiple context expressions.\\n\\nSee also:\\n\\n   **PEP 0343** - The \"with\" statement\\n      The specification, background, and examples for the Python\\n      ``with`` statement.\\n\\n\\nFunction definitions\\n====================\\n\\nA function definition defines a user-defined function object (see\\nsection *The standard type hierarchy*):\\n\\n   funcdef        ::= [decorators] \"def\" funcname \"(\" [parameter_list] \")\" [\"->\" expression] \":\" suite\\n   decorators     ::= decorator+\\n   decorator      ::= \"@\" dotted_name [\"(\" [parameter_list [\",\"]] \")\"] NEWLINE\\n   dotted_name    ::= identifier (\".\" identifier)*\\n   parameter_list ::= (defparameter \",\")*\\n                      ( \"*\" [parameter] (\",\" defparameter)* [\",\" \"**\" parameter]\\n                      | \"**\" parameter\\n                      | defparameter [\",\"] )\\n   parameter      ::= identifier [\":\" expression]\\n   defparameter   ::= parameter [\"=\" expression]\\n   funcname       ::= identifier\\n\\nA function definition is an executable statement.  Its execution binds\\nthe function name in the current local namespace to a function object\\n(a wrapper around the executable code for the function).  This\\nfunction object contains a reference to the current global namespace\\nas the global namespace to be used when the function is called.\\n\\nThe function definition does not execute the function body; this gets\\nexecuted only when the function is called. [3]\\n\\nA function definition may be wrapped by one or more *decorator*\\nexpressions. Decorator expressions are evaluated when the function is\\ndefined, in the scope that contains the function definition.  The\\nresult must be a callable, which is invoked with the function object\\nas the only argument. The returned value is bound to the function name\\ninstead of the function object.  Multiple decorators are applied in\\nnested fashion. For example, the following code\\n\\n   @f1(arg)\\n   @f2\\n   def func(): pass\\n\\nis equivalent to\\n\\n   def func(): pass\\n   func = f1(arg)(f2(func))\\n\\nWhen one or more *parameters* have the form *parameter* ``=``\\n*expression*, the function is said to have \"default parameter values.\"\\nFor a parameter with a default value, the corresponding *argument* may\\nbe omitted from a call, in which case the parameter\\'s default value is\\nsubstituted.  If a parameter has a default value, all following\\nparameters up until the \"``*``\" must also have a default value ---\\nthis is a syntactic restriction that is not expressed by the grammar.\\n\\n**Default parameter values are evaluated when the function definition\\nis executed.** This means that the expression is evaluated once, when\\nthe function is defined, and that the same \"pre-computed\" value is\\nused for each call.  This is especially important to understand when a\\ndefault parameter is a mutable object, such as a list or a dictionary:\\nif the function modifies the object (e.g. by appending an item to a\\nlist), the default value is in effect modified. This is generally not\\nwhat was intended.  A way around this is to use ``None`` as the\\ndefault, and explicitly test for it in the body of the function, e.g.:\\n\\n   def whats_on_the_telly(penguin=None):\\n       if penguin is None:\\n           penguin = []\\n       penguin.append(\"property of the zoo\")\\n       return penguin\\n\\nFunction call semantics are described in more detail in section\\n*Calls*. A function call always assigns values to all parameters\\nmentioned in the parameter list, either from position arguments, from\\nkeyword arguments, or from default values.  If the form\\n\"``*identifier``\" is present, it is initialized to a tuple receiving\\nany excess positional parameters, defaulting to the empty tuple.  If\\nthe form \"``**identifier``\" is present, it is initialized to a new\\ndictionary receiving any excess keyword arguments, defaulting to a new\\nempty dictionary. Parameters after \"``*``\" or \"``*identifier``\" are\\nkeyword-only parameters and may only be passed used keyword arguments.\\n\\nParameters may have annotations of the form \"``: expression``\"\\nfollowing the parameter name.  Any parameter may have an annotation\\neven those of the form ``*identifier`` or ``**identifier``.  Functions\\nmay have \"return\" annotation of the form \"``-> expression``\" after the\\nparameter list.  These annotations can be any valid Python expression\\nand are evaluated when the function definition is executed.\\nAnnotations may be evaluated in a different order than they appear in\\nthe source code.  The presence of annotations does not change the\\nsemantics of a function.  The annotation values are available as\\nvalues of a dictionary keyed by the parameters\\' names in the\\n``__annotations__`` attribute of the function object.\\n\\nIt is also possible to create anonymous functions (functions not bound\\nto a name), for immediate use in expressions.  This uses lambda forms,\\ndescribed in section *Lambdas*.  Note that the lambda form is merely a\\nshorthand for a simplified function definition; a function defined in\\na \"``def``\" statement can be passed around or assigned to another name\\njust like a function defined by a lambda form.  The \"``def``\" form is\\nactually more powerful since it allows the execution of multiple\\nstatements and annotations.\\n\\n**Programmer\\'s note:** Functions are first-class objects.  A \"``def``\"\\nform executed inside a function definition defines a local function\\nthat can be returned or passed around.  Free variables used in the\\nnested function can access the local variables of the function\\ncontaining the def.  See section *Naming and binding* for details.\\n\\nSee also:\\n\\n   **PEP 3107** - Function Annotations\\n      The original specification for function annotations.\\n\\n\\nClass definitions\\n=================\\n\\nA class definition defines a class object (see section *The standard\\ntype hierarchy*):\\n\\n   classdef    ::= [decorators] \"class\" classname [inheritance] \":\" suite\\n   inheritance ::= \"(\" [parameter_list] \")\"\\n   classname   ::= identifier\\n\\nA class definition is an executable statement.  The inheritance list\\nusually gives a list of base classes (see *Customizing class creation*\\nfor more advanced uses), so each item in the list should evaluate to a\\nclass object which allows subclassing.  Classes without an inheritance\\nlist inherit, by default, from the base class ``object``; hence,\\n\\n   class Foo:\\n       pass\\n\\nis equivalent to\\n\\n   class Foo(object):\\n       pass\\n\\nThe class\\'s suite is then executed in a new execution frame (see\\n*Naming and binding*), using a newly created local namespace and the\\noriginal global namespace. (Usually, the suite contains mostly\\nfunction definitions.)  When the class\\'s suite finishes execution, its\\nexecution frame is discarded but its local namespace is saved. [4] A\\nclass object is then created using the inheritance list for the base\\nclasses and the saved local namespace for the attribute dictionary.\\nThe class name is bound to this class object in the original local\\nnamespace.\\n\\nClass creation can be customized heavily using *metaclasses*.\\n\\nClasses can also be decorated: just like when decorating functions,\\n\\n   @f1(arg)\\n   @f2\\n   class Foo: pass\\n\\nis equivalent to\\n\\n   class Foo: pass\\n   Foo = f1(arg)(f2(Foo))\\n\\nThe evaluation rules for the decorator expressions are the same as for\\nfunction decorators.  The result must be a class object, which is then\\nbound to the class name.\\n\\n**Programmer\\'s note:** Variables defined in the class definition are\\nclass attributes; they are shared by instances.  Instance attributes\\ncan be set in a method with ``self.name = value``.  Both class and\\ninstance attributes are accessible through the notation\\n\"``self.name``\", and an instance attribute hides a class attribute\\nwith the same name when accessed in this way.  Class attributes can be\\nused as defaults for instance attributes, but using mutable values\\nthere can lead to unexpected results.  *Descriptors* can be used to\\ncreate instance variables with different implementation details.\\n\\nSee also:\\n\\n   **PEP 3115** - Metaclasses in Python 3 **PEP 3129** - Class\\n   Decorators\\n\\n-[ Footnotes ]-\\n\\n[1] The exception is propagated to the invocation stack unless there\\n    is a ``finally`` clause which happens to raise another exception.\\n    That new exception causes the old one to be lost.\\n\\n[2] Currently, control \"flows off the end\" except in the case of an\\n    exception or the execution of a ``return``, ``continue``, or\\n    ``break`` statement.\\n\\n[3] A string literal appearing as the first statement in the function\\n    body is transformed into the function\\'s ``__doc__`` attribute and\\n    therefore the function\\'s *docstring*.\\n\\n[4] A string literal appearing as the first statement in the class\\n    body is transformed into the namespace\\'s ``__doc__`` item and\\n    therefore the class\\'s *docstring*.\\n',\n'context-managers': '\\nWith Statement Context Managers\\n*******************************\\n\\nA *context manager* is an object that defines the runtime context to\\nbe established when executing a ``with`` statement. The context\\nmanager handles the entry into, and the exit from, the desired runtime\\ncontext for the execution of the block of code.  Context managers are\\nnormally invoked using the ``with`` statement (described in section\\n*The with statement*), but can also be used by directly invoking their\\nmethods.\\n\\nTypical uses of context managers include saving and restoring various\\nkinds of global state, locking and unlocking resources, closing opened\\nfiles, etc.\\n\\nFor more information on context managers, see *Context Manager Types*.\\n\\nobject.__enter__(self)\\n\\n   Enter the runtime context related to this object. The ``with``\\n   statement will bind this method\\'s return value to the target(s)\\n   specified in the ``as`` clause of the statement, if any.\\n\\nobject.__exit__(self, exc_type, exc_value, traceback)\\n\\n   Exit the runtime context related to this object. The parameters\\n   describe the exception that caused the context to be exited. If the\\n   context was exited without an exception, all three arguments will\\n   be ``None``.\\n\\n   If an exception is supplied, and the method wishes to suppress the\\n   exception (i.e., prevent it from being propagated), it should\\n   return a true value. Otherwise, the exception will be processed\\n   normally upon exit from this method.\\n\\n   Note that ``__exit__()`` methods should not reraise the passed-in\\n   exception; this is the caller\\'s responsibility.\\n\\nSee also:\\n\\n   **PEP 0343** - The \"with\" statement\\n      The specification, background, and examples for the Python\\n      ``with`` statement.\\n',\n'continue': '\\nThe ``continue`` statement\\n**************************\\n\\n   continue_stmt ::= \"continue\"\\n\\n``continue`` may only occur syntactically nested in a ``for`` or\\n``while`` loop, but not nested in a function or class definition or\\n``finally`` clause within that loop.  It continues with the next cycle\\nof the nearest enclosing loop.\\n\\nWhen ``continue`` passes control out of a ``try`` statement with a\\n``finally`` clause, that ``finally`` clause is executed before really\\nstarting the next loop cycle.\\n',\n'conversions': '\\nArithmetic conversions\\n**********************\\n\\nWhen a description of an arithmetic operator below uses the phrase\\n\"the numeric arguments are converted to a common type,\" this means\\nthat the operator implementation for built-in types works that way:\\n\\n* If either argument is a complex number, the other is converted to\\n  complex;\\n\\n* otherwise, if either argument is a floating point number, the other\\n  is converted to floating point;\\n\\n* otherwise, both must be integers and no conversion is necessary.\\n\\nSome additional rules apply for certain operators (e.g., a string left\\nargument to the \\'%\\' operator).  Extensions must define their own\\nconversion behavior.\\n',\n'customization': '\\nBasic customization\\n*******************\\n\\nobject.__new__(cls[, ...])\\n\\n   Called to create a new instance of class *cls*.  ``__new__()`` is a\\n   static method (special-cased so you need not declare it as such)\\n   that takes the class of which an instance was requested as its\\n   first argument.  The remaining arguments are those passed to the\\n   object constructor expression (the call to the class).  The return\\n   value of ``__new__()`` should be the new object instance (usually\\n   an instance of *cls*).\\n\\n   Typical implementations create a new instance of the class by\\n   invoking the superclass\\'s ``__new__()`` method using\\n   ``super(currentclass, cls).__new__(cls[, ...])`` with appropriate\\n   arguments and then modifying the newly-created instance as\\n   necessary before returning it.\\n\\n   If ``__new__()`` returns an instance of *cls*, then the new\\n   instance\\'s ``__init__()`` method will be invoked like\\n   ``__init__(self[, ...])``, where *self* is the new instance and the\\n   remaining arguments are the same as were passed to ``__new__()``.\\n\\n   If ``__new__()`` does not return an instance of *cls*, then the new\\n   instance\\'s ``__init__()`` method will not be invoked.\\n\\n   ``__new__()`` is intended mainly to allow subclasses of immutable\\n   types (like int, str, or tuple) to customize instance creation.  It\\n   is also commonly overridden in custom metaclasses in order to\\n   customize class creation.\\n\\nobject.__init__(self[, ...])\\n\\n   Called when the instance is created.  The arguments are those\\n   passed to the class constructor expression.  If a base class has an\\n   ``__init__()`` method, the derived class\\'s ``__init__()`` method,\\n   if any, must explicitly call it to ensure proper initialization of\\n   the base class part of the instance; for example:\\n   ``BaseClass.__init__(self, [args...])``.  As a special constraint\\n   on constructors, no value may be returned; doing so will cause a\\n   ``TypeError`` to be raised at runtime.\\n\\nobject.__del__(self)\\n\\n   Called when the instance is about to be destroyed.  This is also\\n   called a destructor.  If a base class has a ``__del__()`` method,\\n   the derived class\\'s ``__del__()`` method, if any, must explicitly\\n   call it to ensure proper deletion of the base class part of the\\n   instance.  Note that it is possible (though not recommended!) for\\n   the ``__del__()`` method to postpone destruction of the instance by\\n   creating a new reference to it.  It may then be called at a later\\n   time when this new reference is deleted.  It is not guaranteed that\\n   ``__del__()`` methods are called for objects that still exist when\\n   the interpreter exits.\\n\\n   Note: ``del x`` doesn\\'t directly call ``x.__del__()`` --- the former\\n     decrements the reference count for ``x`` by one, and the latter\\n     is only called when ``x``\\'s reference count reaches zero.  Some\\n     common situations that may prevent the reference count of an\\n     object from going to zero include: circular references between\\n     objects (e.g., a doubly-linked list or a tree data structure with\\n     parent and child pointers); a reference to the object on the\\n     stack frame of a function that caught an exception (the traceback\\n     stored in ``sys.exc_info()[2]`` keeps the stack frame alive); or\\n     a reference to the object on the stack frame that raised an\\n     unhandled exception in interactive mode (the traceback stored in\\n     ``sys.last_traceback`` keeps the stack frame alive).  The first\\n     situation can only be remedied by explicitly breaking the cycles;\\n     the latter two situations can be resolved by storing ``None`` in\\n     ``sys.last_traceback``. Circular references which are garbage are\\n     detected when the option cycle detector is enabled (it\\'s on by\\n     default), but can only be cleaned up if there are no Python-\\n     level ``__del__()`` methods involved. Refer to the documentation\\n     for the ``gc`` module for more information about how\\n     ``__del__()`` methods are handled by the cycle detector,\\n     particularly the description of the ``garbage`` value.\\n\\n   Warning: Due to the precarious circumstances under which ``__del__()``\\n     methods are invoked, exceptions that occur during their execution\\n     are ignored, and a warning is printed to ``sys.stderr`` instead.\\n     Also, when ``__del__()`` is invoked in response to a module being\\n     deleted (e.g., when execution of the program is done), other\\n     globals referenced by the ``__del__()`` method may already have\\n     been deleted or in the process of being torn down (e.g. the\\n     import machinery shutting down).  For this reason, ``__del__()``\\n     methods should do the absolute minimum needed to maintain\\n     external invariants.  Starting with version 1.5, Python\\n     guarantees that globals whose name begins with a single\\n     underscore are deleted from their module before other globals are\\n     deleted; if no other references to such globals exist, this may\\n     help in assuring that imported modules are still available at the\\n     time when the ``__del__()`` method is called.\\n\\nobject.__repr__(self)\\n\\n   Called by the ``repr()`` built-in function to compute the\\n   \"official\" string representation of an object.  If at all possible,\\n   this should look like a valid Python expression that could be used\\n   to recreate an object with the same value (given an appropriate\\n   environment).  If this is not possible, a string of the form\\n   ``<...some useful description...>`` should be returned. The return\\n   value must be a string object. If a class defines ``__repr__()``\\n   but not ``__str__()``, then ``__repr__()`` is also used when an\\n   \"informal\" string representation of instances of that class is\\n   required.\\n\\n   This is typically used for debugging, so it is important that the\\n   representation is information-rich and unambiguous.\\n\\nobject.__str__(self)\\n\\n   Called by ``str(object)`` and the built-in functions ``format()``\\n   and ``print()`` to compute the \"informal\" or nicely printable\\n   string representation of an object.  The return value must be a\\n   *string* object.\\n\\n   This method differs from ``object.__repr__()`` in that there is no\\n   expectation that ``__str__()`` return a valid Python expression: a\\n   more convenient or concise representation can be used.\\n\\n   The default implementation defined by the built-in type ``object``\\n   calls ``object.__repr__()``.\\n\\nobject.__bytes__(self)\\n\\n   Called by ``bytes()`` to compute a byte-string representation of an\\n   object. This should return a ``bytes`` object.\\n\\nobject.__format__(self, format_spec)\\n\\n   Called by the ``format()`` built-in function (and by extension, the\\n   ``str.format()`` method of class ``str``) to produce a \"formatted\"\\n   string representation of an object. The ``format_spec`` argument is\\n   a string that contains a description of the formatting options\\n   desired. The interpretation of the ``format_spec`` argument is up\\n   to the type implementing ``__format__()``, however most classes\\n   will either delegate formatting to one of the built-in types, or\\n   use a similar formatting option syntax.\\n\\n   See *Format Specification Mini-Language* for a description of the\\n   standard formatting syntax.\\n\\n   The return value must be a string object.\\n\\nobject.__lt__(self, other)\\nobject.__le__(self, other)\\nobject.__eq__(self, other)\\nobject.__ne__(self, other)\\nobject.__gt__(self, other)\\nobject.__ge__(self, other)\\n\\n   These are the so-called \"rich comparison\" methods. The\\n   correspondence between operator symbols and method names is as\\n   follows: ``x<y`` calls ``x.__lt__(y)``, ``x<=y`` calls\\n   ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, ``x!=y`` calls\\n   ``x.__ne__(y)``, ``x>y`` calls ``x.__gt__(y)``, and ``x>=y`` calls\\n   ``x.__ge__(y)``.\\n\\n   A rich comparison method may return the singleton\\n   ``NotImplemented`` if it does not implement the operation for a\\n   given pair of arguments. By convention, ``False`` and ``True`` are\\n   returned for a successful comparison. However, these methods can\\n   return any value, so if the comparison operator is used in a\\n   Boolean context (e.g., in the condition of an ``if`` statement),\\n   Python will call ``bool()`` on the value to determine if the result\\n   is true or false.\\n\\n   There are no implied relationships among the comparison operators.\\n   The truth of ``x==y`` does not imply that ``x!=y`` is false.\\n   Accordingly, when defining ``__eq__()``, one should also define\\n   ``__ne__()`` so that the operators will behave as expected.  See\\n   the paragraph on ``__hash__()`` for some important notes on\\n   creating *hashable* objects which support custom comparison\\n   operations and are usable as dictionary keys.\\n\\n   There are no swapped-argument versions of these methods (to be used\\n   when the left argument does not support the operation but the right\\n   argument does); rather, ``__lt__()`` and ``__gt__()`` are each\\n   other\\'s reflection, ``__le__()`` and ``__ge__()`` are each other\\'s\\n   reflection, and ``__eq__()`` and ``__ne__()`` are their own\\n   reflection.\\n\\n   Arguments to rich comparison methods are never coerced.\\n\\n   To automatically generate ordering operations from a single root\\n   operation, see ``functools.total_ordering()``.\\n\\nobject.__hash__(self)\\n\\n   Called by built-in function ``hash()`` and for operations on\\n   members of hashed collections including ``set``, ``frozenset``, and\\n   ``dict``.  ``__hash__()`` should return an integer.  The only\\n   required property is that objects which compare equal have the same\\n   hash value; it is advised to somehow mix together (e.g. using\\n   exclusive or) the hash values for the components of the object that\\n   also play a part in comparison of objects.\\n\\n   If a class does not define an ``__eq__()`` method it should not\\n   define a ``__hash__()`` operation either; if it defines\\n   ``__eq__()`` but not ``__hash__()``, its instances will not be\\n   usable as items in hashable collections.  If a class defines\\n   mutable objects and implements an ``__eq__()`` method, it should\\n   not implement ``__hash__()``, since the implementation of hashable\\n   collections requires that a key\\'s hash value is immutable (if the\\n   object\\'s hash value changes, it will be in the wrong hash bucket).\\n\\n   User-defined classes have ``__eq__()`` and ``__hash__()`` methods\\n   by default; with them, all objects compare unequal (except with\\n   themselves) and ``x.__hash__()`` returns an appropriate value such\\n   that ``x == y`` implies both that ``x is y`` and ``hash(x) ==\\n   hash(y)``.\\n\\n   A class that overrides ``__eq__()`` and does not define\\n   ``__hash__()`` will have its ``__hash__()`` implicitly set to\\n   ``None``.  When the ``__hash__()`` method of a class is ``None``,\\n   instances of the class will raise an appropriate ``TypeError`` when\\n   a program attempts to retrieve their hash value, and will also be\\n   correctly identified as unhashable when checking ``isinstance(obj,\\n   collections.Hashable``).\\n\\n   If a class that overrides ``__eq__()`` needs to retain the\\n   implementation of ``__hash__()`` from a parent class, the\\n   interpreter must be told this explicitly by setting ``__hash__ =\\n   <ParentClass>.__hash__``.\\n\\n   If a class that does not override ``__eq__()`` wishes to suppress\\n   hash support, it should include ``__hash__ = None`` in the class\\n   definition. A class which defines its own ``__hash__()`` that\\n   explicitly raises a ``TypeError`` would be incorrectly identified\\n   as hashable by an ``isinstance(obj, collections.Hashable)`` call.\\n\\n   Note: By default, the ``__hash__()`` values of str, bytes and datetime\\n     objects are \"salted\" with an unpredictable random value.\\n     Although they remain constant within an individual Python\\n     process, they are not predictable between repeated invocations of\\n     Python.This is intended to provide protection against a denial-\\n     of-service caused by carefully-chosen inputs that exploit the\\n     worst case performance of a dict insertion, O(n^2) complexity.\\n     See http://www.ocert.org/advisories/ocert-2011-003.html for\\n     details.Changing hash values affects the iteration order of\\n     dicts, sets and other mappings.  Python has never made guarantees\\n     about this ordering (and it typically varies between 32-bit and\\n     64-bit builds).See also ``PYTHONHASHSEED``.\\n\\n   Changed in version 3.3: Hash randomization is enabled by default.\\n\\nobject.__bool__(self)\\n\\n   Called to implement truth value testing and the built-in operation\\n   ``bool()``; should return ``False`` or ``True``.  When this method\\n   is not defined, ``__len__()`` is called, if it is defined, and the\\n   object is considered true if its result is nonzero.  If a class\\n   defines neither ``__len__()`` nor ``__bool__()``, all its instances\\n   are considered true.\\n',\n'debugger': '\\n``pdb`` --- The Python Debugger\\n*******************************\\n\\nThe module ``pdb`` defines an interactive source code debugger for\\nPython programs.  It supports setting (conditional) breakpoints and\\nsingle stepping at the source line level, inspection of stack frames,\\nsource code listing, and evaluation of arbitrary Python code in the\\ncontext of any stack frame.  It also supports post-mortem debugging\\nand can be called under program control.\\n\\nThe debugger is extensible -- it is actually defined as the class\\n``Pdb``. This is currently undocumented but easily understood by\\nreading the source.  The extension interface uses the modules ``bdb``\\nand ``cmd``.\\n\\nThe debugger\\'s prompt is ``(Pdb)``. Typical usage to run a program\\nunder control of the debugger is:\\n\\n   >>> import pdb\\n   >>> import mymodule\\n   >>> pdb.run(\\'mymodule.test()\\')\\n   > <string>(0)?()\\n   (Pdb) continue\\n   > <string>(1)?()\\n   (Pdb) continue\\n   NameError: \\'spam\\'\\n   > <string>(1)?()\\n   (Pdb)\\n\\nChanged in version 3.3: Tab-completion via the ``readline`` module is\\navailable for commands and command arguments, e.g. the current global\\nand local names are offered as arguments of the ``print`` command.\\n\\n``pdb.py`` can also be invoked as a script to debug other scripts.\\nFor example:\\n\\n   python3 -m pdb myscript.py\\n\\nWhen invoked as a script, pdb will automatically enter post-mortem\\ndebugging if the program being debugged exits abnormally.  After post-\\nmortem debugging (or after normal exit of the program), pdb will\\nrestart the program.  Automatic restarting preserves pdb\\'s state (such\\nas breakpoints) and in most cases is more useful than quitting the\\ndebugger upon program\\'s exit.\\n\\nNew in version 3.2: ``pdb.py`` now accepts a ``-c`` option that\\nexecutes commands as if given in a ``.pdbrc`` file, see *Debugger\\nCommands*.\\n\\nThe typical usage to break into the debugger from a running program is\\nto insert\\n\\n   import pdb; pdb.set_trace()\\n\\nat the location you want to break into the debugger.  You can then\\nstep through the code following this statement, and continue running\\nwithout the debugger using the ``continue`` command.\\n\\nThe typical usage to inspect a crashed program is:\\n\\n   >>> import pdb\\n   >>> import mymodule\\n   >>> mymodule.test()\\n   Traceback (most recent call last):\\n     File \"<stdin>\", line 1, in ?\\n     File \"./mymodule.py\", line 4, in test\\n       test2()\\n     File \"./mymodule.py\", line 3, in test2\\n       print(spam)\\n   NameError: spam\\n   >>> pdb.pm()\\n   > ./mymodule.py(3)test2()\\n   -> print(spam)\\n   (Pdb)\\n\\nThe module defines the following functions; each enters the debugger\\nin a slightly different way:\\n\\npdb.run(statement, globals=None, locals=None)\\n\\n   Execute the *statement* (given as a string or a code object) under\\n   debugger control.  The debugger prompt appears before any code is\\n   executed; you can set breakpoints and type ``continue``, or you can\\n   step through the statement using ``step`` or ``next`` (all these\\n   commands are explained below).  The optional *globals* and *locals*\\n   arguments specify the environment in which the code is executed; by\\n   default the dictionary of the module ``__main__`` is used.  (See\\n   the explanation of the built-in ``exec()`` or ``eval()``\\n   functions.)\\n\\npdb.runeval(expression, globals=None, locals=None)\\n\\n   Evaluate the *expression* (given as a string or a code object)\\n   under debugger control.  When ``runeval()`` returns, it returns the\\n   value of the expression.  Otherwise this function is similar to\\n   ``run()``.\\n\\npdb.runcall(function, *args, **kwds)\\n\\n   Call the *function* (a function or method object, not a string)\\n   with the given arguments.  When ``runcall()`` returns, it returns\\n   whatever the function call returned.  The debugger prompt appears\\n   as soon as the function is entered.\\n\\npdb.set_trace()\\n\\n   Enter the debugger at the calling stack frame.  This is useful to\\n   hard-code a breakpoint at a given point in a program, even if the\\n   code is not otherwise being debugged (e.g. when an assertion\\n   fails).\\n\\npdb.post_mortem(traceback=None)\\n\\n   Enter post-mortem debugging of the given *traceback* object.  If no\\n   *traceback* is given, it uses the one of the exception that is\\n   currently being handled (an exception must be being handled if the\\n   default is to be used).\\n\\npdb.pm()\\n\\n   Enter post-mortem debugging of the traceback found in\\n   ``sys.last_traceback``.\\n\\nThe ``run*`` functions and ``set_trace()`` are aliases for\\ninstantiating the ``Pdb`` class and calling the method of the same\\nname.  If you want to access further features, you have to do this\\nyourself:\\n\\nclass class pdb.Pdb(completekey=\\'tab\\', stdin=None, stdout=None, skip=None, nosigint=False)\\n\\n   ``Pdb`` is the debugger class.\\n\\n   The *completekey*, *stdin* and *stdout* arguments are passed to the\\n   underlying ``cmd.Cmd`` class; see the description there.\\n\\n   The *skip* argument, if given, must be an iterable of glob-style\\n   module name patterns.  The debugger will not step into frames that\\n   originate in a module that matches one of these patterns. [1]\\n\\n   By default, Pdb sets a handler for the SIGINT signal (which is sent\\n   when the user presses Ctrl-C on the console) when you give a\\n   ``continue`` command. This allows you to break into the debugger\\n   again by pressing Ctrl-C.  If you want Pdb not to touch the SIGINT\\n   handler, set *nosigint* tot true.\\n\\n   Example call to enable tracing with *skip*:\\n\\n      import pdb; pdb.Pdb(skip=[\\'django.*\\']).set_trace()\\n\\n   New in version 3.1: The *skip* argument.\\n\\n   New in version 3.2: The *nosigint* argument.  Previously, a SIGINT\\n   handler was never set by Pdb.\\n\\n   run(statement, globals=None, locals=None)\\n   runeval(expression, globals=None, locals=None)\\n   runcall(function, *args, **kwds)\\n   set_trace()\\n\\n      See the documentation for the functions explained above.\\n\\n\\nDebugger Commands\\n=================\\n\\nThe commands recognized by the debugger are listed below.  Most\\ncommands can be abbreviated to one or two letters as indicated; e.g.\\n``h(elp)`` means that either ``h`` or ``help`` can be used to enter\\nthe help command (but not ``he`` or ``hel``, nor ``H`` or ``Help`` or\\n``HELP``).  Arguments to commands must be separated by whitespace\\n(spaces or tabs).  Optional arguments are enclosed in square brackets\\n(``[]``) in the command syntax; the square brackets must not be typed.\\nAlternatives in the command syntax are separated by a vertical bar\\n(``|``).\\n\\nEntering a blank line repeats the last command entered.  Exception: if\\nthe last command was a ``list`` command, the next 11 lines are listed.\\n\\nCommands that the debugger doesn\\'t recognize are assumed to be Python\\nstatements and are executed in the context of the program being\\ndebugged.  Python statements can also be prefixed with an exclamation\\npoint (``!``).  This is a powerful way to inspect the program being\\ndebugged; it is even possible to change a variable or call a function.\\nWhen an exception occurs in such a statement, the exception name is\\nprinted but the debugger\\'s state is not changed.\\n\\nThe debugger supports *aliases*.  Aliases can have parameters which\\nallows one a certain level of adaptability to the context under\\nexamination.\\n\\nMultiple commands may be entered on a single line, separated by\\n``;;``.  (A single ``;`` is not used as it is the separator for\\nmultiple commands in a line that is passed to the Python parser.)  No\\nintelligence is applied to separating the commands; the input is split\\nat the first ``;;`` pair, even if it is in the middle of a quoted\\nstring.\\n\\nIf a file ``.pdbrc`` exists in the user\\'s home directory or in the\\ncurrent directory, it is read in and executed as if it had been typed\\nat the debugger prompt.  This is particularly useful for aliases.  If\\nboth files exist, the one in the home directory is read first and\\naliases defined there can be overridden by the local file.\\n\\nChanged in version 3.2: ``.pdbrc`` can now contain commands that\\ncontinue debugging, such as ``continue`` or ``next``.  Previously,\\nthese commands had no effect.\\n\\nh(elp) [command]\\n\\n   Without argument, print the list of available commands.  With a\\n   *command* as argument, print help about that command.  ``help pdb``\\n   displays the full documentation (the docstring of the ``pdb``\\n   module).  Since the *command* argument must be an identifier,\\n   ``help exec`` must be entered to get help on the ``!`` command.\\n\\nw(here)\\n\\n   Print a stack trace, with the most recent frame at the bottom.  An\\n   arrow indicates the current frame, which determines the context of\\n   most commands.\\n\\nd(own) [count]\\n\\n   Move the current frame *count* (default one) levels down in the\\n   stack trace (to a newer frame).\\n\\nu(p) [count]\\n\\n   Move the current frame *count* (default one) levels up in the stack\\n   trace (to an older frame).\\n\\nb(reak) [([filename:]lineno | function) [, condition]]\\n\\n   With a *lineno* argument, set a break there in the current file.\\n   With a *function* argument, set a break at the first executable\\n   statement within that function.  The line number may be prefixed\\n   with a filename and a colon, to specify a breakpoint in another\\n   file (probably one that hasn\\'t been loaded yet).  The file is\\n   searched on ``sys.path``.  Note that each breakpoint is assigned a\\n   number to which all the other breakpoint commands refer.\\n\\n   If a second argument is present, it is an expression which must\\n   evaluate to true before the breakpoint is honored.\\n\\n   Without argument, list all breaks, including for each breakpoint,\\n   the number of times that breakpoint has been hit, the current\\n   ignore count, and the associated condition if any.\\n\\ntbreak [([filename:]lineno | function) [, condition]]\\n\\n   Temporary breakpoint, which is removed automatically when it is\\n   first hit. The arguments are the same as for ``break``.\\n\\ncl(ear) [filename:lineno | bpnumber [bpnumber ...]]\\n\\n   With a *filename:lineno* argument, clear all the breakpoints at\\n   this line. With a space separated list of breakpoint numbers, clear\\n   those breakpoints. Without argument, clear all breaks (but first\\n   ask confirmation).\\n\\ndisable [bpnumber [bpnumber ...]]\\n\\n   Disable the breakpoints given as a space separated list of\\n   breakpoint numbers.  Disabling a breakpoint means it cannot cause\\n   the program to stop execution, but unlike clearing a breakpoint, it\\n   remains in the list of breakpoints and can be (re-)enabled.\\n\\nenable [bpnumber [bpnumber ...]]\\n\\n   Enable the breakpoints specified.\\n\\nignore bpnumber [count]\\n\\n   Set the ignore count for the given breakpoint number.  If count is\\n   omitted, the ignore count is set to 0.  A breakpoint becomes active\\n   when the ignore count is zero.  When non-zero, the count is\\n   decremented each time the breakpoint is reached and the breakpoint\\n   is not disabled and any associated condition evaluates to true.\\n\\ncondition bpnumber [condition]\\n\\n   Set a new *condition* for the breakpoint, an expression which must\\n   evaluate to true before the breakpoint is honored.  If *condition*\\n   is absent, any existing condition is removed; i.e., the breakpoint\\n   is made unconditional.\\n\\ncommands [bpnumber]\\n\\n   Specify a list of commands for breakpoint number *bpnumber*.  The\\n   commands themselves appear on the following lines.  Type a line\\n   containing just ``end`` to terminate the commands. An example:\\n\\n      (Pdb) commands 1\\n      (com) print some_variable\\n      (com) end\\n      (Pdb)\\n\\n   To remove all commands from a breakpoint, type commands and follow\\n   it immediately with ``end``; that is, give no commands.\\n\\n   With no *bpnumber* argument, commands refers to the last breakpoint\\n   set.\\n\\n   You can use breakpoint commands to start your program up again.\\n   Simply use the continue command, or step, or any other command that\\n   resumes execution.\\n\\n   Specifying any command resuming execution (currently continue,\\n   step, next, return, jump, quit and their abbreviations) terminates\\n   the command list (as if that command was immediately followed by\\n   end). This is because any time you resume execution (even with a\\n   simple next or step), you may encounter another breakpoint--which\\n   could have its own command list, leading to ambiguities about which\\n   list to execute.\\n\\n   If you use the \\'silent\\' command in the command list, the usual\\n   message about stopping at a breakpoint is not printed.  This may be\\n   desirable for breakpoints that are to print a specific message and\\n   then continue.  If none of the other commands print anything, you\\n   see no sign that the breakpoint was reached.\\n\\ns(tep)\\n\\n   Execute the current line, stop at the first possible occasion\\n   (either in a function that is called or on the next line in the\\n   current function).\\n\\nn(ext)\\n\\n   Continue execution until the next line in the current function is\\n   reached or it returns.  (The difference between ``next`` and\\n   ``step`` is that ``step`` stops inside a called function, while\\n   ``next`` executes called functions at (nearly) full speed, only\\n   stopping at the next line in the current function.)\\n\\nunt(il) [lineno]\\n\\n   Without argument, continue execution until the line with a number\\n   greater than the current one is reached.\\n\\n   With a line number, continue execution until a line with a number\\n   greater or equal to that is reached.  In both cases, also stop when\\n   the current frame returns.\\n\\n   Changed in version 3.2: Allow giving an explicit line number.\\n\\nr(eturn)\\n\\n   Continue execution until the current function returns.\\n\\nc(ont(inue))\\n\\n   Continue execution, only stop when a breakpoint is encountered.\\n\\nj(ump) lineno\\n\\n   Set the next line that will be executed.  Only available in the\\n   bottom-most frame.  This lets you jump back and execute code again,\\n   or jump forward to skip code that you don\\'t want to run.\\n\\n   It should be noted that not all jumps are allowed -- for instance\\n   it is not possible to jump into the middle of a ``for`` loop or out\\n   of a ``finally`` clause.\\n\\nl(ist) [first[, last]]\\n\\n   List source code for the current file.  Without arguments, list 11\\n   lines around the current line or continue the previous listing.\\n   With ``.`` as argument, list 11 lines around the current line.\\n   With one argument, list 11 lines around at that line.  With two\\n   arguments, list the given range; if the second argument is less\\n   than the first, it is interpreted as a count.\\n\\n   The current line in the current frame is indicated by ``->``.  If\\n   an exception is being debugged, the line where the exception was\\n   originally raised or propagated is indicated by ``>>``, if it\\n   differs from the current line.\\n\\n   New in version 3.2: The ``>>`` marker.\\n\\nll | longlist\\n\\n   List all source code for the current function or frame.\\n   Interesting lines are marked as for ``list``.\\n\\n   New in version 3.2.\\n\\na(rgs)\\n\\n   Print the argument list of the current function.\\n\\np(rint) expression\\n\\n   Evaluate the *expression* in the current context and print its\\n   value.\\n\\npp expression\\n\\n   Like the ``print`` command, except the value of the expression is\\n   pretty-printed using the ``pprint`` module.\\n\\nwhatis expression\\n\\n   Print the type of the *expression*.\\n\\nsource expression\\n\\n   Try to get source code for the given object and display it.\\n\\n   New in version 3.2.\\n\\ndisplay [expression]\\n\\n   Display the value of the expression if it changed, each time\\n   execution stops in the current frame.\\n\\n   Without expression, list all display expressions for the current\\n   frame.\\n\\n   New in version 3.2.\\n\\nundisplay [expression]\\n\\n   Do not display the expression any more in the current frame.\\n   Without expression, clear all display expressions for the current\\n   frame.\\n\\n   New in version 3.2.\\n\\ninteract\\n\\n   Start an interative interpreter (using the ``code`` module) whose\\n   global namespace contains all the (global and local) names found in\\n   the current scope.\\n\\n   New in version 3.2.\\n\\nalias [name [command]]\\n\\n   Create an alias called *name* that executes *command*.  The command\\n   must *not* be enclosed in quotes.  Replaceable parameters can be\\n   indicated by ``%1``, ``%2``, and so on, while ``%*`` is replaced by\\n   all the parameters. If no command is given, the current alias for\\n   *name* is shown. If no arguments are given, all aliases are listed.\\n\\n   Aliases may be nested and can contain anything that can be legally\\n   typed at the pdb prompt.  Note that internal pdb commands *can* be\\n   overridden by aliases.  Such a command is then hidden until the\\n   alias is removed.  Aliasing is recursively applied to the first\\n   word of the command line; all other words in the line are left\\n   alone.\\n\\n   As an example, here are two useful aliases (especially when placed\\n   in the ``.pdbrc`` file):\\n\\n      # Print instance variables (usage \"pi classInst\")\\n      alias pi for k in %1.__dict__.keys(): print(\"%1.\",k,\"=\",%1.__dict__[k])\\n      # Print instance variables in self\\n      alias ps pi self\\n\\nunalias name\\n\\n   Delete the specified alias.\\n\\n! statement\\n\\n   Execute the (one-line) *statement* in the context of the current\\n   stack frame. The exclamation point can be omitted unless the first\\n   word of the statement resembles a debugger command.  To set a\\n   global variable, you can prefix the assignment command with a\\n   ``global`` statement on the same line, e.g.:\\n\\n      (Pdb) global list_options; list_options = [\\'-l\\']\\n      (Pdb)\\n\\nrun [args ...]\\nrestart [args ...]\\n\\n   Restart the debugged Python program.  If an argument is supplied,\\n   it is split with ``shlex`` and the result is used as the new\\n   ``sys.argv``. History, breakpoints, actions and debugger options\\n   are preserved. ``restart`` is an alias for ``run``.\\n\\nq(uit)\\n\\n   Quit from the debugger.  The program being executed is aborted.\\n\\n-[ Footnotes ]-\\n\\n[1] Whether a frame is considered to originate in a certain module is\\n    determined by the ``__name__`` in the frame globals.\\n',\n'del': '\\nThe ``del`` statement\\n*********************\\n\\n   del_stmt ::= \"del\" target_list\\n\\nDeletion is recursively defined very similar to the way assignment is\\ndefined. Rather than spelling it out in full details, here are some\\nhints.\\n\\nDeletion of a target list recursively deletes each target, from left\\nto right.\\n\\nDeletion of a name removes the binding of that name from the local or\\nglobal namespace, depending on whether the name occurs in a ``global``\\nstatement in the same code block.  If the name is unbound, a\\n``NameError`` exception will be raised.\\n\\nDeletion of attribute references, subscriptions and slicings is passed\\nto the primary object involved; deletion of a slicing is in general\\nequivalent to assignment of an empty slice of the right type (but even\\nthis is determined by the sliced object).\\n\\nChanged in version 3.2: Previously it was illegal to delete a name\\nfrom the local namespace if it occurs as a free variable in a nested\\nblock.\\n',\n'dict': '\\nDictionary displays\\n*******************\\n\\nA dictionary display is a possibly empty series of key/datum pairs\\nenclosed in curly braces:\\n\\n   dict_display       ::= \"{\" [key_datum_list | dict_comprehension] \"}\"\\n   key_datum_list     ::= key_datum (\",\" key_datum)* [\",\"]\\n   key_datum          ::= expression \":\" expression\\n   dict_comprehension ::= expression \":\" expression comp_for\\n\\nA dictionary display yields a new dictionary object.\\n\\nIf a comma-separated sequence of key/datum pairs is given, they are\\nevaluated from left to right to define the entries of the dictionary:\\neach key object is used as a key into the dictionary to store the\\ncorresponding datum.  This means that you can specify the same key\\nmultiple times in the key/datum list, and the final dictionary\\'s value\\nfor that key will be the last one given.\\n\\nA dict comprehension, in contrast to list and set comprehensions,\\nneeds two expressions separated with a colon followed by the usual\\n\"for\" and \"if\" clauses. When the comprehension is run, the resulting\\nkey and value elements are inserted in the new dictionary in the order\\nthey are produced.\\n\\nRestrictions on the types of the key values are listed earlier in\\nsection *The standard type hierarchy*.  (To summarize, the key type\\nshould be *hashable*, which excludes all mutable objects.)  Clashes\\nbetween duplicate keys are not detected; the last datum (textually\\nrightmost in the display) stored for a given key value prevails.\\n',\n'dynamic-features': '\\nInteraction with dynamic features\\n*********************************\\n\\nThere are several cases where Python statements are illegal when used\\nin conjunction with nested scopes that contain free variables.\\n\\nIf a variable is referenced in an enclosing scope, it is illegal to\\ndelete the name.  An error will be reported at compile time.\\n\\nIf the wild card form of import --- ``import *`` --- is used in a\\nfunction and the function contains or is a nested block with free\\nvariables, the compiler will raise a ``SyntaxError``.\\n\\nThe ``eval()`` and ``exec()`` functions do not have access to the full\\nenvironment for resolving names.  Names may be resolved in the local\\nand global namespaces of the caller.  Free variables are not resolved\\nin the nearest enclosing namespace, but in the global namespace.  [1]\\nThe ``exec()`` and ``eval()`` functions have optional arguments to\\noverride the global and local namespace.  If only one namespace is\\nspecified, it is used for both.\\n',\n'else': '\\nThe ``if`` statement\\n********************\\n\\nThe ``if`` statement is used for conditional execution:\\n\\n   if_stmt ::= \"if\" expression \":\" suite\\n               ( \"elif\" expression \":\" suite )*\\n               [\"else\" \":\" suite]\\n\\nIt selects exactly one of the suites by evaluating the expressions one\\nby one until one is found to be true (see section *Boolean operations*\\nfor the definition of true and false); then that suite is executed\\n(and no other part of the ``if`` statement is executed or evaluated).\\nIf all expressions are false, the suite of the ``else`` clause, if\\npresent, is executed.\\n',\n'exceptions': '\\nExceptions\\n**********\\n\\nExceptions are a means of breaking out of the normal flow of control\\nof a code block in order to handle errors or other exceptional\\nconditions.  An exception is *raised* at the point where the error is\\ndetected; it may be *handled* by the surrounding code block or by any\\ncode block that directly or indirectly invoked the code block where\\nthe error occurred.\\n\\nThe Python interpreter raises an exception when it detects a run-time\\nerror (such as division by zero).  A Python program can also\\nexplicitly raise an exception with the ``raise`` statement. Exception\\nhandlers are specified with the ``try`` ... ``except`` statement.  The\\n``finally`` clause of such a statement can be used to specify cleanup\\ncode which does not handle the exception, but is executed whether an\\nexception occurred or not in the preceding code.\\n\\nPython uses the \"termination\" model of error handling: an exception\\nhandler can find out what happened and continue execution at an outer\\nlevel, but it cannot repair the cause of the error and retry the\\nfailing operation (except by re-entering the offending piece of code\\nfrom the top).\\n\\nWhen an exception is not handled at all, the interpreter terminates\\nexecution of the program, or returns to its interactive main loop.  In\\neither case, it prints a stack backtrace, except when the exception is\\n``SystemExit``.\\n\\nExceptions are identified by class instances.  The ``except`` clause\\nis selected depending on the class of the instance: it must reference\\nthe class of the instance or a base class thereof.  The instance can\\nbe received by the handler and can carry additional information about\\nthe exceptional condition.\\n\\nNote: Exception messages are not part of the Python API.  Their contents\\n  may change from one version of Python to the next without warning\\n  and should not be relied on by code which will run under multiple\\n  versions of the interpreter.\\n\\nSee also the description of the ``try`` statement in section *The try\\nstatement* and ``raise`` statement in section *The raise statement*.\\n\\n-[ Footnotes ]-\\n\\n[1] This limitation occurs because the code that is executed by these\\n    operations is not available at the time the module is compiled.\\n',\n'execmodel': '\\nExecution model\\n***************\\n\\n\\nNaming and binding\\n==================\\n\\n*Names* refer to objects.  Names are introduced by name binding\\noperations. Each occurrence of a name in the program text refers to\\nthe *binding* of that name established in the innermost function block\\ncontaining the use.\\n\\nA *block* is a piece of Python program text that is executed as a\\nunit. The following are blocks: a module, a function body, and a class\\ndefinition. Each command typed interactively is a block.  A script\\nfile (a file given as standard input to the interpreter or specified\\non the interpreter command line the first argument) is a code block.\\nA script command (a command specified on the interpreter command line\\nwith the \\'**-c**\\' option) is a code block.  The string argument passed\\nto the built-in functions ``eval()`` and ``exec()`` is a code block.\\n\\nA code block is executed in an *execution frame*.  A frame contains\\nsome administrative information (used for debugging) and determines\\nwhere and how execution continues after the code block\\'s execution has\\ncompleted.\\n\\nA *scope* defines the visibility of a name within a block.  If a local\\nvariable is defined in a block, its scope includes that block.  If the\\ndefinition occurs in a function block, the scope extends to any blocks\\ncontained within the defining one, unless a contained block introduces\\na different binding for the name.  The scope of names defined in a\\nclass block is limited to the class block; it does not extend to the\\ncode blocks of methods -- this includes comprehensions and generator\\nexpressions since they are implemented using a function scope.  This\\nmeans that the following will fail:\\n\\n   class A:\\n       a = 42\\n       b = list(a + i for i in range(10))\\n\\nWhen a name is used in a code block, it is resolved using the nearest\\nenclosing scope.  The set of all such scopes visible to a code block\\nis called the block\\'s *environment*.\\n\\nIf a name is bound in a block, it is a local variable of that block,\\nunless declared as ``nonlocal``.  If a name is bound at the module\\nlevel, it is a global variable.  (The variables of the module code\\nblock are local and global.)  If a variable is used in a code block\\nbut not defined there, it is a *free variable*.\\n\\nWhen a name is not found at all, a ``NameError`` exception is raised.\\nIf the name refers to a local variable that has not been bound, a\\n``UnboundLocalError`` exception is raised.  ``UnboundLocalError`` is a\\nsubclass of ``NameError``.\\n\\nThe following constructs bind names: formal parameters to functions,\\n``import`` statements, class and function definitions (these bind the\\nclass or function name in the defining block), and targets that are\\nidentifiers if occurring in an assignment, ``for`` loop header, or\\nafter ``as`` in a ``with`` statement or ``except`` clause. The\\n``import`` statement of the form ``from ... import *`` binds all names\\ndefined in the imported module, except those beginning with an\\nunderscore.  This form may only be used at the module level.\\n\\nA target occurring in a ``del`` statement is also considered bound for\\nthis purpose (though the actual semantics are to unbind the name).\\n\\nEach assignment or import statement occurs within a block defined by a\\nclass or function definition or at the module level (the top-level\\ncode block).\\n\\nIf a name binding operation occurs anywhere within a code block, all\\nuses of the name within the block are treated as references to the\\ncurrent block.  This can lead to errors when a name is used within a\\nblock before it is bound.  This rule is subtle.  Python lacks\\ndeclarations and allows name binding operations to occur anywhere\\nwithin a code block.  The local variables of a code block can be\\ndetermined by scanning the entire text of the block for name binding\\noperations.\\n\\nIf the ``global`` statement occurs within a block, all uses of the\\nname specified in the statement refer to the binding of that name in\\nthe top-level namespace.  Names are resolved in the top-level\\nnamespace by searching the global namespace, i.e. the namespace of the\\nmodule containing the code block, and the builtins namespace, the\\nnamespace of the module ``builtins``.  The global namespace is\\nsearched first.  If the name is not found there, the builtins\\nnamespace is searched.  The global statement must precede all uses of\\nthe name.\\n\\nThe builtins namespace associated with the execution of a code block\\nis actually found by looking up the name ``__builtins__`` in its\\nglobal namespace; this should be a dictionary or a module (in the\\nlatter case the module\\'s dictionary is used).  By default, when in the\\n``__main__`` module, ``__builtins__`` is the built-in module\\n``builtins``; when in any other module, ``__builtins__`` is an alias\\nfor the dictionary of the ``builtins`` module itself.\\n``__builtins__`` can be set to a user-created dictionary to create a\\nweak form of restricted execution.\\n\\n**CPython implementation detail:** Users should not touch\\n``__builtins__``; it is strictly an implementation detail.  Users\\nwanting to override values in the builtins namespace should ``import``\\nthe ``builtins`` module and modify its attributes appropriately.\\n\\nThe namespace for a module is automatically created the first time a\\nmodule is imported.  The main module for a script is always called\\n``__main__``.\\n\\nThe ``global`` statement has the same scope as a name binding\\noperation in the same block.  If the nearest enclosing scope for a\\nfree variable contains a global statement, the free variable is\\ntreated as a global.\\n\\nA class definition is an executable statement that may use and define\\nnames. These references follow the normal rules for name resolution.\\nThe namespace of the class definition becomes the attribute dictionary\\nof the class.  Names defined at the class scope are not visible in\\nmethods.\\n\\n\\nInteraction with dynamic features\\n---------------------------------\\n\\nThere are several cases where Python statements are illegal when used\\nin conjunction with nested scopes that contain free variables.\\n\\nIf a variable is referenced in an enclosing scope, it is illegal to\\ndelete the name.  An error will be reported at compile time.\\n\\nIf the wild card form of import --- ``import *`` --- is used in a\\nfunction and the function contains or is a nested block with free\\nvariables, the compiler will raise a ``SyntaxError``.\\n\\nThe ``eval()`` and ``exec()`` functions do not have access to the full\\nenvironment for resolving names.  Names may be resolved in the local\\nand global namespaces of the caller.  Free variables are not resolved\\nin the nearest enclosing namespace, but in the global namespace.  [1]\\nThe ``exec()`` and ``eval()`` functions have optional arguments to\\noverride the global and local namespace.  If only one namespace is\\nspecified, it is used for both.\\n\\n\\nExceptions\\n==========\\n\\nExceptions are a means of breaking out of the normal flow of control\\nof a code block in order to handle errors or other exceptional\\nconditions.  An exception is *raised* at the point where the error is\\ndetected; it may be *handled* by the surrounding code block or by any\\ncode block that directly or indirectly invoked the code block where\\nthe error occurred.\\n\\nThe Python interpreter raises an exception when it detects a run-time\\nerror (such as division by zero).  A Python program can also\\nexplicitly raise an exception with the ``raise`` statement. Exception\\nhandlers are specified with the ``try`` ... ``except`` statement.  The\\n``finally`` clause of such a statement can be used to specify cleanup\\ncode which does not handle the exception, but is executed whether an\\nexception occurred or not in the preceding code.\\n\\nPython uses the \"termination\" model of error handling: an exception\\nhandler can find out what happened and continue execution at an outer\\nlevel, but it cannot repair the cause of the error and retry the\\nfailing operation (except by re-entering the offending piece of code\\nfrom the top).\\n\\nWhen an exception is not handled at all, the interpreter terminates\\nexecution of the program, or returns to its interactive main loop.  In\\neither case, it prints a stack backtrace, except when the exception is\\n``SystemExit``.\\n\\nExceptions are identified by class instances.  The ``except`` clause\\nis selected depending on the class of the instance: it must reference\\nthe class of the instance or a base class thereof.  The instance can\\nbe received by the handler and can carry additional information about\\nthe exceptional condition.\\n\\nNote: Exception messages are not part of the Python API.  Their contents\\n  may change from one version of Python to the next without warning\\n  and should not be relied on by code which will run under multiple\\n  versions of the interpreter.\\n\\nSee also the description of the ``try`` statement in section *The try\\nstatement* and ``raise`` statement in section *The raise statement*.\\n\\n-[ Footnotes ]-\\n\\n[1] This limitation occurs because the code that is executed by these\\n    operations is not available at the time the module is compiled.\\n',\n'exprlists': '\\nExpression lists\\n****************\\n\\n   expression_list ::= expression ( \",\" expression )* [\",\"]\\n\\nAn expression list containing at least one comma yields a tuple.  The\\nlength of the tuple is the number of expressions in the list.  The\\nexpressions are evaluated from left to right.\\n\\nThe trailing comma is required only to create a single tuple (a.k.a. a\\n*singleton*); it is optional in all other cases.  A single expression\\nwithout a trailing comma doesn\\'t create a tuple, but rather yields the\\nvalue of that expression. (To create an empty tuple, use an empty pair\\nof parentheses: ``()``.)\\n',\n'floating': '\\nFloating point literals\\n***********************\\n\\nFloating point literals are described by the following lexical\\ndefinitions:\\n\\n   floatnumber   ::= pointfloat | exponentfloat\\n   pointfloat    ::= [intpart] fraction | intpart \".\"\\n   exponentfloat ::= (intpart | pointfloat) exponent\\n   intpart       ::= digit+\\n   fraction      ::= \".\" digit+\\n   exponent      ::= (\"e\" | \"E\") [\"+\" | \"-\"] digit+\\n\\nNote that the integer and exponent parts are always interpreted using\\nradix 10. For example, ``077e010`` is legal, and denotes the same\\nnumber as ``77e10``. The allowed range of floating point literals is\\nimplementation-dependent. Some examples of floating point literals:\\n\\n   3.14    10.    .001    1e100    3.14e-10    0e0\\n\\nNote that numeric literals do not include a sign; a phrase like ``-1``\\nis actually an expression composed of the unary operator ``-`` and the\\nliteral ``1``.\\n',\n'for': '\\nThe ``for`` statement\\n*********************\\n\\nThe ``for`` statement is used to iterate over the elements of a\\nsequence (such as a string, tuple or list) or other iterable object:\\n\\n   for_stmt ::= \"for\" target_list \"in\" expression_list \":\" suite\\n                [\"else\" \":\" suite]\\n\\nThe expression list is evaluated once; it should yield an iterable\\nobject.  An iterator is created for the result of the\\n``expression_list``.  The suite is then executed once for each item\\nprovided by the iterator, in the order of ascending indices.  Each\\nitem in turn is assigned to the target list using the standard rules\\nfor assignments (see *Assignment statements*), and then the suite is\\nexecuted.  When the items are exhausted (which is immediately when the\\nsequence is empty or an iterator raises a ``StopIteration``\\nexception), the suite in the ``else`` clause, if present, is executed,\\nand the loop terminates.\\n\\nA ``break`` statement executed in the first suite terminates the loop\\nwithout executing the ``else`` clause\\'s suite.  A ``continue``\\nstatement executed in the first suite skips the rest of the suite and\\ncontinues with the next item, or with the ``else`` clause if there was\\nno next item.\\n\\nThe suite may assign to the variable(s) in the target list; this does\\nnot affect the next item assigned to it.\\n\\nNames in the target list are not deleted when the loop is finished,\\nbut if the sequence is empty, it will not have been assigned to at all\\nby the loop.  Hint: the built-in function ``range()`` returns an\\niterator of integers suitable to emulate the effect of Pascal\\'s ``for\\ni := a to b do``; e.g., ``list(range(3))`` returns the list ``[0, 1,\\n2]``.\\n\\nNote: There is a subtlety when the sequence is being modified by the loop\\n  (this can only occur for mutable sequences, i.e. lists).  An\\n  internal counter is used to keep track of which item is used next,\\n  and this is incremented on each iteration.  When this counter has\\n  reached the length of the sequence the loop terminates.  This means\\n  that if the suite deletes the current (or a previous) item from the\\n  sequence, the next item will be skipped (since it gets the index of\\n  the current item which has already been treated).  Likewise, if the\\n  suite inserts an item in the sequence before the current item, the\\n  current item will be treated again the next time through the loop.\\n  This can lead to nasty bugs that can be avoided by making a\\n  temporary copy using a slice of the whole sequence, e.g.,\\n\\n     for x in a[:]:\\n         if x < 0: a.remove(x)\\n',\n'formatstrings': '\\nFormat String Syntax\\n********************\\n\\nThe ``str.format()`` method and the ``Formatter`` class share the same\\nsyntax for format strings (although in the case of ``Formatter``,\\nsubclasses can define their own format string syntax).\\n\\nFormat strings contain \"replacement fields\" surrounded by curly braces\\n``{}``. Anything that is not contained in braces is considered literal\\ntext, which is copied unchanged to the output.  If you need to include\\na brace character in the literal text, it can be escaped by doubling:\\n``{{`` and ``}}``.\\n\\nThe grammar for a replacement field is as follows:\\n\\n      replacement_field ::= \"{\" [field_name] [\"!\" conversion] [\":\" format_spec] \"}\"\\n      field_name        ::= arg_name (\".\" attribute_name | \"[\" element_index \"]\")*\\n      arg_name          ::= [identifier | integer]\\n      attribute_name    ::= identifier\\n      element_index     ::= integer | index_string\\n      index_string      ::= <any source character except \"]\"> +\\n      conversion        ::= \"r\" | \"s\" | \"a\"\\n      format_spec       ::= <described in the next section>\\n\\nIn less formal terms, the replacement field can start with a\\n*field_name* that specifies the object whose value is to be formatted\\nand inserted into the output instead of the replacement field. The\\n*field_name* is optionally followed by a  *conversion* field, which is\\npreceded by an exclamation point ``\\'!\\'``, and a *format_spec*, which\\nis preceded by a colon ``\\':\\'``.  These specify a non-default format\\nfor the replacement value.\\n\\nSee also the *Format Specification Mini-Language* section.\\n\\nThe *field_name* itself begins with an *arg_name* that is either a\\nnumber or a keyword.  If it\\'s a number, it refers to a positional\\nargument, and if it\\'s a keyword, it refers to a named keyword\\nargument.  If the numerical arg_names in a format string are 0, 1, 2,\\n... in sequence, they can all be omitted (not just some) and the\\nnumbers 0, 1, 2, ... will be automatically inserted in that order.\\nBecause *arg_name* is not quote-delimited, it is not possible to\\nspecify arbitrary dictionary keys (e.g., the strings ``\\'10\\'`` or\\n``\\':-]\\'``) within a format string. The *arg_name* can be followed by\\nany number of index or attribute expressions. An expression of the\\nform ``\\'.name\\'`` selects the named attribute using ``getattr()``,\\nwhile an expression of the form ``\\'[index]\\'`` does an index lookup\\nusing ``__getitem__()``.\\n\\nChanged in version 3.1: The positional argument specifiers can be\\nomitted, so ``\\'{} {}\\'`` is equivalent to ``\\'{0} {1}\\'``.\\n\\nSome simple format string examples:\\n\\n   \"First, thou shalt count to {0}\" # References first positional argument\\n   \"Bring me a {}\"                  # Implicitly references the first positional argument\\n   \"From {} to {}\"                  # Same as \"From {0} to {1}\"\\n   \"My quest is {name}\"             # References keyword argument \\'name\\'\\n   \"Weight in tons {0.weight}\"      # \\'weight\\' attribute of first positional arg\\n   \"Units destroyed: {players[0]}\"  # First element of keyword argument \\'players\\'.\\n\\nThe *conversion* field causes a type coercion before formatting.\\nNormally, the job of formatting a value is done by the\\n``__format__()`` method of the value itself.  However, in some cases\\nit is desirable to force a type to be formatted as a string,\\noverriding its own definition of formatting.  By converting the value\\nto a string before calling ``__format__()``, the normal formatting\\nlogic is bypassed.\\n\\nThree conversion flags are currently supported: ``\\'!s\\'`` which calls\\n``str()`` on the value, ``\\'!r\\'`` which calls ``repr()`` and ``\\'!a\\'``\\nwhich calls ``ascii()``.\\n\\nSome examples:\\n\\n   \"Harold\\'s a clever {0!s}\"        # Calls str() on the argument first\\n   \"Bring out the holy {name!r}\"    # Calls repr() on the argument first\\n   \"More {!a}\"                      # Calls ascii() on the argument first\\n\\nThe *format_spec* field contains a specification of how the value\\nshould be presented, including such details as field width, alignment,\\npadding, decimal precision and so on.  Each value type can define its\\nown \"formatting mini-language\" or interpretation of the *format_spec*.\\n\\nMost built-in types support a common formatting mini-language, which\\nis described in the next section.\\n\\nA *format_spec* field can also include nested replacement fields\\nwithin it. These nested replacement fields can contain only a field\\nname; conversion flags and format specifications are not allowed.  The\\nreplacement fields within the format_spec are substituted before the\\n*format_spec* string is interpreted. This allows the formatting of a\\nvalue to be dynamically specified.\\n\\nSee the *Format examples* section for some examples.\\n\\n\\nFormat Specification Mini-Language\\n==================================\\n\\n\"Format specifications\" are used within replacement fields contained\\nwithin a format string to define how individual values are presented\\n(see *Format String Syntax*).  They can also be passed directly to the\\nbuilt-in ``format()`` function.  Each formattable type may define how\\nthe format specification is to be interpreted.\\n\\nMost built-in types implement the following options for format\\nspecifications, although some of the formatting options are only\\nsupported by the numeric types.\\n\\nA general convention is that an empty format string (``\"\"``) produces\\nthe same result as if you had called ``str()`` on the value. A non-\\nempty format string typically modifies the result.\\n\\nThe general form of a *standard format specifier* is:\\n\\n   format_spec ::= [[fill]align][sign][#][0][width][,][.precision][type]\\n   fill        ::= <a character other than \\'{\\' or \\'}\\'>\\n   align       ::= \"<\" | \">\" | \"=\" | \"^\"\\n   sign        ::= \"+\" | \"-\" | \" \"\\n   width       ::= integer\\n   precision   ::= integer\\n   type        ::= \"b\" | \"c\" | \"d\" | \"e\" | \"E\" | \"f\" | \"F\" | \"g\" | \"G\" | \"n\" | \"o\" | \"s\" | \"x\" | \"X\" | \"%\"\\n\\nThe *fill* character can be any character other than \\'{\\' or \\'}\\'.  The\\npresence of a fill character is signaled by the character following\\nit, which must be one of the alignment options.  If the second\\ncharacter of *format_spec* is not a valid alignment option, then it is\\nassumed that both the fill character and the alignment option are\\nabsent.\\n\\nThe meaning of the various alignment options is as follows:\\n\\n   +-----------+------------------------------------------------------------+\\n   | Option    | Meaning                                                    |\\n   +===========+============================================================+\\n   | ``\\'<\\'``   | Forces the field to be left-aligned within the available   |\\n   |           | space (this is the default for most objects).              |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'>\\'``   | Forces the field to be right-aligned within the available  |\\n   |           | space (this is the default for numbers).                   |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'=\\'``   | Forces the padding to be placed after the sign (if any)    |\\n   |           | but before the digits.  This is used for printing fields   |\\n   |           | in the form \\'+000000120\\'. This alignment option is only    |\\n   |           | valid for numeric types.                                   |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'^\\'``   | Forces the field to be centered within the available       |\\n   |           | space.                                                     |\\n   +-----------+------------------------------------------------------------+\\n\\nNote that unless a minimum field width is defined, the field width\\nwill always be the same size as the data to fill it, so that the\\nalignment option has no meaning in this case.\\n\\nThe *sign* option is only valid for number types, and can be one of\\nthe following:\\n\\n   +-----------+------------------------------------------------------------+\\n   | Option    | Meaning                                                    |\\n   +===========+============================================================+\\n   | ``\\'+\\'``   | indicates that a sign should be used for both positive as  |\\n   |           | well as negative numbers.                                  |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'-\\'``   | indicates that a sign should be used only for negative     |\\n   |           | numbers (this is the default behavior).                    |\\n   +-----------+------------------------------------------------------------+\\n   | space     | indicates that a leading space should be used on positive  |\\n   |           | numbers, and a minus sign on negative numbers.             |\\n   +-----------+------------------------------------------------------------+\\n\\nThe ``\\'#\\'`` option causes the \"alternate form\" to be used for the\\nconversion.  The alternate form is defined differently for different\\ntypes.  This option is only valid for integer, float, complex and\\nDecimal types. For integers, when binary, octal, or hexadecimal output\\nis used, this option adds the prefix respective ``\\'0b\\'``, ``\\'0o\\'``, or\\n``\\'0x\\'`` to the output value. For floats, complex and Decimal the\\nalternate form causes the result of the conversion to always contain a\\ndecimal-point character, even if no digits follow it. Normally, a\\ndecimal-point character appears in the result of these conversions\\nonly if a digit follows it. In addition, for ``\\'g\\'`` and ``\\'G\\'``\\nconversions, trailing zeros are not removed from the result.\\n\\nThe ``\\',\\'`` option signals the use of a comma for a thousands\\nseparator. For a locale aware separator, use the ``\\'n\\'`` integer\\npresentation type instead.\\n\\nChanged in version 3.1: Added the ``\\',\\'`` option (see also **PEP\\n378**).\\n\\n*width* is a decimal integer defining the minimum field width.  If not\\nspecified, then the field width will be determined by the content.\\n\\nPreceding the *width* field by a zero (``\\'0\\'``) character enables\\nsign-aware zero-padding for numeric types.  This is equivalent to a\\n*fill* character of ``\\'0\\'`` with an *alignment* type of ``\\'=\\'``.\\n\\nThe *precision* is a decimal number indicating how many digits should\\nbe displayed after the decimal point for a floating point value\\nformatted with ``\\'f\\'`` and ``\\'F\\'``, or before and after the decimal\\npoint for a floating point value formatted with ``\\'g\\'`` or ``\\'G\\'``.\\nFor non-number types the field indicates the maximum field size - in\\nother words, how many characters will be used from the field content.\\nThe *precision* is not allowed for integer values.\\n\\nFinally, the *type* determines how the data should be presented.\\n\\nThe available string presentation types are:\\n\\n   +-----------+------------------------------------------------------------+\\n   | Type      | Meaning                                                    |\\n   +===========+============================================================+\\n   | ``\\'s\\'``   | String format. This is the default type for strings and    |\\n   |           | may be omitted.                                            |\\n   +-----------+------------------------------------------------------------+\\n   | None      | The same as ``\\'s\\'``.                                       |\\n   +-----------+------------------------------------------------------------+\\n\\nThe available integer presentation types are:\\n\\n   +-----------+------------------------------------------------------------+\\n   | Type      | Meaning                                                    |\\n   +===========+============================================================+\\n   | ``\\'b\\'``   | Binary format. Outputs the number in base 2.               |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'c\\'``   | Character. Converts the integer to the corresponding       |\\n   |           | unicode character before printing.                         |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'d\\'``   | Decimal Integer. Outputs the number in base 10.            |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'o\\'``   | Octal format. Outputs the number in base 8.                |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'x\\'``   | Hex format. Outputs the number in base 16, using lower-    |\\n   |           | case letters for the digits above 9.                       |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'X\\'``   | Hex format. Outputs the number in base 16, using upper-    |\\n   |           | case letters for the digits above 9.                       |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'n\\'``   | Number. This is the same as ``\\'d\\'``, except that it uses   |\\n   |           | the current locale setting to insert the appropriate       |\\n   |           | number separator characters.                               |\\n   +-----------+------------------------------------------------------------+\\n   | None      | The same as ``\\'d\\'``.                                       |\\n   +-----------+------------------------------------------------------------+\\n\\nIn addition to the above presentation types, integers can be formatted\\nwith the floating point presentation types listed below (except\\n``\\'n\\'`` and None). When doing so, ``float()`` is used to convert the\\ninteger to a floating point number before formatting.\\n\\nThe available presentation types for floating point and decimal values\\nare:\\n\\n   +-----------+------------------------------------------------------------+\\n   | Type      | Meaning                                                    |\\n   +===========+============================================================+\\n   | ``\\'e\\'``   | Exponent notation. Prints the number in scientific         |\\n   |           | notation using the letter \\'e\\' to indicate the exponent.    |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'E\\'``   | Exponent notation. Same as ``\\'e\\'`` except it uses an upper |\\n   |           | case \\'E\\' as the separator character.                       |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'f\\'``   | Fixed point. Displays the number as a fixed-point number.  |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'F\\'``   | Fixed point. Same as ``\\'f\\'``, but converts ``nan`` to      |\\n   |           | ``NAN`` and ``inf`` to ``INF``.                            |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'g\\'``   | General format.  For a given precision ``p >= 1``, this    |\\n   |           | rounds the number to ``p`` significant digits and then     |\\n   |           | formats the result in either fixed-point format or in      |\\n   |           | scientific notation, depending on its magnitude.  The      |\\n   |           | precise rules are as follows: suppose that the result      |\\n   |           | formatted with presentation type ``\\'e\\'`` and precision     |\\n   |           | ``p-1`` would have exponent ``exp``.  Then if ``-4 <= exp  |\\n   |           | < p``, the number is formatted with presentation type      |\\n   |           | ``\\'f\\'`` and precision ``p-1-exp``. Otherwise, the number   |\\n   |           | is formatted with presentation type ``\\'e\\'`` and precision  |\\n   |           | ``p-1``. In both cases insignificant trailing zeros are    |\\n   |           | removed from the significand, and the decimal point is     |\\n   |           | also removed if there are no remaining digits following    |\\n   |           | it.  Positive and negative infinity, positive and negative |\\n   |           | zero, and nans, are formatted as ``inf``, ``-inf``, ``0``, |\\n   |           | ``-0`` and ``nan`` respectively, regardless of the         |\\n   |           | precision.  A precision of ``0`` is treated as equivalent  |\\n   |           | to a precision of ``1``.                                   |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'G\\'``   | General format. Same as ``\\'g\\'`` except switches to ``\\'E\\'`` |\\n   |           | if the number gets too large. The representations of       |\\n   |           | infinity and NaN are uppercased, too.                      |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'n\\'``   | Number. This is the same as ``\\'g\\'``, except that it uses   |\\n   |           | the current locale setting to insert the appropriate       |\\n   |           | number separator characters.                               |\\n   +-----------+------------------------------------------------------------+\\n   | ``\\'%\\'``   | Percentage. Multiplies the number by 100 and displays in   |\\n   |           | fixed (``\\'f\\'``) format, followed by a percent sign.        |\\n   +-----------+------------------------------------------------------------+\\n   | None      | Similar to ``\\'g\\'``, except with at least one digit past    |\\n   |           | the decimal point and a default precision of 12. This is   |\\n   |           | intended to match ``str()``, except you can add the other  |\\n   |           | format modifiers.                                          |\\n   +-----------+------------------------------------------------------------+\\n\\n\\nFormat examples\\n===============\\n\\nThis section contains examples of the new format syntax and comparison\\nwith the old ``%``-formatting.\\n\\nIn most of the cases the syntax is similar to the old\\n``%``-formatting, with the addition of the ``{}`` and with ``:`` used\\ninstead of ``%``. For example, ``\\'%03.2f\\'`` can be translated to\\n``\\'{:03.2f}\\'``.\\n\\nThe new format syntax also supports new and different options, shown\\nin the follow examples.\\n\\nAccessing arguments by position:\\n\\n   >>> \\'{0}, {1}, {2}\\'.format(\\'a\\', \\'b\\', \\'c\\')\\n   \\'a, b, c\\'\\n   >>> \\'{}, {}, {}\\'.format(\\'a\\', \\'b\\', \\'c\\')  # 3.1+ only\\n   \\'a, b, c\\'\\n   >>> \\'{2}, {1}, {0}\\'.format(\\'a\\', \\'b\\', \\'c\\')\\n   \\'c, b, a\\'\\n   >>> \\'{2}, {1}, {0}\\'.format(*\\'abc\\')      # unpacking argument sequence\\n   \\'c, b, a\\'\\n   >>> \\'{0}{1}{0}\\'.format(\\'abra\\', \\'cad\\')   # arguments\\' indices can be repeated\\n   \\'abracadabra\\'\\n\\nAccessing arguments by name:\\n\\n   >>> \\'Coordinates: {latitude}, {longitude}\\'.format(latitude=\\'37.24N\\', longitude=\\'-115.81W\\')\\n   \\'Coordinates: 37.24N, -115.81W\\'\\n   >>> coord = {\\'latitude\\': \\'37.24N\\', \\'longitude\\': \\'-115.81W\\'}\\n   >>> \\'Coordinates: {latitude}, {longitude}\\'.format(**coord)\\n   \\'Coordinates: 37.24N, -115.81W\\'\\n\\nAccessing arguments\\' attributes:\\n\\n   >>> c = 3-5j\\n   >>> (\\'The complex number {0} is formed from the real part {0.real} \\'\\n   ...  \\'and the imaginary part {0.imag}.\\').format(c)\\n   \\'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.\\'\\n   >>> class Point:\\n   ...     def __init__(self, x, y):\\n   ...         self.x, self.y = x, y\\n   ...     def __str__(self):\\n   ...         return \\'Point({self.x}, {self.y})\\'.format(self=self)\\n   ...\\n   >>> str(Point(4, 2))\\n   \\'Point(4, 2)\\'\\n\\nAccessing arguments\\' items:\\n\\n   >>> coord = (3, 5)\\n   >>> \\'X: {0[0]};  Y: {0[1]}\\'.format(coord)\\n   \\'X: 3;  Y: 5\\'\\n\\nReplacing ``%s`` and ``%r``:\\n\\n   >>> \"repr() shows quotes: {!r}; str() doesn\\'t: {!s}\".format(\\'test1\\', \\'test2\\')\\n   \"repr() shows quotes: \\'test1\\'; str() doesn\\'t: test2\"\\n\\nAligning the text and specifying a width:\\n\\n   >>> \\'{:<30}\\'.format(\\'left aligned\\')\\n   \\'left aligned                  \\'\\n   >>> \\'{:>30}\\'.format(\\'right aligned\\')\\n   \\'                 right aligned\\'\\n   >>> \\'{:^30}\\'.format(\\'centered\\')\\n   \\'           centered           \\'\\n   >>> \\'{:*^30}\\'.format(\\'centered\\')  # use \\'*\\' as a fill char\\n   \\'***********centered***********\\'\\n\\nReplacing ``%+f``, ``%-f``, and ``% f`` and specifying a sign:\\n\\n   >>> \\'{:+f}; {:+f}\\'.format(3.14, -3.14)  # show it always\\n   \\'+3.140000; -3.140000\\'\\n   >>> \\'{: f}; {: f}\\'.format(3.14, -3.14)  # show a space for positive numbers\\n   \\' 3.140000; -3.140000\\'\\n   >>> \\'{:-f}; {:-f}\\'.format(3.14, -3.14)  # show only the minus -- same as \\'{:f}; {:f}\\'\\n   \\'3.140000; -3.140000\\'\\n\\nReplacing ``%x`` and ``%o`` and converting the value to different\\nbases:\\n\\n   >>> # format also supports binary numbers\\n   >>> \"int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}\".format(42)\\n   \\'int: 42;  hex: 2a;  oct: 52;  bin: 101010\\'\\n   >>> # with 0x, 0o, or 0b as prefix:\\n   >>> \"int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}\".format(42)\\n   \\'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010\\'\\n\\nUsing the comma as a thousands separator:\\n\\n   >>> \\'{:,}\\'.format(1234567890)\\n   \\'1,234,567,890\\'\\n\\nExpressing a percentage:\\n\\n   >>> points = 19\\n   >>> total = 22\\n   >>> \\'Correct answers: {:.2%}\\'.format(points/total)\\n   \\'Correct answers: 86.36%\\'\\n\\nUsing type-specific formatting:\\n\\n   >>> import datetime\\n   >>> d = datetime.datetime(2010, 7, 4, 12, 15, 58)\\n   >>> \\'{:%Y-%m-%d %H:%M:%S}\\'.format(d)\\n   \\'2010-07-04 12:15:58\\'\\n\\nNesting arguments and more complex examples:\\n\\n   >>> for align, text in zip(\\'<^>\\', [\\'left\\', \\'center\\', \\'right\\']):\\n   ...     \\'{0:{fill}{align}16}\\'.format(text, fill=align, align=align)\\n   ...\\n   \\'left<<<<<<<<<<<<\\'\\n   \\'^^^^^center^^^^^\\'\\n   \\'>>>>>>>>>>>right\\'\\n   >>>\\n   >>> octets = [192, 168, 0, 1]\\n   >>> \\'{:02X}{:02X}{:02X}{:02X}\\'.format(*octets)\\n   \\'C0A80001\\'\\n   >>> int(_, 16)\\n   3232235521\\n   >>>\\n   >>> width = 5\\n   >>> for num in range(5,12): #doctest: +NORMALIZE_WHITESPACE\\n   ...     for base in \\'dXob\\':\\n   ...         print(\\'{0:{width}{base}}\\'.format(num, base=base, width=width), end=\\' \\')\\n   ...     print()\\n   ...\\n       5     5     5   101\\n       6     6     6   110\\n       7     7     7   111\\n       8     8    10  1000\\n       9     9    11  1001\\n      10     A    12  1010\\n      11     B    13  1011\\n',\n'function': '\\nFunction definitions\\n********************\\n\\nA function definition defines a user-defined function object (see\\nsection *The standard type hierarchy*):\\n\\n   funcdef        ::= [decorators] \"def\" funcname \"(\" [parameter_list] \")\" [\"->\" expression] \":\" suite\\n   decorators     ::= decorator+\\n   decorator      ::= \"@\" dotted_name [\"(\" [parameter_list [\",\"]] \")\"] NEWLINE\\n   dotted_name    ::= identifier (\".\" identifier)*\\n   parameter_list ::= (defparameter \",\")*\\n                      ( \"*\" [parameter] (\",\" defparameter)* [\",\" \"**\" parameter]\\n                      | \"**\" parameter\\n                      | defparameter [\",\"] )\\n   parameter      ::= identifier [\":\" expression]\\n   defparameter   ::= parameter [\"=\" expression]\\n   funcname       ::= identifier\\n\\nA function definition is an executable statement.  Its execution binds\\nthe function name in the current local namespace to a function object\\n(a wrapper around the executable code for the function).  This\\nfunction object contains a reference to the current global namespace\\nas the global namespace to be used when the function is called.\\n\\nThe function definition does not execute the function body; this gets\\nexecuted only when the function is called. [3]\\n\\nA function definition may be wrapped by one or more *decorator*\\nexpressions. Decorator expressions are evaluated when the function is\\ndefined, in the scope that contains the function definition.  The\\nresult must be a callable, which is invoked with the function object\\nas the only argument. The returned value is bound to the function name\\ninstead of the function object.  Multiple decorators are applied in\\nnested fashion. For example, the following code\\n\\n   @f1(arg)\\n   @f2\\n   def func(): pass\\n\\nis equivalent to\\n\\n   def func(): pass\\n   func = f1(arg)(f2(func))\\n\\nWhen one or more *parameters* have the form *parameter* ``=``\\n*expression*, the function is said to have \"default parameter values.\"\\nFor a parameter with a default value, the corresponding *argument* may\\nbe omitted from a call, in which case the parameter\\'s default value is\\nsubstituted.  If a parameter has a default value, all following\\nparameters up until the \"``*``\" must also have a default value ---\\nthis is a syntactic restriction that is not expressed by the grammar.\\n\\n**Default parameter values are evaluated when the function definition\\nis executed.** This means that the expression is evaluated once, when\\nthe function is defined, and that the same \"pre-computed\" value is\\nused for each call.  This is especially important to understand when a\\ndefault parameter is a mutable object, such as a list or a dictionary:\\nif the function modifies the object (e.g. by appending an item to a\\nlist), the default value is in effect modified. This is generally not\\nwhat was intended.  A way around this is to use ``None`` as the\\ndefault, and explicitly test for it in the body of the function, e.g.:\\n\\n   def whats_on_the_telly(penguin=None):\\n       if penguin is None:\\n           penguin = []\\n       penguin.append(\"property of the zoo\")\\n       return penguin\\n\\nFunction call semantics are described in more detail in section\\n*Calls*. A function call always assigns values to all parameters\\nmentioned in the parameter list, either from position arguments, from\\nkeyword arguments, or from default values.  If the form\\n\"``*identifier``\" is present, it is initialized to a tuple receiving\\nany excess positional parameters, defaulting to the empty tuple.  If\\nthe form \"``**identifier``\" is present, it is initialized to a new\\ndictionary receiving any excess keyword arguments, defaulting to a new\\nempty dictionary. Parameters after \"``*``\" or \"``*identifier``\" are\\nkeyword-only parameters and may only be passed used keyword arguments.\\n\\nParameters may have annotations of the form \"``: expression``\"\\nfollowing the parameter name.  Any parameter may have an annotation\\neven those of the form ``*identifier`` or ``**identifier``.  Functions\\nmay have \"return\" annotation of the form \"``-> expression``\" after the\\nparameter list.  These annotations can be any valid Python expression\\nand are evaluated when the function definition is executed.\\nAnnotations may be evaluated in a different order than they appear in\\nthe source code.  The presence of annotations does not change the\\nsemantics of a function.  The annotation values are available as\\nvalues of a dictionary keyed by the parameters\\' names in the\\n``__annotations__`` attribute of the function object.\\n\\nIt is also possible to create anonymous functions (functions not bound\\nto a name), for immediate use in expressions.  This uses lambda forms,\\ndescribed in section *Lambdas*.  Note that the lambda form is merely a\\nshorthand for a simplified function definition; a function defined in\\na \"``def``\" statement can be passed around or assigned to another name\\njust like a function defined by a lambda form.  The \"``def``\" form is\\nactually more powerful since it allows the execution of multiple\\nstatements and annotations.\\n\\n**Programmer\\'s note:** Functions are first-class objects.  A \"``def``\"\\nform executed inside a function definition defines a local function\\nthat can be returned or passed around.  Free variables used in the\\nnested function can access the local variables of the function\\ncontaining the def.  See section *Naming and binding* for details.\\n\\nSee also:\\n\\n   **PEP 3107** - Function Annotations\\n      The original specification for function annotations.\\n',\n'global': '\\nThe ``global`` statement\\n************************\\n\\n   global_stmt ::= \"global\" identifier (\",\" identifier)*\\n\\nThe ``global`` statement is a declaration which holds for the entire\\ncurrent code block.  It means that the listed identifiers are to be\\ninterpreted as globals.  It would be impossible to assign to a global\\nvariable without ``global``, although free variables may refer to\\nglobals without being declared global.\\n\\nNames listed in a ``global`` statement must not be used in the same\\ncode block textually preceding that ``global`` statement.\\n\\nNames listed in a ``global`` statement must not be defined as formal\\nparameters or in a ``for`` loop control target, ``class`` definition,\\nfunction definition, or ``import`` statement.\\n\\n**CPython implementation detail:** The current implementation does not\\nenforce the latter two restrictions, but programs should not abuse\\nthis freedom, as future implementations may enforce them or silently\\nchange the meaning of the program.\\n\\n**Programmer\\'s note:** the ``global`` is a directive to the parser.\\nIt applies only to code parsed at the same time as the ``global``\\nstatement. In particular, a ``global`` statement contained in a string\\nor code object supplied to the built-in ``exec()`` function does not\\naffect the code block *containing* the function call, and code\\ncontained in such a string is unaffected by ``global`` statements in\\nthe code containing the function call.  The same applies to the\\n``eval()`` and ``compile()`` functions.\\n',\n'id-classes': '\\nReserved classes of identifiers\\n*******************************\\n\\nCertain classes of identifiers (besides keywords) have special\\nmeanings.  These classes are identified by the patterns of leading and\\ntrailing underscore characters:\\n\\n``_*``\\n   Not imported by ``from module import *``.  The special identifier\\n   ``_`` is used in the interactive interpreter to store the result of\\n   the last evaluation; it is stored in the ``builtins`` module.  When\\n   not in interactive mode, ``_`` has no special meaning and is not\\n   defined. See section *The import statement*.\\n\\n   Note: The name ``_`` is often used in conjunction with\\n     internationalization; refer to the documentation for the\\n     ``gettext`` module for more information on this convention.\\n\\n``__*__``\\n   System-defined names. These names are defined by the interpreter\\n   and its implementation (including the standard library).  Current\\n   system names are discussed in the *Special method names* section\\n   and elsewhere.  More will likely be defined in future versions of\\n   Python.  *Any* use of ``__*__`` names, in any context, that does\\n   not follow explicitly documented use, is subject to breakage\\n   without warning.\\n\\n``__*``\\n   Class-private names.  Names in this category, when used within the\\n   context of a class definition, are re-written to use a mangled form\\n   to help avoid name clashes between \"private\" attributes of base and\\n   derived classes. See section *Identifiers (Names)*.\\n',\n'identifiers': '\\nIdentifiers and keywords\\n************************\\n\\nIdentifiers (also referred to as *names*) are described by the\\nfollowing lexical definitions.\\n\\nThe syntax of identifiers in Python is based on the Unicode standard\\nannex UAX-31, with elaboration and changes as defined below; see also\\n**PEP 3131** for further details.\\n\\nWithin the ASCII range (U+0001..U+007F), the valid characters for\\nidentifiers are the same as in Python 2.x: the uppercase and lowercase\\nletters ``A`` through ``Z``, the underscore ``_`` and, except for the\\nfirst character, the digits ``0`` through ``9``.\\n\\nPython 3.0 introduces additional characters from outside the ASCII\\nrange (see **PEP 3131**).  For these characters, the classification\\nuses the version of the Unicode Character Database as included in the\\n``unicodedata`` module.\\n\\nIdentifiers are unlimited in length.  Case is significant.\\n\\n   identifier   ::= xid_start xid_continue*\\n   id_start     ::= <all characters in general categories Lu, Ll, Lt, Lm, Lo, Nl, the underscore, and characters with the Other_ID_Start property>\\n   id_continue  ::= <all characters in id_start, plus characters in the categories Mn, Mc, Nd, Pc and others with the Other_ID_Continue property>\\n   xid_start    ::= <all characters in id_start whose NFKC normalization is in \"id_start xid_continue*\">\\n   xid_continue ::= <all characters in id_continue whose NFKC normalization is in \"id_continue*\">\\n\\nThe Unicode category codes mentioned above stand for:\\n\\n* *Lu* - uppercase letters\\n\\n* *Ll* - lowercase letters\\n\\n* *Lt* - titlecase letters\\n\\n* *Lm* - modifier letters\\n\\n* *Lo* - other letters\\n\\n* *Nl* - letter numbers\\n\\n* *Mn* - nonspacing marks\\n\\n* *Mc* - spacing combining marks\\n\\n* *Nd* - decimal numbers\\n\\n* *Pc* - connector punctuations\\n\\n* *Other_ID_Start* - explicit list of characters in PropList.txt to\\n  support backwards compatibility\\n\\n* *Other_ID_Continue* - likewise\\n\\nAll identifiers are converted into the normal form NFKC while parsing;\\ncomparison of identifiers is based on NFKC.\\n\\nA non-normative HTML file listing all valid identifier characters for\\nUnicode 4.1 can be found at http://www.dcl.hpi.uni-\\npotsdam.de/home/loewis/table-3131.html.\\n\\n\\nKeywords\\n========\\n\\nThe following identifiers are used as reserved words, or *keywords* of\\nthe language, and cannot be used as ordinary identifiers.  They must\\nbe spelled exactly as written here:\\n\\n   False      class      finally    is         return\\n   None       continue   for        lambda     try\\n   True       def        from       nonlocal   while\\n   and        del        global     not        with\\n   as         elif       if         or         yield\\n   assert     else       import     pass\\n   break      except     in         raise\\n\\n\\nReserved classes of identifiers\\n===============================\\n\\nCertain classes of identifiers (besides keywords) have special\\nmeanings.  These classes are identified by the patterns of leading and\\ntrailing underscore characters:\\n\\n``_*``\\n   Not imported by ``from module import *``.  The special identifier\\n   ``_`` is used in the interactive interpreter to store the result of\\n   the last evaluation; it is stored in the ``builtins`` module.  When\\n   not in interactive mode, ``_`` has no special meaning and is not\\n   defined. See section *The import statement*.\\n\\n   Note: The name ``_`` is often used in conjunction with\\n     internationalization; refer to the documentation for the\\n     ``gettext`` module for more information on this convention.\\n\\n``__*__``\\n   System-defined names. These names are defined by the interpreter\\n   and its implementation (including the standard library).  Current\\n   system names are discussed in the *Special method names* section\\n   and elsewhere.  More will likely be defined in future versions of\\n   Python.  *Any* use of ``__*__`` names, in any context, that does\\n   not follow explicitly documented use, is subject to breakage\\n   without warning.\\n\\n``__*``\\n   Class-private names.  Names in this category, when used within the\\n   context of a class definition, are re-written to use a mangled form\\n   to help avoid name clashes between \"private\" attributes of base and\\n   derived classes. See section *Identifiers (Names)*.\\n',\n'if': '\\nThe ``if`` statement\\n********************\\n\\nThe ``if`` statement is used for conditional execution:\\n\\n   if_stmt ::= \"if\" expression \":\" suite\\n               ( \"elif\" expression \":\" suite )*\\n               [\"else\" \":\" suite]\\n\\nIt selects exactly one of the suites by evaluating the expressions one\\nby one until one is found to be true (see section *Boolean operations*\\nfor the definition of true and false); then that suite is executed\\n(and no other part of the ``if`` statement is executed or evaluated).\\nIf all expressions are false, the suite of the ``else`` clause, if\\npresent, is executed.\\n',\n'imaginary': '\\nImaginary literals\\n******************\\n\\nImaginary literals are described by the following lexical definitions:\\n\\n   imagnumber ::= (floatnumber | intpart) (\"j\" | \"J\")\\n\\nAn imaginary literal yields a complex number with a real part of 0.0.\\nComplex numbers are represented as a pair of floating point numbers\\nand have the same restrictions on their range.  To create a complex\\nnumber with a nonzero real part, add a floating point number to it,\\ne.g., ``(3+4j)``.  Some examples of imaginary literals:\\n\\n   3.14j   10.j    10j     .001j   1e100j  3.14e-10j\\n',\n'import': '\\nThe ``import`` statement\\n************************\\n\\n   import_stmt     ::= \"import\" module [\"as\" name] ( \",\" module [\"as\" name] )*\\n                   | \"from\" relative_module \"import\" identifier [\"as\" name]\\n                   ( \",\" identifier [\"as\" name] )*\\n                   | \"from\" relative_module \"import\" \"(\" identifier [\"as\" name]\\n                   ( \",\" identifier [\"as\" name] )* [\",\"] \")\"\\n                   | \"from\" module \"import\" \"*\"\\n   module          ::= (identifier \".\")* identifier\\n   relative_module ::= \".\"* module | \".\"+\\n   name            ::= identifier\\n\\nThe basic import statement (no ``from`` clause) is executed in two\\nsteps:\\n\\n1. find a module, loading and initializing it if necessary\\n\\n2. define a name or names in the local namespace for the scope where\\n   the ``import`` statement occurs.\\n\\nWhen the statement contains multiple clauses (separated by commas) the\\ntwo steps are carried out separately for each clause, just as though\\nthe clauses had been separated out into individiual import statements.\\n\\nThe details of the first step, finding and loading modules is\\ndescribed in greater detail in the section on the *import system*,\\nwhich also describes the various types of packages and modules that\\ncan be imported, as well as all the hooks that can be used to\\ncustomize the import system. Note that failures in this step may\\nindicate either that the module could not be located, *or* that an\\nerror occurred while initializing the module, which includes execution\\nof the module\\'s code.\\n\\nIf the requested module is retrieved successfully, it will be made\\navailable in the local namespace in one of three ways:\\n\\n* If the module name is followed by ``as``, then the name following\\n  ``as`` is bound directly to the imported module.\\n\\n* If no other name is specified, and the module being imported is a\\n  top level module, the module\\'s name is bound in the local namespace\\n  as a reference to the imported module\\n\\n* If the module being imported is *not* a top level module, then the\\n  name of the top level package that contains the module is bound in\\n  the local namespace as a reference to the top level package. The\\n  imported module must be accessed using its full qualified name\\n  rather than directly\\n\\nThe ``from`` form uses a slightly more complex process:\\n\\n1. find the module specified in the ``from`` clause loading and\\n   initializing it if necessary;\\n\\n2. for each of the identifiers specified in the ``import`` clauses:\\n\\n   1. check if the imported module has an attribute by that name\\n\\n   2. if not, attempt to import a submodule with that name and then\\n      check the imported module again for that attribute\\n\\n   3. if the attribute is not found, ``ImportError`` is raised.\\n\\n   4. otherwise, a reference to that value is bound in the local\\n      namespace, using the name in the ``as`` clause if it is present,\\n      otherwise using the attribute name\\n\\nExamples:\\n\\n   import foo                 # foo imported and bound locally\\n   import foo.bar.baz         # foo.bar.baz imported, foo bound locally\\n   import foo.bar.baz as fbb  # foo.bar.baz imported and bound as fbb\\n   from foo.bar import baz    # foo.bar.baz imported and bound as baz\\n   from foo import attr       # foo imported and foo.attr bound as attr\\n\\nIf the list of identifiers is replaced by a star (``\\'*\\'``), all public\\nnames defined in the module are bound in the local namespace for the\\nscope where the ``import`` statement occurs.\\n\\nThe *public names* defined by a module are determined by checking the\\nmodule\\'s namespace for a variable named ``__all__``; if defined, it\\nmust be a sequence of strings which are names defined or imported by\\nthat module.  The names given in ``__all__`` are all considered public\\nand are required to exist.  If ``__all__`` is not defined, the set of\\npublic names includes all names found in the module\\'s namespace which\\ndo not begin with an underscore character (``\\'_\\'``).  ``__all__``\\nshould contain the entire public API. It is intended to avoid\\naccidentally exporting items that are not part of the API (such as\\nlibrary modules which were imported and used within the module).\\n\\nThe ``from`` form with ``*`` may only occur in a module scope.\\nAttempting to use it in class or function definitions will raise a\\n``SyntaxError``.\\n\\nThe *public names* defined by a module are determined by checking the\\nmodule\\'s namespace for a variable named ``__all__``; if defined, it\\nmust be a sequence of strings which are names defined or imported by\\nthat module.  The names given in ``__all__`` are all considered public\\nand are required to exist.  If ``__all__`` is not defined, the set of\\npublic names includes all names found in the module\\'s namespace which\\ndo not begin with an underscore character (``\\'_\\'``).  ``__all__``\\nshould contain the entire public API. It is intended to avoid\\naccidentally exporting items that are not part of the API (such as\\nlibrary modules which were imported and used within the module).\\n\\nThe ``from`` form with ``*`` may only occur in a module scope.  The\\nwild card form of import --- ``import *`` --- is only allowed at the\\nmodule level. Attempting to use it in class or function definitions\\nwill raise a ``SyntaxError``.\\n\\nWhen specifying what module to import you do not have to specify the\\nabsolute name of the module. When a module or package is contained\\nwithin another package it is possible to make a relative import within\\nthe same top package without having to mention the package name. By\\nusing leading dots in the specified module or package after ``from``\\nyou can specify how high to traverse up the current package hierarchy\\nwithout specifying exact names. One leading dot means the current\\npackage where the module making the import exists. Two dots means up\\none package level. Three dots is up two levels, etc. So if you execute\\n``from . import mod`` from a module in the ``pkg`` package then you\\nwill end up importing ``pkg.mod``. If you execute ``from ..subpkg2\\nimport mod`` from within ``pkg.subpkg1`` you will import\\n``pkg.subpkg2.mod``. The specification for relative imports is\\ncontained within **PEP 328**.\\n\\n``importlib.import_module()`` is provided to support applications that\\ndetermine which modules need to be loaded dynamically.\\n\\n\\nFuture statements\\n=================\\n\\nA *future statement* is a directive to the compiler that a particular\\nmodule should be compiled using syntax or semantics that will be\\navailable in a specified future release of Python.  The future\\nstatement is intended to ease migration to future versions of Python\\nthat introduce incompatible changes to the language.  It allows use of\\nthe new features on a per-module basis before the release in which the\\nfeature becomes standard.\\n\\n   future_statement ::= \"from\" \"__future__\" \"import\" feature [\"as\" name]\\n                        (\",\" feature [\"as\" name])*\\n                        | \"from\" \"__future__\" \"import\" \"(\" feature [\"as\" name]\\n                        (\",\" feature [\"as\" name])* [\",\"] \")\"\\n   feature          ::= identifier\\n   name             ::= identifier\\n\\nA future statement must appear near the top of the module.  The only\\nlines that can appear before a future statement are:\\n\\n* the module docstring (if any),\\n\\n* comments,\\n\\n* blank lines, and\\n\\n* other future statements.\\n\\nThe features recognized by Python 3.0 are ``absolute_import``,\\n``division``, ``generators``, ``unicode_literals``,\\n``print_function``, ``nested_scopes`` and ``with_statement``.  They\\nare all redundant because they are always enabled, and only kept for\\nbackwards compatibility.\\n\\nA future statement is recognized and treated specially at compile\\ntime: Changes to the semantics of core constructs are often\\nimplemented by generating different code.  It may even be the case\\nthat a new feature introduces new incompatible syntax (such as a new\\nreserved word), in which case the compiler may need to parse the\\nmodule differently.  Such decisions cannot be pushed off until\\nruntime.\\n\\nFor any given release, the compiler knows which feature names have\\nbeen defined, and raises a compile-time error if a future statement\\ncontains a feature not known to it.\\n\\nThe direct runtime semantics are the same as for any import statement:\\nthere is a standard module ``__future__``, described later, and it\\nwill be imported in the usual way at the time the future statement is\\nexecuted.\\n\\nThe interesting runtime semantics depend on the specific feature\\nenabled by the future statement.\\n\\nNote that there is nothing special about the statement:\\n\\n   import __future__ [as name]\\n\\nThat is not a future statement; it\\'s an ordinary import statement with\\nno special semantics or syntax restrictions.\\n\\nCode compiled by calls to the built-in functions ``exec()`` and\\n``compile()`` that occur in a module ``M`` containing a future\\nstatement will, by default, use the new syntax or semantics associated\\nwith the future statement.  This can be controlled by optional\\narguments to ``compile()`` --- see the documentation of that function\\nfor details.\\n\\nA future statement typed at an interactive interpreter prompt will\\ntake effect for the rest of the interpreter session.  If an\\ninterpreter is started with the *-i* option, is passed a script name\\nto execute, and the script includes a future statement, it will be in\\neffect in the interactive session started after the script is\\nexecuted.\\n\\nSee also:\\n\\n   **PEP 236** - Back to the __future__\\n      The original proposal for the __future__ mechanism.\\n',\n'in': '\\nComparisons\\n***********\\n\\nUnlike C, all comparison operations in Python have the same priority,\\nwhich is lower than that of any arithmetic, shifting or bitwise\\noperation.  Also unlike C, expressions like ``a < b < c`` have the\\ninterpretation that is conventional in mathematics:\\n\\n   comparison    ::= or_expr ( comp_operator or_expr )*\\n   comp_operator ::= \"<\" | \">\" | \"==\" | \">=\" | \"<=\" | \"!=\"\\n                     | \"is\" [\"not\"] | [\"not\"] \"in\"\\n\\nComparisons yield boolean values: ``True`` or ``False``.\\n\\nComparisons can be chained arbitrarily, e.g., ``x < y <= z`` is\\nequivalent to ``x < y and y <= z``, except that ``y`` is evaluated\\nonly once (but in both cases ``z`` is not evaluated at all when ``x <\\ny`` is found to be false).\\n\\nFormally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*,\\n*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y\\nopN z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``,\\nexcept that each expression is evaluated at most once.\\n\\nNote that ``a op1 b op2 c`` doesn\\'t imply any kind of comparison\\nbetween *a* and *c*, so that, e.g., ``x < y > z`` is perfectly legal\\n(though perhaps not pretty).\\n\\nThe operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare\\nthe values of two objects.  The objects need not have the same type.\\nIf both are numbers, they are converted to a common type.  Otherwise,\\nthe ``==`` and ``!=`` operators *always* consider objects of different\\ntypes to be unequal, while the ``<``, ``>``, ``>=`` and ``<=``\\noperators raise a ``TypeError`` when comparing objects of different\\ntypes that do not implement these operators for the given pair of\\ntypes.  You can control comparison behavior of objects of non-built-in\\ntypes by defining rich comparison methods like ``__gt__()``, described\\nin section *Basic customization*.\\n\\nComparison of objects of the same type depends on the type:\\n\\n* Numbers are compared arithmetically.\\n\\n* The values ``float(\\'NaN\\')`` and ``Decimal(\\'NaN\\')`` are special. The\\n  are identical to themselves, ``x is x`` but are not equal to\\n  themselves, ``x != x``.  Additionally, comparing any value to a\\n  not-a-number value will return ``False``.  For example, both ``3 <\\n  float(\\'NaN\\')`` and ``float(\\'NaN\\') < 3`` will return ``False``.\\n\\n* Bytes objects are compared lexicographically using the numeric\\n  values of their elements.\\n\\n* Strings are compared lexicographically using the numeric equivalents\\n  (the result of the built-in function ``ord()``) of their characters.\\n  [3] String and bytes object can\\'t be compared!\\n\\n* Tuples and lists are compared lexicographically using comparison of\\n  corresponding elements.  This means that to compare equal, each\\n  element must compare equal and the two sequences must be of the same\\n  type and have the same length.\\n\\n  If not equal, the sequences are ordered the same as their first\\n  differing elements.  For example, ``[1,2,x] <= [1,2,y]`` has the\\n  same value as ``x <= y``.  If the corresponding element does not\\n  exist, the shorter sequence is ordered first (for example, ``[1,2] <\\n  [1,2,3]``).\\n\\n* Mappings (dictionaries) compare equal if and only if they have the\\n  same ``(key, value)`` pairs. Order comparisons ``(\\'<\\', \\'<=\\', \\'>=\\',\\n  \\'>\\')`` raise ``TypeError``.\\n\\n* Sets and frozensets define comparison operators to mean subset and\\n  superset tests.  Those relations do not define total orderings (the\\n  two sets ``{1,2}`` and {2,3} are not equal, nor subsets of one\\n  another, nor supersets of one another).  Accordingly, sets are not\\n  appropriate arguments for functions which depend on total ordering.\\n  For example, ``min()``, ``max()``, and ``sorted()`` produce\\n  undefined results given a list of sets as inputs.\\n\\n* Most other objects of built-in types compare unequal unless they are\\n  the same object; the choice whether one object is considered smaller\\n  or larger than another one is made arbitrarily but consistently\\n  within one execution of a program.\\n\\nComparison of objects of the differing types depends on whether either\\nof the types provide explicit support for the comparison.  Most\\nnumeric types can be compared with one another.  When cross-type\\ncomparison is not supported, the comparison method returns\\n``NotImplemented``.\\n\\nThe operators ``in`` and ``not in`` test for membership.  ``x in s``\\nevaluates to true if *x* is a member of *s*, and false otherwise.  ``x\\nnot in s`` returns the negation of ``x in s``.  All built-in sequences\\nand set types support this as well as dictionary, for which ``in``\\ntests whether a the dictionary has a given key. For container types\\nsuch as list, tuple, set, frozenset, dict, or collections.deque, the\\nexpression ``x in y`` is equivalent to ``any(x is e or x == e for e in\\ny)``.\\n\\nFor the string and bytes types, ``x in y`` is true if and only if *x*\\nis a substring of *y*.  An equivalent test is ``y.find(x) != -1``.\\nEmpty strings are always considered to be a substring of any other\\nstring, so ``\"\" in \"abc\"`` will return ``True``.\\n\\nFor user-defined classes which define the ``__contains__()`` method,\\n``x in y`` is true if and only if ``y.__contains__(x)`` is true.\\n\\nFor user-defined classes which do not define ``__contains__()`` but do\\ndefine ``__iter__()``, ``x in y`` is true if some value ``z`` with ``x\\n== z`` is produced while iterating over ``y``.  If an exception is\\nraised during the iteration, it is as if ``in`` raised that exception.\\n\\nLastly, the old-style iteration protocol is tried: if a class defines\\n``__getitem__()``, ``x in y`` is true if and only if there is a non-\\nnegative integer index *i* such that ``x == y[i]``, and all lower\\ninteger indices do not raise ``IndexError`` exception.  (If any other\\nexception is raised, it is as if ``in`` raised that exception).\\n\\nThe operator ``not in`` is defined to have the inverse true value of\\n``in``.\\n\\nThe operators ``is`` and ``is not`` test for object identity: ``x is\\ny`` is true if and only if *x* and *y* are the same object.  ``x is\\nnot y`` yields the inverse truth value. [4]\\n',\n'integers': '\\nInteger literals\\n****************\\n\\nInteger literals are described by the following lexical definitions:\\n\\n   integer        ::= decimalinteger | octinteger | hexinteger | bininteger\\n   decimalinteger ::= nonzerodigit digit* | \"0\"+\\n   nonzerodigit   ::= \"1\"...\"9\"\\n   digit          ::= \"0\"...\"9\"\\n   octinteger     ::= \"0\" (\"o\" | \"O\") octdigit+\\n   hexinteger     ::= \"0\" (\"x\" | \"X\") hexdigit+\\n   bininteger     ::= \"0\" (\"b\" | \"B\") bindigit+\\n   octdigit       ::= \"0\"...\"7\"\\n   hexdigit       ::= digit | \"a\"...\"f\" | \"A\"...\"F\"\\n   bindigit       ::= \"0\" | \"1\"\\n\\nThere is no limit for the length of integer literals apart from what\\ncan be stored in available memory.\\n\\nNote that leading zeros in a non-zero decimal number are not allowed.\\nThis is for disambiguation with C-style octal literals, which Python\\nused before version 3.0.\\n\\nSome examples of integer literals:\\n\\n   7     2147483647                        0o177    0b100110111\\n   3     79228162514264337593543950336     0o377    0x100000000\\n         79228162514264337593543950336              0xdeadbeef\\n',\n'lambda': '\\nLambdas\\n*******\\n\\n   lambda_form        ::= \"lambda\" [parameter_list]: expression\\n   lambda_form_nocond ::= \"lambda\" [parameter_list]: expression_nocond\\n\\nLambda forms (lambda expressions) have the same syntactic position as\\nexpressions.  They are a shorthand to create anonymous functions; the\\nexpression ``lambda arguments: expression`` yields a function object.\\nThe unnamed object behaves like a function object defined with\\n\\n   def <lambda>(arguments):\\n       return expression\\n\\nSee section *Function definitions* for the syntax of parameter lists.\\nNote that functions created with lambda forms cannot contain\\nstatements or annotations.\\n',\n'lists': '\\nList displays\\n*************\\n\\nA list display is a possibly empty series of expressions enclosed in\\nsquare brackets:\\n\\n   list_display ::= \"[\" [expression_list | comprehension] \"]\"\\n\\nA list display yields a new list object, the contents being specified\\nby either a list of expressions or a comprehension.  When a comma-\\nseparated list of expressions is supplied, its elements are evaluated\\nfrom left to right and placed into the list object in that order.\\nWhen a comprehension is supplied, the list is constructed from the\\nelements resulting from the comprehension.\\n',\n'naming': \"\\nNaming and binding\\n******************\\n\\n*Names* refer to objects.  Names are introduced by name binding\\noperations. Each occurrence of a name in the program text refers to\\nthe *binding* of that name established in the innermost function block\\ncontaining the use.\\n\\nA *block* is a piece of Python program text that is executed as a\\nunit. The following are blocks: a module, a function body, and a class\\ndefinition. Each command typed interactively is a block.  A script\\nfile (a file given as standard input to the interpreter or specified\\non the interpreter command line the first argument) is a code block.\\nA script command (a command specified on the interpreter command line\\nwith the '**-c**' option) is a code block.  The string argument passed\\nto the built-in functions ``eval()`` and ``exec()`` is a code block.\\n\\nA code block is executed in an *execution frame*.  A frame contains\\nsome administrative information (used for debugging) and determines\\nwhere and how execution continues after the code block's execution has\\ncompleted.\\n\\nA *scope* defines the visibility of a name within a block.  If a local\\nvariable is defined in a block, its scope includes that block.  If the\\ndefinition occurs in a function block, the scope extends to any blocks\\ncontained within the defining one, unless a contained block introduces\\na different binding for the name.  The scope of names defined in a\\nclass block is limited to the class block; it does not extend to the\\ncode blocks of methods -- this includes comprehensions and generator\\nexpressions since they are implemented using a function scope.  This\\nmeans that the following will fail:\\n\\n   class A:\\n       a = 42\\n       b = list(a + i for i in range(10))\\n\\nWhen a name is used in a code block, it is resolved using the nearest\\nenclosing scope.  The set of all such scopes visible to a code block\\nis called the block's *environment*.\\n\\nIf a name is bound in a block, it is a local variable of that block,\\nunless declared as ``nonlocal``.  If a name is bound at the module\\nlevel, it is a global variable.  (The variables of the module code\\nblock are local and global.)  If a variable is used in a code block\\nbut not defined there, it is a *free variable*.\\n\\nWhen a name is not found at all, a ``NameError`` exception is raised.\\nIf the name refers to a local variable that has not been bound, a\\n``UnboundLocalError`` exception is raised.  ``UnboundLocalError`` is a\\nsubclass of ``NameError``.\\n\\nThe following constructs bind names: formal parameters to functions,\\n``import`` statements, class and function definitions (these bind the\\nclass or function name in the defining block), and targets that are\\nidentifiers if occurring in an assignment, ``for`` loop header, or\\nafter ``as`` in a ``with`` statement or ``except`` clause. The\\n``import`` statement of the form ``from ... import *`` binds all names\\ndefined in the imported module, except those beginning with an\\nunderscore.  This form may only be used at the module level.\\n\\nA target occurring in a ``del`` statement is also considered bound for\\nthis purpose (though the actual semantics are to unbind the name).\\n\\nEach assignment or import statement occurs within a block defined by a\\nclass or function definition or at the module level (the top-level\\ncode block).\\n\\nIf a name binding operation occurs anywhere within a code block, all\\nuses of the name within the block are treated as references to the\\ncurrent block.  This can lead to errors when a name is used within a\\nblock before it is bound.  This rule is subtle.  Python lacks\\ndeclarations and allows name binding operations to occur anywhere\\nwithin a code block.  The local variables of a code block can be\\ndetermined by scanning the entire text of the block for name binding\\noperations.\\n\\nIf the ``global`` statement occurs within a block, all uses of the\\nname specified in the statement refer to the binding of that name in\\nthe top-level namespace.  Names are resolved in the top-level\\nnamespace by searching the global namespace, i.e. the namespace of the\\nmodule containing the code block, and the builtins namespace, the\\nnamespace of the module ``builtins``.  The global namespace is\\nsearched first.  If the name is not found there, the builtins\\nnamespace is searched.  The global statement must precede all uses of\\nthe name.\\n\\nThe builtins namespace associated with the execution of a code block\\nis actually found by looking up the name ``__builtins__`` in its\\nglobal namespace; this should be a dictionary or a module (in the\\nlatter case the module's dictionary is used).  By default, when in the\\n``__main__`` module, ``__builtins__`` is the built-in module\\n``builtins``; when in any other module, ``__builtins__`` is an alias\\nfor the dictionary of the ``builtins`` module itself.\\n``__builtins__`` can be set to a user-created dictionary to create a\\nweak form of restricted execution.\\n\\n**CPython implementation detail:** Users should not touch\\n``__builtins__``; it is strictly an implementation detail.  Users\\nwanting to override values in the builtins namespace should ``import``\\nthe ``builtins`` module and modify its attributes appropriately.\\n\\nThe namespace for a module is automatically created the first time a\\nmodule is imported.  The main module for a script is always called\\n``__main__``.\\n\\nThe ``global`` statement has the same scope as a name binding\\noperation in the same block.  If the nearest enclosing scope for a\\nfree variable contains a global statement, the free variable is\\ntreated as a global.\\n\\nA class definition is an executable statement that may use and define\\nnames. These references follow the normal rules for name resolution.\\nThe namespace of the class definition becomes the attribute dictionary\\nof the class.  Names defined at the class scope are not visible in\\nmethods.\\n\\n\\nInteraction with dynamic features\\n=================================\\n\\nThere are several cases where Python statements are illegal when used\\nin conjunction with nested scopes that contain free variables.\\n\\nIf a variable is referenced in an enclosing scope, it is illegal to\\ndelete the name.  An error will be reported at compile time.\\n\\nIf the wild card form of import --- ``import *`` --- is used in a\\nfunction and the function contains or is a nested block with free\\nvariables, the compiler will raise a ``SyntaxError``.\\n\\nThe ``eval()`` and ``exec()`` functions do not have access to the full\\nenvironment for resolving names.  Names may be resolved in the local\\nand global namespaces of the caller.  Free variables are not resolved\\nin the nearest enclosing namespace, but in the global namespace.  [1]\\nThe ``exec()`` and ``eval()`` functions have optional arguments to\\noverride the global and local namespace.  If only one namespace is\\nspecified, it is used for both.\\n\",\n'nonlocal': '\\nThe ``nonlocal`` statement\\n**************************\\n\\n   nonlocal_stmt ::= \"nonlocal\" identifier (\",\" identifier)*\\n\\nThe ``nonlocal`` statement causes the listed identifiers to refer to\\npreviously bound variables in the nearest enclosing scope.  This is\\nimportant because the default behavior for binding is to search the\\nlocal namespace first.  The statement allows encapsulated code to\\nrebind variables outside of the local scope besides the global\\n(module) scope.\\n\\nNames listed in a ``nonlocal`` statement, unlike to those listed in a\\n``global`` statement, must refer to pre-existing bindings in an\\nenclosing scope (the scope in which a new binding should be created\\ncannot be determined unambiguously).\\n\\nNames listed in a ``nonlocal`` statement must not collide with pre-\\nexisting bindings in the local scope.\\n\\nSee also:\\n\\n   **PEP 3104** - Access to Names in Outer Scopes\\n      The specification for the ``nonlocal`` statement.\\n',\n'numbers': \"\\nNumeric literals\\n****************\\n\\nThere are three types of numeric literals: integers, floating point\\nnumbers, and imaginary numbers.  There are no complex literals\\n(complex numbers can be formed by adding a real number and an\\nimaginary number).\\n\\nNote that numeric literals do not include a sign; a phrase like ``-1``\\nis actually an expression composed of the unary operator '``-``' and\\nthe literal ``1``.\\n\",\n'numeric-types': \"\\nEmulating numeric types\\n***********************\\n\\nThe following methods can be defined to emulate numeric objects.\\nMethods corresponding to operations that are not supported by the\\nparticular kind of number implemented (e.g., bitwise operations for\\nnon-integral numbers) should be left undefined.\\n\\nobject.__add__(self, other)\\nobject.__sub__(self, other)\\nobject.__mul__(self, other)\\nobject.__truediv__(self, other)\\nobject.__floordiv__(self, other)\\nobject.__mod__(self, other)\\nobject.__divmod__(self, other)\\nobject.__pow__(self, other[, modulo])\\nobject.__lshift__(self, other)\\nobject.__rshift__(self, other)\\nobject.__and__(self, other)\\nobject.__xor__(self, other)\\nobject.__or__(self, other)\\n\\n   These methods are called to implement the binary arithmetic\\n   operations (``+``, ``-``, ``*``, ``/``, ``//``, ``%``,\\n   ``divmod()``, ``pow()``, ``**``, ``<<``, ``>>``, ``&``, ``^``,\\n   ``|``).  For instance, to evaluate the expression ``x + y``, where\\n   *x* is an instance of a class that has an ``__add__()`` method,\\n   ``x.__add__(y)`` is called.  The ``__divmod__()`` method should be\\n   the equivalent to using ``__floordiv__()`` and ``__mod__()``; it\\n   should not be related to ``__truediv__()``.  Note that\\n   ``__pow__()`` should be defined to accept an optional third\\n   argument if the ternary version of the built-in ``pow()`` function\\n   is to be supported.\\n\\n   If one of those methods does not support the operation with the\\n   supplied arguments, it should return ``NotImplemented``.\\n\\nobject.__radd__(self, other)\\nobject.__rsub__(self, other)\\nobject.__rmul__(self, other)\\nobject.__rtruediv__(self, other)\\nobject.__rfloordiv__(self, other)\\nobject.__rmod__(self, other)\\nobject.__rdivmod__(self, other)\\nobject.__rpow__(self, other)\\nobject.__rlshift__(self, other)\\nobject.__rrshift__(self, other)\\nobject.__rand__(self, other)\\nobject.__rxor__(self, other)\\nobject.__ror__(self, other)\\n\\n   These methods are called to implement the binary arithmetic\\n   operations (``+``, ``-``, ``*``, ``/``, ``//``, ``%``,\\n   ``divmod()``, ``pow()``, ``**``, ``<<``, ``>>``, ``&``, ``^``,\\n   ``|``) with reflected (swapped) operands. These functions are only\\n   called if the left operand does not support the corresponding\\n   operation and the operands are of different types. [2]  For\\n   instance, to evaluate the expression ``x - y``, where *y* is an\\n   instance of a class that has an ``__rsub__()`` method,\\n   ``y.__rsub__(x)`` is called if ``x.__sub__(y)`` returns\\n   *NotImplemented*.\\n\\n   Note that ternary ``pow()`` will not try calling ``__rpow__()``\\n   (the coercion rules would become too complicated).\\n\\n   Note: If the right operand's type is a subclass of the left operand's\\n     type and that subclass provides the reflected method for the\\n     operation, this method will be called before the left operand's\\n     non-reflected method.  This behavior allows subclasses to\\n     override their ancestors' operations.\\n\\nobject.__iadd__(self, other)\\nobject.__isub__(self, other)\\nobject.__imul__(self, other)\\nobject.__itruediv__(self, other)\\nobject.__ifloordiv__(self, other)\\nobject.__imod__(self, other)\\nobject.__ipow__(self, other[, modulo])\\nobject.__ilshift__(self, other)\\nobject.__irshift__(self, other)\\nobject.__iand__(self, other)\\nobject.__ixor__(self, other)\\nobject.__ior__(self, other)\\n\\n   These methods are called to implement the augmented arithmetic\\n   assignments (``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``,\\n   ``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``).  These methods\\n   should attempt to do the operation in-place (modifying *self*) and\\n   return the result (which could be, but does not have to be,\\n   *self*).  If a specific method is not defined, the augmented\\n   assignment falls back to the normal methods.  For instance, to\\n   execute the statement ``x += y``, where *x* is an instance of a\\n   class that has an ``__iadd__()`` method, ``x.__iadd__(y)`` is\\n   called.  If *x* is an instance of a class that does not define a\\n   ``__iadd__()`` method, ``x.__add__(y)`` and ``y.__radd__(x)`` are\\n   considered, as with the evaluation of ``x + y``.\\n\\nobject.__neg__(self)\\nobject.__pos__(self)\\nobject.__abs__(self)\\nobject.__invert__(self)\\n\\n   Called to implement the unary arithmetic operations (``-``, ``+``,\\n   ``abs()`` and ``~``).\\n\\nobject.__complex__(self)\\nobject.__int__(self)\\nobject.__float__(self)\\nobject.__round__(self[, n])\\n\\n   Called to implement the built-in functions ``complex()``,\\n   ``int()``, ``float()`` and ``round()``.  Should return a value of\\n   the appropriate type.\\n\\nobject.__index__(self)\\n\\n   Called to implement ``operator.index()``.  Also called whenever\\n   Python needs an integer object (such as in slicing, or in the\\n   built-in ``bin()``, ``hex()`` and ``oct()`` functions). Must return\\n   an integer.\\n\",\n'objects': '\\nObjects, values and types\\n*************************\\n\\n*Objects* are Python\\'s abstraction for data.  All data in a Python\\nprogram is represented by objects or by relations between objects. (In\\na sense, and in conformance to Von Neumann\\'s model of a \"stored\\nprogram computer,\" code is also represented by objects.)\\n\\nEvery object has an identity, a type and a value.  An object\\'s\\n*identity* never changes once it has been created; you may think of it\\nas the object\\'s address in memory.  The \\'``is``\\' operator compares the\\nidentity of two objects; the ``id()`` function returns an integer\\nrepresenting its identity.\\n\\n**CPython implementation detail:** For CPython, ``id(x)`` is the\\nmemory address where ``x`` is stored.\\n\\nAn object\\'s type determines the operations that the object supports\\n(e.g., \"does it have a length?\") and also defines the possible values\\nfor objects of that type.  The ``type()`` function returns an object\\'s\\ntype (which is an object itself).  Like its identity, an object\\'s\\n*type* is also unchangeable. [1]\\n\\nThe *value* of some objects can change.  Objects whose value can\\nchange are said to be *mutable*; objects whose value is unchangeable\\nonce they are created are called *immutable*. (The value of an\\nimmutable container object that contains a reference to a mutable\\nobject can change when the latter\\'s value is changed; however the\\ncontainer is still considered immutable, because the collection of\\nobjects it contains cannot be changed.  So, immutability is not\\nstrictly the same as having an unchangeable value, it is more subtle.)\\nAn object\\'s mutability is determined by its type; for instance,\\nnumbers, strings and tuples are immutable, while dictionaries and\\nlists are mutable.\\n\\nObjects are never explicitly destroyed; however, when they become\\nunreachable they may be garbage-collected.  An implementation is\\nallowed to postpone garbage collection or omit it altogether --- it is\\na matter of implementation quality how garbage collection is\\nimplemented, as long as no objects are collected that are still\\nreachable.\\n\\n**CPython implementation detail:** CPython currently uses a reference-\\ncounting scheme with (optional) delayed detection of cyclically linked\\ngarbage, which collects most objects as soon as they become\\nunreachable, but is not guaranteed to collect garbage containing\\ncircular references.  See the documentation of the ``gc`` module for\\ninformation on controlling the collection of cyclic garbage. Other\\nimplementations act differently and CPython may change. Do not depend\\non immediate finalization of objects when they become unreachable (ex:\\nalways close files).\\n\\nNote that the use of the implementation\\'s tracing or debugging\\nfacilities may keep objects alive that would normally be collectable.\\nAlso note that catching an exception with a \\'``try``...``except``\\'\\nstatement may keep objects alive.\\n\\nSome objects contain references to \"external\" resources such as open\\nfiles or windows.  It is understood that these resources are freed\\nwhen the object is garbage-collected, but since garbage collection is\\nnot guaranteed to happen, such objects also provide an explicit way to\\nrelease the external resource, usually a ``close()`` method. Programs\\nare strongly recommended to explicitly close such objects.  The\\n\\'``try``...``finally``\\' statement and the \\'``with``\\' statement provide\\nconvenient ways to do this.\\n\\nSome objects contain references to other objects; these are called\\n*containers*. Examples of containers are tuples, lists and\\ndictionaries.  The references are part of a container\\'s value.  In\\nmost cases, when we talk about the value of a container, we imply the\\nvalues, not the identities of the contained objects; however, when we\\ntalk about the mutability of a container, only the identities of the\\nimmediately contained objects are implied.  So, if an immutable\\ncontainer (like a tuple) contains a reference to a mutable object, its\\nvalue changes if that mutable object is changed.\\n\\nTypes affect almost all aspects of object behavior.  Even the\\nimportance of object identity is affected in some sense: for immutable\\ntypes, operations that compute new values may actually return a\\nreference to any existing object with the same type and value, while\\nfor mutable objects this is not allowed.  E.g., after ``a = 1; b =\\n1``, ``a`` and ``b`` may or may not refer to the same object with the\\nvalue one, depending on the implementation, but after ``c = []; d =\\n[]``, ``c`` and ``d`` are guaranteed to refer to two different,\\nunique, newly created empty lists. (Note that ``c = d = []`` assigns\\nthe same object to both ``c`` and ``d``.)\\n',\n'operator-summary': '\\nOperator precedence\\n*******************\\n\\nThe following table summarizes the operator precedences in Python,\\nfrom lowest precedence (least binding) to highest precedence (most\\nbinding).  Operators in the same box have the same precedence.  Unless\\nthe syntax is explicitly given, operators are binary.  Operators in\\nthe same box group left to right (except for comparisons, including\\ntests, which all have the same precedence and chain from left to right\\n--- see section *Comparisons* --- and exponentiation, which groups\\nfrom right to left).\\n\\n+-------------------------------------------------+---------------------------------------+\\n| Operator                                        | Description                           |\\n+=================================================+=======================================+\\n| ``lambda``                                      | Lambda expression                     |\\n+-------------------------------------------------+---------------------------------------+\\n| ``if`` -- ``else``                              | Conditional expression                |\\n+-------------------------------------------------+---------------------------------------+\\n| ``or``                                          | Boolean OR                            |\\n+-------------------------------------------------+---------------------------------------+\\n| ``and``                                         | Boolean AND                           |\\n+-------------------------------------------------+---------------------------------------+\\n| ``not`` ``x``                                   | Boolean NOT                           |\\n+-------------------------------------------------+---------------------------------------+\\n| ``in``, ``not in``, ``is``, ``is not``, ``<``,  | Comparisons, including membership     |\\n| ``<=``, ``>``, ``>=``, ``!=``, ``==``           | tests and identity tests,             |\\n+-------------------------------------------------+---------------------------------------+\\n| ``|``                                           | Bitwise OR                            |\\n+-------------------------------------------------+---------------------------------------+\\n| ``^``                                           | Bitwise XOR                           |\\n+-------------------------------------------------+---------------------------------------+\\n| ``&``                                           | Bitwise AND                           |\\n+-------------------------------------------------+---------------------------------------+\\n| ``<<``, ``>>``                                  | Shifts                                |\\n+-------------------------------------------------+---------------------------------------+\\n| ``+``, ``-``                                    | Addition and subtraction              |\\n+-------------------------------------------------+---------------------------------------+\\n| ``*``, ``/``, ``//``, ``%``                     | Multiplication, division, remainder   |\\n|                                                 | [5]                                   |\\n+-------------------------------------------------+---------------------------------------+\\n| ``+x``, ``-x``, ``~x``                          | Positive, negative, bitwise NOT       |\\n+-------------------------------------------------+---------------------------------------+\\n| ``**``                                          | Exponentiation [6]                    |\\n+-------------------------------------------------+---------------------------------------+\\n| ``x[index]``, ``x[index:index]``,               | Subscription, slicing, call,          |\\n| ``x(arguments...)``, ``x.attribute``            | attribute reference                   |\\n+-------------------------------------------------+---------------------------------------+\\n| ``(expressions...)``, ``[expressions...]``,     | Binding or tuple display, list        |\\n| ``{key: value...}``, ``{expressions...}``       | display, dictionary display, set      |\\n|                                                 | display                               |\\n+-------------------------------------------------+---------------------------------------+\\n\\n-[ Footnotes ]-\\n\\n[1] While ``abs(x%y) < abs(y)`` is true mathematically, for floats it\\n    may not be true numerically due to roundoff.  For example, and\\n    assuming a platform on which a Python float is an IEEE 754 double-\\n    precision number, in order that ``-1e-100 % 1e100`` have the same\\n    sign as ``1e100``, the computed result is ``-1e-100 + 1e100``,\\n    which is numerically exactly equal to ``1e100``.  The function\\n    ``math.fmod()`` returns a result whose sign matches the sign of\\n    the first argument instead, and so returns ``-1e-100`` in this\\n    case. Which approach is more appropriate depends on the\\n    application.\\n\\n[2] If x is very close to an exact integer multiple of y, it\\'s\\n    possible for ``x//y`` to be one larger than ``(x-x%y)//y`` due to\\n    rounding.  In such cases, Python returns the latter result, in\\n    order to preserve that ``divmod(x,y)[0] * y + x % y`` be very\\n    close to ``x``.\\n\\n[3] While comparisons between strings make sense at the byte level,\\n    they may be counter-intuitive to users.  For example, the strings\\n    ``\"\\\\u00C7\"`` and ``\"\\\\u0327\\\\u0043\"`` compare differently, even\\n    though they both represent the same unicode character (LATIN\\n    CAPITAL LETTER C WITH CEDILLA).  To compare strings in a human\\n    recognizable way, compare using ``unicodedata.normalize()``.\\n\\n[4] Due to automatic garbage-collection, free lists, and the dynamic\\n    nature of descriptors, you may notice seemingly unusual behaviour\\n    in certain uses of the ``is`` operator, like those involving\\n    comparisons between instance methods, or constants.  Check their\\n    documentation for more info.\\n\\n[5] The ``%`` operator is also used for string formatting; the same\\n    precedence applies.\\n\\n[6] The power operator ``**`` binds less tightly than an arithmetic or\\n    bitwise unary operator on its right, that is, ``2**-1`` is\\n    ``0.5``.\\n',\n'pass': '\\nThe ``pass`` statement\\n**********************\\n\\n   pass_stmt ::= \"pass\"\\n\\n``pass`` is a null operation --- when it is executed, nothing happens.\\nIt is useful as a placeholder when a statement is required\\nsyntactically, but no code needs to be executed, for example:\\n\\n   def f(arg): pass    # a function that does nothing (yet)\\n\\n   class C: pass       # a class with no methods (yet)\\n',\n'power': '\\nThe power operator\\n******************\\n\\nThe power operator binds more tightly than unary operators on its\\nleft; it binds less tightly than unary operators on its right.  The\\nsyntax is:\\n\\n   power ::= primary [\"**\" u_expr]\\n\\nThus, in an unparenthesized sequence of power and unary operators, the\\noperators are evaluated from right to left (this does not constrain\\nthe evaluation order for the operands): ``-1**2`` results in ``-1``.\\n\\nThe power operator has the same semantics as the built-in ``pow()``\\nfunction, when called with two arguments: it yields its left argument\\nraised to the power of its right argument.  The numeric arguments are\\nfirst converted to a common type, and the result is of that type.\\n\\nFor int operands, the result has the same type as the operands unless\\nthe second argument is negative; in that case, all arguments are\\nconverted to float and a float result is delivered. For example,\\n``10**2`` returns ``100``, but ``10**-2`` returns ``0.01``.\\n\\nRaising ``0.0`` to a negative power results in a\\n``ZeroDivisionError``. Raising a negative number to a fractional power\\nresults in a ``complex`` number. (In earlier versions it raised a\\n``ValueError``.)\\n',\n'raise': '\\nThe ``raise`` statement\\n***********************\\n\\n   raise_stmt ::= \"raise\" [expression [\"from\" expression]]\\n\\nIf no expressions are present, ``raise`` re-raises the last exception\\nthat was active in the current scope.  If no exception is active in\\nthe current scope, a ``RuntimeError`` exception is raised indicating\\nthat this is an error.\\n\\nOtherwise, ``raise`` evaluates the first expression as the exception\\nobject.  It must be either a subclass or an instance of\\n``BaseException``. If it is a class, the exception instance will be\\nobtained when needed by instantiating the class with no arguments.\\n\\nThe *type* of the exception is the exception instance\\'s class, the\\n*value* is the instance itself.\\n\\nA traceback object is normally created automatically when an exception\\nis raised and attached to it as the ``__traceback__`` attribute, which\\nis writable. You can create an exception and set your own traceback in\\none step using the ``with_traceback()`` exception method (which\\nreturns the same exception instance, with its traceback set to its\\nargument), like so:\\n\\n   raise Exception(\"foo occurred\").with_traceback(tracebackobj)\\n\\nThe ``from`` clause is used for exception chaining: if given, the\\nsecond *expression* must be another exception class or instance, which\\nwill then be attached to the raised exception as the ``__cause__``\\nattribute (which is writable).  If the raised exception is not\\nhandled, both exceptions will be printed:\\n\\n   >>> try:\\n   ...     print(1 / 0)\\n   ... except Exception as exc:\\n   ...     raise RuntimeError(\"Something bad happened\") from exc\\n   ...\\n   Traceback (most recent call last):\\n     File \"<stdin>\", line 2, in <module>\\n   ZeroDivisionError: int division or modulo by zero\\n\\n   The above exception was the direct cause of the following exception:\\n\\n   Traceback (most recent call last):\\n     File \"<stdin>\", line 4, in <module>\\n   RuntimeError: Something bad happened\\n\\nA similar mechanism works implicitly if an exception is raised inside\\nan exception handler: the previous exception is then attached as the\\nnew exception\\'s ``__context__`` attribute:\\n\\n   >>> try:\\n   ...     print(1 / 0)\\n   ... except:\\n   ...     raise RuntimeError(\"Something bad happened\")\\n   ...\\n   Traceback (most recent call last):\\n     File \"<stdin>\", line 2, in <module>\\n   ZeroDivisionError: int division or modulo by zero\\n\\n   During handling of the above exception, another exception occurred:\\n\\n   Traceback (most recent call last):\\n     File \"<stdin>\", line 4, in <module>\\n   RuntimeError: Something bad happened\\n\\nAdditional information on exceptions can be found in section\\n*Exceptions*, and information about handling exceptions is in section\\n*The try statement*.\\n',\n'return': '\\nThe ``return`` statement\\n************************\\n\\n   return_stmt ::= \"return\" [expression_list]\\n\\n``return`` may only occur syntactically nested in a function\\ndefinition, not within a nested class definition.\\n\\nIf an expression list is present, it is evaluated, else ``None`` is\\nsubstituted.\\n\\n``return`` leaves the current function call with the expression list\\n(or ``None``) as return value.\\n\\nWhen ``return`` passes control out of a ``try`` statement with a\\n``finally`` clause, that ``finally`` clause is executed before really\\nleaving the function.\\n\\nIn a generator function, the ``return`` statement indicates that the\\ngenerator is done and will cause ``StopIteration`` to be raised. The\\nreturned value (if any) is used as an argument to construct\\n``StopIteration`` and becomes the ``StopIteration.value`` attribute.\\n',\n'sequence-types': \"\\nEmulating container types\\n*************************\\n\\nThe following methods can be defined to implement container objects.\\nContainers usually are sequences (such as lists or tuples) or mappings\\n(like dictionaries), but can represent other containers as well.  The\\nfirst set of methods is used either to emulate a sequence or to\\nemulate a mapping; the difference is that for a sequence, the\\nallowable keys should be the integers *k* for which ``0 <= k < N``\\nwhere *N* is the length of the sequence, or slice objects, which\\ndefine a range of items.  It is also recommended that mappings provide\\nthe methods ``keys()``, ``values()``, ``items()``, ``get()``,\\n``clear()``, ``setdefault()``, ``pop()``, ``popitem()``, ``copy()``,\\nand ``update()`` behaving similar to those for Python's standard\\ndictionary objects.  The ``collections`` module provides a\\n``MutableMapping`` abstract base class to help create those methods\\nfrom a base set of ``__getitem__()``, ``__setitem__()``,\\n``__delitem__()``, and ``keys()``. Mutable sequences should provide\\nmethods ``append()``, ``count()``, ``index()``, ``extend()``,\\n``insert()``, ``pop()``, ``remove()``, ``reverse()`` and ``sort()``,\\nlike Python standard list objects.  Finally, sequence types should\\nimplement addition (meaning concatenation) and multiplication (meaning\\nrepetition) by defining the methods ``__add__()``, ``__radd__()``,\\n``__iadd__()``, ``__mul__()``, ``__rmul__()`` and ``__imul__()``\\ndescribed below; they should not define other numerical operators.  It\\nis recommended that both mappings and sequences implement the\\n``__contains__()`` method to allow efficient use of the ``in``\\noperator; for mappings, ``in`` should search the mapping's keys; for\\nsequences, it should search through the values.  It is further\\nrecommended that both mappings and sequences implement the\\n``__iter__()`` method to allow efficient iteration through the\\ncontainer; for mappings, ``__iter__()`` should be the same as\\n``keys()``; for sequences, it should iterate through the values.\\n\\nobject.__len__(self)\\n\\n   Called to implement the built-in function ``len()``.  Should return\\n   the length of the object, an integer ``>=`` 0.  Also, an object\\n   that doesn't define a ``__bool__()`` method and whose ``__len__()``\\n   method returns zero is considered to be false in a Boolean context.\\n\\nNote: Slicing is done exclusively with the following three methods.  A\\n  call like\\n\\n     a[1:2] = b\\n\\n  is translated to\\n\\n     a[slice(1, 2, None)] = b\\n\\n  and so forth.  Missing slice items are always filled in with\\n  ``None``.\\n\\nobject.__getitem__(self, key)\\n\\n   Called to implement evaluation of ``self[key]``. For sequence\\n   types, the accepted keys should be integers and slice objects.\\n   Note that the special interpretation of negative indexes (if the\\n   class wishes to emulate a sequence type) is up to the\\n   ``__getitem__()`` method. If *key* is of an inappropriate type,\\n   ``TypeError`` may be raised; if of a value outside the set of\\n   indexes for the sequence (after any special interpretation of\\n   negative values), ``IndexError`` should be raised. For mapping\\n   types, if *key* is missing (not in the container), ``KeyError``\\n   should be raised.\\n\\n   Note: ``for`` loops expect that an ``IndexError`` will be raised for\\n     illegal indexes to allow proper detection of the end of the\\n     sequence.\\n\\nobject.__setitem__(self, key, value)\\n\\n   Called to implement assignment to ``self[key]``.  Same note as for\\n   ``__getitem__()``.  This should only be implemented for mappings if\\n   the objects support changes to the values for keys, or if new keys\\n   can be added, or for sequences if elements can be replaced.  The\\n   same exceptions should be raised for improper *key* values as for\\n   the ``__getitem__()`` method.\\n\\nobject.__delitem__(self, key)\\n\\n   Called to implement deletion of ``self[key]``.  Same note as for\\n   ``__getitem__()``.  This should only be implemented for mappings if\\n   the objects support removal of keys, or for sequences if elements\\n   can be removed from the sequence.  The same exceptions should be\\n   raised for improper *key* values as for the ``__getitem__()``\\n   method.\\n\\nobject.__iter__(self)\\n\\n   This method is called when an iterator is required for a container.\\n   This method should return a new iterator object that can iterate\\n   over all the objects in the container.  For mappings, it should\\n   iterate over the keys of the container, and should also be made\\n   available as the method ``keys()``.\\n\\n   Iterator objects also need to implement this method; they are\\n   required to return themselves.  For more information on iterator\\n   objects, see *Iterator Types*.\\n\\nobject.__reversed__(self)\\n\\n   Called (if present) by the ``reversed()`` built-in to implement\\n   reverse iteration.  It should return a new iterator object that\\n   iterates over all the objects in the container in reverse order.\\n\\n   If the ``__reversed__()`` method is not provided, the\\n   ``reversed()`` built-in will fall back to using the sequence\\n   protocol (``__len__()`` and ``__getitem__()``).  Objects that\\n   support the sequence protocol should only provide\\n   ``__reversed__()`` if they can provide an implementation that is\\n   more efficient than the one provided by ``reversed()``.\\n\\nThe membership test operators (``in`` and ``not in``) are normally\\nimplemented as an iteration through a sequence.  However, container\\nobjects can supply the following special method with a more efficient\\nimplementation, which also does not require the object be a sequence.\\n\\nobject.__contains__(self, item)\\n\\n   Called to implement membership test operators.  Should return true\\n   if *item* is in *self*, false otherwise.  For mapping objects, this\\n   should consider the keys of the mapping rather than the values or\\n   the key-item pairs.\\n\\n   For objects that don't define ``__contains__()``, the membership\\n   test first tries iteration via ``__iter__()``, then the old\\n   sequence iteration protocol via ``__getitem__()``, see *this\\n   section in the language reference*.\\n\",\n'shifting': '\\nShifting operations\\n*******************\\n\\nThe shifting operations have lower priority than the arithmetic\\noperations:\\n\\n   shift_expr ::= a_expr | shift_expr ( \"<<\" | \">>\" ) a_expr\\n\\nThese operators accept integers as arguments.  They shift the first\\nargument to the left or right by the number of bits given by the\\nsecond argument.\\n\\nA right shift by *n* bits is defined as division by ``pow(2,n)``.  A\\nleft shift by *n* bits is defined as multiplication with ``pow(2,n)``.\\n\\nNote: In the current implementation, the right-hand operand is required to\\n  be at most ``sys.maxsize``.  If the right-hand operand is larger\\n  than ``sys.maxsize`` an ``OverflowError`` exception is raised.\\n',\n'slicings': '\\nSlicings\\n********\\n\\nA slicing selects a range of items in a sequence object (e.g., a\\nstring, tuple or list).  Slicings may be used as expressions or as\\ntargets in assignment or ``del`` statements.  The syntax for a\\nslicing:\\n\\n   slicing      ::= primary \"[\" slice_list \"]\"\\n   slice_list   ::= slice_item (\",\" slice_item)* [\",\"]\\n   slice_item   ::= expression | proper_slice\\n   proper_slice ::= [lower_bound] \":\" [upper_bound] [ \":\" [stride] ]\\n   lower_bound  ::= expression\\n   upper_bound  ::= expression\\n   stride       ::= expression\\n\\nThere is ambiguity in the formal syntax here: anything that looks like\\nan expression list also looks like a slice list, so any subscription\\ncan be interpreted as a slicing.  Rather than further complicating the\\nsyntax, this is disambiguated by defining that in this case the\\ninterpretation as a subscription takes priority over the\\ninterpretation as a slicing (this is the case if the slice list\\ncontains no proper slice).\\n\\nThe semantics for a slicing are as follows.  The primary must evaluate\\nto a mapping object, and it is indexed (using the same\\n``__getitem__()`` method as normal subscription) with a key that is\\nconstructed from the slice list, as follows.  If the slice list\\ncontains at least one comma, the key is a tuple containing the\\nconversion of the slice items; otherwise, the conversion of the lone\\nslice item is the key.  The conversion of a slice item that is an\\nexpression is that expression.  The conversion of a proper slice is a\\nslice object (see section *The standard type hierarchy*) whose\\n``start``, ``stop`` and ``step`` attributes are the values of the\\nexpressions given as lower bound, upper bound and stride,\\nrespectively, substituting ``None`` for missing expressions.\\n',\n'specialattrs': '\\nSpecial Attributes\\n******************\\n\\nThe implementation adds a few special read-only attributes to several\\nobject types, where they are relevant.  Some of these are not reported\\nby the ``dir()`` built-in function.\\n\\nobject.__dict__\\n\\n   A dictionary or other mapping object used to store an object\\'s\\n   (writable) attributes.\\n\\ninstance.__class__\\n\\n   The class to which a class instance belongs.\\n\\nclass.__bases__\\n\\n   The tuple of base classes of a class object.\\n\\nclass.__name__\\n\\n   The name of the class or type.\\n\\nclass.__qualname__\\n\\n   The *qualified name* of the class or type.\\n\\n   New in version 3.3.\\n\\nclass.__mro__\\n\\n   This attribute is a tuple of classes that are considered when\\n   looking for base classes during method resolution.\\n\\nclass.mro()\\n\\n   This method can be overridden by a metaclass to customize the\\n   method resolution order for its instances.  It is called at class\\n   instantiation, and its result is stored in ``__mro__``.\\n\\nclass.__subclasses__()\\n\\n   Each class keeps a list of weak references to its immediate\\n   subclasses.  This method returns a list of all those references\\n   still alive. Example:\\n\\n      >>> int.__subclasses__()\\n      [<class \\'bool\\'>]\\n\\n-[ Footnotes ]-\\n\\n[1] Additional information on these special methods may be found in\\n    the Python Reference Manual (*Basic customization*).\\n\\n[2] As a consequence, the list ``[1, 2]`` is considered equal to\\n    ``[1.0, 2.0]``, and similarly for tuples.\\n\\n[3] They must have since the parser can\\'t tell the type of the\\n    operands.\\n\\n[4] Cased characters are those with general category property being\\n    one of \"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\"\\n    (Letter, titlecase).\\n\\n[5] To format only a tuple you should therefore provide a singleton\\n    tuple whose only element is the tuple to be formatted.\\n',\n'specialnames': '\\nSpecial method names\\n********************\\n\\nA class can implement certain operations that are invoked by special\\nsyntax (such as arithmetic operations or subscripting and slicing) by\\ndefining methods with special names. This is Python\\'s approach to\\n*operator overloading*, allowing classes to define their own behavior\\nwith respect to language operators.  For instance, if a class defines\\na method named ``__getitem__()``, and ``x`` is an instance of this\\nclass, then ``x[i]`` is roughly equivalent to ``type(x).__getitem__(x,\\ni)``.  Except where mentioned, attempts to execute an operation raise\\nan exception when no appropriate method is defined (typically\\n``AttributeError`` or ``TypeError``).\\n\\nWhen implementing a class that emulates any built-in type, it is\\nimportant that the emulation only be implemented to the degree that it\\nmakes sense for the object being modelled.  For example, some\\nsequences may work well with retrieval of individual elements, but\\nextracting a slice may not make sense.  (One example of this is the\\n``NodeList`` interface in the W3C\\'s Document Object Model.)\\n\\n\\nBasic customization\\n===================\\n\\nobject.__new__(cls[, ...])\\n\\n   Called to create a new instance of class *cls*.  ``__new__()`` is a\\n   static method (special-cased so you need not declare it as such)\\n   that takes the class of which an instance was requested as its\\n   first argument.  The remaining arguments are those passed to the\\n   object constructor expression (the call to the class).  The return\\n   value of ``__new__()`` should be the new object instance (usually\\n   an instance of *cls*).\\n\\n   Typical implementations create a new instance of the class by\\n   invoking the superclass\\'s ``__new__()`` method using\\n   ``super(currentclass, cls).__new__(cls[, ...])`` with appropriate\\n   arguments and then modifying the newly-created instance as\\n   necessary before returning it.\\n\\n   If ``__new__()`` returns an instance of *cls*, then the new\\n   instance\\'s ``__init__()`` method will be invoked like\\n   ``__init__(self[, ...])``, where *self* is the new instance and the\\n   remaining arguments are the same as were passed to ``__new__()``.\\n\\n   If ``__new__()`` does not return an instance of *cls*, then the new\\n   instance\\'s ``__init__()`` method will not be invoked.\\n\\n   ``__new__()`` is intended mainly to allow subclasses of immutable\\n   types (like int, str, or tuple) to customize instance creation.  It\\n   is also commonly overridden in custom metaclasses in order to\\n   customize class creation.\\n\\nobject.__init__(self[, ...])\\n\\n   Called when the instance is created.  The arguments are those\\n   passed to the class constructor expression.  If a base class has an\\n   ``__init__()`` method, the derived class\\'s ``__init__()`` method,\\n   if any, must explicitly call it to ensure proper initialization of\\n   the base class part of the instance; for example:\\n   ``BaseClass.__init__(self, [args...])``.  As a special constraint\\n   on constructors, no value may be returned; doing so will cause a\\n   ``TypeError`` to be raised at runtime.\\n\\nobject.__del__(self)\\n\\n   Called when the instance is about to be destroyed.  This is also\\n   called a destructor.  If a base class has a ``__del__()`` method,\\n   the derived class\\'s ``__del__()`` method, if any, must explicitly\\n   call it to ensure proper deletion of the base class part of the\\n   instance.  Note that it is possible (though not recommended!) for\\n   the ``__del__()`` method to postpone destruction of the instance by\\n   creating a new reference to it.  It may then be called at a later\\n   time when this new reference is deleted.  It is not guaranteed that\\n   ``__del__()`` methods are called for objects that still exist when\\n   the interpreter exits.\\n\\n   Note: ``del x`` doesn\\'t directly call ``x.__del__()`` --- the former\\n     decrements the reference count for ``x`` by one, and the latter\\n     is only called when ``x``\\'s reference count reaches zero.  Some\\n     common situations that may prevent the reference count of an\\n     object from going to zero include: circular references between\\n     objects (e.g., a doubly-linked list or a tree data structure with\\n     parent and child pointers); a reference to the object on the\\n     stack frame of a function that caught an exception (the traceback\\n     stored in ``sys.exc_info()[2]`` keeps the stack frame alive); or\\n     a reference to the object on the stack frame that raised an\\n     unhandled exception in interactive mode (the traceback stored in\\n     ``sys.last_traceback`` keeps the stack frame alive).  The first\\n     situation can only be remedied by explicitly breaking the cycles;\\n     the latter two situations can be resolved by storing ``None`` in\\n     ``sys.last_traceback``. Circular references which are garbage are\\n     detected when the option cycle detector is enabled (it\\'s on by\\n     default), but can only be cleaned up if there are no Python-\\n     level ``__del__()`` methods involved. Refer to the documentation\\n     for the ``gc`` module for more information about how\\n     ``__del__()`` methods are handled by the cycle detector,\\n     particularly the description of the ``garbage`` value.\\n\\n   Warning: Due to the precarious circumstances under which ``__del__()``\\n     methods are invoked, exceptions that occur during their execution\\n     are ignored, and a warning is printed to ``sys.stderr`` instead.\\n     Also, when ``__del__()`` is invoked in response to a module being\\n     deleted (e.g., when execution of the program is done), other\\n     globals referenced by the ``__del__()`` method may already have\\n     been deleted or in the process of being torn down (e.g. the\\n     import machinery shutting down).  For this reason, ``__del__()``\\n     methods should do the absolute minimum needed to maintain\\n     external invariants.  Starting with version 1.5, Python\\n     guarantees that globals whose name begins with a single\\n     underscore are deleted from their module before other globals are\\n     deleted; if no other references to such globals exist, this may\\n     help in assuring that imported modules are still available at the\\n     time when the ``__del__()`` method is called.\\n\\nobject.__repr__(self)\\n\\n   Called by the ``repr()`` built-in function to compute the\\n   \"official\" string representation of an object.  If at all possible,\\n   this should look like a valid Python expression that could be used\\n   to recreate an object with the same value (given an appropriate\\n   environment).  If this is not possible, a string of the form\\n   ``<...some useful description...>`` should be returned. The return\\n   value must be a string object. If a class defines ``__repr__()``\\n   but not ``__str__()``, then ``__repr__()`` is also used when an\\n   \"informal\" string representation of instances of that class is\\n   required.\\n\\n   This is typically used for debugging, so it is important that the\\n   representation is information-rich and unambiguous.\\n\\nobject.__str__(self)\\n\\n   Called by ``str(object)`` and the built-in functions ``format()``\\n   and ``print()`` to compute the \"informal\" or nicely printable\\n   string representation of an object.  The return value must be a\\n   *string* object.\\n\\n   This method differs from ``object.__repr__()`` in that there is no\\n   expectation that ``__str__()`` return a valid Python expression: a\\n   more convenient or concise representation can be used.\\n\\n   The default implementation defined by the built-in type ``object``\\n   calls ``object.__repr__()``.\\n\\nobject.__bytes__(self)\\n\\n   Called by ``bytes()`` to compute a byte-string representation of an\\n   object. This should return a ``bytes`` object.\\n\\nobject.__format__(self, format_spec)\\n\\n   Called by the ``format()`` built-in function (and by extension, the\\n   ``str.format()`` method of class ``str``) to produce a \"formatted\"\\n   string representation of an object. The ``format_spec`` argument is\\n   a string that contains a description of the formatting options\\n   desired. The interpretation of the ``format_spec`` argument is up\\n   to the type implementing ``__format__()``, however most classes\\n   will either delegate formatting to one of the built-in types, or\\n   use a similar formatting option syntax.\\n\\n   See *Format Specification Mini-Language* for a description of the\\n   standard formatting syntax.\\n\\n   The return value must be a string object.\\n\\nobject.__lt__(self, other)\\nobject.__le__(self, other)\\nobject.__eq__(self, other)\\nobject.__ne__(self, other)\\nobject.__gt__(self, other)\\nobject.__ge__(self, other)\\n\\n   These are the so-called \"rich comparison\" methods. The\\n   correspondence between operator symbols and method names is as\\n   follows: ``x<y`` calls ``x.__lt__(y)``, ``x<=y`` calls\\n   ``x.__le__(y)``, ``x==y`` calls ``x.__eq__(y)``, ``x!=y`` calls\\n   ``x.__ne__(y)``, ``x>y`` calls ``x.__gt__(y)``, and ``x>=y`` calls\\n   ``x.__ge__(y)``.\\n\\n   A rich comparison method may return the singleton\\n   ``NotImplemented`` if it does not implement the operation for a\\n   given pair of arguments. By convention, ``False`` and ``True`` are\\n   returned for a successful comparison. However, these methods can\\n   return any value, so if the comparison operator is used in a\\n   Boolean context (e.g., in the condition of an ``if`` statement),\\n   Python will call ``bool()`` on the value to determine if the result\\n   is true or false.\\n\\n   There are no implied relationships among the comparison operators.\\n   The truth of ``x==y`` does not imply that ``x!=y`` is false.\\n   Accordingly, when defining ``__eq__()``, one should also define\\n   ``__ne__()`` so that the operators will behave as expected.  See\\n   the paragraph on ``__hash__()`` for some important notes on\\n   creating *hashable* objects which support custom comparison\\n   operations and are usable as dictionary keys.\\n\\n   There are no swapped-argument versions of these methods (to be used\\n   when the left argument does not support the operation but the right\\n   argument does); rather, ``__lt__()`` and ``__gt__()`` are each\\n   other\\'s reflection, ``__le__()`` and ``__ge__()`` are each other\\'s\\n   reflection, and ``__eq__()`` and ``__ne__()`` are their own\\n   reflection.\\n\\n   Arguments to rich comparison methods are never coerced.\\n\\n   To automatically generate ordering operations from a single root\\n   operation, see ``functools.total_ordering()``.\\n\\nobject.__hash__(self)\\n\\n   Called by built-in function ``hash()`` and for operations on\\n   members of hashed collections including ``set``, ``frozenset``, and\\n   ``dict``.  ``__hash__()`` should return an integer.  The only\\n   required property is that objects which compare equal have the same\\n   hash value; it is advised to somehow mix together (e.g. using\\n   exclusive or) the hash values for the components of the object that\\n   also play a part in comparison of objects.\\n\\n   If a class does not define an ``__eq__()`` method it should not\\n   define a ``__hash__()`` operation either; if it defines\\n   ``__eq__()`` but not ``__hash__()``, its instances will not be\\n   usable as items in hashable collections.  If a class defines\\n   mutable objects and implements an ``__eq__()`` method, it should\\n   not implement ``__hash__()``, since the implementation of hashable\\n   collections requires that a key\\'s hash value is immutable (if the\\n   object\\'s hash value changes, it will be in the wrong hash bucket).\\n\\n   User-defined classes have ``__eq__()`` and ``__hash__()`` methods\\n   by default; with them, all objects compare unequal (except with\\n   themselves) and ``x.__hash__()`` returns an appropriate value such\\n   that ``x == y`` implies both that ``x is y`` and ``hash(x) ==\\n   hash(y)``.\\n\\n   A class that overrides ``__eq__()`` and does not define\\n   ``__hash__()`` will have its ``__hash__()`` implicitly set to\\n   ``None``.  When the ``__hash__()`` method of a class is ``None``,\\n   instances of the class will raise an appropriate ``TypeError`` when\\n   a program attempts to retrieve their hash value, and will also be\\n   correctly identified as unhashable when checking ``isinstance(obj,\\n   collections.Hashable``).\\n\\n   If a class that overrides ``__eq__()`` needs to retain the\\n   implementation of ``__hash__()`` from a parent class, the\\n   interpreter must be told this explicitly by setting ``__hash__ =\\n   <ParentClass>.__hash__``.\\n\\n   If a class that does not override ``__eq__()`` wishes to suppress\\n   hash support, it should include ``__hash__ = None`` in the class\\n   definition. A class which defines its own ``__hash__()`` that\\n   explicitly raises a ``TypeError`` would be incorrectly identified\\n   as hashable by an ``isinstance(obj, collections.Hashable)`` call.\\n\\n   Note: By default, the ``__hash__()`` values of str, bytes and datetime\\n     objects are \"salted\" with an unpredictable random value.\\n     Although they remain constant within an individual Python\\n     process, they are not predictable between repeated invocations of\\n     Python.This is intended to provide protection against a denial-\\n     of-service caused by carefully-chosen inputs that exploit the\\n     worst case performance of a dict insertion, O(n^2) complexity.\\n     See http://www.ocert.org/advisories/ocert-2011-003.html for\\n     details.Changing hash values affects the iteration order of\\n     dicts, sets and other mappings.  Python has never made guarantees\\n     about this ordering (and it typically varies between 32-bit and\\n     64-bit builds).See also ``PYTHONHASHSEED``.\\n\\n   Changed in version 3.3: Hash randomization is enabled by default.\\n\\nobject.__bool__(self)\\n\\n   Called to implement truth value testing and the built-in operation\\n   ``bool()``; should return ``False`` or ``True``.  When this method\\n   is not defined, ``__len__()`` is called, if it is defined, and the\\n   object is considered true if its result is nonzero.  If a class\\n   defines neither ``__len__()`` nor ``__bool__()``, all its instances\\n   are considered true.\\n\\n\\nCustomizing attribute access\\n============================\\n\\nThe following methods can be defined to customize the meaning of\\nattribute access (use of, assignment to, or deletion of ``x.name``)\\nfor class instances.\\n\\nobject.__getattr__(self, name)\\n\\n   Called when an attribute lookup has not found the attribute in the\\n   usual places (i.e. it is not an instance attribute nor is it found\\n   in the class tree for ``self``).  ``name`` is the attribute name.\\n   This method should return the (computed) attribute value or raise\\n   an ``AttributeError`` exception.\\n\\n   Note that if the attribute is found through the normal mechanism,\\n   ``__getattr__()`` is not called.  (This is an intentional asymmetry\\n   between ``__getattr__()`` and ``__setattr__()``.) This is done both\\n   for efficiency reasons and because otherwise ``__getattr__()``\\n   would have no way to access other attributes of the instance.  Note\\n   that at least for instance variables, you can fake total control by\\n   not inserting any values in the instance attribute dictionary (but\\n   instead inserting them in another object).  See the\\n   ``__getattribute__()`` method below for a way to actually get total\\n   control over attribute access.\\n\\nobject.__getattribute__(self, name)\\n\\n   Called unconditionally to implement attribute accesses for\\n   instances of the class. If the class also defines\\n   ``__getattr__()``, the latter will not be called unless\\n   ``__getattribute__()`` either calls it explicitly or raises an\\n   ``AttributeError``. This method should return the (computed)\\n   attribute value or raise an ``AttributeError`` exception. In order\\n   to avoid infinite recursion in this method, its implementation\\n   should always call the base class method with the same name to\\n   access any attributes it needs, for example,\\n   ``object.__getattribute__(self, name)``.\\n\\n   Note: This method may still be bypassed when looking up special methods\\n     as the result of implicit invocation via language syntax or\\n     built-in functions. See *Special method lookup*.\\n\\nobject.__setattr__(self, name, value)\\n\\n   Called when an attribute assignment is attempted.  This is called\\n   instead of the normal mechanism (i.e. store the value in the\\n   instance dictionary). *name* is the attribute name, *value* is the\\n   value to be assigned to it.\\n\\n   If ``__setattr__()`` wants to assign to an instance attribute, it\\n   should call the base class method with the same name, for example,\\n   ``object.__setattr__(self, name, value)``.\\n\\nobject.__delattr__(self, name)\\n\\n   Like ``__setattr__()`` but for attribute deletion instead of\\n   assignment.  This should only be implemented if ``del obj.name`` is\\n   meaningful for the object.\\n\\nobject.__dir__(self)\\n\\n   Called when ``dir()`` is called on the object. A sequence must be\\n   returned. ``dir()`` converts the returned sequence to a list and\\n   sorts it.\\n\\n\\nImplementing Descriptors\\n------------------------\\n\\nThe following methods only apply when an instance of the class\\ncontaining the method (a so-called *descriptor* class) appears in an\\n*owner* class (the descriptor must be in either the owner\\'s class\\ndictionary or in the class dictionary for one of its parents).  In the\\nexamples below, \"the attribute\" refers to the attribute whose name is\\nthe key of the property in the owner class\\' ``__dict__``.\\n\\nobject.__get__(self, instance, owner)\\n\\n   Called to get the attribute of the owner class (class attribute\\n   access) or of an instance of that class (instance attribute\\n   access). *owner* is always the owner class, while *instance* is the\\n   instance that the attribute was accessed through, or ``None`` when\\n   the attribute is accessed through the *owner*.  This method should\\n   return the (computed) attribute value or raise an\\n   ``AttributeError`` exception.\\n\\nobject.__set__(self, instance, value)\\n\\n   Called to set the attribute on an instance *instance* of the owner\\n   class to a new value, *value*.\\n\\nobject.__delete__(self, instance)\\n\\n   Called to delete the attribute on an instance *instance* of the\\n   owner class.\\n\\n\\nInvoking Descriptors\\n--------------------\\n\\nIn general, a descriptor is an object attribute with \"binding\\nbehavior\", one whose attribute access has been overridden by methods\\nin the descriptor protocol:  ``__get__()``, ``__set__()``, and\\n``__delete__()``. If any of those methods are defined for an object,\\nit is said to be a descriptor.\\n\\nThe default behavior for attribute access is to get, set, or delete\\nthe attribute from an object\\'s dictionary. For instance, ``a.x`` has a\\nlookup chain starting with ``a.__dict__[\\'x\\']``, then\\n``type(a).__dict__[\\'x\\']``, and continuing through the base classes of\\n``type(a)`` excluding metaclasses.\\n\\nHowever, if the looked-up value is an object defining one of the\\ndescriptor methods, then Python may override the default behavior and\\ninvoke the descriptor method instead.  Where this occurs in the\\nprecedence chain depends on which descriptor methods were defined and\\nhow they were called.\\n\\nThe starting point for descriptor invocation is a binding, ``a.x``.\\nHow the arguments are assembled depends on ``a``:\\n\\nDirect Call\\n   The simplest and least common call is when user code directly\\n   invokes a descriptor method:    ``x.__get__(a)``.\\n\\nInstance Binding\\n   If binding to an object instance, ``a.x`` is transformed into the\\n   call: ``type(a).__dict__[\\'x\\'].__get__(a, type(a))``.\\n\\nClass Binding\\n   If binding to a class, ``A.x`` is transformed into the call:\\n   ``A.__dict__[\\'x\\'].__get__(None, A)``.\\n\\nSuper Binding\\n   If ``a`` is an instance of ``super``, then the binding ``super(B,\\n   obj).m()`` searches ``obj.__class__.__mro__`` for the base class\\n   ``A`` immediately preceding ``B`` and then invokes the descriptor\\n   with the call: ``A.__dict__[\\'m\\'].__get__(obj, obj.__class__)``.\\n\\nFor instance bindings, the precedence of descriptor invocation depends\\non the which descriptor methods are defined.  A descriptor can define\\nany combination of ``__get__()``, ``__set__()`` and ``__delete__()``.\\nIf it does not define ``__get__()``, then accessing the attribute will\\nreturn the descriptor object itself unless there is a value in the\\nobject\\'s instance dictionary.  If the descriptor defines ``__set__()``\\nand/or ``__delete__()``, it is a data descriptor; if it defines\\nneither, it is a non-data descriptor.  Normally, data descriptors\\ndefine both ``__get__()`` and ``__set__()``, while non-data\\ndescriptors have just the ``__get__()`` method.  Data descriptors with\\n``__set__()`` and ``__get__()`` defined always override a redefinition\\nin an instance dictionary.  In contrast, non-data descriptors can be\\noverridden by instances.\\n\\nPython methods (including ``staticmethod()`` and ``classmethod()``)\\nare implemented as non-data descriptors.  Accordingly, instances can\\nredefine and override methods.  This allows individual instances to\\nacquire behaviors that differ from other instances of the same class.\\n\\nThe ``property()`` function is implemented as a data descriptor.\\nAccordingly, instances cannot override the behavior of a property.\\n\\n\\n__slots__\\n---------\\n\\nBy default, instances of classes have a dictionary for attribute\\nstorage.  This wastes space for objects having very few instance\\nvariables.  The space consumption can become acute when creating large\\nnumbers of instances.\\n\\nThe default can be overridden by defining *__slots__* in a class\\ndefinition. The *__slots__* declaration takes a sequence of instance\\nvariables and reserves just enough space in each instance to hold a\\nvalue for each variable.  Space is saved because *__dict__* is not\\ncreated for each instance.\\n\\nobject.__slots__\\n\\n   This class variable can be assigned a string, iterable, or sequence\\n   of strings with variable names used by instances.  If defined in a\\n   class, *__slots__* reserves space for the declared variables and\\n   prevents the automatic creation of *__dict__* and *__weakref__* for\\n   each instance.\\n\\n\\nNotes on using *__slots__*\\n~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\\n* When inheriting from a class without *__slots__*, the *__dict__*\\n  attribute of that class will always be accessible, so a *__slots__*\\n  definition in the subclass is meaningless.\\n\\n* Without a *__dict__* variable, instances cannot be assigned new\\n  variables not listed in the *__slots__* definition.  Attempts to\\n  assign to an unlisted variable name raises ``AttributeError``. If\\n  dynamic assignment of new variables is desired, then add\\n  ``\\'__dict__\\'`` to the sequence of strings in the *__slots__*\\n  declaration.\\n\\n* Without a *__weakref__* variable for each instance, classes defining\\n  *__slots__* do not support weak references to its instances. If weak\\n  reference support is needed, then add ``\\'__weakref__\\'`` to the\\n  sequence of strings in the *__slots__* declaration.\\n\\n* *__slots__* are implemented at the class level by creating\\n  descriptors (*Implementing Descriptors*) for each variable name.  As\\n  a result, class attributes cannot be used to set default values for\\n  instance variables defined by *__slots__*; otherwise, the class\\n  attribute would overwrite the descriptor assignment.\\n\\n* The action of a *__slots__* declaration is limited to the class\\n  where it is defined.  As a result, subclasses will have a *__dict__*\\n  unless they also define *__slots__* (which must only contain names\\n  of any *additional* slots).\\n\\n* If a class defines a slot also defined in a base class, the instance\\n  variable defined by the base class slot is inaccessible (except by\\n  retrieving its descriptor directly from the base class). This\\n  renders the meaning of the program undefined.  In the future, a\\n  check may be added to prevent this.\\n\\n* Nonempty *__slots__* does not work for classes derived from\\n  \"variable-length\" built-in types such as ``int``, ``str`` and\\n  ``tuple``.\\n\\n* Any non-string iterable may be assigned to *__slots__*. Mappings may\\n  also be used; however, in the future, special meaning may be\\n  assigned to the values corresponding to each key.\\n\\n* *__class__* assignment works only if both classes have the same\\n  *__slots__*.\\n\\n\\nCustomizing class creation\\n==========================\\n\\nBy default, classes are constructed using ``type()``. The class body\\nis executed in a new namespace and the class name is bound locally to\\nthe result of ``type(name, bases, namespace)``.\\n\\nThe class creation process can be customised by passing the\\n``metaclass`` keyword argument in the class definition line, or by\\ninheriting from an existing class that included such an argument. In\\nthe following example, both ``MyClass`` and ``MySubclass`` are\\ninstances of ``Meta``:\\n\\n   class Meta(type):\\n       pass\\n\\n   class MyClass(metaclass=Meta):\\n       pass\\n\\n   class MySubclass(MyClass):\\n       pass\\n\\nAny other keyword arguments that are specified in the class definition\\nare passed through to all metaclass operations described below.\\n\\nWhen a class definition is executed, the following steps occur:\\n\\n* the appropriate metaclass is determined\\n\\n* the class namespace is prepared\\n\\n* the class body is executed\\n\\n* the class object is created\\n\\n\\nDetermining the appropriate metaclass\\n-------------------------------------\\n\\nThe appropriate metaclass for a class definition is determined as\\nfollows:\\n\\n* if no bases and no explicit metaclass are given, then ``type()`` is\\n  used\\n\\n* if an explicit metaclass is given and it is *not* an instance of\\n  ``type()``, then it is used directly as the metaclass\\n\\n* if an instance of ``type()`` is given as the explicit metaclass, or\\n  bases are defined, then the most derived metaclass is used\\n\\nThe most derived metaclass is selected from the explicitly specified\\nmetaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all\\nspecified base classes. The most derived metaclass is one which is a\\nsubtype of *all* of these candidate metaclasses. If none of the\\ncandidate metaclasses meets that criterion, then the class definition\\nwill fail with ``TypeError``.\\n\\n\\nPreparing the class namespace\\n-----------------------------\\n\\nOnce the appropriate metaclass has been identified, then the class\\nnamespace is prepared. If the metaclass has a ``__prepare__``\\nattribute, it is called as ``namespace = metaclass.__prepare__(name,\\nbases, **kwds)`` (where the additional keyword arguments, if any, come\\nfrom the class definition).\\n\\nIf the metaclass has no ``__prepare__`` attribute, then the class\\nnamespace is initialised as an empty ``dict()`` instance.\\n\\nSee also:\\n\\n   **PEP 3115** - Metaclasses in Python 3000\\n      Introduced the ``__prepare__`` namespace hook\\n\\n\\nExecuting the class body\\n------------------------\\n\\nThe class body is executed (approximately) as ``exec(body, globals(),\\nnamespace)``. The key difference from a normal call to ``exec()`` is\\nthat lexical scoping allows the class body (including any methods) to\\nreference names from the current and outer scopes when the class\\ndefinition occurs inside a function.\\n\\nHowever, even when the class definition occurs inside the function,\\nmethods defined inside the class still cannot see names defined at the\\nclass scope. Class variables must be accessed through the first\\nparameter of instance or class methods, and cannot be accessed at all\\nfrom static methods.\\n\\n\\nCreating the class object\\n-------------------------\\n\\nOnce the class namespace has been populated by executing the class\\nbody, the class object is created by calling ``metaclass(name, bases,\\nnamespace, **kwds)`` (the additional keywords passed here are the same\\nas those passed to ``__prepare__``).\\n\\nThis class object is the one that will be referenced by the zero-\\nargument form of ``super()``. ``__class__`` is an implicit closure\\nreference created by the compiler if any methods in a class body refer\\nto either ``__class__`` or ``super``. This allows the zero argument\\nform of ``super()`` to correctly identify the class being defined\\nbased on lexical scoping, while the class or instance that was used to\\nmake the current call is identified based on the first argument passed\\nto the method.\\n\\nAfter the class object is created, it is passed to the class\\ndecorators included in the class definition (if any) and the resulting\\nobject is bound in the local namespace as the defined class.\\n\\nSee also:\\n\\n   **PEP 3135** - New super\\n      Describes the implicit ``__class__`` closure reference\\n\\n\\nMetaclass example\\n-----------------\\n\\nThe potential uses for metaclasses are boundless. Some ideas that have\\nbeen explored include logging, interface checking, automatic\\ndelegation, automatic property creation, proxies, frameworks, and\\nautomatic resource locking/synchronization.\\n\\nHere is an example of a metaclass that uses an\\n``collections.OrderedDict`` to remember the order that class members\\nwere defined:\\n\\n   class OrderedClass(type):\\n\\n        @classmethod\\n        def __prepare__(metacls, name, bases, **kwds):\\n           return collections.OrderedDict()\\n\\n        def __new__(cls, name, bases, namespace, **kwds):\\n           result = type.__new__(cls, name, bases, dict(namespace))\\n           result.members = tuple(namespace)\\n           return result\\n\\n   class A(metaclass=OrderedClass):\\n       def one(self): pass\\n       def two(self): pass\\n       def three(self): pass\\n       def four(self): pass\\n\\n   >>> A.members\\n   (\\'__module__\\', \\'one\\', \\'two\\', \\'three\\', \\'four\\')\\n\\nWhen the class definition for *A* gets executed, the process begins\\nwith calling the metaclass\\'s ``__prepare__()`` method which returns an\\nempty ``collections.OrderedDict``.  That mapping records the methods\\nand attributes of *A* as they are defined within the body of the class\\nstatement. Once those definitions are executed, the ordered dictionary\\nis fully populated and the metaclass\\'s ``__new__()`` method gets\\ninvoked.  That method builds the new type and it saves the ordered\\ndictionary keys in an attribute called ``members``.\\n\\n\\nCustomizing instance and subclass checks\\n========================================\\n\\nThe following methods are used to override the default behavior of the\\n``isinstance()`` and ``issubclass()`` built-in functions.\\n\\nIn particular, the metaclass ``abc.ABCMeta`` implements these methods\\nin order to allow the addition of Abstract Base Classes (ABCs) as\\n\"virtual base classes\" to any class or type (including built-in\\ntypes), including other ABCs.\\n\\nclass.__instancecheck__(self, instance)\\n\\n   Return true if *instance* should be considered a (direct or\\n   indirect) instance of *class*. If defined, called to implement\\n   ``isinstance(instance, class)``.\\n\\nclass.__subclasscheck__(self, subclass)\\n\\n   Return true if *subclass* should be considered a (direct or\\n   indirect) subclass of *class*.  If defined, called to implement\\n   ``issubclass(subclass, class)``.\\n\\nNote that these methods are looked up on the type (metaclass) of a\\nclass.  They cannot be defined as class methods in the actual class.\\nThis is consistent with the lookup of special methods that are called\\non instances, only in this case the instance is itself a class.\\n\\nSee also:\\n\\n   **PEP 3119** - Introducing Abstract Base Classes\\n      Includes the specification for customizing ``isinstance()`` and\\n      ``issubclass()`` behavior through ``__instancecheck__()`` and\\n      ``__subclasscheck__()``, with motivation for this functionality\\n      in the context of adding Abstract Base Classes (see the ``abc``\\n      module) to the language.\\n\\n\\nEmulating callable objects\\n==========================\\n\\nobject.__call__(self[, args...])\\n\\n   Called when the instance is \"called\" as a function; if this method\\n   is defined, ``x(arg1, arg2, ...)`` is a shorthand for\\n   ``x.__call__(arg1, arg2, ...)``.\\n\\n\\nEmulating container types\\n=========================\\n\\nThe following methods can be defined to implement container objects.\\nContainers usually are sequences (such as lists or tuples) or mappings\\n(like dictionaries), but can represent other containers as well.  The\\nfirst set of methods is used either to emulate a sequence or to\\nemulate a mapping; the difference is that for a sequence, the\\nallowable keys should be the integers *k* for which ``0 <= k < N``\\nwhere *N* is the length of the sequence, or slice objects, which\\ndefine a range of items.  It is also recommended that mappings provide\\nthe methods ``keys()``, ``values()``, ``items()``, ``get()``,\\n``clear()``, ``setdefault()``, ``pop()``, ``popitem()``, ``copy()``,\\nand ``update()`` behaving similar to those for Python\\'s standard\\ndictionary objects.  The ``collections`` module provides a\\n``MutableMapping`` abstract base class to help create those methods\\nfrom a base set of ``__getitem__()``, ``__setitem__()``,\\n``__delitem__()``, and ``keys()``. Mutable sequences should provide\\nmethods ``append()``, ``count()``, ``index()``, ``extend()``,\\n``insert()``, ``pop()``, ``remove()``, ``reverse()`` and ``sort()``,\\nlike Python standard list objects.  Finally, sequence types should\\nimplement addition (meaning concatenation) and multiplication (meaning\\nrepetition) by defining the methods ``__add__()``, ``__radd__()``,\\n``__iadd__()``, ``__mul__()``, ``__rmul__()`` and ``__imul__()``\\ndescribed below; they should not define other numerical operators.  It\\nis recommended that both mappings and sequences implement the\\n``__contains__()`` method to allow efficient use of the ``in``\\noperator; for mappings, ``in`` should search the mapping\\'s keys; for\\nsequences, it should search through the values.  It is further\\nrecommended that both mappings and sequences implement the\\n``__iter__()`` method to allow efficient iteration through the\\ncontainer; for mappings, ``__iter__()`` should be the same as\\n``keys()``; for sequences, it should iterate through the values.\\n\\nobject.__len__(self)\\n\\n   Called to implement the built-in function ``len()``.  Should return\\n   the length of the object, an integer ``>=`` 0.  Also, an object\\n   that doesn\\'t define a ``__bool__()`` method and whose ``__len__()``\\n   method returns zero is considered to be false in a Boolean context.\\n\\nNote: Slicing is done exclusively with the following three methods.  A\\n  call like\\n\\n     a[1:2] = b\\n\\n  is translated to\\n\\n     a[slice(1, 2, None)] = b\\n\\n  and so forth.  Missing slice items are always filled in with\\n  ``None``.\\n\\nobject.__getitem__(self, key)\\n\\n   Called to implement evaluation of ``self[key]``. For sequence\\n   types, the accepted keys should be integers and slice objects.\\n   Note that the special interpretation of negative indexes (if the\\n   class wishes to emulate a sequence type) is up to the\\n   ``__getitem__()`` method. If *key* is of an inappropriate type,\\n   ``TypeError`` may be raised; if of a value outside the set of\\n   indexes for the sequence (after any special interpretation of\\n   negative values), ``IndexError`` should be raised. For mapping\\n   types, if *key* is missing (not in the container), ``KeyError``\\n   should be raised.\\n\\n   Note: ``for`` loops expect that an ``IndexError`` will be raised for\\n     illegal indexes to allow proper detection of the end of the\\n     sequence.\\n\\nobject.__setitem__(self, key, value)\\n\\n   Called to implement assignment to ``self[key]``.  Same note as for\\n   ``__getitem__()``.  This should only be implemented for mappings if\\n   the objects support changes to the values for keys, or if new keys\\n   can be added, or for sequences if elements can be replaced.  The\\n   same exceptions should be raised for improper *key* values as for\\n   the ``__getitem__()`` method.\\n\\nobject.__delitem__(self, key)\\n\\n   Called to implement deletion of ``self[key]``.  Same note as for\\n   ``__getitem__()``.  This should only be implemented for mappings if\\n   the objects support removal of keys, or for sequences if elements\\n   can be removed from the sequence.  The same exceptions should be\\n   raised for improper *key* values as for the ``__getitem__()``\\n   method.\\n\\nobject.__iter__(self)\\n\\n   This method is called when an iterator is required for a container.\\n   This method should return a new iterator object that can iterate\\n   over all the objects in the container.  For mappings, it should\\n   iterate over the keys of the container, and should also be made\\n   available as the method ``keys()``.\\n\\n   Iterator objects also need to implement this method; they are\\n   required to return themselves.  For more information on iterator\\n   objects, see *Iterator Types*.\\n\\nobject.__reversed__(self)\\n\\n   Called (if present) by the ``reversed()`` built-in to implement\\n   reverse iteration.  It should return a new iterator object that\\n   iterates over all the objects in the container in reverse order.\\n\\n   If the ``__reversed__()`` method is not provided, the\\n   ``reversed()`` built-in will fall back to using the sequence\\n   protocol (``__len__()`` and ``__getitem__()``).  Objects that\\n   support the sequence protocol should only provide\\n   ``__reversed__()`` if they can provide an implementation that is\\n   more efficient than the one provided by ``reversed()``.\\n\\nThe membership test operators (``in`` and ``not in``) are normally\\nimplemented as an iteration through a sequence.  However, container\\nobjects can supply the following special method with a more efficient\\nimplementation, which also does not require the object be a sequence.\\n\\nobject.__contains__(self, item)\\n\\n   Called to implement membership test operators.  Should return true\\n   if *item* is in *self*, false otherwise.  For mapping objects, this\\n   should consider the keys of the mapping rather than the values or\\n   the key-item pairs.\\n\\n   For objects that don\\'t define ``__contains__()``, the membership\\n   test first tries iteration via ``__iter__()``, then the old\\n   sequence iteration protocol via ``__getitem__()``, see *this\\n   section in the language reference*.\\n\\n\\nEmulating numeric types\\n=======================\\n\\nThe following methods can be defined to emulate numeric objects.\\nMethods corresponding to operations that are not supported by the\\nparticular kind of number implemented (e.g., bitwise operations for\\nnon-integral numbers) should be left undefined.\\n\\nobject.__add__(self, other)\\nobject.__sub__(self, other)\\nobject.__mul__(self, other)\\nobject.__truediv__(self, other)\\nobject.__floordiv__(self, other)\\nobject.__mod__(self, other)\\nobject.__divmod__(self, other)\\nobject.__pow__(self, other[, modulo])\\nobject.__lshift__(self, other)\\nobject.__rshift__(self, other)\\nobject.__and__(self, other)\\nobject.__xor__(self, other)\\nobject.__or__(self, other)\\n\\n   These methods are called to implement the binary arithmetic\\n   operations (``+``, ``-``, ``*``, ``/``, ``//``, ``%``,\\n   ``divmod()``, ``pow()``, ``**``, ``<<``, ``>>``, ``&``, ``^``,\\n   ``|``).  For instance, to evaluate the expression ``x + y``, where\\n   *x* is an instance of a class that has an ``__add__()`` method,\\n   ``x.__add__(y)`` is called.  The ``__divmod__()`` method should be\\n   the equivalent to using ``__floordiv__()`` and ``__mod__()``; it\\n   should not be related to ``__truediv__()``.  Note that\\n   ``__pow__()`` should be defined to accept an optional third\\n   argument if the ternary version of the built-in ``pow()`` function\\n   is to be supported.\\n\\n   If one of those methods does not support the operation with the\\n   supplied arguments, it should return ``NotImplemented``.\\n\\nobject.__radd__(self, other)\\nobject.__rsub__(self, other)\\nobject.__rmul__(self, other)\\nobject.__rtruediv__(self, other)\\nobject.__rfloordiv__(self, other)\\nobject.__rmod__(self, other)\\nobject.__rdivmod__(self, other)\\nobject.__rpow__(self, other)\\nobject.__rlshift__(self, other)\\nobject.__rrshift__(self, other)\\nobject.__rand__(self, other)\\nobject.__rxor__(self, other)\\nobject.__ror__(self, other)\\n\\n   These methods are called to implement the binary arithmetic\\n   operations (``+``, ``-``, ``*``, ``/``, ``//``, ``%``,\\n   ``divmod()``, ``pow()``, ``**``, ``<<``, ``>>``, ``&``, ``^``,\\n   ``|``) with reflected (swapped) operands. These functions are only\\n   called if the left operand does not support the corresponding\\n   operation and the operands are of different types. [2]  For\\n   instance, to evaluate the expression ``x - y``, where *y* is an\\n   instance of a class that has an ``__rsub__()`` method,\\n   ``y.__rsub__(x)`` is called if ``x.__sub__(y)`` returns\\n   *NotImplemented*.\\n\\n   Note that ternary ``pow()`` will not try calling ``__rpow__()``\\n   (the coercion rules would become too complicated).\\n\\n   Note: If the right operand\\'s type is a subclass of the left operand\\'s\\n     type and that subclass provides the reflected method for the\\n     operation, this method will be called before the left operand\\'s\\n     non-reflected method.  This behavior allows subclasses to\\n     override their ancestors\\' operations.\\n\\nobject.__iadd__(self, other)\\nobject.__isub__(self, other)\\nobject.__imul__(self, other)\\nobject.__itruediv__(self, other)\\nobject.__ifloordiv__(self, other)\\nobject.__imod__(self, other)\\nobject.__ipow__(self, other[, modulo])\\nobject.__ilshift__(self, other)\\nobject.__irshift__(self, other)\\nobject.__iand__(self, other)\\nobject.__ixor__(self, other)\\nobject.__ior__(self, other)\\n\\n   These methods are called to implement the augmented arithmetic\\n   assignments (``+=``, ``-=``, ``*=``, ``/=``, ``//=``, ``%=``,\\n   ``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``).  These methods\\n   should attempt to do the operation in-place (modifying *self*) and\\n   return the result (which could be, but does not have to be,\\n   *self*).  If a specific method is not defined, the augmented\\n   assignment falls back to the normal methods.  For instance, to\\n   execute the statement ``x += y``, where *x* is an instance of a\\n   class that has an ``__iadd__()`` method, ``x.__iadd__(y)`` is\\n   called.  If *x* is an instance of a class that does not define a\\n   ``__iadd__()`` method, ``x.__add__(y)`` and ``y.__radd__(x)`` are\\n   considered, as with the evaluation of ``x + y``.\\n\\nobject.__neg__(self)\\nobject.__pos__(self)\\nobject.__abs__(self)\\nobject.__invert__(self)\\n\\n   Called to implement the unary arithmetic operations (``-``, ``+``,\\n   ``abs()`` and ``~``).\\n\\nobject.__complex__(self)\\nobject.__int__(self)\\nobject.__float__(self)\\nobject.__round__(self[, n])\\n\\n   Called to implement the built-in functions ``complex()``,\\n   ``int()``, ``float()`` and ``round()``.  Should return a value of\\n   the appropriate type.\\n\\nobject.__index__(self)\\n\\n   Called to implement ``operator.index()``.  Also called whenever\\n   Python needs an integer object (such as in slicing, or in the\\n   built-in ``bin()``, ``hex()`` and ``oct()`` functions). Must return\\n   an integer.\\n\\n\\nWith Statement Context Managers\\n===============================\\n\\nA *context manager* is an object that defines the runtime context to\\nbe established when executing a ``with`` statement. The context\\nmanager handles the entry into, and the exit from, the desired runtime\\ncontext for the execution of the block of code.  Context managers are\\nnormally invoked using the ``with`` statement (described in section\\n*The with statement*), but can also be used by directly invoking their\\nmethods.\\n\\nTypical uses of context managers include saving and restoring various\\nkinds of global state, locking and unlocking resources, closing opened\\nfiles, etc.\\n\\nFor more information on context managers, see *Context Manager Types*.\\n\\nobject.__enter__(self)\\n\\n   Enter the runtime context related to this object. The ``with``\\n   statement will bind this method\\'s return value to the target(s)\\n   specified in the ``as`` clause of the statement, if any.\\n\\nobject.__exit__(self, exc_type, exc_value, traceback)\\n\\n   Exit the runtime context related to this object. The parameters\\n   describe the exception that caused the context to be exited. If the\\n   context was exited without an exception, all three arguments will\\n   be ``None``.\\n\\n   If an exception is supplied, and the method wishes to suppress the\\n   exception (i.e., prevent it from being propagated), it should\\n   return a true value. Otherwise, the exception will be processed\\n   normally upon exit from this method.\\n\\n   Note that ``__exit__()`` methods should not reraise the passed-in\\n   exception; this is the caller\\'s responsibility.\\n\\nSee also:\\n\\n   **PEP 0343** - The \"with\" statement\\n      The specification, background, and examples for the Python\\n      ``with`` statement.\\n\\n\\nSpecial method lookup\\n=====================\\n\\nFor custom classes, implicit invocations of special methods are only\\nguaranteed to work correctly if defined on an object\\'s type, not in\\nthe object\\'s instance dictionary.  That behaviour is the reason why\\nthe following code raises an exception:\\n\\n   >>> class C:\\n   ...     pass\\n   ...\\n   >>> c = C()\\n   >>> c.__len__ = lambda: 5\\n   >>> len(c)\\n   Traceback (most recent call last):\\n     File \"<stdin>\", line 1, in <module>\\n   TypeError: object of type \\'C\\' has no len()\\n\\nThe rationale behind this behaviour lies with a number of special\\nmethods such as ``__hash__()`` and ``__repr__()`` that are implemented\\nby all objects, including type objects. If the implicit lookup of\\nthese methods used the conventional lookup process, they would fail\\nwhen invoked on the type object itself:\\n\\n   >>> 1 .__hash__() == hash(1)\\n   True\\n   >>> int.__hash__() == hash(int)\\n   Traceback (most recent call last):\\n     File \"<stdin>\", line 1, in <module>\\n   TypeError: descriptor \\'__hash__\\' of \\'int\\' object needs an argument\\n\\nIncorrectly attempting to invoke an unbound method of a class in this\\nway is sometimes referred to as \\'metaclass confusion\\', and is avoided\\nby bypassing the instance when looking up special methods:\\n\\n   >>> type(1).__hash__(1) == hash(1)\\n   True\\n   >>> type(int).__hash__(int) == hash(int)\\n   True\\n\\nIn addition to bypassing any instance attributes in the interest of\\ncorrectness, implicit special method lookup generally also bypasses\\nthe ``__getattribute__()`` method even of the object\\'s metaclass:\\n\\n   >>> class Meta(type):\\n   ...    def __getattribute__(*args):\\n   ...       print(\"Metaclass getattribute invoked\")\\n   ...       return type.__getattribute__(*args)\\n   ...\\n   >>> class C(object, metaclass=Meta):\\n   ...     def __len__(self):\\n   ...         return 10\\n   ...     def __getattribute__(*args):\\n   ...         print(\"Class getattribute invoked\")\\n   ...         return object.__getattribute__(*args)\\n   ...\\n   >>> c = C()\\n   >>> c.__len__()                 # Explicit lookup via instance\\n   Class getattribute invoked\\n   10\\n   >>> type(c).__len__(c)          # Explicit lookup via type\\n   Metaclass getattribute invoked\\n   10\\n   >>> len(c)                      # Implicit lookup\\n   10\\n\\nBypassing the ``__getattribute__()`` machinery in this fashion\\nprovides significant scope for speed optimisations within the\\ninterpreter, at the cost of some flexibility in the handling of\\nspecial methods (the special method *must* be set on the class object\\nitself in order to be consistently invoked by the interpreter).\\n\\n-[ Footnotes ]-\\n\\n[1] It *is* possible in some cases to change an object\\'s type, under\\n    certain controlled conditions. It generally isn\\'t a good idea\\n    though, since it can lead to some very strange behaviour if it is\\n    handled incorrectly.\\n\\n[2] For operands of the same type, it is assumed that if the non-\\n    reflected method (such as ``__add__()``) fails the operation is\\n    not supported, which is why the reflected method is not called.\\n',\n'string-methods': '\\nString Methods\\n**************\\n\\nStrings implement all of the *common* sequence operations, along with\\nthe additional methods described below.\\n\\nStrings also support two styles of string formatting, one providing a\\nlarge degree of flexibility and customization (see ``str.format()``,\\n*Format String Syntax* and *String Formatting*) and the other based on\\nC ``printf`` style formatting that handles a narrower range of types\\nand is slightly harder to use correctly, but is often faster for the\\ncases it can handle (*printf-style String Formatting*).\\n\\nThe *Text Processing Services* section of the standard library covers\\na number of other modules that provide various text related utilities\\n(including regular expression support in the ``re`` module).\\n\\nstr.capitalize()\\n\\n   Return a copy of the string with its first character capitalized\\n   and the rest lowercased.\\n\\nstr.casefold()\\n\\n   Return a casefolded copy of the string. Casefolded strings may be\\n   used for caseless matching.\\n\\n   Casefolding is similar to lowercasing but more aggressive because\\n   it is intended to remove all case distinctions in a string. For\\n   example, the German lowercase letter ``\\'\\xc3\\x9f\\'`` is equivalent to\\n   ``\"ss\"``. Since it is already lowercase, ``lower()`` would do\\n   nothing to ``\\'\\xc3\\x9f\\'``; ``casefold()`` converts it to ``\"ss\"``.\\n\\n   The casefolding algorithm is described in section 3.13 of the\\n   Unicode Standard.\\n\\n   New in version 3.3.\\n\\nstr.center(width[, fillchar])\\n\\n   Return centered in a string of length *width*. Padding is done\\n   using the specified *fillchar* (default is a space).\\n\\nstr.count(sub[, start[, end]])\\n\\n   Return the number of non-overlapping occurrences of substring *sub*\\n   in the range [*start*, *end*].  Optional arguments *start* and\\n   *end* are interpreted as in slice notation.\\n\\nstr.encode(encoding=\"utf-8\", errors=\"strict\")\\n\\n   Return an encoded version of the string as a bytes object. Default\\n   encoding is ``\\'utf-8\\'``. *errors* may be given to set a different\\n   error handling scheme. The default for *errors* is ``\\'strict\\'``,\\n   meaning that encoding errors raise a ``UnicodeError``. Other\\n   possible values are ``\\'ignore\\'``, ``\\'replace\\'``,\\n   ``\\'xmlcharrefreplace\\'``, ``\\'backslashreplace\\'`` and any other name\\n   registered via ``codecs.register_error()``, see section *Codec Base\\n   Classes*. For a list of possible encodings, see section *Standard\\n   Encodings*.\\n\\n   Changed in version 3.1: Support for keyword arguments added.\\n\\nstr.endswith(suffix[, start[, end]])\\n\\n   Return ``True`` if the string ends with the specified *suffix*,\\n   otherwise return ``False``.  *suffix* can also be a tuple of\\n   suffixes to look for.  With optional *start*, test beginning at\\n   that position.  With optional *end*, stop comparing at that\\n   position.\\n\\nstr.expandtabs([tabsize])\\n\\n   Return a copy of the string where all tab characters are replaced\\n   by zero or more spaces, depending on the current column and the\\n   given tab size.  The column number is reset to zero after each\\n   newline occurring in the string. If *tabsize* is not given, a tab\\n   size of ``8`` characters is assumed.  This doesn\\'t understand other\\n   non-printing characters or escape sequences.\\n\\nstr.find(sub[, start[, end]])\\n\\n   Return the lowest index in the string where substring *sub* is\\n   found, such that *sub* is contained in the slice ``s[start:end]``.\\n   Optional arguments *start* and *end* are interpreted as in slice\\n   notation.  Return ``-1`` if *sub* is not found.\\n\\n   Note: The ``find()`` method should be used only if you need to know the\\n     position of *sub*.  To check if *sub* is a substring or not, use\\n     the ``in`` operator:\\n\\n        >>> \\'Py\\' in \\'Python\\'\\n        True\\n\\nstr.format(*args, **kwargs)\\n\\n   Perform a string formatting operation.  The string on which this\\n   method is called can contain literal text or replacement fields\\n   delimited by braces ``{}``.  Each replacement field contains either\\n   the numeric index of a positional argument, or the name of a\\n   keyword argument.  Returns a copy of the string where each\\n   replacement field is replaced with the string value of the\\n   corresponding argument.\\n\\n   >>> \"The sum of 1 + 2 is {0}\".format(1+2)\\n   \\'The sum of 1 + 2 is 3\\'\\n\\n   See *Format String Syntax* for a description of the various\\n   formatting options that can be specified in format strings.\\n\\nstr.format_map(mapping)\\n\\n   Similar to ``str.format(**mapping)``, except that ``mapping`` is\\n   used directly and not copied to a ``dict`` .  This is useful if for\\n   example ``mapping`` is a dict subclass:\\n\\n   >>> class Default(dict):\\n   ...     def __missing__(self, key):\\n   ...         return key\\n   ...\\n   >>> \\'{name} was born in {country}\\'.format_map(Default(name=\\'Guido\\'))\\n   \\'Guido was born in country\\'\\n\\n   New in version 3.2.\\n\\nstr.index(sub[, start[, end]])\\n\\n   Like ``find()``, but raise ``ValueError`` when the substring is not\\n   found.\\n\\nstr.isalnum()\\n\\n   Return true if all characters in the string are alphanumeric and\\n   there is at least one character, false otherwise.  A character\\n   ``c`` is alphanumeric if one of the following returns ``True``:\\n   ``c.isalpha()``, ``c.isdecimal()``, ``c.isdigit()``, or\\n   ``c.isnumeric()``.\\n\\nstr.isalpha()\\n\\n   Return true if all characters in the string are alphabetic and\\n   there is at least one character, false otherwise.  Alphabetic\\n   characters are those characters defined in the Unicode character\\n   database as \"Letter\", i.e., those with general category property\\n   being one of \"Lm\", \"Lt\", \"Lu\", \"Ll\", or \"Lo\".  Note that this is\\n   different from the \"Alphabetic\" property defined in the Unicode\\n   Standard.\\n\\nstr.isdecimal()\\n\\n   Return true if all characters in the string are decimal characters\\n   and there is at least one character, false otherwise. Decimal\\n   characters are those from general category \"Nd\". This category\\n   includes digit characters, and all characters that can be used to\\n   form decimal-radix numbers, e.g. U+0660, ARABIC-INDIC DIGIT ZERO.\\n\\nstr.isdigit()\\n\\n   Return true if all characters in the string are digits and there is\\n   at least one character, false otherwise.  Digits include decimal\\n   characters and digits that need special handling, such as the\\n   compatibility superscript digits.  Formally, a digit is a character\\n   that has the property value Numeric_Type=Digit or\\n   Numeric_Type=Decimal.\\n\\nstr.isidentifier()\\n\\n   Return true if the string is a valid identifier according to the\\n   language definition, section *Identifiers and keywords*.\\n\\nstr.islower()\\n\\n   Return true if all cased characters [4] in the string are lowercase\\n   and there is at least one cased character, false otherwise.\\n\\nstr.isnumeric()\\n\\n   Return true if all characters in the string are numeric characters,\\n   and there is at least one character, false otherwise. Numeric\\n   characters include digit characters, and all characters that have\\n   the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION\\n   ONE FIFTH.  Formally, numeric characters are those with the\\n   property value Numeric_Type=Digit, Numeric_Type=Decimal or\\n   Numeric_Type=Numeric.\\n\\nstr.isprintable()\\n\\n   Return true if all characters in the string are printable or the\\n   string is empty, false otherwise.  Nonprintable characters are\\n   those characters defined in the Unicode character database as\\n   \"Other\" or \"Separator\", excepting the ASCII space (0x20) which is\\n   considered printable.  (Note that printable characters in this\\n   context are those which should not be escaped when ``repr()`` is\\n   invoked on a string.  It has no bearing on the handling of strings\\n   written to ``sys.stdout`` or ``sys.stderr``.)\\n\\nstr.isspace()\\n\\n   Return true if there are only whitespace characters in the string\\n   and there is at least one character, false otherwise.  Whitespace\\n   characters  are those characters defined in the Unicode character\\n   database as \"Other\" or \"Separator\" and those with bidirectional\\n   property being one of \"WS\", \"B\", or \"S\".\\n\\nstr.istitle()\\n\\n   Return true if the string is a titlecased string and there is at\\n   least one character, for example uppercase characters may only\\n   follow uncased characters and lowercase characters only cased ones.\\n   Return false otherwise.\\n\\nstr.isupper()\\n\\n   Return true if all cased characters [4] in the string are uppercase\\n   and there is at least one cased character, false otherwise.\\n\\nstr.join(iterable)\\n\\n   Return a string which is the concatenation of the strings in the\\n   *iterable* *iterable*.  A ``TypeError`` will be raised if there are\\n   any non-string values in *iterable*, including ``bytes`` objects.\\n   The separator between elements is the string providing this method.\\n\\nstr.ljust(width[, fillchar])\\n\\n   Return the string left justified in a string of length *width*.\\n   Padding is done using the specified *fillchar* (default is a\\n   space).  The original string is returned if *width* is less than or\\n   equal to ``len(s)``.\\n\\nstr.lower()\\n\\n   Return a copy of the string with all the cased characters [4]\\n   converted to lowercase.\\n\\n   The lowercasing algorithm used is described in section 3.13 of the\\n   Unicode Standard.\\n\\nstr.lstrip([chars])\\n\\n   Return a copy of the string with leading characters removed.  The\\n   *chars* argument is a string specifying the set of characters to be\\n   removed.  If omitted or ``None``, the *chars* argument defaults to\\n   removing whitespace.  The *chars* argument is not a prefix; rather,\\n   all combinations of its values are stripped:\\n\\n   >>> \\'   spacious   \\'.lstrip()\\n   \\'spacious   \\'\\n   >>> \\'www.example.com\\'.lstrip(\\'cmowz.\\')\\n   \\'example.com\\'\\n\\nstatic str.maketrans(x[, y[, z]])\\n\\n   This static method returns a translation table usable for\\n   ``str.translate()``.\\n\\n   If there is only one argument, it must be a dictionary mapping\\n   Unicode ordinals (integers) or characters (strings of length 1) to\\n   Unicode ordinals, strings (of arbitrary lengths) or None.\\n   Character keys will then be converted to ordinals.\\n\\n   If there are two arguments, they must be strings of equal length,\\n   and in the resulting dictionary, each character in x will be mapped\\n   to the character at the same position in y.  If there is a third\\n   argument, it must be a string, whose characters will be mapped to\\n   None in the result.\\n\\nstr.partition(sep)\\n\\n   Split the string at the first occurrence of *sep*, and return a\\n   3-tuple containing the part before the separator, the separator\\n   itself, and the part after the separator.  If the separator is not\\n   found, return a 3-tuple containing the string itself, followed by\\n   two empty strings.\\n\\nstr.replace(old, new[, count])\\n\\n   Return a copy of the string with all occurrences of substring *old*\\n   replaced by *new*.  If the optional argument *count* is given, only\\n   the first *count* occurrences are replaced.\\n\\nstr.rfind(sub[, start[, end]])\\n\\n   Return the highest index in the string where substring *sub* is\\n   found, such that *sub* is contained within ``s[start:end]``.\\n   Optional arguments *start* and *end* are interpreted as in slice\\n   notation.  Return ``-1`` on failure.\\n\\nstr.rindex(sub[, start[, end]])\\n\\n   Like ``rfind()`` but raises ``ValueError`` when the substring *sub*\\n   is not found.\\n\\nstr.rjust(width[, fillchar])\\n\\n   Return the string right justified in a string of length *width*.\\n   Padding is done using the specified *fillchar* (default is a\\n   space). The original string is returned if *width* is less than or\\n   equal to ``len(s)``.\\n\\nstr.rpartition(sep)\\n\\n   Split the string at the last occurrence of *sep*, and return a\\n   3-tuple containing the part before the separator, the separator\\n   itself, and the part after the separator.  If the separator is not\\n   found, return a 3-tuple containing two empty strings, followed by\\n   the string itself.\\n\\nstr.rsplit(sep=None, maxsplit=-1)\\n\\n   Return a list of the words in the string, using *sep* as the\\n   delimiter string. If *maxsplit* is given, at most *maxsplit* splits\\n   are done, the *rightmost* ones.  If *sep* is not specified or\\n   ``None``, any whitespace string is a separator.  Except for\\n   splitting from the right, ``rsplit()`` behaves like ``split()``\\n   which is described in detail below.\\n\\nstr.rstrip([chars])\\n\\n   Return a copy of the string with trailing characters removed.  The\\n   *chars* argument is a string specifying the set of characters to be\\n   removed.  If omitted or ``None``, the *chars* argument defaults to\\n   removing whitespace.  The *chars* argument is not a suffix; rather,\\n   all combinations of its values are stripped:\\n\\n   >>> \\'   spacious   \\'.rstrip()\\n   \\'   spacious\\'\\n   >>> \\'mississippi\\'.rstrip(\\'ipz\\')\\n   \\'mississ\\'\\n\\nstr.split(sep=None, maxsplit=-1)\\n\\n   Return a list of the words in the string, using *sep* as the\\n   delimiter string.  If *maxsplit* is given, at most *maxsplit*\\n   splits are done (thus, the list will have at most ``maxsplit+1``\\n   elements).  If *maxsplit* is not specified or ``-1``, then there is\\n   no limit on the number of splits (all possible splits are made).\\n\\n   If *sep* is given, consecutive delimiters are not grouped together\\n   and are deemed to delimit empty strings (for example,\\n   ``\\'1,,2\\'.split(\\',\\')`` returns ``[\\'1\\', \\'\\', \\'2\\']``).  The *sep*\\n   argument may consist of multiple characters (for example,\\n   ``\\'1<>2<>3\\'.split(\\'<>\\')`` returns ``[\\'1\\', \\'2\\', \\'3\\']``). Splitting\\n   an empty string with a specified separator returns ``[\\'\\']``.\\n\\n   If *sep* is not specified or is ``None``, a different splitting\\n   algorithm is applied: runs of consecutive whitespace are regarded\\n   as a single separator, and the result will contain no empty strings\\n   at the start or end if the string has leading or trailing\\n   whitespace.  Consequently, splitting an empty string or a string\\n   consisting of just whitespace with a ``None`` separator returns\\n   ``[]``.\\n\\n   For example, ``\\' 1  2   3  \\'.split()`` returns ``[\\'1\\', \\'2\\', \\'3\\']``,\\n   and ``\\'  1  2   3  \\'.split(None, 1)`` returns ``[\\'1\\', \\'2   3  \\']``.\\n\\nstr.splitlines([keepends])\\n\\n   Return a list of the lines in the string, breaking at line\\n   boundaries. This method uses the *universal newlines* approach to\\n   splitting lines. Line breaks are not included in the resulting list\\n   unless *keepends* is given and true.\\n\\n   For example, ``\\'ab c\\\\n\\\\nde fg\\\\rkl\\\\r\\\\n\\'.splitlines()`` returns\\n   ``[\\'ab c\\', \\'\\', \\'de fg\\', \\'kl\\']``, while the same call with\\n   ``splitlines(True)`` returns ``[\\'ab c\\\\n\\', \\'\\\\n\\', \\'de fg\\\\r\\',\\n   \\'kl\\\\r\\\\n\\']``.\\n\\n   Unlike ``split()`` when a delimiter string *sep* is given, this\\n   method returns an empty list for the empty string, and a terminal\\n   line break does not result in an extra line.\\n\\nstr.startswith(prefix[, start[, end]])\\n\\n   Return ``True`` if string starts with the *prefix*, otherwise\\n   return ``False``. *prefix* can also be a tuple of prefixes to look\\n   for.  With optional *start*, test string beginning at that\\n   position.  With optional *end*, stop comparing string at that\\n   position.\\n\\nstr.strip([chars])\\n\\n   Return a copy of the string with the leading and trailing\\n   characters removed. The *chars* argument is a string specifying the\\n   set of characters to be removed. If omitted or ``None``, the\\n   *chars* argument defaults to removing whitespace. The *chars*\\n   argument is not a prefix or suffix; rather, all combinations of its\\n   values are stripped:\\n\\n   >>> \\'   spacious   \\'.strip()\\n   \\'spacious\\'\\n   >>> \\'www.example.com\\'.strip(\\'cmowz.\\')\\n   \\'example\\'\\n\\nstr.swapcase()\\n\\n   Return a copy of the string with uppercase characters converted to\\n   lowercase and vice versa. Note that it is not necessarily true that\\n   ``s.swapcase().swapcase() == s``.\\n\\nstr.title()\\n\\n   Return a titlecased version of the string where words start with an\\n   uppercase character and the remaining characters are lowercase.\\n\\n   The algorithm uses a simple language-independent definition of a\\n   word as groups of consecutive letters.  The definition works in\\n   many contexts but it means that apostrophes in contractions and\\n   possessives form word boundaries, which may not be the desired\\n   result:\\n\\n      >>> \"they\\'re bill\\'s friends from the UK\".title()\\n      \"They\\'Re Bill\\'S Friends From The Uk\"\\n\\n   A workaround for apostrophes can be constructed using regular\\n   expressions:\\n\\n      >>> import re\\n      >>> def titlecase(s):\\n      ...     return re.sub(r\"[A-Za-z]+(\\'[A-Za-z]+)?\",\\n      ...                   lambda mo: mo.group(0)[0].upper() +\\n      ...                              mo.group(0)[1:].lower(),\\n      ...                   s)\\n      ...\\n      >>> titlecase(\"they\\'re bill\\'s friends.\")\\n      \"They\\'re Bill\\'s Friends.\"\\n\\nstr.translate(map)\\n\\n   Return a copy of the *s* where all characters have been mapped\\n   through the *map* which must be a dictionary of Unicode ordinals\\n   (integers) to Unicode ordinals, strings or ``None``.  Unmapped\\n   characters are left untouched. Characters mapped to ``None`` are\\n   deleted.\\n\\n   You can use ``str.maketrans()`` to create a translation map from\\n   character-to-character mappings in different formats.\\n\\n   Note: An even more flexible approach is to create a custom character\\n     mapping codec using the ``codecs`` module (see\\n     ``encodings.cp1251`` for an example).\\n\\nstr.upper()\\n\\n   Return a copy of the string with all the cased characters [4]\\n   converted to uppercase.  Note that ``str.upper().isupper()`` might\\n   be ``False`` if ``s`` contains uncased characters or if the Unicode\\n   category of the resulting character(s) is not \"Lu\" (Letter,\\n   uppercase), but e.g. \"Lt\" (Letter, titlecase).\\n\\n   The uppercasing algorithm used is described in section 3.13 of the\\n   Unicode Standard.\\n\\nstr.zfill(width)\\n\\n   Return the numeric string left filled with zeros in a string of\\n   length *width*.  A sign prefix is handled correctly.  The original\\n   string is returned if *width* is less than or equal to ``len(s)``.\\n',\n'strings': '\\nString and Bytes literals\\n*************************\\n\\nString literals are described by the following lexical definitions:\\n\\n   stringliteral   ::= [stringprefix](shortstring | longstring)\\n   stringprefix    ::= \"r\" | \"u\" | \"R\" | \"U\"\\n   shortstring     ::= \"\\'\" shortstringitem* \"\\'\" | \\'\"\\' shortstringitem* \\'\"\\'\\n   longstring      ::= \"\\'\\'\\'\" longstringitem* \"\\'\\'\\'\" | \\'\"\"\"\\' longstringitem* \\'\"\"\"\\'\\n   shortstringitem ::= shortstringchar | stringescapeseq\\n   longstringitem  ::= longstringchar | stringescapeseq\\n   shortstringchar ::= <any source character except \"\\\\\" or newline or the quote>\\n   longstringchar  ::= <any source character except \"\\\\\">\\n   stringescapeseq ::= \"\\\\\" <any source character>\\n\\n   bytesliteral   ::= bytesprefix(shortbytes | longbytes)\\n   bytesprefix    ::= \"b\" | \"B\" | \"br\" | \"Br\" | \"bR\" | \"BR\" | \"rb\" | \"rB\" | \"Rb\" | \"RB\"\\n   shortbytes     ::= \"\\'\" shortbytesitem* \"\\'\" | \\'\"\\' shortbytesitem* \\'\"\\'\\n   longbytes      ::= \"\\'\\'\\'\" longbytesitem* \"\\'\\'\\'\" | \\'\"\"\"\\' longbytesitem* \\'\"\"\"\\'\\n   shortbytesitem ::= shortbyteschar | bytesescapeseq\\n   longbytesitem  ::= longbyteschar | bytesescapeseq\\n   shortbyteschar ::= <any ASCII character except \"\\\\\" or newline or the quote>\\n   longbyteschar  ::= <any ASCII character except \"\\\\\">\\n   bytesescapeseq ::= \"\\\\\" <any ASCII character>\\n\\nOne syntactic restriction not indicated by these productions is that\\nwhitespace is not allowed between the ``stringprefix`` or\\n``bytesprefix`` and the rest of the literal. The source character set\\nis defined by the encoding declaration; it is UTF-8 if no encoding\\ndeclaration is given in the source file; see section *Encoding\\ndeclarations*.\\n\\nIn plain English: Both types of literals can be enclosed in matching\\nsingle quotes (``\\'``) or double quotes (``\"``).  They can also be\\nenclosed in matching groups of three single or double quotes (these\\nare generally referred to as *triple-quoted strings*).  The backslash\\n(``\\\\``) character is used to escape characters that otherwise have a\\nspecial meaning, such as newline, backslash itself, or the quote\\ncharacter.\\n\\nBytes literals are always prefixed with ``\\'b\\'`` or ``\\'B\\'``; they\\nproduce an instance of the ``bytes`` type instead of the ``str`` type.\\nThey may only contain ASCII characters; bytes with a numeric value of\\n128 or greater must be expressed with escapes.\\n\\nAs of Python 3.3 it is possible again to prefix unicode strings with a\\n``u`` prefix to simplify maintenance of dual 2.x and 3.x codebases.\\n\\nBoth string and bytes literals may optionally be prefixed with a\\nletter ``\\'r\\'`` or ``\\'R\\'``; such strings are called *raw strings* and\\ntreat backslashes as literal characters.  As a result, in string\\nliterals, ``\\'\\\\U\\'`` and ``\\'\\\\u\\'`` escapes in raw strings are not treated\\nspecially. Given that Python 2.x\\'s raw unicode literals behave\\ndifferently than Python 3.x\\'s the ``\\'ur\\'`` syntax is not supported.\\n\\n   New in version 3.3: The ``\\'rb\\'`` prefix of raw bytes literals has\\n   been added as a synonym of ``\\'br\\'``.\\n\\n   New in version 3.3: Support for the unicode legacy literal\\n   (``u\\'value\\'``) was reintroduced to simplify the maintenance of dual\\n   Python 2.x and 3.x codebases. See **PEP 414** for more information.\\n\\nIn triple-quoted strings, unescaped newlines and quotes are allowed\\n(and are retained), except that three unescaped quotes in a row\\nterminate the string.  (A \"quote\" is the character used to open the\\nstring, i.e. either ``\\'`` or ``\"``.)\\n\\nUnless an ``\\'r\\'`` or ``\\'R\\'`` prefix is present, escape sequences in\\nstrings are interpreted according to rules similar to those used by\\nStandard C.  The recognized escape sequences are:\\n\\n+-------------------+-----------------------------------+---------+\\n| Escape Sequence   | Meaning                           | Notes   |\\n+===================+===================================+=========+\\n| ``\\\\newline``      | Backslash and newline ignored     |         |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\\\\\``            | Backslash (``\\\\``)                 |         |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\\\'``            | Single quote (``\\'``)              |         |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\\"``            | Double quote (``\"``)              |         |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\a``            | ASCII Bell (BEL)                  |         |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\b``            | ASCII Backspace (BS)              |         |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\f``            | ASCII Formfeed (FF)               |         |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\n``            | ASCII Linefeed (LF)               |         |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\r``            | ASCII Carriage Return (CR)        |         |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\t``            | ASCII Horizontal Tab (TAB)        |         |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\v``            | ASCII Vertical Tab (VT)           |         |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\ooo``          | Character with octal value *ooo*  | (1,3)   |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\xhh``          | Character with hex value *hh*     | (2,3)   |\\n+-------------------+-----------------------------------+---------+\\n\\nEscape sequences only recognized in string literals are:\\n\\n+-------------------+-----------------------------------+---------+\\n| Escape Sequence   | Meaning                           | Notes   |\\n+===================+===================================+=========+\\n| ``\\\\N{name}``      | Character named *name* in the     | (4)     |\\n|                   | Unicode database                  |         |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\uxxxx``        | Character with 16-bit hex value   | (5)     |\\n|                   | *xxxx*                            |         |\\n+-------------------+-----------------------------------+---------+\\n| ``\\\\Uxxxxxxxx``    | Character with 32-bit hex value   | (6)     |\\n|                   | *xxxxxxxx*                        |         |\\n+-------------------+-----------------------------------+---------+\\n\\nNotes:\\n\\n1. As in Standard C, up to three octal digits are accepted.\\n\\n2. Unlike in Standard C, exactly two hex digits are required.\\n\\n3. In a bytes literal, hexadecimal and octal escapes denote the byte\\n   with the given value. In a string literal, these escapes denote a\\n   Unicode character with the given value.\\n\\n4. Changed in version 3.3: Support for name aliases [1] has been\\n   added.\\n\\n5. Individual code units which form parts of a surrogate pair can be\\n   encoded using this escape sequence.  Exactly four hex digits are\\n   required.\\n\\n6. Any Unicode character can be encoded this way.  Exactly eight hex\\n   digits are required.\\n\\nUnlike Standard C, all unrecognized escape sequences are left in the\\nstring unchanged, i.e., *the backslash is left in the string*.  (This\\nbehavior is useful when debugging: if an escape sequence is mistyped,\\nthe resulting output is more easily recognized as broken.)  It is also\\nimportant to note that the escape sequences only recognized in string\\nliterals fall into the category of unrecognized escapes for bytes\\nliterals.\\n\\nEven in a raw string, string quotes can be escaped with a backslash,\\nbut the backslash remains in the string; for example, ``r\"\\\\\"\"`` is a\\nvalid string literal consisting of two characters: a backslash and a\\ndouble quote; ``r\"\\\\\"`` is not a valid string literal (even a raw\\nstring cannot end in an odd number of backslashes).  Specifically, *a\\nraw string cannot end in a single backslash* (since the backslash\\nwould escape the following quote character).  Note also that a single\\nbackslash followed by a newline is interpreted as those two characters\\nas part of the string, *not* as a line continuation.\\n',\n'subscriptions': '\\nSubscriptions\\n*************\\n\\nA subscription selects an item of a sequence (string, tuple or list)\\nor mapping (dictionary) object:\\n\\n   subscription ::= primary \"[\" expression_list \"]\"\\n\\nThe primary must evaluate to an object that supports subscription,\\ne.g. a list or dictionary.  User-defined objects can support\\nsubscription by defining a ``__getitem__()`` method.\\n\\nFor built-in objects, there are two types of objects that support\\nsubscription:\\n\\nIf the primary is a mapping, the expression list must evaluate to an\\nobject whose value is one of the keys of the mapping, and the\\nsubscription selects the value in the mapping that corresponds to that\\nkey.  (The expression list is a tuple except if it has exactly one\\nitem.)\\n\\nIf the primary is a sequence, the expression (list) must evaluate to\\nan integer or a slice (as discussed in the following section).\\n\\nThe formal syntax makes no special provision for negative indices in\\nsequences; however, built-in sequences all provide a ``__getitem__()``\\nmethod that interprets negative indices by adding the length of the\\nsequence to the index (so that ``x[-1]`` selects the last item of\\n``x``).  The resulting value must be a nonnegative integer less than\\nthe number of items in the sequence, and the subscription selects the\\nitem whose index is that value (counting from zero). Since the support\\nfor negative indices and slicing occurs in the object\\'s\\n``__getitem__()`` method, subclasses overriding this method will need\\nto explicitly add that support.\\n\\nA string\\'s items are characters.  A character is not a separate data\\ntype but a string of exactly one character.\\n',\n'truth': \"\\nTruth Value Testing\\n*******************\\n\\nAny object can be tested for truth value, for use in an ``if`` or\\n``while`` condition or as operand of the Boolean operations below. The\\nfollowing values are considered false:\\n\\n* ``None``\\n\\n* ``False``\\n\\n* zero of any numeric type, for example, ``0``, ``0.0``, ``0j``.\\n\\n* any empty sequence, for example, ``''``, ``()``, ``[]``.\\n\\n* any empty mapping, for example, ``{}``.\\n\\n* instances of user-defined classes, if the class defines a\\n  ``__bool__()`` or ``__len__()`` method, when that method returns the\\n  integer zero or ``bool`` value ``False``. [1]\\n\\nAll other values are considered true --- so objects of many types are\\nalways true.\\n\\nOperations and built-in functions that have a Boolean result always\\nreturn ``0`` or ``False`` for false and ``1`` or ``True`` for true,\\nunless otherwise stated. (Important exception: the Boolean operations\\n``or`` and ``and`` always return one of their operands.)\\n\",\n'try': '\\nThe ``try`` statement\\n*********************\\n\\nThe ``try`` statement specifies exception handlers and/or cleanup code\\nfor a group of statements:\\n\\n   try_stmt  ::= try1_stmt | try2_stmt\\n   try1_stmt ::= \"try\" \":\" suite\\n                 (\"except\" [expression [\"as\" target]] \":\" suite)+\\n                 [\"else\" \":\" suite]\\n                 [\"finally\" \":\" suite]\\n   try2_stmt ::= \"try\" \":\" suite\\n                 \"finally\" \":\" suite\\n\\nThe ``except`` clause(s) specify one or more exception handlers. When\\nno exception occurs in the ``try`` clause, no exception handler is\\nexecuted. When an exception occurs in the ``try`` suite, a search for\\nan exception handler is started.  This search inspects the except\\nclauses in turn until one is found that matches the exception.  An\\nexpression-less except clause, if present, must be last; it matches\\nany exception.  For an except clause with an expression, that\\nexpression is evaluated, and the clause matches the exception if the\\nresulting object is \"compatible\" with the exception.  An object is\\ncompatible with an exception if it is the class or a base class of the\\nexception object or a tuple containing an item compatible with the\\nexception.\\n\\nIf no except clause matches the exception, the search for an exception\\nhandler continues in the surrounding code and on the invocation stack.\\n[1]\\n\\nIf the evaluation of an expression in the header of an except clause\\nraises an exception, the original search for a handler is canceled and\\na search starts for the new exception in the surrounding code and on\\nthe call stack (it is treated as if the entire ``try`` statement\\nraised the exception).\\n\\nWhen a matching except clause is found, the exception is assigned to\\nthe target specified after the ``as`` keyword in that except clause,\\nif present, and the except clause\\'s suite is executed.  All except\\nclauses must have an executable block.  When the end of this block is\\nreached, execution continues normally after the entire try statement.\\n(This means that if two nested handlers exist for the same exception,\\nand the exception occurs in the try clause of the inner handler, the\\nouter handler will not handle the exception.)\\n\\nWhen an exception has been assigned using ``as target``, it is cleared\\nat the end of the except clause.  This is as if\\n\\n   except E as N:\\n       foo\\n\\nwas translated to\\n\\n   except E as N:\\n       try:\\n           foo\\n       finally:\\n           del N\\n\\nThis means the exception must be assigned to a different name to be\\nable to refer to it after the except clause.  Exceptions are cleared\\nbecause with the traceback attached to them, they form a reference\\ncycle with the stack frame, keeping all locals in that frame alive\\nuntil the next garbage collection occurs.\\n\\nBefore an except clause\\'s suite is executed, details about the\\nexception are stored in the ``sys`` module and can be access via\\n``sys.exc_info()``. ``sys.exc_info()`` returns a 3-tuple consisting of\\nthe exception class, the exception instance and a traceback object\\n(see section *The standard type hierarchy*) identifying the point in\\nthe program where the exception occurred.  ``sys.exc_info()`` values\\nare restored to their previous values (before the call) when returning\\nfrom a function that handled an exception.\\n\\nThe optional ``else`` clause is executed if and when control flows off\\nthe end of the ``try`` clause. [2] Exceptions in the ``else`` clause\\nare not handled by the preceding ``except`` clauses.\\n\\nIf ``finally`` is present, it specifies a \\'cleanup\\' handler.  The\\n``try`` clause is executed, including any ``except`` and ``else``\\nclauses.  If an exception occurs in any of the clauses and is not\\nhandled, the exception is temporarily saved. The ``finally`` clause is\\nexecuted.  If there is a saved exception it is re-raised at the end of\\nthe ``finally`` clause.  If the ``finally`` clause raises another\\nexception, the saved exception is set as the context of the new\\nexception. If the ``finally`` clause executes a ``return`` or\\n``break`` statement, the saved exception is discarded:\\n\\n   def f():\\n       try:\\n           1/0\\n       finally:\\n           return 42\\n\\n   >>> f()\\n   42\\n\\nThe exception information is not available to the program during\\nexecution of the ``finally`` clause.\\n\\nWhen a ``return``, ``break`` or ``continue`` statement is executed in\\nthe ``try`` suite of a ``try``...``finally`` statement, the\\n``finally`` clause is also executed \\'on the way out.\\' A ``continue``\\nstatement is illegal in the ``finally`` clause. (The reason is a\\nproblem with the current implementation --- this restriction may be\\nlifted in the future).\\n\\nAdditional information on exceptions can be found in section\\n*Exceptions*, and information on using the ``raise`` statement to\\ngenerate exceptions may be found in section *The raise statement*.\\n',\n'types': '\\nThe standard type hierarchy\\n***************************\\n\\nBelow is a list of the types that are built into Python.  Extension\\nmodules (written in C, Java, or other languages, depending on the\\nimplementation) can define additional types.  Future versions of\\nPython may add types to the type hierarchy (e.g., rational numbers,\\nefficiently stored arrays of integers, etc.), although such additions\\nwill often be provided via the standard library instead.\\n\\nSome of the type descriptions below contain a paragraph listing\\n\\'special attributes.\\'  These are attributes that provide access to the\\nimplementation and are not intended for general use.  Their definition\\nmay change in the future.\\n\\nNone\\n   This type has a single value.  There is a single object with this\\n   value. This object is accessed through the built-in name ``None``.\\n   It is used to signify the absence of a value in many situations,\\n   e.g., it is returned from functions that don\\'t explicitly return\\n   anything. Its truth value is false.\\n\\nNotImplemented\\n   This type has a single value.  There is a single object with this\\n   value. This object is accessed through the built-in name\\n   ``NotImplemented``. Numeric methods and rich comparison methods may\\n   return this value if they do not implement the operation for the\\n   operands provided.  (The interpreter will then try the reflected\\n   operation, or some other fallback, depending on the operator.)  Its\\n   truth value is true.\\n\\nEllipsis\\n   This type has a single value.  There is a single object with this\\n   value. This object is accessed through the literal ``...`` or the\\n   built-in name ``Ellipsis``.  Its truth value is true.\\n\\n``numbers.Number``\\n   These are created by numeric literals and returned as results by\\n   arithmetic operators and arithmetic built-in functions.  Numeric\\n   objects are immutable; once created their value never changes.\\n   Python numbers are of course strongly related to mathematical\\n   numbers, but subject to the limitations of numerical representation\\n   in computers.\\n\\n   Python distinguishes between integers, floating point numbers, and\\n   complex numbers:\\n\\n   ``numbers.Integral``\\n      These represent elements from the mathematical set of integers\\n      (positive and negative).\\n\\n      There are two types of integers:\\n\\n      Integers (``int``)\\n\\n         These represent numbers in an unlimited range, subject to\\n         available (virtual) memory only.  For the purpose of shift\\n         and mask operations, a binary representation is assumed, and\\n         negative numbers are represented in a variant of 2\\'s\\n         complement which gives the illusion of an infinite string of\\n         sign bits extending to the left.\\n\\n      Booleans (``bool``)\\n         These represent the truth values False and True.  The two\\n         objects representing the values False and True are the only\\n         Boolean objects. The Boolean type is a subtype of the integer\\n         type, and Boolean values behave like the values 0 and 1,\\n         respectively, in almost all contexts, the exception being\\n         that when converted to a string, the strings ``\"False\"`` or\\n         ``\"True\"`` are returned, respectively.\\n\\n      The rules for integer representation are intended to give the\\n      most meaningful interpretation of shift and mask operations\\n      involving negative integers.\\n\\n   ``numbers.Real`` (``float``)\\n      These represent machine-level double precision floating point\\n      numbers. You are at the mercy of the underlying machine\\n      architecture (and C or Java implementation) for the accepted\\n      range and handling of overflow. Python does not support single-\\n      precision floating point numbers; the savings in processor and\\n      memory usage that are usually the reason for using these is\\n      dwarfed by the overhead of using objects in Python, so there is\\n      no reason to complicate the language with two kinds of floating\\n      point numbers.\\n\\n   ``numbers.Complex`` (``complex``)\\n      These represent complex numbers as a pair of machine-level\\n      double precision floating point numbers.  The same caveats apply\\n      as for floating point numbers. The real and imaginary parts of a\\n      complex number ``z`` can be retrieved through the read-only\\n      attributes ``z.real`` and ``z.imag``.\\n\\nSequences\\n   These represent finite ordered sets indexed by non-negative\\n   numbers. The built-in function ``len()`` returns the number of\\n   items of a sequence. When the length of a sequence is *n*, the\\n   index set contains the numbers 0, 1, ..., *n*-1.  Item *i* of\\n   sequence *a* is selected by ``a[i]``.\\n\\n   Sequences also support slicing: ``a[i:j]`` selects all items with\\n   index *k* such that *i* ``<=`` *k* ``<`` *j*.  When used as an\\n   expression, a slice is a sequence of the same type.  This implies\\n   that the index set is renumbered so that it starts at 0.\\n\\n   Some sequences also support \"extended slicing\" with a third \"step\"\\n   parameter: ``a[i:j:k]`` selects all items of *a* with index *x*\\n   where ``x = i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<``\\n   *j*.\\n\\n   Sequences are distinguished according to their mutability:\\n\\n   Immutable sequences\\n      An object of an immutable sequence type cannot change once it is\\n      created.  (If the object contains references to other objects,\\n      these other objects may be mutable and may be changed; however,\\n      the collection of objects directly referenced by an immutable\\n      object cannot change.)\\n\\n      The following types are immutable sequences:\\n\\n      Strings\\n         A string is a sequence of values that represent Unicode\\n         codepoints. All the codepoints in range ``U+0000 - U+10FFFF``\\n         can be represented in a string.  Python doesn\\'t have a\\n         ``chr`` type, and every character in the string is\\n         represented as a string object with length ``1``.  The built-\\n         in function ``ord()`` converts a character to its codepoint\\n         (as an integer); ``chr()`` converts an integer in range ``0 -\\n         10FFFF`` to the corresponding character. ``str.encode()`` can\\n         be used to convert a ``str`` to ``bytes`` using the given\\n         encoding, and ``bytes.decode()`` can be used to achieve the\\n         opposite.\\n\\n      Tuples\\n         The items of a tuple are arbitrary Python objects. Tuples of\\n         two or more items are formed by comma-separated lists of\\n         expressions.  A tuple of one item (a \\'singleton\\') can be\\n         formed by affixing a comma to an expression (an expression by\\n         itself does not create a tuple, since parentheses must be\\n         usable for grouping of expressions).  An empty tuple can be\\n         formed by an empty pair of parentheses.\\n\\n      Bytes\\n         A bytes object is an immutable array.  The items are 8-bit\\n         bytes, represented by integers in the range 0 <= x < 256.\\n         Bytes literals (like ``b\\'abc\\'``) and the built-in function\\n         ``bytes()`` can be used to construct bytes objects.  Also,\\n         bytes objects can be decoded to strings via the ``decode()``\\n         method.\\n\\n   Mutable sequences\\n      Mutable sequences can be changed after they are created.  The\\n      subscription and slicing notations can be used as the target of\\n      assignment and ``del`` (delete) statements.\\n\\n      There are currently two intrinsic mutable sequence types:\\n\\n      Lists\\n         The items of a list are arbitrary Python objects.  Lists are\\n         formed by placing a comma-separated list of expressions in\\n         square brackets. (Note that there are no special cases needed\\n         to form lists of length 0 or 1.)\\n\\n      Byte Arrays\\n         A bytearray object is a mutable array. They are created by\\n         the built-in ``bytearray()`` constructor.  Aside from being\\n         mutable (and hence unhashable), byte arrays otherwise provide\\n         the same interface and functionality as immutable bytes\\n         objects.\\n\\n      The extension module ``array`` provides an additional example of\\n      a mutable sequence type, as does the ``collections`` module.\\n\\nSet types\\n   These represent unordered, finite sets of unique, immutable\\n   objects. As such, they cannot be indexed by any subscript. However,\\n   they can be iterated over, and the built-in function ``len()``\\n   returns the number of items in a set. Common uses for sets are fast\\n   membership testing, removing duplicates from a sequence, and\\n   computing mathematical operations such as intersection, union,\\n   difference, and symmetric difference.\\n\\n   For set elements, the same immutability rules apply as for\\n   dictionary keys. Note that numeric types obey the normal rules for\\n   numeric comparison: if two numbers compare equal (e.g., ``1`` and\\n   ``1.0``), only one of them can be contained in a set.\\n\\n   There are currently two intrinsic set types:\\n\\n   Sets\\n      These represent a mutable set. They are created by the built-in\\n      ``set()`` constructor and can be modified afterwards by several\\n      methods, such as ``add()``.\\n\\n   Frozen sets\\n      These represent an immutable set.  They are created by the\\n      built-in ``frozenset()`` constructor.  As a frozenset is\\n      immutable and *hashable*, it can be used again as an element of\\n      another set, or as a dictionary key.\\n\\nMappings\\n   These represent finite sets of objects indexed by arbitrary index\\n   sets. The subscript notation ``a[k]`` selects the item indexed by\\n   ``k`` from the mapping ``a``; this can be used in expressions and\\n   as the target of assignments or ``del`` statements. The built-in\\n   function ``len()`` returns the number of items in a mapping.\\n\\n   There is currently a single intrinsic mapping type:\\n\\n   Dictionaries\\n      These represent finite sets of objects indexed by nearly\\n      arbitrary values.  The only types of values not acceptable as\\n      keys are values containing lists or dictionaries or other\\n      mutable types that are compared by value rather than by object\\n      identity, the reason being that the efficient implementation of\\n      dictionaries requires a key\\'s hash value to remain constant.\\n      Numeric types used for keys obey the normal rules for numeric\\n      comparison: if two numbers compare equal (e.g., ``1`` and\\n      ``1.0``) then they can be used interchangeably to index the same\\n      dictionary entry.\\n\\n      Dictionaries are mutable; they can be created by the ``{...}``\\n      notation (see section *Dictionary displays*).\\n\\n      The extension modules ``dbm.ndbm`` and ``dbm.gnu`` provide\\n      additional examples of mapping types, as does the\\n      ``collections`` module.\\n\\nCallable types\\n   These are the types to which the function call operation (see\\n   section *Calls*) can be applied:\\n\\n   User-defined functions\\n      A user-defined function object is created by a function\\n      definition (see section *Function definitions*).  It should be\\n      called with an argument list containing the same number of items\\n      as the function\\'s formal parameter list.\\n\\n      Special attributes:\\n\\n      +---------------------------+---------------------------------+-------------+\\n      | Attribute                 | Meaning                         |             |\\n      +===========================+=================================+=============+\\n      | ``__doc__``               | The function\\'s documentation    | Writable    |\\n      |                           | string, or ``None`` if          |             |\\n      |                           | unavailable                     |             |\\n      +---------------------------+---------------------------------+-------------+\\n      | ``__name__``              | The function\\'s name             | Writable    |\\n      +---------------------------+---------------------------------+-------------+\\n      | ``__qualname__``          | The function\\'s *qualified name* | Writable    |\\n      |                           | New in version 3.3.             |             |\\n      +---------------------------+---------------------------------+-------------+\\n      | ``__module__``            | The name of the module the      | Writable    |\\n      |                           | function was defined in, or     |             |\\n      |                           | ``None`` if unavailable.        |             |\\n      +---------------------------+---------------------------------+-------------+\\n      | ``__defaults__``          | A tuple containing default      | Writable    |\\n      |                           | argument values for those       |             |\\n      |                           | arguments that have defaults,   |             |\\n      |                           | or ``None`` if no arguments     |             |\\n      |                           | have a default value            |             |\\n      +---------------------------+---------------------------------+-------------+\\n      | ``__code__``              | The code object representing    | Writable    |\\n      |                           | the compiled function body.     |             |\\n      +---------------------------+---------------------------------+-------------+\\n      | ``__globals__``           | A reference to the dictionary   | Read-only   |\\n      |                           | that holds the function\\'s       |             |\\n      |                           | global variables --- the global |             |\\n      |                           | namespace of the module in      |             |\\n      |                           | which the function was defined. |             |\\n      +---------------------------+---------------------------------+-------------+\\n      | ``__dict__``              | The namespace supporting        | Writable    |\\n      |                           | arbitrary function attributes.  |             |\\n      +---------------------------+---------------------------------+-------------+\\n      | ``__closure__``           | ``None`` or a tuple of cells    | Read-only   |\\n      |                           | that contain bindings for the   |             |\\n      |                           | function\\'s free variables.      |             |\\n      +---------------------------+---------------------------------+-------------+\\n      | ``__annotations__``       | A dict containing annotations   | Writable    |\\n      |                           | of parameters.  The keys of the |             |\\n      |                           | dict are the parameter names,   |             |\\n      |                           | or ``\\'return\\'`` for the return  |             |\\n      |                           | annotation, if provided.        |             |\\n      +---------------------------+---------------------------------+-------------+\\n      | ``__kwdefaults__``        | A dict containing defaults for  | Writable    |\\n      |                           | keyword-only parameters.        |             |\\n      +---------------------------+---------------------------------+-------------+\\n\\n      Most of the attributes labelled \"Writable\" check the type of the\\n      assigned value.\\n\\n      Function objects also support getting and setting arbitrary\\n      attributes, which can be used, for example, to attach metadata\\n      to functions.  Regular attribute dot-notation is used to get and\\n      set such attributes. *Note that the current implementation only\\n      supports function attributes on user-defined functions. Function\\n      attributes on built-in functions may be supported in the\\n      future.*\\n\\n      Additional information about a function\\'s definition can be\\n      retrieved from its code object; see the description of internal\\n      types below.\\n\\n   Instance methods\\n      An instance method object combines a class, a class instance and\\n      any callable object (normally a user-defined function).\\n\\n      Special read-only attributes: ``__self__`` is the class instance\\n      object, ``__func__`` is the function object; ``__doc__`` is the\\n      method\\'s documentation (same as ``__func__.__doc__``);\\n      ``__name__`` is the method name (same as ``__func__.__name__``);\\n      ``__module__`` is the name of the module the method was defined\\n      in, or ``None`` if unavailable.\\n\\n      Methods also support accessing (but not setting) the arbitrary\\n      function attributes on the underlying function object.\\n\\n      User-defined method objects may be created when getting an\\n      attribute of a class (perhaps via an instance of that class), if\\n      that attribute is a user-defined function object or a class\\n      method object.\\n\\n      When an instance method object is created by retrieving a user-\\n      defined function object from a class via one of its instances,\\n      its ``__self__`` attribute is the instance, and the method\\n      object is said to be bound.  The new method\\'s ``__func__``\\n      attribute is the original function object.\\n\\n      When a user-defined method object is created by retrieving\\n      another method object from a class or instance, the behaviour is\\n      the same as for a function object, except that the ``__func__``\\n      attribute of the new instance is not the original method object\\n      but its ``__func__`` attribute.\\n\\n      When an instance method object is created by retrieving a class\\n      method object from a class or instance, its ``__self__``\\n      attribute is the class itself, and its ``__func__`` attribute is\\n      the function object underlying the class method.\\n\\n      When an instance method object is called, the underlying\\n      function (``__func__``) is called, inserting the class instance\\n      (``__self__``) in front of the argument list.  For instance,\\n      when ``C`` is a class which contains a definition for a function\\n      ``f()``, and ``x`` is an instance of ``C``, calling ``x.f(1)``\\n      is equivalent to calling ``C.f(x, 1)``.\\n\\n      When an instance method object is derived from a class method\\n      object, the \"class instance\" stored in ``__self__`` will\\n      actually be the class itself, so that calling either ``x.f(1)``\\n      or ``C.f(1)`` is equivalent to calling ``f(C,1)`` where ``f`` is\\n      the underlying function.\\n\\n      Note that the transformation from function object to instance\\n      method object happens each time the attribute is retrieved from\\n      the instance.  In some cases, a fruitful optimization is to\\n      assign the attribute to a local variable and call that local\\n      variable. Also notice that this transformation only happens for\\n      user-defined functions; other callable objects (and all non-\\n      callable objects) are retrieved without transformation.  It is\\n      also important to note that user-defined functions which are\\n      attributes of a class instance are not converted to bound\\n      methods; this *only* happens when the function is an attribute\\n      of the class.\\n\\n   Generator functions\\n      A function or method which uses the ``yield`` statement (see\\n      section *The yield statement*) is called a *generator function*.\\n      Such a function, when called, always returns an iterator object\\n      which can be used to execute the body of the function:  calling\\n      the iterator\\'s ``iterator__next__()`` method will cause the\\n      function to execute until it provides a value using the\\n      ``yield`` statement.  When the function executes a ``return``\\n      statement or falls off the end, a ``StopIteration`` exception is\\n      raised and the iterator will have reached the end of the set of\\n      values to be returned.\\n\\n   Built-in functions\\n      A built-in function object is a wrapper around a C function.\\n      Examples of built-in functions are ``len()`` and ``math.sin()``\\n      (``math`` is a standard built-in module). The number and type of\\n      the arguments are determined by the C function. Special read-\\n      only attributes: ``__doc__`` is the function\\'s documentation\\n      string, or ``None`` if unavailable; ``__name__`` is the\\n      function\\'s name; ``__self__`` is set to ``None`` (but see the\\n      next item); ``__module__`` is the name of the module the\\n      function was defined in or ``None`` if unavailable.\\n\\n   Built-in methods\\n      This is really a different disguise of a built-in function, this\\n      time containing an object passed to the C function as an\\n      implicit extra argument.  An example of a built-in method is\\n      ``alist.append()``, assuming *alist* is a list object. In this\\n      case, the special read-only attribute ``__self__`` is set to the\\n      object denoted by *alist*.\\n\\n   Classes\\n      Classes are callable.  These objects normally act as factories\\n      for new instances of themselves, but variations are possible for\\n      class types that override ``__new__()``.  The arguments of the\\n      call are passed to ``__new__()`` and, in the typical case, to\\n      ``__init__()`` to initialize the new instance.\\n\\n   Class Instances\\n      Instances of arbitrary classes can be made callable by defining\\n      a ``__call__()`` method in their class.\\n\\nModules\\n   Modules are a basic organizational unit of Python code, and are\\n   created by the *import system* as invoked either by the ``import``\\n   statement (see ``import``), or by calling functions such as\\n   ``importlib.import_module()`` and built-in ``__import__()``.  A\\n   module object has a namespace implemented by a dictionary object\\n   (this is the dictionary referenced by the ``__globals__`` attribute\\n   of functions defined in the module).  Attribute references are\\n   translated to lookups in this dictionary, e.g., ``m.x`` is\\n   equivalent to ``m.__dict__[\"x\"]``. A module object does not contain\\n   the code object used to initialize the module (since it isn\\'t\\n   needed once the initialization is done).\\n\\n   Attribute assignment updates the module\\'s namespace dictionary,\\n   e.g., ``m.x = 1`` is equivalent to ``m.__dict__[\"x\"] = 1``.\\n\\n   Special read-only attribute: ``__dict__`` is the module\\'s namespace\\n   as a dictionary object.\\n\\n   **CPython implementation detail:** Because of the way CPython\\n   clears module dictionaries, the module dictionary will be cleared\\n   when the module falls out of scope even if the dictionary still has\\n   live references.  To avoid this, copy the dictionary or keep the\\n   module around while using its dictionary directly.\\n\\n   Predefined (writable) attributes: ``__name__`` is the module\\'s\\n   name; ``__doc__`` is the module\\'s documentation string, or ``None``\\n   if unavailable; ``__file__`` is the pathname of the file from which\\n   the module was loaded, if it was loaded from a file. The\\n   ``__file__`` attribute may be missing for certain types of modules,\\n   such as C modules that are statically linked into the interpreter;\\n   for extension modules loaded dynamically from a shared library, it\\n   is the pathname of the shared library file.\\n\\nCustom classes\\n   Custom class types are typically created by class definitions (see\\n   section *Class definitions*).  A class has a namespace implemented\\n   by a dictionary object. Class attribute references are translated\\n   to lookups in this dictionary, e.g., ``C.x`` is translated to\\n   ``C.__dict__[\"x\"]`` (although there are a number of hooks which\\n   allow for other means of locating attributes). When the attribute\\n   name is not found there, the attribute search continues in the base\\n   classes. This search of the base classes uses the C3 method\\n   resolution order which behaves correctly even in the presence of\\n   \\'diamond\\' inheritance structures where there are multiple\\n   inheritance paths leading back to a common ancestor. Additional\\n   details on the C3 MRO used by Python can be found in the\\n   documentation accompanying the 2.3 release at\\n   http://www.python.org/download/releases/2.3/mro/.\\n\\n   When a class attribute reference (for class ``C``, say) would yield\\n   a class method object, it is transformed into an instance method\\n   object whose ``__self__`` attributes is ``C``.  When it would yield\\n   a static method object, it is transformed into the object wrapped\\n   by the static method object. See section *Implementing Descriptors*\\n   for another way in which attributes retrieved from a class may\\n   differ from those actually contained in its ``__dict__``.\\n\\n   Class attribute assignments update the class\\'s dictionary, never\\n   the dictionary of a base class.\\n\\n   A class object can be called (see above) to yield a class instance\\n   (see below).\\n\\n   Special attributes: ``__name__`` is the class name; ``__module__``\\n   is the module name in which the class was defined; ``__dict__`` is\\n   the dictionary containing the class\\'s namespace; ``__bases__`` is a\\n   tuple (possibly empty or a singleton) containing the base classes,\\n   in the order of their occurrence in the base class list;\\n   ``__doc__`` is the class\\'s documentation string, or None if\\n   undefined.\\n\\nClass instances\\n   A class instance is created by calling a class object (see above).\\n   A class instance has a namespace implemented as a dictionary which\\n   is the first place in which attribute references are searched.\\n   When an attribute is not found there, and the instance\\'s class has\\n   an attribute by that name, the search continues with the class\\n   attributes.  If a class attribute is found that is a user-defined\\n   function object, it is transformed into an instance method object\\n   whose ``__self__`` attribute is the instance.  Static method and\\n   class method objects are also transformed; see above under\\n   \"Classes\".  See section *Implementing Descriptors* for another way\\n   in which attributes of a class retrieved via its instances may\\n   differ from the objects actually stored in the class\\'s\\n   ``__dict__``.  If no class attribute is found, and the object\\'s\\n   class has a ``__getattr__()`` method, that is called to satisfy the\\n   lookup.\\n\\n   Attribute assignments and deletions update the instance\\'s\\n   dictionary, never a class\\'s dictionary.  If the class has a\\n   ``__setattr__()`` or ``__delattr__()`` method, this is called\\n   instead of updating the instance dictionary directly.\\n\\n   Class instances can pretend to be numbers, sequences, or mappings\\n   if they have methods with certain special names.  See section\\n   *Special method names*.\\n\\n   Special attributes: ``__dict__`` is the attribute dictionary;\\n   ``__class__`` is the instance\\'s class.\\n\\nI/O objects (also known as file objects)\\n   A *file object* represents an open file.  Various shortcuts are\\n   available to create file objects: the ``open()`` built-in function,\\n   and also ``os.popen()``, ``os.fdopen()``, and the ``makefile()``\\n   method of socket objects (and perhaps by other functions or methods\\n   provided by extension modules).\\n\\n   The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are\\n   initialized to file objects corresponding to the interpreter\\'s\\n   standard input, output and error streams; they are all open in text\\n   mode and therefore follow the interface defined by the\\n   ``io.TextIOBase`` abstract class.\\n\\nInternal types\\n   A few types used internally by the interpreter are exposed to the\\n   user. Their definitions may change with future versions of the\\n   interpreter, but they are mentioned here for completeness.\\n\\n   Code objects\\n      Code objects represent *byte-compiled* executable Python code,\\n      or *bytecode*. The difference between a code object and a\\n      function object is that the function object contains an explicit\\n      reference to the function\\'s globals (the module in which it was\\n      defined), while a code object contains no context; also the\\n      default argument values are stored in the function object, not\\n      in the code object (because they represent values calculated at\\n      run-time).  Unlike function objects, code objects are immutable\\n      and contain no references (directly or indirectly) to mutable\\n      objects.\\n\\n      Special read-only attributes: ``co_name`` gives the function\\n      name; ``co_argcount`` is the number of positional arguments\\n      (including arguments with default values); ``co_nlocals`` is the\\n      number of local variables used by the function (including\\n      arguments); ``co_varnames`` is a tuple containing the names of\\n      the local variables (starting with the argument names);\\n      ``co_cellvars`` is a tuple containing the names of local\\n      variables that are referenced by nested functions;\\n      ``co_freevars`` is a tuple containing the names of free\\n      variables; ``co_code`` is a string representing the sequence of\\n      bytecode instructions; ``co_consts`` is a tuple containing the\\n      literals used by the bytecode; ``co_names`` is a tuple\\n      containing the names used by the bytecode; ``co_filename`` is\\n      the filename from which the code was compiled;\\n      ``co_firstlineno`` is the first line number of the function;\\n      ``co_lnotab`` is a string encoding the mapping from bytecode\\n      offsets to line numbers (for details see the source code of the\\n      interpreter); ``co_stacksize`` is the required stack size\\n      (including local variables); ``co_flags`` is an integer encoding\\n      a number of flags for the interpreter.\\n\\n      The following flag bits are defined for ``co_flags``: bit\\n      ``0x04`` is set if the function uses the ``*arguments`` syntax\\n      to accept an arbitrary number of positional arguments; bit\\n      ``0x08`` is set if the function uses the ``**keywords`` syntax\\n      to accept arbitrary keyword arguments; bit ``0x20`` is set if\\n      the function is a generator.\\n\\n      Future feature declarations (``from __future__ import\\n      division``) also use bits in ``co_flags`` to indicate whether a\\n      code object was compiled with a particular feature enabled: bit\\n      ``0x2000`` is set if the function was compiled with future\\n      division enabled; bits ``0x10`` and ``0x1000`` were used in\\n      earlier versions of Python.\\n\\n      Other bits in ``co_flags`` are reserved for internal use.\\n\\n      If a code object represents a function, the first item in\\n      ``co_consts`` is the documentation string of the function, or\\n      ``None`` if undefined.\\n\\n   Frame objects\\n      Frame objects represent execution frames.  They may occur in\\n      traceback objects (see below).\\n\\n      Special read-only attributes: ``f_back`` is to the previous\\n      stack frame (towards the caller), or ``None`` if this is the\\n      bottom stack frame; ``f_code`` is the code object being executed\\n      in this frame; ``f_locals`` is the dictionary used to look up\\n      local variables; ``f_globals`` is used for global variables;\\n      ``f_builtins`` is used for built-in (intrinsic) names;\\n      ``f_lasti`` gives the precise instruction (this is an index into\\n      the bytecode string of the code object).\\n\\n      Special writable attributes: ``f_trace``, if not ``None``, is a\\n      function called at the start of each source code line (this is\\n      used by the debugger); ``f_lineno`` is the current line number\\n      of the frame --- writing to this from within a trace function\\n      jumps to the given line (only for the bottom-most frame).  A\\n      debugger can implement a Jump command (aka Set Next Statement)\\n      by writing to f_lineno.\\n\\n   Traceback objects\\n      Traceback objects represent a stack trace of an exception.  A\\n      traceback object is created when an exception occurs.  When the\\n      search for an exception handler unwinds the execution stack, at\\n      each unwound level a traceback object is inserted in front of\\n      the current traceback.  When an exception handler is entered,\\n      the stack trace is made available to the program. (See section\\n      *The try statement*.) It is accessible as the third item of the\\n      tuple returned by ``sys.exc_info()``. When the program contains\\n      no suitable handler, the stack trace is written (nicely\\n      formatted) to the standard error stream; if the interpreter is\\n      interactive, it is also made available to the user as\\n      ``sys.last_traceback``.\\n\\n      Special read-only attributes: ``tb_next`` is the next level in\\n      the stack trace (towards the frame where the exception\\n      occurred), or ``None`` if there is no next level; ``tb_frame``\\n      points to the execution frame of the current level;\\n      ``tb_lineno`` gives the line number where the exception\\n      occurred; ``tb_lasti`` indicates the precise instruction.  The\\n      line number and last instruction in the traceback may differ\\n      from the line number of its frame object if the exception\\n      occurred in a ``try`` statement with no matching except clause\\n      or with a finally clause.\\n\\n   Slice objects\\n      Slice objects are used to represent slices for ``__getitem__()``\\n      methods.  They are also created by the built-in ``slice()``\\n      function.\\n\\n      Special read-only attributes: ``start`` is the lower bound;\\n      ``stop`` is the upper bound; ``step`` is the step value; each is\\n      ``None`` if omitted. These attributes can have any type.\\n\\n      Slice objects support one method:\\n\\n      slice.indices(self, length)\\n\\n         This method takes a single integer argument *length* and\\n         computes information about the slice that the slice object\\n         would describe if applied to a sequence of *length* items.\\n         It returns a tuple of three integers; respectively these are\\n         the *start* and *stop* indices and the *step* or stride\\n         length of the slice. Missing or out-of-bounds indices are\\n         handled in a manner consistent with regular slices.\\n\\n   Static method objects\\n      Static method objects provide a way of defeating the\\n      transformation of function objects to method objects described\\n      above. A static method object is a wrapper around any other\\n      object, usually a user-defined method object. When a static\\n      method object is retrieved from a class or a class instance, the\\n      object actually returned is the wrapped object, which is not\\n      subject to any further transformation. Static method objects are\\n      not themselves callable, although the objects they wrap usually\\n      are. Static method objects are created by the built-in\\n      ``staticmethod()`` constructor.\\n\\n   Class method objects\\n      A class method object, like a static method object, is a wrapper\\n      around another object that alters the way in which that object\\n      is retrieved from classes and class instances. The behaviour of\\n      class method objects upon such retrieval is described above,\\n      under \"User-defined methods\". Class method objects are created\\n      by the built-in ``classmethod()`` constructor.\\n',\n'typesfunctions': '\\nFunctions\\n*********\\n\\nFunction objects are created by function definitions.  The only\\noperation on a function object is to call it: ``func(argument-list)``.\\n\\nThere are really two flavors of function objects: built-in functions\\nand user-defined functions.  Both support the same operation (to call\\nthe function), but the implementation is different, hence the\\ndifferent object types.\\n\\nSee *Function definitions* for more information.\\n',\n'typesmapping': '\\nMapping Types --- ``dict``\\n**************************\\n\\nA *mapping* object maps *hashable* values to arbitrary objects.\\nMappings are mutable objects.  There is currently only one standard\\nmapping type, the *dictionary*.  (For other containers see the built-\\nin ``list``, ``set``, and ``tuple`` classes, and the ``collections``\\nmodule.)\\n\\nA dictionary\\'s keys are *almost* arbitrary values.  Values that are\\nnot *hashable*, that is, values containing lists, dictionaries or\\nother mutable types (that are compared by value rather than by object\\nidentity) may not be used as keys.  Numeric types used for keys obey\\nthe normal rules for numeric comparison: if two numbers compare equal\\n(such as ``1`` and ``1.0``) then they can be used interchangeably to\\nindex the same dictionary entry.  (Note however, that since computers\\nstore floating-point numbers as approximations it is usually unwise to\\nuse them as dictionary keys.)\\n\\nDictionaries can be created by placing a comma-separated list of\\n``key: value`` pairs within braces, for example: ``{\\'jack\\': 4098,\\n\\'sjoerd\\': 4127}`` or ``{4098: \\'jack\\', 4127: \\'sjoerd\\'}``, or by the\\n``dict`` constructor.\\n\\nclass class dict(**kwarg)\\nclass class dict(mapping, **kwarg)\\nclass class dict(iterable, **kwarg)\\n\\n   Return a new dictionary initialized from an optional positional\\n   argument and a possibly empty set of keyword arguments.\\n\\n   If no positional argument is given, an empty dictionary is created.\\n   If a positional argument is given and it is a mapping object, a\\n   dictionary is created with the same key-value pairs as the mapping\\n   object.  Otherwise, the positional argument must be an *iterator*\\n   object.  Each item in the iterable must itself be an iterator with\\n   exactly two objects.  The first object of each item becomes a key\\n   in the new dictionary, and the second object the corresponding\\n   value.  If a key occurs more than once, the last value for that key\\n   becomes the corresponding value in the new dictionary.\\n\\n   If keyword arguments are given, the keyword arguments and their\\n   values are added to the dictionary created from the positional\\n   argument.  If a key being added is already present, the value from\\n   the keyword argument replaces the value from the positional\\n   argument.\\n\\n   To illustrate, the following examples all return a dictionary equal\\n   to ``{\"one\": 1, \"two\": 2, \"three\": 3}``:\\n\\n      >>> a = dict(one=1, two=2, three=3)\\n      >>> b = {\\'one\\': 1, \\'two\\': 2, \\'three\\': 3}\\n      >>> c = dict(zip([\\'one\\', \\'two\\', \\'three\\'], [1, 2, 3]))\\n      >>> d = dict([(\\'two\\', 2), (\\'one\\', 1), (\\'three\\', 3)])\\n      >>> e = dict({\\'three\\': 3, \\'one\\': 1, \\'two\\': 2})\\n      >>> a == b == c == d == e\\n      True\\n\\n   Providing keyword arguments as in the first example only works for\\n   keys that are valid Python identifiers.  Otherwise, any valid keys\\n   can be used.\\n\\n   These are the operations that dictionaries support (and therefore,\\n   custom mapping types should support too):\\n\\n   len(d)\\n\\n      Return the number of items in the dictionary *d*.\\n\\n   d[key]\\n\\n      Return the item of *d* with key *key*.  Raises a ``KeyError`` if\\n      *key* is not in the map.\\n\\n      If a subclass of dict defines a method ``__missing__()``, if the\\n      key *key* is not present, the ``d[key]`` operation calls that\\n      method with the key *key* as argument.  The ``d[key]`` operation\\n      then returns or raises whatever is returned or raised by the\\n      ``__missing__(key)`` call if the key is not present. No other\\n      operations or methods invoke ``__missing__()``. If\\n      ``__missing__()`` is not defined, ``KeyError`` is raised.\\n      ``__missing__()`` must be a method; it cannot be an instance\\n      variable:\\n\\n         >>> class Counter(dict):\\n         ...     def __missing__(self, key):\\n         ...         return 0\\n         >>> c = Counter()\\n         >>> c[\\'red\\']\\n         0\\n         >>> c[\\'red\\'] += 1\\n         >>> c[\\'red\\']\\n         1\\n\\n      See ``collections.Counter`` for a complete implementation\\n      including other methods helpful for accumulating and managing\\n      tallies.\\n\\n   d[key] = value\\n\\n      Set ``d[key]`` to *value*.\\n\\n   del d[key]\\n\\n      Remove ``d[key]`` from *d*.  Raises a ``KeyError`` if *key* is\\n      not in the map.\\n\\n   key in d\\n\\n      Return ``True`` if *d* has a key *key*, else ``False``.\\n\\n   key not in d\\n\\n      Equivalent to ``not key in d``.\\n\\n   iter(d)\\n\\n      Return an iterator over the keys of the dictionary.  This is a\\n      shortcut for ``iter(d.keys())``.\\n\\n   clear()\\n\\n      Remove all items from the dictionary.\\n\\n   copy()\\n\\n      Return a shallow copy of the dictionary.\\n\\n   classmethod fromkeys(seq[, value])\\n\\n      Create a new dictionary with keys from *seq* and values set to\\n      *value*.\\n\\n      ``fromkeys()`` is a class method that returns a new dictionary.\\n      *value* defaults to ``None``.\\n\\n   get(key[, default])\\n\\n      Return the value for *key* if *key* is in the dictionary, else\\n      *default*. If *default* is not given, it defaults to ``None``,\\n      so that this method never raises a ``KeyError``.\\n\\n   items()\\n\\n      Return a new view of the dictionary\\'s items (``(key, value)``\\n      pairs). See the *documentation of view objects*.\\n\\n   keys()\\n\\n      Return a new view of the dictionary\\'s keys.  See the\\n      *documentation of view objects*.\\n\\n   pop(key[, default])\\n\\n      If *key* is in the dictionary, remove it and return its value,\\n      else return *default*.  If *default* is not given and *key* is\\n      not in the dictionary, a ``KeyError`` is raised.\\n\\n   popitem()\\n\\n      Remove and return an arbitrary ``(key, value)`` pair from the\\n      dictionary.\\n\\n      ``popitem()`` is useful to destructively iterate over a\\n      dictionary, as often used in set algorithms.  If the dictionary\\n      is empty, calling ``popitem()`` raises a ``KeyError``.\\n\\n   setdefault(key[, default])\\n\\n      If *key* is in the dictionary, return its value.  If not, insert\\n      *key* with a value of *default* and return *default*.  *default*\\n      defaults to ``None``.\\n\\n   update([other])\\n\\n      Update the dictionary with the key/value pairs from *other*,\\n      overwriting existing keys.  Return ``None``.\\n\\n      ``update()`` accepts either another dictionary object or an\\n      iterable of key/value pairs (as tuples or other iterables of\\n      length two).  If keyword arguments are specified, the dictionary\\n      is then updated with those key/value pairs: ``d.update(red=1,\\n      blue=2)``.\\n\\n   values()\\n\\n      Return a new view of the dictionary\\'s values.  See the\\n      *documentation of view objects*.\\n\\nSee also:\\n\\n   ``types.MappingProxyType`` can be used to create a read-only view\\n   of a ``dict``.\\n\\n\\nDictionary view objects\\n=======================\\n\\nThe objects returned by ``dict.keys()``, ``dict.values()`` and\\n``dict.items()`` are *view objects*.  They provide a dynamic view on\\nthe dictionary\\'s entries, which means that when the dictionary\\nchanges, the view reflects these changes.\\n\\nDictionary views can be iterated over to yield their respective data,\\nand support membership tests:\\n\\nlen(dictview)\\n\\n   Return the number of entries in the dictionary.\\n\\niter(dictview)\\n\\n   Return an iterator over the keys, values or items (represented as\\n   tuples of ``(key, value)``) in the dictionary.\\n\\n   Keys and values are iterated over in an arbitrary order which is\\n   non-random, varies across Python implementations, and depends on\\n   the dictionary\\'s history of insertions and deletions. If keys,\\n   values and items views are iterated over with no intervening\\n   modifications to the dictionary, the order of items will directly\\n   correspond.  This allows the creation of ``(value, key)`` pairs\\n   using ``zip()``: ``pairs = zip(d.values(), d.keys())``.  Another\\n   way to create the same list is ``pairs = [(v, k) for (k, v) in\\n   d.items()]``.\\n\\n   Iterating views while adding or deleting entries in the dictionary\\n   may raise a ``RuntimeError`` or fail to iterate over all entries.\\n\\nx in dictview\\n\\n   Return ``True`` if *x* is in the underlying dictionary\\'s keys,\\n   values or items (in the latter case, *x* should be a ``(key,\\n   value)`` tuple).\\n\\nKeys views are set-like since their entries are unique and hashable.\\nIf all values are hashable, so that ``(key, value)`` pairs are unique\\nand hashable, then the items view is also set-like.  (Values views are\\nnot treated as set-like since the entries are generally not unique.)\\nFor set-like views, all of the operations defined for the abstract\\nbase class ``collections.abc.Set`` are available (for example, ``==``,\\n``<``, or ``^``).\\n\\nAn example of dictionary view usage:\\n\\n   >>> dishes = {\\'eggs\\': 2, \\'sausage\\': 1, \\'bacon\\': 1, \\'spam\\': 500}\\n   >>> keys = dishes.keys()\\n   >>> values = dishes.values()\\n\\n   >>> # iteration\\n   >>> n = 0\\n   >>> for val in values:\\n   ...     n += val\\n   >>> print(n)\\n   504\\n\\n   >>> # keys and values are iterated over in the same order\\n   >>> list(keys)\\n   [\\'eggs\\', \\'bacon\\', \\'sausage\\', \\'spam\\']\\n   >>> list(values)\\n   [2, 1, 1, 500]\\n\\n   >>> # view objects are dynamic and reflect dict changes\\n   >>> del dishes[\\'eggs\\']\\n   >>> del dishes[\\'sausage\\']\\n   >>> list(keys)\\n   [\\'spam\\', \\'bacon\\']\\n\\n   >>> # set operations\\n   >>> keys & {\\'eggs\\', \\'bacon\\', \\'salad\\'}\\n   {\\'bacon\\'}\\n   >>> keys ^ {\\'sausage\\', \\'juice\\'}\\n   {\\'juice\\', \\'sausage\\', \\'bacon\\', \\'spam\\'}\\n',\n'typesmethods': '\\nMethods\\n*******\\n\\nMethods are functions that are called using the attribute notation.\\nThere are two flavors: built-in methods (such as ``append()`` on\\nlists) and class instance methods.  Built-in methods are described\\nwith the types that support them.\\n\\nIf you access a method (a function defined in a class namespace)\\nthrough an instance, you get a special object: a *bound method* (also\\ncalled *instance method*) object. When called, it will add the\\n``self`` argument to the argument list.  Bound methods have two\\nspecial read-only attributes: ``m.__self__`` is the object on which\\nthe method operates, and ``m.__func__`` is the function implementing\\nthe method.  Calling ``m(arg-1, arg-2, ..., arg-n)`` is completely\\nequivalent to calling ``m.__func__(m.__self__, arg-1, arg-2, ...,\\narg-n)``.\\n\\nLike function objects, bound method objects support getting arbitrary\\nattributes.  However, since method attributes are actually stored on\\nthe underlying function object (``meth.__func__``), setting method\\nattributes on bound methods is disallowed.  Attempting to set an\\nattribute on a method results in an ``AttributeError`` being raised.\\nIn order to set a method attribute, you need to explicitly set it on\\nthe underlying function object:\\n\\n   >>> class C:\\n   ...     def method(self):\\n   ...         pass\\n   ...\\n   >>> c = C()\\n   >>> c.method.whoami = \\'my name is method\\'  # can\\'t set on the method\\n   Traceback (most recent call last):\\n     File \"<stdin>\", line 1, in <module>\\n   AttributeError: \\'method\\' object has no attribute \\'whoami\\'\\n   >>> c.method.__func__.whoami = \\'my name is method\\'\\n   >>> c.method.whoami\\n   \\'my name is method\\'\\n\\nSee *The standard type hierarchy* for more information.\\n',\n'typesmodules': \"\\nModules\\n*******\\n\\nThe only special operation on a module is attribute access:\\n``m.name``, where *m* is a module and *name* accesses a name defined\\nin *m*'s symbol table. Module attributes can be assigned to.  (Note\\nthat the ``import`` statement is not, strictly speaking, an operation\\non a module object; ``import foo`` does not require a module object\\nnamed *foo* to exist, rather it requires an (external) *definition*\\nfor a module named *foo* somewhere.)\\n\\nA special attribute of every module is ``__dict__``. This is the\\ndictionary containing the module's symbol table. Modifying this\\ndictionary will actually change the module's symbol table, but direct\\nassignment to the ``__dict__`` attribute is not possible (you can\\nwrite ``m.__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but\\nyou can't write ``m.__dict__ = {}``).  Modifying ``__dict__`` directly\\nis not recommended.\\n\\nModules built into the interpreter are written like this: ``<module\\n'sys' (built-in)>``.  If loaded from a file, they are written as\\n``<module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``.\\n\",\n'typesseq': '\\nSequence Types --- ``list``, ``tuple``, ``range``\\n*************************************************\\n\\nThere are three basic sequence types: lists, tuples, and range\\nobjects. Additional sequence types tailored for processing of *binary\\ndata* and *text strings* are described in dedicated sections.\\n\\n\\nCommon Sequence Operations\\n==========================\\n\\nThe operations in the following table are supported by most sequence\\ntypes, both mutable and immutable. The ``collections.abc.Sequence``\\nABC is provided to make it easier to correctly implement these\\noperations on custom sequence types.\\n\\nThis table lists the sequence operations sorted in ascending priority\\n(operations in the same box have the same priority).  In the table,\\n*s* and *t* are sequences of the same type, *n*, *i*, *j* and *k* are\\nintegers and *x* is an arbitrary object that meets any type and value\\nrestrictions imposed by *s*.\\n\\nThe ``in`` and ``not in`` operations have the same priorities as the\\ncomparison operations. The ``+`` (concatenation) and ``*``\\n(repetition) operations have the same priority as the corresponding\\nnumeric operations.\\n\\n+----------------------------+----------------------------------+------------+\\n| Operation                  | Result                           | Notes      |\\n+============================+==================================+============+\\n| ``x in s``                 | ``True`` if an item of *s* is    | (1)        |\\n|                            | equal to *x*, else ``False``     |            |\\n+----------------------------+----------------------------------+------------+\\n| ``x not in s``             | ``False`` if an item of *s* is   | (1)        |\\n|                            | equal to *x*, else ``True``      |            |\\n+----------------------------+----------------------------------+------------+\\n| ``s + t``                  | the concatenation of *s* and *t* | (6)(7)     |\\n+----------------------------+----------------------------------+------------+\\n| ``s * n`` or ``n * s``     | *n* shallow copies of *s*        | (2)(7)     |\\n|                            | concatenated                     |            |\\n+----------------------------+----------------------------------+------------+\\n| ``s[i]``                   | *i*th item of *s*, origin 0      | (3)        |\\n+----------------------------+----------------------------------+------------+\\n| ``s[i:j]``                 | slice of *s* from *i* to *j*     | (3)(4)     |\\n+----------------------------+----------------------------------+------------+\\n| ``s[i:j:k]``               | slice of *s* from *i* to *j*     | (3)(5)     |\\n|                            | with step *k*                    |            |\\n+----------------------------+----------------------------------+------------+\\n| ``len(s)``                 | length of *s*                    |            |\\n+----------------------------+----------------------------------+------------+\\n| ``min(s)``                 | smallest item of *s*             |            |\\n+----------------------------+----------------------------------+------------+\\n| ``max(s)``                 | largest item of *s*              |            |\\n+----------------------------+----------------------------------+------------+\\n| ``s.index(x[, i[, j]])``   | index of the first occurence of  | (8)        |\\n|                            | *x* in *s* (at or after index    |            |\\n|                            | *i* and before index *j*)        |            |\\n+----------------------------+----------------------------------+------------+\\n| ``s.count(x)``             | total number of occurences of    |            |\\n|                            | *x* in *s*                       |            |\\n+----------------------------+----------------------------------+------------+\\n\\nSequences of the same type also support comparisons.  In particular,\\ntuples and lists are compared lexicographically by comparing\\ncorresponding elements. This means that to compare equal, every\\nelement must compare equal and the two sequences must be of the same\\ntype and have the same length.  (For full details see *Comparisons* in\\nthe language reference.)\\n\\nNotes:\\n\\n1. While the ``in`` and ``not in`` operations are used only for simple\\n   containment testing in the general case, some specialised sequences\\n   (such as ``str``, ``bytes`` and ``bytearray``) also use them for\\n   subsequence testing:\\n\\n      >>> \"gg\" in \"eggs\"\\n      True\\n\\n2. Values of *n* less than ``0`` are treated as ``0`` (which yields an\\n   empty sequence of the same type as *s*).  Note also that the copies\\n   are shallow; nested structures are not copied.  This often haunts\\n   new Python programmers; consider:\\n\\n      >>> lists = [[]] * 3\\n      >>> lists\\n      [[], [], []]\\n      >>> lists[0].append(3)\\n      >>> lists\\n      [[3], [3], [3]]\\n\\n   What has happened is that ``[[]]`` is a one-element list containing\\n   an empty list, so all three elements of ``[[]] * 3`` are (pointers\\n   to) this single empty list.  Modifying any of the elements of\\n   ``lists`` modifies this single list. You can create a list of\\n   different lists this way:\\n\\n      >>> lists = [[] for i in range(3)]\\n      >>> lists[0].append(3)\\n      >>> lists[1].append(5)\\n      >>> lists[2].append(7)\\n      >>> lists\\n      [[3], [5], [7]]\\n\\n3. If *i* or *j* is negative, the index is relative to the end of the\\n   string: ``len(s) + i`` or ``len(s) + j`` is substituted.  But note\\n   that ``-0`` is still ``0``.\\n\\n4. The slice of *s* from *i* to *j* is defined as the sequence of\\n   items with index *k* such that ``i <= k < j``.  If *i* or *j* is\\n   greater than ``len(s)``, use ``len(s)``.  If *i* is omitted or\\n   ``None``, use ``0``.  If *j* is omitted or ``None``, use\\n   ``len(s)``.  If *i* is greater than or equal to *j*, the slice is\\n   empty.\\n\\n5. The slice of *s* from *i* to *j* with step *k* is defined as the\\n   sequence of items with index  ``x = i + n*k`` such that ``0 <= n <\\n   (j-i)/k``.  In other words, the indices are ``i``, ``i+k``,\\n   ``i+2*k``, ``i+3*k`` and so on, stopping when *j* is reached (but\\n   never including *j*).  If *i* or *j* is greater than ``len(s)``,\\n   use ``len(s)``.  If *i* or *j* are omitted or ``None``, they become\\n   \"end\" values (which end depends on the sign of *k*).  Note, *k*\\n   cannot be zero. If *k* is ``None``, it is treated like ``1``.\\n\\n6. Concatenating immutable sequences always results in a new object.\\n   This means that building up a sequence by repeated concatenation\\n   will have a quadratic runtime cost in the total sequence length.\\n   To get a linear runtime cost, you must switch to one of the\\n   alternatives below:\\n\\n   * if concatenating ``str`` objects, you can build a list and use\\n     ``str.join()`` at the end or else write to a ``io.StringIO``\\n     instance and retrieve its value when complete\\n\\n   * if concatenating ``bytes`` objects, you can similarly use\\n     ``bytes.join()`` or ``io.BytesIO``, or you can do in-place\\n     concatenation with a ``bytearray`` object.  ``bytearray`` objects\\n     are mutable and have an efficient overallocation mechanism\\n\\n   * if concatenating ``tuple`` objects, extend a ``list`` instead\\n\\n   * for other types, investigate the relevant class documentation\\n\\n7. Some sequence types (such as ``range``) only support item sequences\\n   that follow specific patterns, and hence don\\'t support sequence\\n   concatenation or repetition.\\n\\n8. ``index`` raises ``ValueError`` when *x* is not found in *s*. When\\n   supported, the additional arguments to the index method allow\\n   efficient searching of subsections of the sequence. Passing the\\n   extra arguments is roughly equivalent to using ``s[i:j].index(x)``,\\n   only without copying any data and with the returned index being\\n   relative to the start of the sequence rather than the start of the\\n   slice.\\n\\n\\nImmutable Sequence Types\\n========================\\n\\nThe only operation that immutable sequence types generally implement\\nthat is not also implemented by mutable sequence types is support for\\nthe ``hash()`` built-in.\\n\\nThis support allows immutable sequences, such as ``tuple`` instances,\\nto be used as ``dict`` keys and stored in ``set`` and ``frozenset``\\ninstances.\\n\\nAttempting to hash an immutable sequence that contains unhashable\\nvalues will result in ``TypeError``.\\n\\n\\nMutable Sequence Types\\n======================\\n\\nThe operations in the following table are defined on mutable sequence\\ntypes. The ``collections.abc.MutableSequence`` ABC is provided to make\\nit easier to correctly implement these operations on custom sequence\\ntypes.\\n\\nIn the table *s* is an instance of a mutable sequence type, *t* is any\\niterable object and *x* is an arbitrary object that meets any type and\\nvalue restrictions imposed by *s* (for example, ``bytearray`` only\\naccepts integers that meet the value restriction ``0 <= x <= 255``).\\n\\n+--------------------------------+----------------------------------+-----------------------+\\n| Operation                      | Result                           | Notes                 |\\n+================================+==================================+=======================+\\n| ``s[i] = x``                   | item *i* of *s* is replaced by   |                       |\\n|                                | *x*                              |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s[i:j] = t``                 | slice of *s* from *i* to *j* is  |                       |\\n|                                | replaced by the contents of the  |                       |\\n|                                | iterable *t*                     |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``del s[i:j]``                 | same as ``s[i:j] = []``          |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s[i:j:k] = t``               | the elements of ``s[i:j:k]`` are | (1)                   |\\n|                                | replaced by those of *t*         |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``del s[i:j:k]``               | removes the elements of          |                       |\\n|                                | ``s[i:j:k]`` from the list       |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.append(x)``                | appends *x* to the end of the    |                       |\\n|                                | sequence (same as                |                       |\\n|                                | ``s[len(s):len(s)] = [x]``)      |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.clear()``                  | removes all items from ``s``     | (5)                   |\\n|                                | (same as ``del s[:]``)           |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.copy()``                   | creates a shallow copy of ``s``  | (5)                   |\\n|                                | (same as ``s[:]``)               |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.extend(t)``                | extends *s* with the contents of |                       |\\n|                                | *t* (same as ``s[len(s):len(s)]  |                       |\\n|                                | = t``)                           |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.insert(i, x)``             | inserts *x* into *s* at the      |                       |\\n|                                | index given by *i* (same as      |                       |\\n|                                | ``s[i:i] = [x]``)                |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.pop([i])``                 | retrieves the item at *i* and    | (2)                   |\\n|                                | also removes it from *s*         |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.remove(x)``                | remove the first item from *s*   | (3)                   |\\n|                                | where ``s[i] == x``              |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.reverse()``                | reverses the items of *s* in     | (4)                   |\\n|                                | place                            |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n\\nNotes:\\n\\n1. *t* must have the same length as the slice it is replacing.\\n\\n2. The optional argument *i* defaults to ``-1``, so that by default\\n   the last item is removed and returned.\\n\\n3. ``remove`` raises ``ValueError`` when *x* is not found in *s*.\\n\\n4. The ``reverse()`` method modifies the sequence in place for economy\\n   of space when reversing a large sequence.  To remind users that it\\n   operates by side effect, it does not return the reversed sequence.\\n\\n5. ``clear()`` and ``copy()`` are included for consistency with the\\n   interfaces of mutable containers that don\\'t support slicing\\n   operations (such as ``dict`` and ``set``)\\n\\n   New in version 3.3: ``clear()`` and ``copy()`` methods.\\n\\n\\nLists\\n=====\\n\\nLists are mutable sequences, typically used to store collections of\\nhomogeneous items (where the precise degree of similarity will vary by\\napplication).\\n\\nclass class list([iterable])\\n\\n   Lists may be constructed in several ways:\\n\\n   * Using a pair of square brackets to denote the empty list: ``[]``\\n\\n   * Using square brackets, separating items with commas: ``[a]``,\\n     ``[a, b, c]``\\n\\n   * Using a list comprehension: ``[x for x in iterable]``\\n\\n   * Using the type constructor: ``list()`` or ``list(iterable)``\\n\\n   The constructor builds a list whose items are the same and in the\\n   same order as *iterable*\\'s items.  *iterable* may be either a\\n   sequence, a container that supports iteration, or an iterator\\n   object.  If *iterable* is already a list, a copy is made and\\n   returned, similar to ``iterable[:]``. For example, ``list(\\'abc\\')``\\n   returns ``[\\'a\\', \\'b\\', \\'c\\']`` and ``list( (1, 2, 3) )`` returns ``[1,\\n   2, 3]``. If no argument is given, the constructor creates a new\\n   empty list, ``[]``.\\n\\n   Many other operations also produce lists, including the\\n   ``sorted()`` built-in.\\n\\n   Lists implement all of the *common* and *mutable* sequence\\n   operations. Lists also provide the following additional method:\\n\\n   sort(*, key=None, reverse=None)\\n\\n      This method sorts the list in place, using only ``<``\\n      comparisons between items. Exceptions are not suppressed - if\\n      any comparison operations fail, the entire sort operation will\\n      fail (and the list will likely be left in a partially modified\\n      state).\\n\\n      *key* specifies a function of one argument that is used to\\n      extract a comparison key from each list element (for example,\\n      ``key=str.lower``). The key corresponding to each item in the\\n      list is calculated once and then used for the entire sorting\\n      process. The default value of ``None`` means that list items are\\n      sorted directly without calculating a separate key value.\\n\\n      The ``functools.cmp_to_key()`` utility is available to convert a\\n      2.x style *cmp* function to a *key* function.\\n\\n      *reverse* is a boolean value.  If set to ``True``, then the list\\n      elements are sorted as if each comparison were reversed.\\n\\n      This method modifies the sequence in place for economy of space\\n      when sorting a large sequence.  To remind users that it operates\\n      by side effect, it does not return the sorted sequence (use\\n      ``sorted()`` to explicitly request a new sorted list instance).\\n\\n      The ``sort()`` method is guaranteed to be stable.  A sort is\\n      stable if it guarantees not to change the relative order of\\n      elements that compare equal --- this is helpful for sorting in\\n      multiple passes (for example, sort by department, then by salary\\n      grade).\\n\\n      **CPython implementation detail:** While a list is being sorted,\\n      the effect of attempting to mutate, or even inspect, the list is\\n      undefined.  The C implementation of Python makes the list appear\\n      empty for the duration, and raises ``ValueError`` if it can\\n      detect that the list has been mutated during a sort.\\n\\n\\nTuples\\n======\\n\\nTuples are immutable sequences, typically used to store collections of\\nheterogeneous data (such as the 2-tuples produced by the\\n``enumerate()`` built-in). Tuples are also used for cases where an\\nimmutable sequence of homogeneous data is needed (such as allowing\\nstorage in a ``set`` or ``dict`` instance).\\n\\nclass class tuple([iterable])\\n\\n   Tuples may be constructed in a number of ways:\\n\\n   * Using a pair of parentheses to denote the empty tuple: ``()``\\n\\n   * Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``\\n\\n   * Separating items with commas: ``a, b, c`` or ``(a, b, c)``\\n\\n   * Using the ``tuple()`` built-in: ``tuple()`` or\\n     ``tuple(iterable)``\\n\\n   The constructor builds a tuple whose items are the same and in the\\n   same order as *iterable*\\'s items.  *iterable* may be either a\\n   sequence, a container that supports iteration, or an iterator\\n   object.  If *iterable* is already a tuple, it is returned\\n   unchanged. For example, ``tuple(\\'abc\\')`` returns ``(\\'a\\', \\'b\\',\\n   \\'c\\')`` and ``tuple( [1, 2, 3] )`` returns ``(1, 2, 3)``. If no\\n   argument is given, the constructor creates a new empty tuple,\\n   ``()``.\\n\\n   Note that it is actually the comma which makes a tuple, not the\\n   parentheses. The parentheses are optional, except in the empty\\n   tuple case, or when they are needed to avoid syntactic ambiguity.\\n   For example, ``f(a, b, c)`` is a function call with three\\n   arguments, while ``f((a, b, c))`` is a function call with a 3-tuple\\n   as the sole argument.\\n\\n   Tuples implement all of the *common* sequence operations.\\n\\nFor heterogeneous collections of data where access by name is clearer\\nthan access by index, ``collections.namedtuple()`` may be a more\\nappropriate choice than a simple tuple object.\\n\\n\\nRanges\\n======\\n\\nThe ``range`` type represents an immutable sequence of numbers and is\\ncommonly used for looping a specific number of times in ``for`` loops.\\n\\nclass class range(stop)\\nclass class range(start, stop[, step])\\n\\n   The arguments to the range constructor must be integers (either\\n   built-in ``int`` or any object that implements the ``__index__``\\n   special method).  If the *step* argument is omitted, it defaults to\\n   ``1``. If the *start* argument is omitted, it defaults to ``0``. If\\n   *step* is zero, ``ValueError`` is raised.\\n\\n   For a positive *step*, the contents of a range ``r`` are determined\\n   by the formula ``r[i] = start + step*i`` where ``i >= 0`` and\\n   ``r[i] < stop``.\\n\\n   For a negative *step*, the contents of the range are still\\n   determined by the formula ``r[i] = start + step*i``, but the\\n   constraints are ``i >= 0`` and ``r[i] > stop``.\\n\\n   A range object will be empty if ``r[0]`` does not meet the value\\n   constraint. Ranges do support negative indices, but these are\\n   interpreted as indexing from the end of the sequence determined by\\n   the positive indices.\\n\\n   Ranges containing absolute values larger than ``sys.maxsize`` are\\n   permitted but some features (such as ``len()``) may raise\\n   ``OverflowError``.\\n\\n   Range examples:\\n\\n      >>> list(range(10))\\n      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\\n      >>> list(range(1, 11))\\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\\n      >>> list(range(0, 30, 5))\\n      [0, 5, 10, 15, 20, 25]\\n      >>> list(range(0, 10, 3))\\n      [0, 3, 6, 9]\\n      >>> list(range(0, -10, -1))\\n      [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\\n      >>> list(range(0))\\n      []\\n      >>> list(range(1, 0))\\n      []\\n\\n   Ranges implement all of the *common* sequence operations except\\n   concatenation and repetition (due to the fact that range objects\\n   can only represent sequences that follow a strict pattern and\\n   repetition and concatenation will usually violate that pattern).\\n\\nThe advantage of the ``range`` type over a regular ``list`` or\\n``tuple`` is that a ``range`` object will always take the same (small)\\namount of memory, no matter the size of the range it represents (as it\\nonly stores the ``start``, ``stop`` and ``step`` values, calculating\\nindividual items and subranges as needed).\\n\\nRange objects implement the ``collections.Sequence`` ABC, and provide\\nfeatures such as containment tests, element index lookup, slicing and\\nsupport for negative indices (see *Sequence Types --- list, tuple,\\nrange*):\\n\\n>>> r = range(0, 20, 2)\\n>>> r\\nrange(0, 20, 2)\\n>>> 11 in r\\nFalse\\n>>> 10 in r\\nTrue\\n>>> r.index(10)\\n5\\n>>> r[5]\\n10\\n>>> r[:5]\\nrange(0, 10, 2)\\n>>> r[-1]\\n18\\n\\nTesting range objects for equality with ``==`` and ``!=`` compares\\nthem as sequences.  That is, two range objects are considered equal if\\nthey represent the same sequence of values.  (Note that two range\\nobjects that compare equal might have different ``start``, ``stop``\\nand ``step`` attributes, for example ``range(0) == range(2, 1, 3)`` or\\n``range(0, 3, 2) == range(0, 4, 2)``.)\\n\\nChanged in version 3.2: Implement the Sequence ABC. Support slicing\\nand negative indices. Test ``int`` objects for membership in constant\\ntime instead of iterating through all items.\\n\\nChanged in version 3.3: Define \\'==\\' and \\'!=\\' to compare range objects\\nbased on the sequence of values they define (instead of comparing\\nbased on object identity).\\n\\nNew in version 3.3: The ``start``, ``stop`` and ``step`` attributes.\\n',\n'typesseq-mutable': \"\\nMutable Sequence Types\\n**********************\\n\\nThe operations in the following table are defined on mutable sequence\\ntypes. The ``collections.abc.MutableSequence`` ABC is provided to make\\nit easier to correctly implement these operations on custom sequence\\ntypes.\\n\\nIn the table *s* is an instance of a mutable sequence type, *t* is any\\niterable object and *x* is an arbitrary object that meets any type and\\nvalue restrictions imposed by *s* (for example, ``bytearray`` only\\naccepts integers that meet the value restriction ``0 <= x <= 255``).\\n\\n+--------------------------------+----------------------------------+-----------------------+\\n| Operation                      | Result                           | Notes                 |\\n+================================+==================================+=======================+\\n| ``s[i] = x``                   | item *i* of *s* is replaced by   |                       |\\n|                                | *x*                              |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s[i:j] = t``                 | slice of *s* from *i* to *j* is  |                       |\\n|                                | replaced by the contents of the  |                       |\\n|                                | iterable *t*                     |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``del s[i:j]``                 | same as ``s[i:j] = []``          |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s[i:j:k] = t``               | the elements of ``s[i:j:k]`` are | (1)                   |\\n|                                | replaced by those of *t*         |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``del s[i:j:k]``               | removes the elements of          |                       |\\n|                                | ``s[i:j:k]`` from the list       |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.append(x)``                | appends *x* to the end of the    |                       |\\n|                                | sequence (same as                |                       |\\n|                                | ``s[len(s):len(s)] = [x]``)      |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.clear()``                  | removes all items from ``s``     | (5)                   |\\n|                                | (same as ``del s[:]``)           |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.copy()``                   | creates a shallow copy of ``s``  | (5)                   |\\n|                                | (same as ``s[:]``)               |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.extend(t)``                | extends *s* with the contents of |                       |\\n|                                | *t* (same as ``s[len(s):len(s)]  |                       |\\n|                                | = t``)                           |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.insert(i, x)``             | inserts *x* into *s* at the      |                       |\\n|                                | index given by *i* (same as      |                       |\\n|                                | ``s[i:i] = [x]``)                |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.pop([i])``                 | retrieves the item at *i* and    | (2)                   |\\n|                                | also removes it from *s*         |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.remove(x)``                | remove the first item from *s*   | (3)                   |\\n|                                | where ``s[i] == x``              |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n| ``s.reverse()``                | reverses the items of *s* in     | (4)                   |\\n|                                | place                            |                       |\\n+--------------------------------+----------------------------------+-----------------------+\\n\\nNotes:\\n\\n1. *t* must have the same length as the slice it is replacing.\\n\\n2. The optional argument *i* defaults to ``-1``, so that by default\\n   the last item is removed and returned.\\n\\n3. ``remove`` raises ``ValueError`` when *x* is not found in *s*.\\n\\n4. The ``reverse()`` method modifies the sequence in place for economy\\n   of space when reversing a large sequence.  To remind users that it\\n   operates by side effect, it does not return the reversed sequence.\\n\\n5. ``clear()`` and ``copy()`` are included for consistency with the\\n   interfaces of mutable containers that don't support slicing\\n   operations (such as ``dict`` and ``set``)\\n\\n   New in version 3.3: ``clear()`` and ``copy()`` methods.\\n\",\n'unary': '\\nUnary arithmetic and bitwise operations\\n***************************************\\n\\nAll unary arithmetic and bitwise operations have the same priority:\\n\\n   u_expr ::= power | \"-\" u_expr | \"+\" u_expr | \"~\" u_expr\\n\\nThe unary ``-`` (minus) operator yields the negation of its numeric\\nargument.\\n\\nThe unary ``+`` (plus) operator yields its numeric argument unchanged.\\n\\nThe unary ``~`` (invert) operator yields the bitwise inversion of its\\ninteger argument.  The bitwise inversion of ``x`` is defined as\\n``-(x+1)``.  It only applies to integral numbers.\\n\\nIn all three cases, if the argument does not have the proper type, a\\n``TypeError`` exception is raised.\\n',\n'while': '\\nThe ``while`` statement\\n***********************\\n\\nThe ``while`` statement is used for repeated execution as long as an\\nexpression is true:\\n\\n   while_stmt ::= \"while\" expression \":\" suite\\n                  [\"else\" \":\" suite]\\n\\nThis repeatedly tests the expression and, if it is true, executes the\\nfirst suite; if the expression is false (which may be the first time\\nit is tested) the suite of the ``else`` clause, if present, is\\nexecuted and the loop terminates.\\n\\nA ``break`` statement executed in the first suite terminates the loop\\nwithout executing the ``else`` clause\\'s suite.  A ``continue``\\nstatement executed in the first suite skips the rest of the suite and\\ngoes back to testing the expression.\\n',\n'with': '\\nThe ``with`` statement\\n**********************\\n\\nThe ``with`` statement is used to wrap the execution of a block with\\nmethods defined by a context manager (see section *With Statement\\nContext Managers*). This allows common\\n``try``...``except``...``finally`` usage patterns to be encapsulated\\nfor convenient reuse.\\n\\n   with_stmt ::= \"with\" with_item (\",\" with_item)* \":\" suite\\n   with_item ::= expression [\"as\" target]\\n\\nThe execution of the ``with`` statement with one \"item\" proceeds as\\nfollows:\\n\\n1. The context expression (the expression given in the ``with_item``)\\n   is evaluated to obtain a context manager.\\n\\n2. The context manager\\'s ``__exit__()`` is loaded for later use.\\n\\n3. The context manager\\'s ``__enter__()`` method is invoked.\\n\\n4. If a target was included in the ``with`` statement, the return\\n   value from ``__enter__()`` is assigned to it.\\n\\n   Note: The ``with`` statement guarantees that if the ``__enter__()``\\n     method returns without an error, then ``__exit__()`` will always\\n     be called. Thus, if an error occurs during the assignment to the\\n     target list, it will be treated the same as an error occurring\\n     within the suite would be. See step 6 below.\\n\\n5. The suite is executed.\\n\\n6. The context manager\\'s ``__exit__()`` method is invoked.  If an\\n   exception caused the suite to be exited, its type, value, and\\n   traceback are passed as arguments to ``__exit__()``. Otherwise,\\n   three ``None`` arguments are supplied.\\n\\n   If the suite was exited due to an exception, and the return value\\n   from the ``__exit__()`` method was false, the exception is\\n   reraised.  If the return value was true, the exception is\\n   suppressed, and execution continues with the statement following\\n   the ``with`` statement.\\n\\n   If the suite was exited for any reason other than an exception, the\\n   return value from ``__exit__()`` is ignored, and execution proceeds\\n   at the normal location for the kind of exit that was taken.\\n\\nWith more than one item, the context managers are processed as if\\nmultiple ``with`` statements were nested:\\n\\n   with A() as a, B() as b:\\n       suite\\n\\nis equivalent to\\n\\n   with A() as a:\\n       with B() as b:\\n           suite\\n\\nChanged in version 3.1: Support for multiple context expressions.\\n\\nSee also:\\n\\n   **PEP 0343** - The \"with\" statement\\n      The specification, background, and examples for the Python\\n      ``with`` statement.\\n',\n'yield': '\\nThe ``yield`` statement\\n***********************\\n\\n   yield_stmt ::= yield_expression\\n\\nThe ``yield`` statement is only used when defining a generator\\nfunction, and is only used in the body of the generator function.\\nUsing a ``yield`` statement in a function definition is sufficient to\\ncause that definition to create a generator function instead of a\\nnormal function.\\n\\nWhen a generator function is called, it returns an iterator known as a\\ngenerator iterator, or more commonly, a generator.  The body of the\\ngenerator function is executed by calling the ``next()`` function on\\nthe generator repeatedly until it raises an exception.\\n\\nWhen a ``yield`` statement is executed, the state of the generator is\\nfrozen and the value of ``expression_list`` is returned to\\n``next()``\\'s caller.  By \"frozen\" we mean that all local state is\\nretained, including the current bindings of local variables, the\\ninstruction pointer, and the internal evaluation stack: enough\\ninformation is saved so that the next time ``next()`` is invoked, the\\nfunction can proceed exactly as if the ``yield`` statement were just\\nanother external call.\\n\\nThe ``yield`` statement is allowed in the ``try`` clause of a ``try``\\n...  ``finally`` construct.  If the generator is not resumed before it\\nis finalized (by reaching a zero reference count or by being garbage\\ncollected), the generator-iterator\\'s ``close()`` method will be\\ncalled, allowing any pending ``finally`` clauses to execute.\\n\\nWhen ``yield from <expr>`` is used, it treats the supplied expression\\nas a subiterator, producing values from it until the underlying\\niterator is exhausted.\\n\\n   Changed in version 3.3: Added ``yield from <expr>`` to delegate\\n   control flow to a subiterator\\n\\nFor full details of ``yield`` semantics, refer to the *Yield\\nexpressions* section.\\n\\nSee also:\\n\\n   **PEP 0255** - Simple Generators\\n      The proposal for adding generators and the ``yield`` statement\\n      to Python.\\n\\n   **PEP 0342** - Coroutines via Enhanced Generators\\n      The proposal to enhance the API and syntax of generators, making\\n      them usable as simple coroutines.\\n\\n   **PEP 0380** - Syntax for Delegating to a Subgenerator\\n      The proposal to introduce the ``yield_from`` syntax, making\\n      delegation to sub-generators easy.\\n'}\n"], "markdown2": [".py", "import browser.html\nimport re\n\nclass URL:\n def __init__(self,src):\n  elts = src.split(maxsplit=1)\n  self.href = elts[0]\n  self.alt = ''\n  if len(elts)==2:\n   alt = elts[1]\n   if alt[0]=='\"' and alt[-1]=='\"':self.alt=alt[1:-1]\n   elif alt[0]==\"'\" and alt[-1]==\"'\":self.alt=alt[1:-1]\n   elif alt[0]==\"(\" and alt[-1]==\")\":self.alt=alt[1:-1]\n   \nclass CodeBlock:\n def __init__(self,line):\n  self.lines = [line]\n  \n def to_html(self):\n  if self.lines[0].startswith(\"`\"):\n   self.lines.pop(0)\n  res = escape('\\n'.join(self.lines))\n  res = unmark(res)\n  res = '<pre class=\"marked\">%s</pre>\\n' %res\n  return res,[]\n  \nclass Marked:\n def __init__(self, line=''):\n  self.line = line\n  self.children = []\n  \n def to_html(self):\n  return apply_markdown(self.line)\n  \n  \nrefs = {}\nref_pattern = r\"^\\[(.*)\\]:\\s+(.*)\"\n\ndef mark(src):\n\n global refs\n refs = {}\n \n \n \n \n \n \n \n \n src = src.replace('\\r\\n','\\n')\n \n \n src = re.sub(r'(.*?)\\n=+\\n', '\\n# \\\\1\\n', src)\n src = re.sub(r'(.*?)\\n-+\\n', '\\n## \\\\1\\n', src) \n \n lines = src.split('\\n')\n \n i = bq = 0\n ul = ol = 0\n \n while i<len(lines):\n \n \n  if lines[i].startswith('>'):\n   nb = 1\n   while nb<len(lines[i]) and lines[i][nb]=='>':\n    nb += 1\n   lines[i] = lines[i][nb:]\n   if nb>bq:\n    lines.insert(i,'<blockquote>'*(nb-bq))\n    i += 1\n    bq = nb\n   elif nb<bq:\n    lines.insert(i,'</blockquote>'*(bq-nb))\n    i += 1\n    bq = nb\n  elif bq>0:\n   lines.insert(i,'</blockquote>'*bq)\n   i += 1\n   bq = 0\n   \n   \n  if lines[i].strip() and lines[i].lstrip()[0] in '-+*' and (i==0 or ul or not lines[i-1].strip()):\n   print('is ul',lines[i])\n   \n   nb = 1+len(lines[i])-len(lines[i].lstrip())\n   lines[i] = '<li>'+lines[i][1+nb:]\n   if nb>ul:\n    lines.insert(i,'<ul>'*(nb-ul))\n    i += 1\n   elif nb<ul:\n    lines.insert(i,'</ul>'*(ul-nb))\n    i += 1\n   ul = nb\n  elif ul:\n   lines.insert(i,'</ul>'*ul)\n   i += 1\n   ul = 0\n   \n   \n  mo = re.search(r'^(\\d+\\.)',lines[i])\n  if mo:\n   if not ol:\n    lines.insert(i,'<ol>')\n    i += 1\n   lines[i] = '<li>'+lines[i][len(mo.groups()[0]):]\n   ol = 1\n  elif ol:\n   lines.insert(i,'</ol>')\n   i += 1\n   ol = 0\n  i += 1\n  \n sections = []\n scripts = []\n section = Marked()\n \n i = 0\n while i<len(lines):\n  line = lines[i]\n  if line.strip() and line.startswith('    '):\n   if isinstance(section,Marked) and section.line:\n    sections.append(section)\n   section = CodeBlock(line[4:])\n   j = i+1\n   while j<len(lines) and lines[j].strip() and lines[j].startswith('    '):\n    section.lines.append(lines[j][4:])\n    j += 1\n   sections.append(section)\n   section = Marked()\n   i = j \n   continue\n  elif line.lower().startswith('<script'):\n   if isinstance(section,Marked) and section.line:\n    sections.append(section)\n    section = Marked()\n   j = i+1\n   while j<len(lines):\n    if lines[j].lower().startswith('</script>'):\n     scripts.append('\\n'.join(lines[i+1:j]))\n     for k in range(i,j+1):\n      lines[k] = ''\n     break\n    j += 1\n   i = j\n   continue\n  else:\n   mo = re.search(ref_pattern,line)\n   if mo is not None:\n    if isinstance(section,Marked) and section.line:\n     sections.append(section)\n     section = Marked()\n    key = mo.groups()[0]\n    value = URL(mo.groups()[1])\n    refs[key.lower()] = value\n   else:\n    if line.strip():\n     if section.line:\n      section.line += ' '\n     section.line += line\n    else:\n     sections.append(section)\n     section = Marked()\n   i += 1\n   \n res = ''\n for section in sections:\n  mk,_scripts = section.to_html()\n  res += '<p>'+mk+'\\n'\n  scripts += _scripts\n return res,scripts\n \ndef escape(czone):\n czone = czone.replace('&','&amp;')\n czone = czone.replace('<','&lt;')\n czone = czone.replace('>','&gt;')\n return czone\n \ndef s_escape(mo):\n\n czone = mo.string[mo.start():mo.end()]\n return escape(czone)\n \ndef unmark(code_zone):\n\n code_zone = code_zone.replace('_','&#95;')\n return code_zone\n \ndef s_unmark(mo):\n\n code_zone = mo.string[mo.start():mo.end()]\n code_zone = code_zone.replace('_','&#95;')\n return code_zone\n \ndef apply_markdown(src):\n\n scripts = []\n \n \n src = re.sub(r'\\\\\\`','&#96;',src)\n \n \n code_pattern = r'\\`(\\S.*?\\S)\\`'\n src = re.sub(code_pattern,s_escape,src)\n \n src = re.sub(code_pattern,s_unmark,src)\n \n \n link_pattern1 = r'\\[(.+?)\\]\\s?\\((.+?)\\)'\n def repl(mo):\n  g1,g2 = mo.groups()\n  g2 = re.sub('_','&#95;',g2)\n  return '<a href=\"%s\">%s</a>' %(g2,g1)\n src = re.sub(link_pattern1,repl,src)\n \n \n link_pattern2 = r'\\[(.+?)\\]\\s?\\[(.*?)\\]'\n while True:\n  mo = re.search(link_pattern2,src)\n  if mo is None:break\n  text,key = mo.groups()\n  print(text,key)\n  if not key:key=text \n  if key.lower() not in refs:\n   raise KeyError('unknow reference %s' %key)\n  url = refs[key.lower()]\n  repl = '<a href=\"'+url.href+'\"'\n  if url.alt:\n   repl += ' title=\"'+url.alt+'\"'\n  repl += '>%s</a>' %text\n  src = re.sub(link_pattern2,repl,src,count=1)\n  \n  \n  \n  \n src = re.sub(r'\\\\\\*','&#42;',src)\n \n src = re.sub(r'\\\\\\_','&#95;',src)\n \n src = re.sub(r' _ ',' &#95; ',src)\n src = re.sub(r' \\* ',' &#42; ',src)\n \n strong_patterns = [('STRONG',r'\\*\\*(.*?)\\*\\*'),('B',r'__(.*?)__')]\n for tag,strong_pattern in strong_patterns:\n  src = re.sub(strong_pattern,r'<%s>\\1</%s>' %(tag,tag),src)\n  \n em_patterns = [('EM',r'\\*(.*?)\\*'),('I',r'\\_(.*?)\\_')]\n for tag,em_pattern in em_patterns:\n  src = re.sub(em_pattern,r'<%s>\\1</%s>' %(tag,tag),src)\n  \n  \n  \n src = re.sub(r'\\\\\\`','&#96;',src)\n \n code_pattern = r'\\`(.*?)\\`'\n src = re.sub(code_pattern,r'<code>\\1</code>',src)\n \n \n lines = src.split('\\n')\n \n atx_header_pattern = '^(#+)(.*)(#*)'\n for i,line in enumerate(lines):\n  print('line [%s]' %line, line.startswith('#'))\n  mo = re.search(atx_header_pattern,line)\n  if not mo:continue\n  print('pattern matches')\n  level = len(mo.groups()[0])\n  lines[i] = re.sub(atx_header_pattern,\n  '<H%s>%s</H%s>\\n' %(level,mo.groups()[1],level),\n  line,count=1)\n  \n src = '\\n'.join(lines) \n src = re.sub('\\n\\n+','\\n<p>',src)+'\\n'\n \n return src,scripts\n"], "site-packages.pygame.rect": [".py", "\n\n\"\"\n\n__docformat__ = 'restructuredtext'\n__version__ = '$Id$'\n\nimport copy\n\n\nimport SDL\n\nclass _RectProxy:\n \"\"\n \n __slots__ = ['x', 'y', 'w', 'h']\n \n def __init__(self, r):\n  if isinstance(r, SDL.SDL_Rect) or isinstance(r, Rect):\n   self.x = r.x\n   self.y = r.y\n   self.w = r.w\n   self.h = r.h\n  else:\n   self.x = r[0]\n   self.y = r[1]\n   self.w = r[2]\n   self.h = r[3]\n   \n def _get_as_parameter_(self):\n  return SDL.SDL_Rect(self.x, self.y, self.w, self.h)\n  \n _as_parameter_ = property(_get_as_parameter_)\n \nclass Rect:\n __slots__ = ['_r']\n \n def __init__(self, *args):\n  if len(args) == 1:\n   arg = args[0]\n   if isinstance(arg, Rect):\n    object.__setattr__(self, '_r', copy.copy(arg._r))\n    return\n   elif isinstance(arg, SDL.SDL_Rect):\n    object.__setattr__(self, '_r', copy.copy(arg))\n    return\n   elif hasattr(arg, 'rect'):\n    arg = arg.rect\n    if callable(arg):\n     arg = arg()\n    self.__init__(arg)\n    return\n   elif hasattr(arg, '__len__'):\n    args = arg\n   else:\n    raise TypeError('Argument must be rect style object')\n  if len(args) == 4:\n   if args[2] < 0 or args[3] < 0:\n    object.__setattr__(self, '_r', _RectProxy((int(args[0]),\n    int(args[1]),\n    int(args[2]),\n    int(args[3]))))\n   else:\n    object.__setattr__(self, '_r', SDL.SDL_Rect(int(args[0]),\n    int(args[1]),\n    int(args[2]),\n    int(args[3])))\n  elif len(args) == 2:\n   if args[1][0] < 0 or args[1][1] < 0:\n    object.__setattr__(self, '_r', \n    _RectProxy((int(args[0][0]), \n    int(args[0][1]), \n    int(args[1][0]), \n    int(args[1][1]))))\n   else:\n    object.__setattr__(self, '_r', \n    SDL.SDL_Rect(int(args[0][0]), \n    int(args[0][1]), \n    int(args[1][0]), \n    int(args[1][1])))\n  else:\n   raise TypeError('Argument must be rect style object')\n   \n def __copy__(self):\n  return Rect(self)\n  \n def __repr__(self):\n  return '<rect(%d, %d, %d, %d)>' % (self._r.x, self._r.y, self._r.w, self._r.h)\n  \n def __cmp__(self, *other):\n  other = _rect_from_object(other)\n  \n  if self._r.x != other._r.x:\n   return cmp(self._r.x, other._r.x)\n  if self._r.y != other._r.y:\n   return cmp(self._r.y, other._r.y)\n  if self._r.w != other._r.w:\n   return cmp(self._r.w, other._r.w)\n  if self._r.h != other._r.h:\n   return cmp(self._r.h, other._r.h)\n  return 0\n  \n def __nonzero__(self):\n  return self._r.w != 0 and self._r.h != 0\n  \n def __getattr__(self, name):\n  if name == 'top':\n   return self._r.y\n  elif name == 'left':\n   return self._r.x\n  elif name == 'bottom':\n   return self._r.y + self._r.h\n  elif name == 'right':\n   return self._r.x + self._r.w\n  elif name == 'topleft':\n   return self._r.x, self._r.y\n  elif name == 'bottomleft':\n   return self._r.x, self._r.y + self._r.h\n  elif name == 'topright':\n   return self._r.x + self._r.w, self._r.y\n  elif name == 'bottomright':\n   return self._r.x + self._r.w, self._r.y + self._r.h\n  elif name == 'midtop':\n   return self._r.x + self._r.w / 2, self._r.y\n  elif name == 'midleft':\n   return self._r.x, self._r.y + self._r.h / 2\n  elif name == 'midbottom':\n   return self._r.x + self._r.w / 2, self._r.y + self._r.h\n  elif name == 'midright':\n   return self._r.x + self._r.w, self._r.y + self._r.h / 2\n  elif name == 'center':\n   return self._r.x + self._r.w / 2, self._r.y + self._r.h / 2\n  elif name == 'centerx':\n   return self._r.x + self._r.w / 2\n  elif name == 'centery':\n   return self._r.y + self._r.h / 2\n  elif name == 'size':\n   return self._r.w, self._r.h\n  elif name == 'width':\n   return self._r.w\n  elif name == 'height':\n   return self._r.h\n  else:\n   raise AttributeError(name)\n   \n def __setattr__(self, name, value):\n  if name == 'top' or name == 'y':\n   self._r.y = value\n  elif name == 'left' or name == 'x':\n   self._r.x = int(value)\n  elif name == 'bottom':\n   self._r.y = int(value) - self._r.h\n  elif name == 'right':\n   self._r.x = int(value) - self._r.w\n  elif name == 'topleft':\n   self._r.x = int(value[0]) \n   self._r.y = int(value[1])\n  elif name == 'bottomleft':\n   self._r.x = int(value[0])\n   self._r.y = int(value[1]) - self._r.h\n  elif name == 'topright':\n   self._r.x = int(value[0]) - self._r.w\n   self._r.y = int(value[1])\n  elif name == 'bottomright':\n   self._r.x = int(value[0]) - self._r.w\n   self._r.y = int(value[1]) - self._r.h\n  elif name == 'midtop':\n   self._r.x = int(value[0]) - self._r.w / 2\n   self._r.y = int(value[1])\n  elif name == 'midleft':\n   self._r.x = int(value[0])\n   self._r.y = int(value[1]) - self._r.h / 2\n  elif name == 'midbottom':\n   self._r.x = int(value[0]) - self._r.w / 2\n   self._r.y = int(value[1]) - self._r.h\n  elif name == 'midright':\n   self._r.x = int(value[0]) - self._r.w\n   self._r.y = int(value[1]) - self._r.h / 2\n  elif name == 'center':\n   self._r.x = int(value[0]) - self._r.w / 2\n   self._r.y = int(value[1]) - self._r.h / 2\n  elif name == 'centerx':\n   self._r.x = int(value) - self._r.w / 2\n  elif name == 'centery':\n   self._r.y = int(value) - self._r.h / 2\n  elif name == 'size':\n   if int(value[0]) < 0 or int(value[1]) < 0:\n    self._ensure_proxy()\n   self._r.w, self._r.h = int(value)\n  elif name == 'width':\n   if int(value) < 0:\n    self._ensure_proxy()\n   self._r.w = int(value)\n  elif name == 'height':\n   if int(value) < 0:\n    self._ensure_proxy()\n   self._r.h = int(value)\n  else:\n   raise AttributeError(name)\n   \n def _ensure_proxy(self):\n  if not isinstance(self._r, _RectProxy):\n   object.__setattr__(self, '_r', _RectProxy(self._r))\n   \n def __len__(self):\n  return 4\n  \n def __getitem__(self, key):\n  return (self._r.x, self._r.y, self._r.w, self._r.h)[key]\n  \n def __setitem__(self, key, value):\n  r = [self._r.x, self._r.y, self._r.w, self._r.h]\n  r[key] = value\n  self._r.x, self._r.y, self._r.w, self._r.h = r\n  \n def __coerce__(self, *other):\n  try:\n   return self, Rect(*other)\n  except TypeError:\n   return None\n   \n def move(self, *pos):\n  x, y = _two_ints_from_args(pos)\n  return Rect(self._r.x + x, self._r.y + y, self._r.w, self._r.h)\n  \n def move_ip(self, *pos):\n  x, y = _two_ints_from_args(pos)\n  self._r.x += x\n  self._r.y += y\n  \n def inflate(self, x, y):\n  return Rect(self._r.x - x / 2, self._r.y - y / 2, \n  self._r.w + x, self._r.h + y)\n  \n def inflate_ip(self, x, y):\n  self._r.x -= x / 2\n  self._r.y -= y / 2\n  self._r.w += x\n  self._r.h += y\n  \n def clamp(self, *other):\n  r = Rect(self)\n  r.clamp_ip(*other)\n  return r\n  \n def clamp_ip(self, *other):\n  other = _rect_from_object(other)._r\n  if self._r.w >= other.w:\n   x = other.x + other.w / 2 - self._r.w / 2\n  elif self._r.x < other.x:\n   x = other.x\n  elif self._r.x + self._r.w > other.x + other.w:\n   x = other.x + other.w - self._r.w\n  else:\n   x = self._r.x\n   \n  if self._r.h >= other.h:\n   y = other.y + other.h / 2 - self._r.h / 2\n  elif self._r.y < other.y:\n   y = other.y\n  elif self._r.y + self._r.h > other.y + other.h:\n   y = other.y + other.h - self._r.h\n  else:\n   y = self._r.y\n   \n  self._r.x, self._r.y = x, y\n  \n def clip(self, *other):\n  r = Rect(self)\n  r.clip_ip(*other)\n  return r\n  \n def clip_ip(self, *other):\n  other = _rect_from_object(other)._r\n  x = max(self._r.x, other.x)\n  w = min(self._r.x + self._r.w, other.x + other.w) - x\n  y = max(self._r.y, other.y)\n  h = min(self._r.y + self._r.h, other.y + other.h) - y\n  \n  if w <= 0 or h <= 0:\n   self._r.w, self._r.h = 0, 0\n  else:\n   self._r.x, self._r.y, self._r.w, self._r.h = x, y, w, h\n   \n def union(self, *other):\n  r = Rect(self)\n  r.union_ip(*other)\n  return r\n  \n def union_ip(self, *other):\n  other = _rect_from_object(other)._r\n  x = min(self._r.x, other.x)\n  y = min(self._r.y, other.y)\n  w = max(self._r.x + self._r.w, other.x + other.w) - x\n  h = max(self._r.y + self._r.h, other.y + other.h) - y\n  self._r.x, self._r.y, self._r.w, self._r.h = x, y, w, h\n  \n def unionall(self, others):\n  r = Rect(self)\n  r.unionall_ip(others)\n  return r\n  \n def unionall_ip(self, others):\n  l = self._r.x\n  r = self._r.x + self._r.w\n  t = self._r.y\n  b = self._r.y + self._r.h\n  for other in others:\n   other = _rect_from_object(other)._r\n   l = min(l, other.x)\n   r = max(r, other.x + other.w)\n   t = min(t, other.y)\n   b = max(b, other.y + other.h)\n  self._r.x, self._r.y, self._r.w, self._r.h = l, t, r - l, b - t\n  \n def fit(self, *other):\n  r = Rect(self)\n  r.fit_ip(*other)\n  return r\n  \n def fit_ip(self, *other):\n  other = _rect_from_object(other)._r\n  \n  xratio = self._r.w / float(other.w)\n  yratio = self._r.h / float(other.h)\n  maxratio = max(xratio, yratio)\n  self._r.w = int(self._r.w / maxratio)\n  self._r.h = int(self._r.h / maxratio)\n  self._r.x = other.x + (other.w - self._r.w) / 2\n  self._r.y = other.y + (other.h - self._r.h) / 2\n  \n def normalize(self):\n  if self._r.w < 0:\n   self._r.x += self._r.w\n   self._r.w = -self._r.w\n  if self._r.h < 0:\n   self._r.y += self._r.h\n   self._r.h = -self._r.h\n  if isinstance(self._r, _RectProxy):\n   object.__setattr__(self, '_r', SDL.SDL_Rect(self._r.x,\n   self._r.y,\n   self._r.w,\n   self._r.h))\n   \n def contains(self, *other):\n  other = _rect_from_object(other)._r\n  return self._r.x <= other.x and self._r.y <= other.y and self._r.x + self._r.w >= other.x + other.w and self._r.y + self._r.h >= other.y + other.h and self._r.x + self._r.w > other.x and self._r.y + self._r.h > other.y\n  \n def collidepoint(self, x, y):\n  return x >= self._r.x and y >= self._r.y and x < self._r.x + self._r.w and y < self._r.y + self._r.h\n  \n def colliderect(self, *other):\n  return _rect_collide(self._r, _rect_from_object(other)._r)\n  \n def collidelist(self, others):\n  for i in range(len(others)):\n   if _rect_collide(self._r, _rect_from_object(others[i])._r):\n    return i\n  return -1\n  \n def collidelistall(self, others):\n  matches = []\n  for i in range(len(others)):\n   if _rect_collide(self._r, _rect_from_object(others[i])._r):\n    matches.append(i)\n  return matches\n  \n def collidedict(self, d):\n  for key, other in d.items():\n   if _rect_collide(self._r, _rect_from_object(other)._r):\n    return key, other\n  return None\n  \n def collidedictall(self, d):\n  matches = []\n  for key, other in d.items():\n   if _rect_collide(self._r, _rect_from_object(other)._r):\n    matches.append((key, other))\n  return matches\n  \ndef _rect_from_object(obj):\n if isinstance(obj, Rect):\n  return obj\n if type(obj) in (tuple, list):\n  return Rect(*obj)\n else:\n  return Rect(obj)\n  \ndef _rect_collide(a, b):\n return a.x + a.w > b.x and b.x + b.w > a.x and a.y + a.h > b.y and b.y + b.h > a.y\n \ndef _two_ints_from_args(arg):\n if len(arg) == 1:\n  return _two_ints_from_args(arg[0])\n else:\n  return arg[:2]\n"], "types": [".py", "\"\"\nimport sys\n\n\n\n\n\n\ndef _f(): pass\nFunctionType = type(_f)\nLambdaType = type(lambda: None) \nCodeType = type(_f.__code__)\nMappingProxyType = type(type.__dict__)\nSimpleNamespace = type(sys.implementation)\n\ndef _g():\n yield 1\nGeneratorType = type(_g())\n\nclass _C:\n def _m(self): pass\nMethodType = type(_C()._m)\n\nBuiltinFunctionType = type(len)\nBuiltinMethodType = type([].append) \n\nModuleType = type(sys)\n\ntry:\n raise TypeError\nexcept TypeError:\n tb = sys.exc_info()[2]\n TracebackType = type(tb)\n FrameType = type(tb.tb_frame)\n tb = None; del tb\n \n \nGetSetDescriptorType = type(FunctionType.__code__)\nMemberDescriptorType = type(FunctionType.__globals__)\n\ndel sys, _f, _g, _C, \n\n\n\ndef new_class(name, bases=(), kwds=None, exec_body=None):\n \"\"\n meta, ns, kwds = prepare_class(name, bases, kwds)\n if exec_body is not None:\n  exec_body(ns)\n return meta(name, bases, ns, **kwds)\n \ndef prepare_class(name, bases=(), kwds=None):\n \"\"\n if kwds is None:\n  kwds = {}\n else:\n  kwds = dict(kwds) \n if 'metaclass' in kwds:\n  meta = kwds.pop('metaclass')\n else:\n  if bases:\n   meta = type(bases[0])\n  else:\n   meta = type\n if isinstance(meta, type):\n \n \n  meta = _calculate_meta(meta, bases)\n if hasattr(meta, '__prepare__'):\n  ns = meta.__prepare__(name, bases, **kwds)\n else:\n  ns = {}\n return meta, ns, kwds\n \ndef _calculate_meta(meta, bases):\n \"\"\n winner = meta\n for base in bases:\n  base_meta = type(base)\n  if issubclass(winner, base_meta):\n   continue\n  if issubclass(base_meta, winner):\n   winner = base_meta\n   continue\n   \n  raise TypeError(\"metaclass conflict: \"\n  \"the metaclass of a derived class \"\n  \"must be a (non-strict) subclass \"\n  \"of the metaclasses of all its bases\")\n return winner\n"], "xml.sax.expatreader": [".py", "\"\"\n\nversion = \"0.20\"\n\nfrom xml.sax._exceptions import *\nfrom xml.sax.handler import feature_validation, feature_namespaces\nfrom xml.sax.handler import feature_namespace_prefixes\nfrom xml.sax.handler import feature_external_ges, feature_external_pes\nfrom xml.sax.handler import feature_string_interning\nfrom xml.sax.handler import property_xml_string, property_interning_dict\n\n\nimport sys\nif sys.platform[:4] == \"java\":\n raise SAXReaderNotAvailable(\"expat not available in Java\", None)\ndel sys\n\ntry:\n from xml.parsers import expat\nexcept ImportError:\n raise SAXReaderNotAvailable(\"expat not supported\", None)\nelse:\n if not hasattr(expat, \"ParserCreate\"):\n  raise SAXReaderNotAvailable(\"expat not supported\", None)\nfrom xml.sax import xmlreader, saxutils, handler\n\nAttributesImpl = xmlreader.AttributesImpl\nAttributesNSImpl = xmlreader.AttributesNSImpl\n\n\n\n\ntry:\n import _weakref\nexcept ImportError:\n def _mkproxy(o):\n  return o\nelse:\n import weakref\n _mkproxy = weakref.proxy\n del weakref, _weakref\n \n \n \nclass ExpatLocator(xmlreader.Locator):\n \"\"\n def __init__(self, parser):\n  self._ref = _mkproxy(parser)\n  \n def getColumnNumber(self):\n  parser = self._ref\n  if parser._parser is None:\n   return None\n  return parser._parser.ErrorColumnNumber\n  \n def getLineNumber(self):\n  parser = self._ref\n  if parser._parser is None:\n   return 1\n  return parser._parser.ErrorLineNumber\n  \n def getPublicId(self):\n  parser = self._ref\n  if parser is None:\n   return None\n  return parser._source.getPublicId()\n  \n def getSystemId(self):\n  parser = self._ref\n  if parser is None:\n   return None\n  return parser._source.getSystemId()\n  \n  \n  \n  \nclass ExpatParser(xmlreader.IncrementalParser, xmlreader.Locator):\n \"\"\n \n def __init__(self, namespaceHandling=0, bufsize=2**16-20):\n  xmlreader.IncrementalParser.__init__(self, bufsize)\n  self._source = xmlreader.InputSource()\n  self._parser = None\n  self._namespaces = namespaceHandling\n  self._lex_handler_prop = None\n  self._parsing = 0\n  self._entity_stack = []\n  self._external_ges = 1\n  self._interning = None\n  \n  \n  \n def parse(self, source):\n  \"\"\n  source = saxutils.prepare_input_source(source)\n  \n  self._source = source\n  self.reset()\n  self._cont_handler.setDocumentLocator(ExpatLocator(self))\n  xmlreader.IncrementalParser.parse(self, source)\n  \n def prepareParser(self, source):\n  if source.getSystemId() is not None:\n   self._parser.SetBase(source.getSystemId())\n   \n   \n   \n def setContentHandler(self, handler):\n  xmlreader.IncrementalParser.setContentHandler(self, handler)\n  if self._parsing:\n   self._reset_cont_handler()\n   \n def getFeature(self, name):\n  if name == feature_namespaces:\n   return self._namespaces\n  elif name == feature_string_interning:\n   return self._interning is not None\n  elif name in (feature_validation, feature_external_pes,\n  feature_namespace_prefixes):\n   return 0\n  elif name == feature_external_ges:\n   return self._external_ges\n  raise SAXNotRecognizedException(\"Feature '%s' not recognized\" % name)\n  \n def setFeature(self, name, state):\n  if self._parsing:\n   raise SAXNotSupportedException(\"Cannot set features while parsing\")\n   \n  if name == feature_namespaces:\n   self._namespaces = state\n  elif name == feature_external_ges:\n   self._external_ges = state\n  elif name == feature_string_interning:\n   if state:\n    if self._interning is None:\n     self._interning = {}\n   else:\n    self._interning = None\n  elif name == feature_validation:\n   if state:\n    raise SAXNotSupportedException(\n    \"expat does not support validation\")\n  elif name == feature_external_pes:\n   if state:\n    raise SAXNotSupportedException(\n    \"expat does not read external parameter entities\")\n  elif name == feature_namespace_prefixes:\n   if state:\n    raise SAXNotSupportedException(\n    \"expat does not report namespace prefixes\")\n  else:\n   raise SAXNotRecognizedException(\n   \"Feature '%s' not recognized\" % name)\n   \n def getProperty(self, name):\n  if name == handler.property_lexical_handler:\n   return self._lex_handler_prop\n  elif name == property_interning_dict:\n   return self._interning\n  elif name == property_xml_string:\n   if self._parser:\n    if hasattr(self._parser, \"GetInputContext\"):\n     return self._parser.GetInputContext()\n    else:\n     raise SAXNotRecognizedException(\n     \"This version of expat does not support getting\"\n     \" the XML string\")\n   else:\n    raise SAXNotSupportedException(\n    \"XML string cannot be returned when not parsing\")\n  raise SAXNotRecognizedException(\"Property '%s' not recognized\" % name)\n  \n def setProperty(self, name, value):\n  if name == handler.property_lexical_handler:\n   self._lex_handler_prop = value\n   if self._parsing:\n    self._reset_lex_handler_prop()\n  elif name == property_interning_dict:\n   self._interning = value\n  elif name == property_xml_string:\n   raise SAXNotSupportedException(\"Property '%s' cannot be set\" %\n   name)\n  else:\n   raise SAXNotRecognizedException(\"Property '%s' not recognized\" %\n   name)\n   \n   \n   \n def feed(self, data, isFinal = 0):\n  if not self._parsing:\n   self.reset()\n   self._parsing = 1\n   self._cont_handler.startDocument()\n   \n  try:\n  \n  \n  \n  \n   self._parser.Parse(data, isFinal)\n  except expat.error as e:\n   exc = SAXParseException(expat.ErrorString(e.code), e, self)\n   \n   self._err_handler.fatalError(exc)\n   \n def close(self):\n  if self._entity_stack:\n  \n   return\n  self.feed(\"\", isFinal = 1)\n  self._cont_handler.endDocument()\n  self._parsing = 0\n  \n  self._parser = None\n  bs = self._source.getByteStream()\n  if bs is not None:\n   bs.close()\n   \n def _reset_cont_handler(self):\n  self._parser.ProcessingInstructionHandler = self._cont_handler.processingInstruction\n  self._parser.CharacterDataHandler = self._cont_handler.characters\n  \n def _reset_lex_handler_prop(self):\n  lex = self._lex_handler_prop\n  parser = self._parser\n  if lex is None:\n   parser.CommentHandler = None\n   parser.StartCdataSectionHandler = None\n   parser.EndCdataSectionHandler = None\n   parser.StartDoctypeDeclHandler = None\n   parser.EndDoctypeDeclHandler = None\n  else:\n   parser.CommentHandler = lex.comment\n   parser.StartCdataSectionHandler = lex.startCDATA\n   parser.EndCdataSectionHandler = lex.endCDATA\n   parser.StartDoctypeDeclHandler = self.start_doctype_decl\n   parser.EndDoctypeDeclHandler = lex.endDTD\n   \n def reset(self):\n  if self._namespaces:\n   self._parser = expat.ParserCreate(self._source.getEncoding(), \" \",\n   intern=self._interning)\n   self._parser.namespace_prefixes = 1\n   self._parser.StartElementHandler = self.start_element_ns\n   self._parser.EndElementHandler = self.end_element_ns\n  else:\n   self._parser = expat.ParserCreate(self._source.getEncoding(),\n   intern = self._interning)\n   self._parser.StartElementHandler = self.start_element\n   self._parser.EndElementHandler = self.end_element\n   \n  self._reset_cont_handler()\n  self._parser.UnparsedEntityDeclHandler = self.unparsed_entity_decl\n  self._parser.NotationDeclHandler = self.notation_decl\n  self._parser.StartNamespaceDeclHandler = self.start_namespace_decl\n  self._parser.EndNamespaceDeclHandler = self.end_namespace_decl\n  \n  self._decl_handler_prop = None\n  if self._lex_handler_prop:\n   self._reset_lex_handler_prop()\n   \n   \n   \n  self._parser.ExternalEntityRefHandler = self.external_entity_ref\n  try:\n   self._parser.SkippedEntityHandler = self.skipped_entity_handler\n  except AttributeError:\n  \n   pass\n  self._parser.SetParamEntityParsing(\n  expat.XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE)\n  \n  self._parsing = 0\n  self._entity_stack = []\n  \n  \n  \n def getColumnNumber(self):\n  if self._parser is None:\n   return None\n  return self._parser.ErrorColumnNumber\n  \n def getLineNumber(self):\n  if self._parser is None:\n   return 1\n  return self._parser.ErrorLineNumber\n  \n def getPublicId(self):\n  return self._source.getPublicId()\n  \n def getSystemId(self):\n  return self._source.getSystemId()\n  \n  \n def start_element(self, name, attrs):\n  self._cont_handler.startElement(name, AttributesImpl(attrs))\n  \n def end_element(self, name):\n  self._cont_handler.endElement(name)\n  \n def start_element_ns(self, name, attrs):\n  pair = name.split()\n  if len(pair) == 1:\n  \n   pair = (None, name)\n  elif len(pair) == 3:\n   pair = pair[0], pair[1]\n  else:\n  \n   pair = tuple(pair)\n   \n  newattrs = {}\n  qnames = {}\n  for (aname, value) in attrs.items():\n   parts = aname.split()\n   length = len(parts)\n   if length == 1:\n   \n    qname = aname\n    apair = (None, aname)\n   elif length == 3:\n    qname = \"%s:%s\" % (parts[2], parts[1])\n    apair = parts[0], parts[1]\n   else:\n   \n    qname = parts[1]\n    apair = tuple(parts)\n    \n   newattrs[apair] = value\n   qnames[apair] = qname\n   \n  self._cont_handler.startElementNS(pair, None,\n  AttributesNSImpl(newattrs, qnames))\n  \n def end_element_ns(self, name):\n  pair = name.split()\n  if len(pair) == 1:\n   pair = (None, name)\n  elif len(pair) == 3:\n   pair = pair[0], pair[1]\n  else:\n   pair = tuple(pair)\n   \n  self._cont_handler.endElementNS(pair, None)\n  \n  \n def processing_instruction(self, target, data):\n  self._cont_handler.processingInstruction(target, data)\n  \n  \n def character_data(self, data):\n  self._cont_handler.characters(data)\n  \n def start_namespace_decl(self, prefix, uri):\n  self._cont_handler.startPrefixMapping(prefix, uri)\n  \n def end_namespace_decl(self, prefix):\n  self._cont_handler.endPrefixMapping(prefix)\n  \n def start_doctype_decl(self, name, sysid, pubid, has_internal_subset):\n  self._lex_handler_prop.startDTD(name, pubid, sysid)\n  \n def unparsed_entity_decl(self, name, base, sysid, pubid, notation_name):\n  self._dtd_handler.unparsedEntityDecl(name, pubid, sysid, notation_name)\n  \n def notation_decl(self, name, base, sysid, pubid):\n  self._dtd_handler.notationDecl(name, pubid, sysid)\n  \n def external_entity_ref(self, context, base, sysid, pubid):\n  if not self._external_ges:\n   return 1\n   \n  source = self._ent_handler.resolveEntity(pubid, sysid)\n  source = saxutils.prepare_input_source(source,\n  self._source.getSystemId() or\n  \"\")\n  \n  self._entity_stack.append((self._parser, self._source))\n  self._parser = self._parser.ExternalEntityParserCreate(context)\n  self._source = source\n  \n  try:\n   xmlreader.IncrementalParser.parse(self, source)\n  except:\n   return 0 \n   \n  (self._parser, self._source) = self._entity_stack[-1]\n  del self._entity_stack[-1]\n  return 1\n  \n def skipped_entity_handler(self, name, is_pe):\n  if is_pe:\n  \n   name = '%'+name\n  self._cont_handler.skippedEntity(name)\n  \n  \n  \ndef create_parser(*args, **kwargs):\n return ExpatParser(*args, **kwargs)\n \n \n \nif __name__ == \"__main__\":\n import xml.sax.saxutils\n p = create_parser()\n p.setContentHandler(xml.sax.saxutils.XMLGenerator())\n p.setErrorHandler(xml.sax.ErrorHandler())\n p.parse(\"http://www.ibiblio.org/xml/examples/shakespeare/hamlet.xml\")\n"], "site-packages.highlight": [".py", "import keyword\nimport _jsre as re\n\nfrom browser import html\n\nletters = 'abcdefghijklmnopqrstuvwxyz'\nletters += letters.upper()+'_'\ndigits = '0123456789'\n\nbuiltin_funcs = (\"abs|divmod|input|open|staticmethod|all|enumerate|int|ord|str|any|\" +\n\"eval|isinstance|pow|sum|basestring|execfile|issubclass|print|super|\" +\n\"binfile|iter|property|tuple|bool|filter|len|range|type|bytearray|\" +\n\"float|list|raw_input|unichr|callable|format|locals|reduce|unicode|\" +\n\"chr|frozenset|long|reload|vars|classmethod|getattr|map|repr|xrange|\" +\n\"cmp|globals|max|reversed|zip|compile|hasattr|memoryview|round|\" +\n\"__import__|complex|hash|min|set|apply|delattr|help|next|setattr|\" +\n\"buffer|dict|hex|object|slice|coerce|dir|id|oct|sorted|intern\")\n\nkw_pattern = '^('+'|'.join(keyword.kwlist)+')$'\nbf_pattern = '^('+builtin_funcs+')$'\n\ndef highlight(txt, string_color=\"blue\", comment_color=\"green\",\nkeyword_color=\"purple\"):\n res = html.PRE()\n i = 0\n name = ''\n while i<len(txt):\n  car = txt[i]\n  if car in [\"'\",'\"']:\n   k = i+1\n   while k<len(txt):\n    if txt[k]==car:\n     nb_as = 0\n     j = k-1\n     while True:\n      if txt[j]=='\\\\':\n       nb_as+=1\n       j -= 1\n      else:\n       break\n     if nb_as % 2 == 0:\n      res <= html.SPAN(txt[i:k+1],\n      style=dict(color=string_color))\n      i = k\n      break\n    k += 1\n  elif car == '#': \n   end = txt.find('\\n', i)\n   if end== -1:\n    res <= html.SPAN(txt[i:],style=dict(color=comment_color))\n    break\n   else:\n    res <= html.SPAN(txt[i:end],style=dict(color=comment_color))\n    i = end-1\n  elif car in letters:\n   name += car\n  elif car in digits and name:\n   name += car\n  else:\n   if name:\n    if re.search(kw_pattern,name):\n     res <= html.SPAN(name,style=dict(color=keyword_color))\n    elif re.search(bf_pattern,name):\n     res <= html.SPAN(name,style=dict(color=keyword_color))\n    else:\n     res <= name\n    name = ''\n   res <= car\n  i += 1\n res <= name\n return res"], "_weakref": [".py", "class ProxyType:\n\n def __init__(self,obj):\n  self.obj = obj\n  \nCallableProxyType = ProxyType\nProxyTypes = [ProxyType,CallableProxyType]\n\nclass ReferenceType:\n\n def __init__(self,obj,callback):\n  self.obj = obj\n  self.callback = callback\n  \nclass ref:\n\n def __init__(self,obj,callback=None):\n  self.obj = ReferenceType(obj,callback)\n  self.callback=callback\n  \ndef getweakrefcount(obj):\n return 1\n \ndef getweakrefs(obj):\n return obj\n \n \ndef proxy(obj,callback):\n return ProxyType(obj)\n \n"], "difflib": [".py", "\n\n\"\"\n\n__all__ = ['get_close_matches', 'ndiff', 'restore', 'SequenceMatcher',\n'Differ','IS_CHARACTER_JUNK', 'IS_LINE_JUNK', 'context_diff',\n'unified_diff', 'HtmlDiff', 'Match']\n\nimport warnings\nimport heapq\nfrom collections import namedtuple as _namedtuple\n\nMatch = _namedtuple('Match', 'a b size')\n\ndef _calculate_ratio(matches, length):\n if length:\n  return 2.0 * matches / length\n return 1.0\n \nclass SequenceMatcher:\n\n \"\"\n \n def __init__(self, isjunk=None, a='', b='', autojunk=True):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  self.isjunk = isjunk\n  self.a = self.b = None\n  self.autojunk = autojunk\n  self.set_seqs(a, b)\n  \n def set_seqs(self, a, b):\n  \"\"\n  \n  self.set_seq1(a)\n  self.set_seq2(b)\n  \n def set_seq1(self, a):\n  \"\"\n  \n  if a is self.a:\n   return\n  self.a = a\n  self.matching_blocks = self.opcodes = None\n  \n def set_seq2(self, b):\n  \"\"\n  \n  if b is self.b:\n   return\n  self.b = b\n  self.matching_blocks = self.opcodes = None\n  self.fullbcount = None\n  self.__chain_b()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def __chain_b(self):\n \n \n \n \n \n \n \n \n \n \n  b = self.b\n  self.b2j = b2j = {}\n  \n  for i, elt in enumerate(b):\n   indices = b2j.setdefault(elt, [])\n   indices.append(i)\n   \n   \n  self.bjunk = junk = set()\n  isjunk = self.isjunk\n  if isjunk:\n   for elt in b2j.keys():\n    if isjunk(elt):\n     junk.add(elt)\n   for elt in junk: \n    del b2j[elt]\n    \n    \n  self.bpopular = popular = set()\n  n = len(b)\n  if self.autojunk and n >= 200:\n   ntest = n // 100 + 1\n   for elt, idxs in b2j.items():\n    if len(idxs) > ntest:\n     popular.add(elt)\n   for elt in popular: \n    del b2j[elt]\n    \n def isbjunk(self, item):\n  \"\"\n  warnings.warn(\"'SequenceMatcher().isbjunk(item)' is deprecated;\\n\"\n  \"use 'item in SMinstance.bjunk' instead.\",\n  DeprecationWarning, 2)\n  return item in self.bjunk\n  \n def isbpopular(self, item):\n  \"\"\n  warnings.warn(\"'SequenceMatcher().isbpopular(item)' is deprecated;\\n\"\n  \"use 'item in SMinstance.bpopular' instead.\",\n  DeprecationWarning, 2)\n  return item in self.bpopular\n  \n def find_longest_match(self, alo, ahi, blo, bhi):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  a, b, b2j, isbjunk = self.a, self.b, self.b2j, self.bjunk.__contains__\n  besti, bestj, bestsize = alo, blo, 0\n  \n  \n  \n  j2len = {}\n  nothing = []\n  for i in range(alo, ahi):\n  \n  \n   j2lenget = j2len.get\n   newj2len = {}\n   for j in b2j.get(a[i], nothing):\n   \n    if j < blo:\n     continue\n    if j >= bhi:\n     break\n    k = newj2len[j] = j2lenget(j-1, 0) + 1\n    if k > bestsize:\n     besti, bestj, bestsize = i-k+1, j-k+1, k\n   j2len = newj2len\n   \n   \n   \n   \n   \n  while besti > alo and bestj > blo and not isbjunk(b[bestj-1]) and a[besti-1] == b[bestj-1]:\n   besti, bestj, bestsize = besti-1, bestj-1, bestsize+1\n  while besti+bestsize < ahi and bestj+bestsize < bhi and not isbjunk(b[bestj+bestsize]) and a[besti+bestsize] == b[bestj+bestsize]:\n   bestsize += 1\n   \n   \n   \n   \n   \n   \n   \n   \n  while besti > alo and bestj > blo and isbjunk(b[bestj-1]) and a[besti-1] == b[bestj-1]:\n   besti, bestj, bestsize = besti-1, bestj-1, bestsize+1\n  while besti+bestsize < ahi and bestj+bestsize < bhi and isbjunk(b[bestj+bestsize]) and a[besti+bestsize] == b[bestj+bestsize]:\n   bestsize = bestsize + 1\n   \n  return Match(besti, bestj, bestsize)\n  \n def get_matching_blocks(self):\n  \"\"\n  \n  if self.matching_blocks is not None:\n   return self.matching_blocks\n  la, lb = len(self.a), len(self.b)\n  \n  \n  \n  \n  \n  \n  \n  queue = [(0, la, 0, lb)]\n  matching_blocks = []\n  while queue:\n   alo, ahi, blo, bhi = queue.pop()\n   i, j, k = x = self.find_longest_match(alo, ahi, blo, bhi)\n   \n   \n   \n   if k: \n    matching_blocks.append(x)\n    if alo < i and blo < j:\n     queue.append((alo, i, blo, j))\n    if i+k < ahi and j+k < bhi:\n     queue.append((i+k, ahi, j+k, bhi))\n  matching_blocks.sort()\n  \n  \n  \n  \n  i1 = j1 = k1 = 0\n  non_adjacent = []\n  for i2, j2, k2 in matching_blocks:\n  \n   if i1 + k1 == i2 and j1 + k1 == j2:\n   \n   \n   \n    k1 += k2\n   else:\n   \n   \n   \n    if k1:\n     non_adjacent.append((i1, j1, k1))\n    i1, j1, k1 = i2, j2, k2\n  if k1:\n   non_adjacent.append((i1, j1, k1))\n   \n  non_adjacent.append( (la, lb, 0) )\n  self.matching_blocks = non_adjacent\n  return map(Match._make, self.matching_blocks)\n  \n def get_opcodes(self):\n  \"\"\n  \n  if self.opcodes is not None:\n   return self.opcodes\n  i = j = 0\n  self.opcodes = answer = []\n  for ai, bj, size in self.get_matching_blocks():\n  \n  \n  \n  \n  \n   tag = ''\n   if i < ai and j < bj:\n    tag = 'replace'\n   elif i < ai:\n    tag = 'delete'\n   elif j < bj:\n    tag = 'insert'\n   if tag:\n    answer.append( (tag, i, ai, j, bj) )\n   i, j = ai+size, bj+size\n   \n   \n   if size:\n    answer.append( ('equal', ai, i, bj, j) )\n  return answer\n  \n def get_grouped_opcodes(self, n=3):\n  \"\"\n  \n  codes = self.get_opcodes()\n  if not codes:\n   codes = [(\"equal\", 0, 1, 0, 1)]\n   \n  if codes[0][0] == 'equal':\n   tag, i1, i2, j1, j2 = codes[0]\n   codes[0] = tag, max(i1, i2-n), i2, max(j1, j2-n), j2\n  if codes[-1][0] == 'equal':\n   tag, i1, i2, j1, j2 = codes[-1]\n   codes[-1] = tag, i1, min(i2, i1+n), j1, min(j2, j1+n)\n   \n  nn = n + n\n  group = []\n  for tag, i1, i2, j1, j2 in codes:\n  \n  \n   if tag == 'equal' and i2-i1 > nn:\n    group.append((tag, i1, min(i2, i1+n), j1, min(j2, j1+n)))\n    yield group\n    group = []\n    i1, j1 = max(i1, i2-n), max(j1, j2-n)\n   group.append((tag, i1, i2, j1 ,j2))\n  if group and not (len(group)==1 and group[0][0] == 'equal'):\n   yield group\n   \n def ratio(self):\n  \"\"\n  \n  matches = sum(triple[-1] for triple in self.get_matching_blocks())\n  return _calculate_ratio(matches, len(self.a) + len(self.b))\n  \n def quick_ratio(self):\n  \"\"\n  \n  \n  \n  \n  if self.fullbcount is None:\n   self.fullbcount = fullbcount = {}\n   for elt in self.b:\n    fullbcount[elt] = fullbcount.get(elt, 0) + 1\n  fullbcount = self.fullbcount\n  \n  \n  avail = {}\n  availhas, matches = avail.__contains__, 0\n  for elt in self.a:\n   if availhas(elt):\n    numb = avail[elt]\n   else:\n    numb = fullbcount.get(elt, 0)\n   avail[elt] = numb - 1\n   if numb > 0:\n    matches = matches + 1\n  return _calculate_ratio(matches, len(self.a) + len(self.b))\n  \n def real_quick_ratio(self):\n  \"\"\n  \n  la, lb = len(self.a), len(self.b)\n  \n  \n  return _calculate_ratio(min(la, lb), la + lb)\n  \ndef get_close_matches(word, possibilities, n=3, cutoff=0.6):\n \"\"\n \n if not n > 0:\n  raise ValueError(\"n must be > 0: %r\" % (n,))\n if not 0.0 <= cutoff <= 1.0:\n  raise ValueError(\"cutoff must be in [0.0, 1.0]: %r\" % (cutoff,))\n result = []\n s = SequenceMatcher()\n s.set_seq2(word)\n for x in possibilities:\n  s.set_seq1(x)\n  if s.real_quick_ratio() >= cutoff and s.quick_ratio() >= cutoff and s.ratio() >= cutoff:\n   result.append((s.ratio(), x))\n   \n   \n result = heapq.nlargest(n, result)\n \n return [x for score, x in result]\n \ndef _count_leading(line, ch):\n \"\"\n \n i, n = 0, len(line)\n while i < n and line[i] == ch:\n  i += 1\n return i\n \nclass Differ:\n \"\"\n \n def __init__(self, linejunk=None, charjunk=None):\n  \"\"\n  \n  self.linejunk = linejunk\n  self.charjunk = charjunk\n  \n def compare(self, a, b):\n  \"\"\n  \n  cruncher = SequenceMatcher(self.linejunk, a, b)\n  for tag, alo, ahi, blo, bhi in cruncher.get_opcodes():\n   if tag == 'replace':\n    g = self._fancy_replace(a, alo, ahi, b, blo, bhi)\n   elif tag == 'delete':\n    g = self._dump('-', a, alo, ahi)\n   elif tag == 'insert':\n    g = self._dump('+', b, blo, bhi)\n   elif tag == 'equal':\n    g = self._dump(' ', a, alo, ahi)\n   else:\n    raise ValueError('unknown tag %r' % (tag,))\n    \n   for line in g:\n    yield line\n    \n def _dump(self, tag, x, lo, hi):\n  \"\"\n  for i in range(lo, hi):\n   yield '%s %s' % (tag, x[i])\n   \n def _plain_replace(self, a, alo, ahi, b, blo, bhi):\n  assert alo < ahi and blo < bhi\n  \n  \n  if bhi - blo < ahi - alo:\n   first = self._dump('+', b, blo, bhi)\n   second = self._dump('-', a, alo, ahi)\n  else:\n   first = self._dump('-', a, alo, ahi)\n   second = self._dump('+', b, blo, bhi)\n   \n  for g in first, second:\n   for line in g:\n    yield line\n    \n def _fancy_replace(self, a, alo, ahi, b, blo, bhi):\n  \"\"\n  \n  \n  \n  best_ratio, cutoff = 0.74, 0.75\n  cruncher = SequenceMatcher(self.charjunk)\n  eqi, eqj = None, None \n  \n  \n  \n  \n  for j in range(blo, bhi):\n   bj = b[j]\n   cruncher.set_seq2(bj)\n   for i in range(alo, ahi):\n    ai = a[i]\n    if ai == bj:\n     if eqi is None:\n      eqi, eqj = i, j\n     continue\n    cruncher.set_seq1(ai)\n    \n    \n    \n    \n    \n    \n    if cruncher.real_quick_ratio() > best_ratio and cruncher.quick_ratio() > best_ratio and cruncher.ratio() > best_ratio:\n     best_ratio, best_i, best_j = cruncher.ratio(), i, j\n  if best_ratio < cutoff:\n  \n   if eqi is None:\n   \n    for line in self._plain_replace(a, alo, ahi, b, blo, bhi):\n     yield line\n    return\n    \n   best_i, best_j, best_ratio = eqi, eqj, 1.0\n  else:\n  \n   eqi = None\n   \n   \n   \n   \n   \n  for line in self._fancy_helper(a, alo, best_i, b, blo, best_j):\n   yield line\n   \n   \n  aelt, belt = a[best_i], b[best_j]\n  if eqi is None:\n  \n   atags = btags = \"\"\n   cruncher.set_seqs(aelt, belt)\n   for tag, ai1, ai2, bj1, bj2 in cruncher.get_opcodes():\n    la, lb = ai2 - ai1, bj2 - bj1\n    if tag == 'replace':\n     atags += '^' * la\n     btags += '^' * lb\n    elif tag == 'delete':\n     atags += '-' * la\n    elif tag == 'insert':\n     btags += '+' * lb\n    elif tag == 'equal':\n     atags += ' ' * la\n     btags += ' ' * lb\n    else:\n     raise ValueError('unknown tag %r' % (tag,))\n   for line in self._qformat(aelt, belt, atags, btags):\n    yield line\n  else:\n  \n   yield '  ' + aelt\n   \n   \n  for line in self._fancy_helper(a, best_i+1, ahi, b, best_j+1, bhi):\n   yield line\n   \n def _fancy_helper(self, a, alo, ahi, b, blo, bhi):\n  g = []\n  if alo < ahi:\n   if blo < bhi:\n    g = self._fancy_replace(a, alo, ahi, b, blo, bhi)\n   else:\n    g = self._dump('-', a, alo, ahi)\n  elif blo < bhi:\n   g = self._dump('+', b, blo, bhi)\n   \n  for line in g:\n   yield line\n   \n def _qformat(self, aline, bline, atags, btags):\n  \"\"\n  \n  \n  common = min(_count_leading(aline, \"\\t\"),\n  _count_leading(bline, \"\\t\"))\n  common = min(common, _count_leading(atags[:common], \" \"))\n  common = min(common, _count_leading(btags[:common], \" \"))\n  atags = atags[common:].rstrip()\n  btags = btags[common:].rstrip()\n  \n  yield \"- \" + aline\n  if atags:\n   yield \"? %s%s\\n\" % (\"\\t\" * common, atags)\n   \n  yield \"+ \" + bline\n  if btags:\n   yield \"? %s%s\\n\" % (\"\\t\" * common, btags)\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \nimport re\n\ndef IS_LINE_JUNK(line, pat=re.compile(r\"\\s*#?\\s*$\").match):\n \"\"\n \n return pat(line) is not None\n \ndef IS_CHARACTER_JUNK(ch, ws=\" \\t\"):\n \"\"\n \n return ch in ws\n \n \n \n \n \n \ndef _format_range_unified(start, stop):\n \"\"\n \n beginning = start + 1 \n length = stop - start\n if length == 1:\n  return '{}'.format(beginning)\n if not length:\n  beginning -= 1 \n return '{},{}'.format(beginning, length)\n \ndef unified_diff(a, b, fromfile='', tofile='', fromfiledate='',\ntofiledate='', n=3, lineterm='\\n'):\n \"\"\n \n started = False\n for group in SequenceMatcher(None,a,b).get_grouped_opcodes(n):\n  if not started:\n   started = True\n   fromdate = '\\t{}'.format(fromfiledate) if fromfiledate else ''\n   todate = '\\t{}'.format(tofiledate) if tofiledate else ''\n   yield '--- {}{}{}'.format(fromfile, fromdate, lineterm)\n   yield '+++ {}{}{}'.format(tofile, todate, lineterm)\n   \n  first, last = group[0], group[-1]\n  file1_range = _format_range_unified(first[1], last[2])\n  file2_range = _format_range_unified(first[3], last[4])\n  yield '@@ -{} +{} @@{}'.format(file1_range, file2_range, lineterm)\n  \n  for tag, i1, i2, j1, j2 in group:\n   if tag == 'equal':\n    for line in a[i1:i2]:\n     yield ' ' + line\n    continue\n   if tag in {'replace', 'delete'}:\n    for line in a[i1:i2]:\n     yield '-' + line\n   if tag in {'replace', 'insert'}:\n    for line in b[j1:j2]:\n     yield '+' + line\n     \n     \n     \n     \n     \n     \ndef _format_range_context(start, stop):\n \"\"\n \n beginning = start + 1 \n length = stop - start\n if not length:\n  beginning -= 1 \n if length <= 1:\n  return '{}'.format(beginning)\n return '{},{}'.format(beginning, beginning + length - 1)\n \n \ndef context_diff(a, b, fromfile='', tofile='',\nfromfiledate='', tofiledate='', n=3, lineterm='\\n'):\n \"\"\n \n prefix = dict(insert='+ ', delete='- ', replace='! ', equal='  ')\n started = False\n for group in SequenceMatcher(None,a,b).get_grouped_opcodes(n):\n  if not started:\n   started = True\n   fromdate = '\\t{}'.format(fromfiledate) if fromfiledate else ''\n   todate = '\\t{}'.format(tofiledate) if tofiledate else ''\n   yield '*** {}{}{}'.format(fromfile, fromdate, lineterm)\n   yield '--- {}{}{}'.format(tofile, todate, lineterm)\n   \n  first, last = group[0], group[-1]\n  yield '***************' + lineterm\n  \n  file1_range = _format_range_context(first[1], last[2])\n  yield '*** {} ****{}'.format(file1_range, lineterm)\n  \n  if any(tag in {'replace', 'delete'} for tag, _, _, _, _ in group):\n   for tag, i1, i2, _, _ in group:\n    if tag != 'insert':\n     for line in a[i1:i2]:\n      yield prefix[tag] + line\n      \n  file2_range = _format_range_context(first[3], last[4])\n  yield '--- {} ----{}'.format(file2_range, lineterm)\n  \n  if any(tag in {'replace', 'insert'} for tag, _, _, _, _ in group):\n   for tag, _, _, j1, j2 in group:\n    if tag != 'delete':\n     for line in b[j1:j2]:\n      yield prefix[tag] + line\n      \ndef ndiff(a, b, linejunk=None, charjunk=IS_CHARACTER_JUNK):\n \"\"\n return Differ(linejunk, charjunk).compare(a, b)\n \ndef _mdiff(fromlines, tolines, context=None, linejunk=None,\ncharjunk=IS_CHARACTER_JUNK):\n \"\"\n import re\n \n \n change_re = re.compile('(\\++|\\-+|\\^+)')\n \n \n diff_lines_iterator = ndiff(fromlines,tolines,linejunk,charjunk)\n \n def _make_line(lines, format_key, side, num_lines=[0,0]):\n  \"\"\n  num_lines[side] += 1\n  \n  \n  if format_key is None:\n   return (num_lines[side],lines.pop(0)[2:])\n   \n  if format_key == '?':\n   text, markers = lines.pop(0), lines.pop(0)\n   \n   sub_info = []\n   def record_sub_info(match_object,sub_info=sub_info):\n    sub_info.append([match_object.group(1)[0],match_object.span()])\n    return match_object.group(1)\n   change_re.sub(record_sub_info,markers)\n   \n   \n   for key,(begin,end) in sub_info[::-1]:\n    text = text[0:begin]+'\\0'+key+text[begin:end]+'\\1'+text[end:]\n   text = text[2:]\n   \n  else:\n   text = lines.pop(0)[2:]\n   \n   \n   if not text:\n    text = ' '\n    \n   text = '\\0' + format_key + text + '\\1'\n   \n   \n   \n  return (num_lines[side],text)\n  \n def _line_iterator():\n  \"\"\n  lines = []\n  num_blanks_pending, num_blanks_to_yield = 0, 0\n  while True:\n  \n  \n  \n   while len(lines) < 4:\n    try:\n     lines.append(next(diff_lines_iterator))\n    except StopIteration:\n     lines.append('X')\n   s = ''.join([line[0] for line in lines])\n   if s.startswith('X'):\n   \n   \n   \n    num_blanks_to_yield = num_blanks_pending\n   elif s.startswith('-?+?'):\n   \n    yield _make_line(lines,'?',0), _make_line(lines,'?',1), True\n    continue\n   elif s.startswith('--++'):\n   \n   \n    num_blanks_pending -= 1\n    yield _make_line(lines,'-',0), None, True\n    continue\n   elif s.startswith(('--?+', '--+', '- ')):\n   \n   \n    from_line,to_line = _make_line(lines,'-',0), None\n    num_blanks_to_yield,num_blanks_pending = num_blanks_pending-1,0\n   elif s.startswith('-+?'):\n   \n    yield _make_line(lines,None,0), _make_line(lines,'?',1), True\n    continue\n   elif s.startswith('-?+'):\n   \n    yield _make_line(lines,'?',0), _make_line(lines,None,1), True\n    continue\n   elif s.startswith('-'):\n   \n    num_blanks_pending -= 1\n    yield _make_line(lines,'-',0), None, True\n    continue\n   elif s.startswith('+--'):\n   \n   \n    num_blanks_pending += 1\n    yield None, _make_line(lines,'+',1), True\n    continue\n   elif s.startswith(('+ ', '+-')):\n   \n    from_line, to_line = None, _make_line(lines,'+',1)\n    num_blanks_to_yield,num_blanks_pending = num_blanks_pending+1,0\n   elif s.startswith('+'):\n   \n    num_blanks_pending += 1\n    yield None, _make_line(lines,'+',1), True\n    continue\n   elif s.startswith(' '):\n   \n    yield _make_line(lines[:],None,0),_make_line(lines,None,1),False\n    continue\n    \n    \n   while(num_blanks_to_yield < 0):\n    num_blanks_to_yield += 1\n    yield None,('','\\n'),True\n   while(num_blanks_to_yield > 0):\n    num_blanks_to_yield -= 1\n    yield ('','\\n'),None,True\n   if s.startswith('X'):\n    raise StopIteration\n   else:\n    yield from_line,to_line,True\n    \n def _line_pair_iterator():\n  \"\"\n  line_iterator = _line_iterator()\n  fromlines,tolines=[],[]\n  while True:\n  \n   while (len(fromlines)==0 or len(tolines)==0):\n    from_line, to_line, found_diff = next(line_iterator)\n    if from_line is not None:\n     fromlines.append((from_line,found_diff))\n    if to_line is not None:\n     tolines.append((to_line,found_diff))\n     \n   from_line, fromDiff = fromlines.pop(0)\n   to_line, to_diff = tolines.pop(0)\n   yield (from_line,to_line,fromDiff or to_diff)\n   \n   \n   \n line_pair_iterator = _line_pair_iterator()\n if context is None:\n  while True:\n   yield next(line_pair_iterator)\n   \n   \n else:\n  context += 1\n  lines_to_write = 0\n  while True:\n  \n  \n  \n   index, contextLines = 0, [None]*(context)\n   found_diff = False\n   while(found_diff is False):\n    from_line, to_line, found_diff = next(line_pair_iterator)\n    i = index % context\n    contextLines[i] = (from_line, to_line, found_diff)\n    index += 1\n    \n    \n   if index > context:\n    yield None, None, None\n    lines_to_write = context\n   else:\n    lines_to_write = index\n    index = 0\n   while(lines_to_write):\n    i = index % context\n    index += 1\n    yield contextLines[i]\n    lines_to_write -= 1\n    \n   lines_to_write = context-1\n   while(lines_to_write):\n    from_line, to_line, found_diff = next(line_pair_iterator)\n    \n    if found_diff:\n     lines_to_write = context-1\n    else:\n     lines_to_write -= 1\n    yield from_line, to_line, found_diff\n    \n    \n_file_template = \"\"\"\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n          \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\n<html>\n\n<head>\n    <meta http-equiv=\"Content-Type\"\n          content=\"text/html; charset=ISO-8859-1\" />\n    <title></title>\n    <style type=\"text/css\">%(styles)s\n    </style>\n</head>\n\n<body>\n    %(table)s%(legend)s\n</body>\n\n</html>\"\"\"\n\n_styles = \"\"\"\n        table.diff {font-family:Courier; border:medium;}\n        .diff_header {background-color:#e0e0e0}\n        td.diff_header {text-align:right}\n        .diff_next {background-color:#c0c0c0}\n        .diff_add {background-color:#aaffaa}\n        .diff_chg {background-color:#ffff77}\n        .diff_sub {background-color:#ffaaaa}\"\"\"\n\n_table_template = \"\"\"\n    <table class=\"diff\" id=\"difflib_chg_%(prefix)s_top\"\n           cellspacing=\"0\" cellpadding=\"0\" rules=\"groups\" >\n        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>\n        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>\n        %(header_row)s\n        <tbody>\n%(data_rows)s        </tbody>\n    </table>\"\"\"\n\n_legend = \"\"\"\n    <table class=\"diff\" summary=\"Legends\">\n        <tr> <th colspan=\"2\"> Legends </th> </tr>\n        <tr> <td> <table border=\"\" summary=\"Colors\">\n                      <tr><th> Colors </th> </tr>\n                      <tr><td class=\"diff_add\">&nbsp;Added&nbsp;</td></tr>\n                      <tr><td class=\"diff_chg\">Changed</td> </tr>\n                      <tr><td class=\"diff_sub\">Deleted</td> </tr>\n                  </table></td>\n             <td> <table border=\"\" summary=\"Links\">\n                      <tr><th colspan=\"2\"> Links </th> </tr>\n                      <tr><td>(f)irst change</td> </tr>\n                      <tr><td>(n)ext change</td> </tr>\n                      <tr><td>(t)op</td> </tr>\n                  </table></td> </tr>\n    </table>\"\"\"\n\nclass HtmlDiff(object):\n \"\"\n \n _file_template = _file_template\n _styles = _styles\n _table_template = _table_template\n _legend = _legend\n _default_prefix = 0\n \n def __init__(self,tabsize=8,wrapcolumn=None,linejunk=None,\n charjunk=IS_CHARACTER_JUNK):\n  \"\"\n  self._tabsize = tabsize\n  self._wrapcolumn = wrapcolumn\n  self._linejunk = linejunk\n  self._charjunk = charjunk\n  \n def make_file(self,fromlines,tolines,fromdesc='',todesc='',context=False,\n numlines=5):\n  \"\"\n  \n  return self._file_template % dict(\n  styles = self._styles,\n  legend = self._legend,\n  table = self.make_table(fromlines,tolines,fromdesc,todesc,\n  context=context,numlines=numlines))\n  \n def _tab_newline_replace(self,fromlines,tolines):\n  \"\"\n  def expand_tabs(line):\n  \n   line = line.replace(' ','\\0')\n   \n   line = line.expandtabs(self._tabsize)\n   \n   \n   line = line.replace(' ','\\t')\n   return line.replace('\\0',' ').rstrip('\\n')\n  fromlines = [expand_tabs(line) for line in fromlines]\n  tolines = [expand_tabs(line) for line in tolines]\n  return fromlines,tolines\n  \n def _split_line(self,data_list,line_num,text):\n  \"\"\n  \n  if not line_num:\n   data_list.append((line_num,text))\n   return\n   \n   \n  size = len(text)\n  max = self._wrapcolumn\n  if (size <= max) or ((size -(text.count('\\0')*3)) <= max):\n   data_list.append((line_num,text))\n   return\n   \n   \n   \n  i = 0\n  n = 0\n  mark = ''\n  while n < max and i < size:\n   if text[i] == '\\0':\n    i += 1\n    mark = text[i]\n    i += 1\n   elif text[i] == '\\1':\n    i += 1\n    mark = ''\n   else:\n    i += 1\n    n += 1\n    \n    \n  line1 = text[:i]\n  line2 = text[i:]\n  \n  \n  \n  \n  if mark:\n   line1 = line1 + '\\1'\n   line2 = '\\0' + mark + line2\n   \n   \n  data_list.append((line_num,line1))\n  \n  \n  self._split_line(data_list,'>',line2)\n  \n def _line_wrapper(self,diffs):\n  \"\"\n  \n  \n  for fromdata,todata,flag in diffs:\n  \n   if flag is None:\n    yield fromdata,todata,flag\n    continue\n   (fromline,fromtext),(toline,totext) = fromdata,todata\n   \n   \n   fromlist,tolist = [],[]\n   self._split_line(fromlist,fromline,fromtext)\n   self._split_line(tolist,toline,totext)\n   \n   \n   while fromlist or tolist:\n    if fromlist:\n     fromdata = fromlist.pop(0)\n    else:\n     fromdata = ('',' ')\n    if tolist:\n     todata = tolist.pop(0)\n    else:\n     todata = ('',' ')\n    yield fromdata,todata,flag\n    \n def _collect_lines(self,diffs):\n  \"\"\n  \n  fromlist,tolist,flaglist = [],[],[]\n  \n  for fromdata,todata,flag in diffs:\n   try:\n   \n    fromlist.append(self._format_line(0,flag,*fromdata))\n    tolist.append(self._format_line(1,flag,*todata))\n   except TypeError:\n   \n    fromlist.append(None)\n    tolist.append(None)\n   flaglist.append(flag)\n  return fromlist,tolist,flaglist\n  \n def _format_line(self,side,flag,linenum,text):\n  \"\"\n  try:\n   linenum = '%d' % linenum\n   id = ' id=\"%s%s\"' % (self._prefix[side],linenum)\n  except TypeError:\n  \n   id = ''\n   \n  text=text.replace(\"&\",\"&amp;\").replace(\">\",\"&gt;\").replace(\"<\",\"&lt;\")\n  \n  \n  text = text.replace(' ','&nbsp;').rstrip()\n  \n  return '<td class=\"diff_header\"%s>%s</td><td nowrap=\"nowrap\">%s</td>' % (id,linenum,text)\n  \n def _make_prefix(self):\n  \"\"\n  \n  \n  \n  fromprefix = \"from%d_\" % HtmlDiff._default_prefix\n  toprefix = \"to%d_\" % HtmlDiff._default_prefix\n  HtmlDiff._default_prefix += 1\n  \n  self._prefix = [fromprefix,toprefix]\n  \n def _convert_flags(self,fromlist,tolist,flaglist,context,numlines):\n  \"\"\n  \n  \n  toprefix = self._prefix[1]\n  \n  \n  next_id = ['']*len(flaglist)\n  next_href = ['']*len(flaglist)\n  num_chg, in_change = 0, False\n  last = 0\n  for i,flag in enumerate(flaglist):\n   if flag:\n    if not in_change:\n     in_change = True\n     last = i\n     \n     \n     \n     i = max([0,i-numlines])\n     next_id[i] = ' id=\"difflib_chg_%s_%d\"' % (toprefix,num_chg)\n     \n     \n     num_chg += 1\n     next_href[last] = '<a href=\"#difflib_chg_%s_%d\">n</a>' % (\n     toprefix,num_chg)\n   else:\n    in_change = False\n    \n  if not flaglist:\n   flaglist = [False]\n   next_id = ['']\n   next_href = ['']\n   last = 0\n   if context:\n    fromlist = ['<td></td><td>&nbsp;No Differences Found&nbsp;</td>']\n    tolist = fromlist\n   else:\n    fromlist = tolist = ['<td></td><td>&nbsp;Empty File&nbsp;</td>']\n    \n  if not flaglist[0]:\n   next_href[0] = '<a href=\"#difflib_chg_%s_0\">f</a>' % toprefix\n   \n  next_href[last] = '<a href=\"#difflib_chg_%s_top\">t</a>' % (toprefix)\n  \n  return fromlist,tolist,flaglist,next_href,next_id\n  \n def make_table(self,fromlines,tolines,fromdesc='',todesc='',context=False,\n numlines=5):\n  \"\"\n  \n  \n  \n  self._make_prefix()\n  \n  \n  \n  fromlines,tolines = self._tab_newline_replace(fromlines,tolines)\n  \n  \n  if context:\n   context_lines = numlines\n  else:\n   context_lines = None\n  diffs = _mdiff(fromlines,tolines,context_lines,linejunk=self._linejunk,\n  charjunk=self._charjunk)\n  \n  \n  if self._wrapcolumn:\n   diffs = self._line_wrapper(diffs)\n   \n   \n  fromlist,tolist,flaglist = self._collect_lines(diffs)\n  \n  \n  fromlist,tolist,flaglist,next_href,next_id = self._convert_flags(\n  fromlist,tolist,flaglist,context,numlines)\n  \n  s = []\n  fmt = '            <tr><td class=\"diff_next\"%s>%s</td>%s' + '<td class=\"diff_next\">%s</td>%s</tr>\\n'\n  for i in range(len(flaglist)):\n   if flaglist[i] is None:\n   \n   \n    if i > 0:\n     s.append('        </tbody>        \\n        <tbody>\\n')\n   else:\n    s.append( fmt % (next_id[i],next_href[i],fromlist[i],\n    next_href[i],tolist[i]))\n  if fromdesc or todesc:\n   header_row = '<thead><tr>%s%s%s%s</tr></thead>' % (\n   '<th class=\"diff_next\"><br /></th>',\n   '<th colspan=\"2\" class=\"diff_header\">%s</th>' % fromdesc,\n   '<th class=\"diff_next\"><br /></th>',\n   '<th colspan=\"2\" class=\"diff_header\">%s</th>' % todesc)\n  else:\n   header_row = ''\n   \n  table = self._table_template % dict(\n  data_rows=''.join(s),\n  header_row=header_row,\n  prefix=self._prefix[1])\n  \n  return table.replace('\\0+','<span class=\"diff_add\">'). replace('\\0-','<span class=\"diff_sub\">'). replace('\\0^','<span class=\"diff_chg\">'). replace('\\1','</span>'). replace('\\t','&nbsp;')\n  \ndel re\n\ndef restore(delta, which):\n \"\"\n try:\n  tag = {1: \"- \", 2: \"+ \"}[int(which)]\n except KeyError:\n  raise ValueError('unknown delta choice (must be 1 or 2): %r'\n  % which)\n prefixes = (\"  \", tag)\n for line in delta:\n  if line[:2] in prefixes:\n   yield line[2:]\n   \ndef _test():\n import doctest, difflib\n return doctest.testmod(difflib)\n \nif __name__ == \"__main__\":\n _test()\n"], "site-packages.pygame.color": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\n\n\ntry:\n from colordict import THECOLORS\nexcept ImportError:\n\n THECOLORS = {}\n \n \n \ndef Color(colorname):\n \"\"\n \n if colorname[:2] == '0x' or colorname[0] == '#': \n  if colorname[0] == '#':\n   colorname = colorname[1:]\n  else:\n   colorname = colorname[2:]\n  a = 255\n  try:\n   r = int('0x' + colorname[0:2], 16)\n   g = int('0x' + colorname[2:4], 16)\n   b = int('0x' + colorname[4:6], 16)\n   if len(colorname) > 6:\n    a = int('0x' + colorname[6:8], 16)\n  except ValueError:\n   raise ValueError(\"Illegal hex color\")\n  return r, g, b, a\n  \n else: \n \n  name = colorname.replace(' ', '').lower()\n  try:\n   return THECOLORS[name]\n  except KeyError:\n   raise ValueError(\"Illegal color name, \" + name)\n   \n   \n   \ndef _splitcolor(color, defaultalpha=255):\n try:\n  second = int(color)\n  r = g = b = color\n  a = defaultalpha\n except TypeError:\n  if len(color) == 4:\n   r, g, b, a = color\n  elif len(color) == 3:\n   r, g, b = color\n   a = defaultalpha\n return r, g, b, a\n \n \ndef add(color1, color2):\n \"\"\n r1, g1, b1, a1 = _splitcolor(color1)\n r2, g2, b2, a2 = _splitcolor(color2)\n m, i = min, int\n return m(i(r1+r2), 255), m(i(g1+g2), 255), m(i(b1+b2), 255), m(i(a1+a2), 255)\n \n \ndef subtract(color1, color2):\n \"\"\n r1, g1, b1, a1 = _splitcolor(color1)\n r2, g2, b2, a2 = _splitcolor(color2, 0)\n m, i = max, int\n return m(i(r1-r2), 0), m(i(g1-g2), 0), m(i(b1-b2), 0), m(i(a1-a2), 0)\n \n \ndef multiply(color1, color2):\n \"\"\n r1, g1, b1, a1 = _splitcolor(color1)\n r2, g2, b2, a2 = _splitcolor(color2)\n m, i = min, int\n return m(i(r1*r2)/255, 255), m(i(g1*g2)/255, 255), m(i(b1*b2)/255, 255), m(i(a1*a2)/255, 255)\n \n"], "_io": [".py", "\"\"\n\nimport os\nimport abc\nimport codecs\nimport errno\n\ntry:\n from _thread import allocate_lock as Lock\nexcept ImportError:\n from _dummy_thread import allocate_lock as Lock\n \nimport io\n\n\nSEEK_SET=0\nSEEK_CUR=1\nSEEK_END=2\n\nvalid_seek_flags = {0, 1, 2} \nif hasattr(os, 'SEEK_HOLE') :\n valid_seek_flags.add(os.SEEK_HOLE)\n valid_seek_flags.add(os.SEEK_DATA)\n \n \nDEFAULT_BUFFER_SIZE = 8 * 1024 \n\n\n\n\n\n\nBlockingIOError = BlockingIOError\n\n\ndef __open(file, mode=\"r\", buffering=-1, encoding=None, errors=None,\nnewline=None, closefd=True, opener=None):\n\n \"\"\n if not isinstance(file, (str, bytes, int)):\n  raise TypeError(\"invalid file: %r\" % file)\n if not isinstance(mode, str):\n  raise TypeError(\"invalid mode: %r\" % mode)\n if not isinstance(buffering, int):\n  raise TypeError(\"invalid buffering: %r\" % buffering)\n if encoding is not None and not isinstance(encoding, str):\n  raise TypeError(\"invalid encoding: %r\" % encoding)\n if errors is not None and not isinstance(errors, str):\n  raise TypeError(\"invalid errors: %r\" % errors)\n modes = set(mode)\n if modes - set(\"axrwb+tU\") or len(mode) > len(modes):\n  raise ValueError(\"invalid mode: %r\" % mode)\n creating = \"x\" in modes\n reading = \"r\" in modes\n writing = \"w\" in modes\n appending = \"a\" in modes\n updating = \"+\" in modes\n text = \"t\" in modes\n binary = \"b\" in modes\n if \"U\" in modes:\n  if creating or writing or appending:\n   raise ValueError(\"can't use U and writing mode at once\")\n  reading = True\n if text and binary:\n  raise ValueError(\"can't have text and binary mode at once\")\n if creating + reading + writing + appending > 1:\n  raise ValueError(\"can't have read/write/append mode at once\")\n if not (creating or reading or writing or appending):\n  raise ValueError(\"must have exactly one of read/write/append mode\")\n if binary and encoding is not None:\n  raise ValueError(\"binary mode doesn't take an encoding argument\")\n if binary and errors is not None:\n  raise ValueError(\"binary mode doesn't take an errors argument\")\n if binary and newline is not None:\n  raise ValueError(\"binary mode doesn't take a newline argument\")\n raw = FileIO(file,\n (creating and \"x\" or \"\") +\n (reading and \"r\" or \"\") +\n (writing and \"w\" or \"\") +\n (appending and \"a\" or \"\") +\n (updating and \"+\" or \"\"),\n closefd, opener=opener)\n line_buffering = False\n if buffering == 1 or buffering < 0 and raw.isatty():\n  buffering = -1\n  line_buffering = True\n if buffering < 0:\n  buffering = DEFAULT_BUFFER_SIZE\n  try:\n   bs = os.fstat(raw.fileno()).st_blksize\n  except (os.error, AttributeError):\n   pass\n  else:\n   if bs > 1:\n    buffering = bs\n if buffering < 0:\n  raise ValueError(\"invalid buffering size\")\n if buffering == 0:\n  if binary:\n   return raw\n  raise ValueError(\"can't have unbuffered text I/O\")\n if updating:\n  buffer = BufferedRandom(raw, buffering)\n elif creating or writing or appending:\n  buffer = BufferedWriter(raw, buffering)\n elif reading:\n  buffer = BufferedReader(raw, buffering)\n else:\n  raise ValueError(\"unknown mode: %r\" % mode)\n if binary:\n  return buffer\n text = TextIOWrapper(buffer, encoding, errors, newline, line_buffering)\n text.mode = mode\n return text\n \n \nclass DocDescriptor:\n \"\"\n def __get__(self, obj, typ):\n  return (\n  \"open(file, mode='r', buffering=-1, encoding=None, \"\n  \"errors=None, newline=None, closefd=True)\\n\\n\" +\n  open.__doc__)\n  \nclass OpenWrapper:\n \"\"\n __doc__ = DocDescriptor()\n \n def __new__(cls, *args, **kwargs):\n  return open(*args, **kwargs)\n  \n  \n  \n  \ntry:\n UnsupportedOperation = io.UnsupportedOperation\nexcept AttributeError:\n class UnsupportedOperation(ValueError, IOError):\n  pass\n  \n  \nclass IOBase(metaclass=abc.ABCMeta):\n\n \"\"\n \n \n \n def _unsupported(self, name):\n  \"\"\n  raise UnsupportedOperation(\"%s.%s() not supported\" %\n  (self.__class__.__name__, name))\n  \n  \n  \n def seek(self, pos, whence=0):\n  \"\"\n  self._unsupported(\"seek\")\n  \n def tell(self):\n  \"\"\n  return self.seek(0, 1)\n  \n def truncate(self, pos=None):\n  \"\"\n  self._unsupported(\"truncate\")\n  \n  \n  \n def flush(self):\n  \"\"\n  self._checkClosed()\n  \n  \n __closed = False\n \n def close(self):\n  \"\"\n  if not self.__closed:\n   try:\n    self.flush()\n   finally:\n    self.__closed = True\n    \n def __del__(self):\n  \"\"\n  \n  \n  \n  \n  \n  try:\n   self.close()\n  except:\n   pass\n   \n   \n   \n def seekable(self):\n  \"\"\n  return False\n  \n def _checkSeekable(self, msg=None):\n  \"\"\n  if not self.seekable():\n   raise UnsupportedOperation(\"File or stream is not seekable.\"\n   if msg is None else msg)\n   \n def readable(self):\n  \"\"\n  return False\n  \n def _checkReadable(self, msg=None):\n  \"\"\n  if not self.readable():\n   raise UnsupportedOperation(\"File or stream is not readable.\"\n   if msg is None else msg)\n   \n def writable(self):\n  \"\"\n  return False\n  \n def _checkWritable(self, msg=None):\n  \"\"\n  if not self.writable():\n   raise UnsupportedOperation(\"File or stream is not writable.\"\n   if msg is None else msg)\n   \n @property\n def closed(self):\n  \"\"\n  return self.__closed\n  \n def _checkClosed(self, msg=None):\n  \"\"\n  if self.closed:\n   raise ValueError(\"I/O operation on closed file.\"\n   if msg is None else msg)\n   \n   \n   \n def __enter__(self): \n  \"\"\n  self._checkClosed()\n  return self\n  \n def __exit__(self, *args):\n  \"\"\n  self.close()\n  \n  \n  \n  \n  \n def fileno(self):\n  \"\"\n  self._unsupported(\"fileno\")\n  \n def isatty(self):\n  \"\"\n  self._checkClosed()\n  return False\n  \n  \n  \n def readline(self, limit=-1):\n  \"\"\n  \n  if hasattr(self, \"peek\"):\n   def nreadahead():\n    readahead = self.peek(1)\n    if not readahead:\n     return 1\n    n = (readahead.find(b\"\\n\") + 1) or len(readahead)\n    if limit >= 0:\n     n = min(n, limit)\n    return n\n  else:\n   def nreadahead():\n    return 1\n  if limit is None:\n   limit = -1\n  elif not isinstance(limit, int):\n   raise TypeError(\"limit must be an integer\")\n  res = bytearray()\n  while limit < 0 or len(res) < limit:\n   b = self.read(nreadahead())\n   if not b:\n    break\n   res += b\n   if res.endswith(b\"\\n\"):\n    break\n  return bytes(res)\n  \n def __iter__(self):\n  self._checkClosed()\n  return self\n  \n def __next__(self):\n  line = self.readline()\n  if not line:\n   raise StopIteration\n  return line\n  \n def readlines(self, hint=None):\n  \"\"\n  if hint is None or hint <= 0:\n   return list(self)\n  n = 0\n  lines = []\n  for line in self:\n   lines.append(line)\n   n += len(line)\n   if n >= hint:\n    break\n  return lines\n  \n def writelines(self, lines):\n  self._checkClosed()\n  for line in lines:\n   self.write(line)\n   \n   \n   \n   \n   \nclass RawIOBase(IOBase):\n\n \"\"\n \n \n \n \n \n \n \n \n \n \n \n def read(self, n=-1):\n  \"\"\n  if n is None:\n   n = -1\n  if n < 0:\n   return self.readall()\n  b = bytearray(n.__index__())\n  n = self.readinto(b)\n  if n is None:\n   return None\n  del b[n:]\n  return bytes(b)\n  \n def readall(self):\n  \"\"\n  res = bytearray()\n  while True:\n   data = self.read(DEFAULT_BUFFER_SIZE)\n   if not data:\n    break\n   res += data\n  if res:\n   return bytes(res)\n  else:\n  \n   return data\n   \n def readinto(self, b):\n  \"\"\n  self._unsupported(\"readinto\")\n  \n def write(self, b):\n  \"\"\n  self._unsupported(\"write\")\n  \n  \n  \n  \n  \n  \n  \nclass BufferedIOBase(IOBase):\n\n \"\"\n \n def read(self, n=None):\n  \"\"\n  self._unsupported(\"read\")\n  \n def read1(self, n=None):\n  \"\"\n  self._unsupported(\"read1\")\n  \n def readinto(self, b):\n  \"\"\n  \n  data = self.read(len(b))\n  n = len(data)\n  try:\n   b[:n] = data\n  except TypeError as err:\n   import array\n   if not isinstance(b, array.array):\n    raise err\n   b[:n] = array.array('b', data)\n  return n\n  \n def write(self, b):\n  \"\"\n  self._unsupported(\"write\")\n  \n def detach(self):\n  \"\"\n  self._unsupported(\"detach\")\n  \n  \n  \n  \n  \nclass _BufferedIOMixin(BufferedIOBase):\n\n \"\"\n \n def __init__(self, raw):\n  self._raw = raw\n  \n  \n  \n def seek(self, pos, whence=0):\n  new_position = self.raw.seek(pos, whence)\n  if new_position < 0:\n   raise IOError(\"seek() returned an invalid position\")\n  return new_position\n  \n def tell(self):\n  pos = self.raw.tell()\n  if pos < 0:\n   raise IOError(\"tell() returned an invalid position\")\n  return pos\n  \n def truncate(self, pos=None):\n \n \n \n  self.flush()\n  \n  if pos is None:\n   pos = self.tell()\n   \n   \n  return self.raw.truncate(pos)\n  \n  \n  \n def flush(self):\n  if self.closed:\n   raise ValueError(\"flush of closed file\")\n  self.raw.flush()\n  \n def close(self):\n  if self.raw is not None and not self.closed:\n   try:\n   \n    self.flush()\n   finally:\n    self.raw.close()\n    \n def detach(self):\n  if self.raw is None:\n   raise ValueError(\"raw stream already detached\")\n  self.flush()\n  raw = self._raw\n  self._raw = None\n  return raw\n  \n  \n  \n def seekable(self):\n  return self.raw.seekable()\n  \n def readable(self):\n  return self.raw.readable()\n  \n def writable(self):\n  return self.raw.writable()\n  \n @property\n def raw(self):\n  return self._raw\n  \n @property\n def closed(self):\n  return self.raw.closed\n  \n @property\n def name(self):\n  return self.raw.name\n  \n @property\n def mode(self):\n  return self.raw.mode\n  \n def __getstate__(self):\n  raise TypeError(\"can not serialize a '{0}' object\"\n  .format(self.__class__.__name__))\n  \n def __repr__(self):\n  clsname = self.__class__.__name__\n  try:\n   name = self.name\n  except AttributeError:\n   return \"<_io.{0}>\".format(clsname)\n  else:\n   return \"<_io.{0} name={1!r}>\".format(clsname, name)\n   \n   \n   \n def fileno(self):\n  return self.raw.fileno()\n  \n def isatty(self):\n  return self.raw.isatty()\n  \n  \nclass BytesIO(BufferedIOBase):\n\n \"\"\n \n def __init__(self, initial_bytes=None):\n  buf = bytearray()\n  if initial_bytes is not None:\n   buf += initial_bytes\n  self._buffer = buf\n  self._pos = 0\n  \n def __getstate__(self):\n  if self.closed:\n   raise ValueError(\"__getstate__ on closed file\")\n  return self.__dict__.copy()\n  \n def getvalue(self):\n  \"\"\n  if self.closed:\n   raise ValueError(\"getvalue on closed file\")\n  return bytes(self._buffer)\n  \n def getbuffer(self):\n  \"\"\n  return memoryview(self._buffer)\n  \n def read(self, n=None):\n  if self.closed:\n   raise ValueError(\"read from closed file\")\n  if n is None:\n   n = -1\n  if n < 0:\n   n = len(self._buffer)\n  if len(self._buffer) <= self._pos:\n   return b\"\"\n  newpos = min(len(self._buffer), self._pos + n)\n  b = self._buffer[self._pos : newpos]\n  self._pos = newpos\n  return bytes(b)\n  \n def read1(self, n):\n  \"\"\n  return self.read(n)\n  \n def write(self, b):\n  if self.closed:\n   raise ValueError(\"write to closed file\")\n  if isinstance(b, str):\n   raise TypeError(\"can't write str to binary stream\")\n  n = len(b)\n  if n == 0:\n   return 0\n  pos = self._pos\n  if pos > len(self._buffer):\n  \n  \n   padding = b'\\x00' * (pos - len(self._buffer))\n   self._buffer += padding\n  self._buffer[pos:pos + n] = b\n  self._pos += n\n  return n\n  \n def seek(self, pos, whence=0):\n  if self.closed:\n   raise ValueError(\"seek on closed file\")\n  try:\n   pos.__index__\n  except AttributeError as err:\n   raise TypeError(\"an integer is required\") from err\n  if whence == 0:\n   if pos < 0:\n    raise ValueError(\"negative seek position %r\" % (pos,))\n   self._pos = pos\n  elif whence == 1:\n   self._pos = max(0, self._pos + pos)\n  elif whence == 2:\n   self._pos = max(0, len(self._buffer) + pos)\n  else:\n   raise ValueError(\"unsupported whence value\")\n  return self._pos\n  \n def tell(self):\n  if self.closed:\n   raise ValueError(\"tell on closed file\")\n  return self._pos\n  \n def truncate(self, pos=None):\n  if self.closed:\n   raise ValueError(\"truncate on closed file\")\n  if pos is None:\n   pos = self._pos\n  else:\n   try:\n    pos.__index__\n   except AttributeError as err:\n    raise TypeError(\"an integer is required\") from err\n   if pos < 0:\n    raise ValueError(\"negative truncate position %r\" % (pos,))\n  del self._buffer[pos:]\n  return pos\n  \n def readable(self):\n  if self.closed:\n   raise ValueError(\"I/O operation on closed file.\")\n  return True\n  \n def writable(self):\n  if self.closed:\n   raise ValueError(\"I/O operation on closed file.\")\n  return True\n  \n def seekable(self):\n  if self.closed:\n   raise ValueError(\"I/O operation on closed file.\")\n  return True\n  \n  \nclass BufferedReader(_BufferedIOMixin):\n\n \"\"\n \n def __init__(self, raw, buffer_size=DEFAULT_BUFFER_SIZE):\n  \"\"\n  if not raw.readable():\n   raise IOError('\"raw\" argument must be readable.')\n   \n  _BufferedIOMixin.__init__(self, raw)\n  if buffer_size <= 0:\n   raise ValueError(\"invalid buffer size\")\n  self.buffer_size = buffer_size\n  self._reset_read_buf()\n  self._read_lock = Lock()\n  \n def _reset_read_buf(self):\n  self._read_buf = b\"\"\n  self._read_pos = 0\n  \n def read(self, n=None):\n  \"\"\n  if n is not None and n < -1:\n   raise ValueError(\"invalid number of bytes to read\")\n  with self._read_lock:\n   return self._read_unlocked(n)\n   \n def _read_unlocked(self, n=None):\n  nodata_val = b\"\"\n  empty_values = (b\"\", None)\n  buf = self._read_buf\n  pos = self._read_pos\n  \n  \n  if n is None or n == -1:\n   self._reset_read_buf()\n   if hasattr(self.raw, 'readall'):\n    chunk = self.raw.readall()\n    if chunk is None:\n     return buf[pos:] or None\n    else:\n     return buf[pos:] + chunk\n   chunks = [buf[pos:]] \n   current_size = 0\n   while True:\n   \n    try:\n     chunk = self.raw.read()\n    except InterruptedError:\n     continue\n    if chunk in empty_values:\n     nodata_val = chunk\n     break\n    current_size += len(chunk)\n    chunks.append(chunk)\n   return b\"\".join(chunks) or nodata_val\n   \n   \n  avail = len(buf) - pos \n  if n <= avail:\n  \n   self._read_pos += n\n   return buf[pos:pos+n]\n   \n   \n  chunks = [buf[pos:]]\n  wanted = max(self.buffer_size, n)\n  while avail < n:\n   try:\n    chunk = self.raw.read(wanted)\n   except InterruptedError:\n    continue\n   if chunk in empty_values:\n    nodata_val = chunk\n    break\n   avail += len(chunk)\n   chunks.append(chunk)\n   \n   \n  n = min(n, avail)\n  out = b\"\".join(chunks)\n  self._read_buf = out[n:] \n  self._read_pos = 0\n  return out[:n] if out else nodata_val\n  \n def peek(self, n=0):\n  \"\"\n  with self._read_lock:\n   return self._peek_unlocked(n)\n   \n def _peek_unlocked(self, n=0):\n  want = min(n, self.buffer_size)\n  have = len(self._read_buf) - self._read_pos\n  if have < want or have <= 0:\n   to_read = self.buffer_size - have\n   while True:\n    try:\n     current = self.raw.read(to_read)\n    except InterruptedError:\n     continue\n    break\n   if current:\n    self._read_buf = self._read_buf[self._read_pos:] + current\n    self._read_pos = 0\n  return self._read_buf[self._read_pos:]\n  \n def read1(self, n):\n  \"\"\n  \n  \n  if n < 0:\n   raise ValueError(\"number of bytes to read must be positive\")\n  if n == 0:\n   return b\"\"\n  with self._read_lock:\n   self._peek_unlocked(1)\n   return self._read_unlocked(\n   min(n, len(self._read_buf) - self._read_pos))\n   \n def tell(self):\n  return _BufferedIOMixin.tell(self) - len(self._read_buf) + self._read_pos\n  \n def seek(self, pos, whence=0):\n  if whence not in valid_seek_flags:\n   raise ValueError(\"invalid whence value\")\n  with self._read_lock:\n   if whence == 1:\n    pos -= len(self._read_buf) - self._read_pos\n   pos = _BufferedIOMixin.seek(self, pos, whence)\n   self._reset_read_buf()\n   return pos\n   \nclass BufferedWriter(_BufferedIOMixin):\n\n \"\"\n \n def __init__(self, raw, buffer_size=DEFAULT_BUFFER_SIZE):\n  if not raw.writable():\n   raise IOError('\"raw\" argument must be writable.')\n   \n  _BufferedIOMixin.__init__(self, raw)\n  if buffer_size <= 0:\n   raise ValueError(\"invalid buffer size\")\n  self.buffer_size = buffer_size\n  self._write_buf = bytearray()\n  self._write_lock = Lock()\n  \n def write(self, b):\n  if self.closed:\n   raise ValueError(\"write to closed file\")\n  if isinstance(b, str):\n   raise TypeError(\"can't write str to binary stream\")\n  with self._write_lock:\n  \n  \n   if len(self._write_buf) > self.buffer_size:\n   \n   \n    self._flush_unlocked()\n   before = len(self._write_buf)\n   self._write_buf.extend(b)\n   written = len(self._write_buf) - before\n   if len(self._write_buf) > self.buffer_size:\n    try:\n     self._flush_unlocked()\n    except BlockingIOError as e:\n     if len(self._write_buf) > self.buffer_size:\n     \n     \n      overage = len(self._write_buf) - self.buffer_size\n      written -= overage\n      self._write_buf = self._write_buf[:self.buffer_size]\n      raise BlockingIOError(e.errno, e.strerror, written)\n   return written\n   \n def truncate(self, pos=None):\n  with self._write_lock:\n   self._flush_unlocked()\n   if pos is None:\n    pos = self.raw.tell()\n   return self.raw.truncate(pos)\n   \n def flush(self):\n  with self._write_lock:\n   self._flush_unlocked()\n   \n def _flush_unlocked(self):\n  if self.closed:\n   raise ValueError(\"flush of closed file\")\n  while self._write_buf:\n   try:\n    n = self.raw.write(self._write_buf)\n   except InterruptedError:\n    continue\n   except BlockingIOError:\n    raise RuntimeError(\"self.raw should implement RawIOBase: it \"\n    \"should not raise BlockingIOError\")\n   if n is None:\n    raise BlockingIOError(\n    errno.EAGAIN,\n    \"write could not complete without blocking\", 0)\n   if n > len(self._write_buf) or n < 0:\n    raise IOError(\"write() returned incorrect number of bytes\")\n   del self._write_buf[:n]\n   \n def tell(self):\n  return _BufferedIOMixin.tell(self) + len(self._write_buf)\n  \n def seek(self, pos, whence=0):\n  if whence not in valid_seek_flags:\n   raise ValueError(\"invalid whence value\")\n  with self._write_lock:\n   self._flush_unlocked()\n   return _BufferedIOMixin.seek(self, pos, whence)\n   \n   \nclass BufferedRWPair(BufferedIOBase):\n\n \"\"\n \n \n \n \n def __init__(self, reader, writer, buffer_size=DEFAULT_BUFFER_SIZE):\n  \"\"\n  if not reader.readable():\n   raise IOError('\"reader\" argument must be readable.')\n   \n  if not writer.writable():\n   raise IOError('\"writer\" argument must be writable.')\n   \n  self.reader = BufferedReader(reader, buffer_size)\n  self.writer = BufferedWriter(writer, buffer_size)\n  \n def read(self, n=None):\n  if n is None:\n   n = -1\n  return self.reader.read(n)\n  \n def readinto(self, b):\n  return self.reader.readinto(b)\n  \n def write(self, b):\n  return self.writer.write(b)\n  \n def peek(self, n=0):\n  return self.reader.peek(n)\n  \n def read1(self, n):\n  return self.reader.read1(n)\n  \n def readable(self):\n  return self.reader.readable()\n  \n def writable(self):\n  return self.writer.writable()\n  \n def flush(self):\n  return self.writer.flush()\n  \n def close(self):\n  self.writer.close()\n  self.reader.close()\n  \n def isatty(self):\n  return self.reader.isatty() or self.writer.isatty()\n  \n @property\n def closed(self):\n  return self.writer.closed\n  \n  \nclass BufferedRandom(BufferedWriter, BufferedReader):\n\n \"\"\n \n def __init__(self, raw, buffer_size=DEFAULT_BUFFER_SIZE):\n  raw._checkSeekable()\n  BufferedReader.__init__(self, raw, buffer_size)\n  BufferedWriter.__init__(self, raw, buffer_size)\n  \n def seek(self, pos, whence=0):\n  if whence not in valid_seek_flags:\n   raise ValueError(\"invalid whence value\")\n  self.flush()\n  if self._read_buf:\n  \n   with self._read_lock:\n    self.raw.seek(self._read_pos - len(self._read_buf), 1)\n    \n    \n  pos = self.raw.seek(pos, whence)\n  with self._read_lock:\n   self._reset_read_buf()\n  if pos < 0:\n   raise IOError(\"seek() returned invalid position\")\n  return pos\n  \n def tell(self):\n  if self._write_buf:\n   return BufferedWriter.tell(self)\n  else:\n   return BufferedReader.tell(self)\n   \n def truncate(self, pos=None):\n  if pos is None:\n   pos = self.tell()\n   \n  return BufferedWriter.truncate(self, pos)\n  \n def read(self, n=None):\n  if n is None:\n   n = -1\n  self.flush()\n  return BufferedReader.read(self, n)\n  \n def readinto(self, b):\n  self.flush()\n  return BufferedReader.readinto(self, b)\n  \n def peek(self, n=0):\n  self.flush()\n  return BufferedReader.peek(self, n)\n  \n def read1(self, n):\n  self.flush()\n  return BufferedReader.read1(self, n)\n  \n def write(self, b):\n  if self._read_buf:\n  \n   with self._read_lock:\n    self.raw.seek(self._read_pos - len(self._read_buf), 1)\n    self._reset_read_buf()\n  return BufferedWriter.write(self, b)\n  \n  \nclass TextIOBase(IOBase):\n\n \"\"\n \n def read(self, n=-1):\n  \"\"\n  self._unsupported(\"read\")\n  \n def write(self, s):\n  \"\"\n  self._unsupported(\"write\")\n  \n def truncate(self, pos=None):\n  \"\"\n  self._unsupported(\"truncate\")\n  \n def readline(self):\n  \"\"\n  self._unsupported(\"readline\")\n  \n def detach(self):\n  \"\"\n  self._unsupported(\"detach\")\n  \n @property\n def encoding(self):\n  \"\"\n  return None\n  \n @property\n def newlines(self):\n  \"\"\n  return None\n  \n @property\n def errors(self):\n  \"\"\n  return None\n  \n  \n  \n  \n  \nclass IncrementalNewlineDecoder(codecs.IncrementalDecoder):\n \"\"\n def __init__(self, decoder, translate, errors='strict'):\n  codecs.IncrementalDecoder.__init__(self, errors=errors)\n  self.translate = translate\n  self.decoder = decoder\n  self.seennl = 0\n  self.pendingcr = False\n  \n def decode(self, input, final=False):\n \n  if self.decoder is None:\n   output = input\n  else:\n   output = self.decoder.decode(input, final=final)\n  if self.pendingcr and (output or final):\n   output = \"\\r\" + output\n   self.pendingcr = False\n   \n   \n   \n  if output.endswith(\"\\r\") and not final:\n   output = output[:-1]\n   self.pendingcr = True\n   \n   \n  crlf = output.count('\\r\\n')\n  cr = output.count('\\r') - crlf\n  lf = output.count('\\n') - crlf\n  self.seennl |= (lf and self._LF) | (cr and self._CR) | (crlf and self._CRLF)\n  \n  if self.translate:\n   if crlf:\n    output = output.replace(\"\\r\\n\", \"\\n\")\n   if cr:\n    output = output.replace(\"\\r\", \"\\n\")\n    \n  return output\n  \n def getstate(self):\n  if self.decoder is None:\n   buf = b\"\"\n   flag = 0\n  else:\n   buf, flag = self.decoder.getstate()\n  flag <<= 1\n  if self.pendingcr:\n   flag |= 1\n  return buf, flag\n  \n def setstate(self, state):\n  buf, flag = state\n  self.pendingcr = bool(flag & 1)\n  if self.decoder is not None:\n   self.decoder.setstate((buf, flag >> 1))\n   \n def reset(self):\n  self.seennl = 0\n  self.pendingcr = False\n  if self.decoder is not None:\n   self.decoder.reset()\n   \n _LF = 1\n _CR = 2\n _CRLF = 4\n \n @property\n def newlines(self):\n  return (None,\n  \"\\n\",\n  \"\\r\",\n  (\"\\r\", \"\\n\"),\n  \"\\r\\n\",\n  (\"\\n\", \"\\r\\n\"),\n  (\"\\r\", \"\\r\\n\"),\n  (\"\\r\", \"\\n\", \"\\r\\n\")\n  )[self.seennl]\n  \n  \nclass TextIOWrapper(TextIOBase):\n\n \"\"\n \n _CHUNK_SIZE = 2048\n \n \n \n \n def __init__(self, buffer, encoding=None, errors=None, newline=None,\n line_buffering=False, write_through=False):\n  if newline is not None and not isinstance(newline, str):\n   raise TypeError(\"illegal newline type: %r\" % (type(newline),))\n  if newline not in (None, \"\", \"\\n\", \"\\r\", \"\\r\\n\"):\n   raise ValueError(\"illegal newline value: %r\" % (newline,))\n  if encoding is None:\n   try:\n    encoding = os.device_encoding(buffer.fileno())\n   except (AttributeError, UnsupportedOperation):\n    pass\n   if encoding is None:\n    try:\n     import locale\n    except ImportError:\n    \n     encoding = \"ascii\"\n    else:\n     encoding = locale.getpreferredencoding(False)\n     \n  if not isinstance(encoding, str):\n   raise ValueError(\"invalid encoding: %r\" % encoding)\n   \n  if errors is None:\n   errors = \"strict\"\n  else:\n   if not isinstance(errors, str):\n    raise ValueError(\"invalid errors: %r\" % errors)\n    \n  self._buffer = buffer\n  self._line_buffering = line_buffering\n  self._encoding = encoding\n  self._errors = errors\n  self._readuniversal = not newline\n  self._readtranslate = newline is None\n  self._readnl = newline\n  self._writetranslate = newline != ''\n  self._writenl = newline or os.linesep\n  self._encoder = None\n  self._decoder = None\n  self._decoded_chars = '' \n  self._decoded_chars_used = 0 \n  self._snapshot = None \n  self._seekable = self._telling = self.buffer.seekable()\n  self._has_read1 = hasattr(self.buffer, 'read1')\n  self._b2cratio = 0.0\n  \n  if self._seekable and self.writable():\n   position = self.buffer.tell()\n   if position != 0:\n    try:\n     self._get_encoder().setstate(0)\n    except LookupError:\n    \n     pass\n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n def __repr__(self):\n  result = \"<_io.TextIOWrapper\"\n  try:\n   name = self.name\n  except AttributeError:\n   pass\n  else:\n   result += \" name={0!r}\".format(name)\n  try:\n   mode = self.mode\n  except AttributeError:\n   pass\n  else:\n   result += \" mode={0!r}\".format(mode)\n  return result + \" encoding={0!r}>\".format(self.encoding)\n  \n @property\n def encoding(self):\n  return self._encoding\n  \n @property\n def errors(self):\n  return self._errors\n  \n @property\n def line_buffering(self):\n  return self._line_buffering\n  \n @property\n def buffer(self):\n  return self._buffer\n  \n def seekable(self):\n  if self.closed:\n   raise ValueError(\"I/O operation on closed file.\")\n  return self._seekable\n  \n def readable(self):\n  return self.buffer.readable()\n  \n def writable(self):\n  return self.buffer.writable()\n  \n def flush(self):\n  self.buffer.flush()\n  self._telling = self._seekable\n  \n def close(self):\n  if self.buffer is not None and not self.closed:\n   try:\n    self.flush()\n   finally:\n    self.buffer.close()\n    \n @property\n def closed(self):\n  return self.buffer.closed\n  \n @property\n def name(self):\n  return self.buffer.name\n  \n def fileno(self):\n  return self.buffer.fileno()\n  \n def isatty(self):\n  return self.buffer.isatty()\n  \n def write(self, s):\n  \"\"\n  if self.closed:\n   raise ValueError(\"write to closed file\")\n  if not isinstance(s, str):\n   raise TypeError(\"can't write %s to text stream\" %\n   s.__class__.__name__)\n  length = len(s)\n  haslf = (self._writetranslate or self._line_buffering) and \"\\n\" in s\n  if haslf and self._writetranslate and self._writenl != \"\\n\":\n   s = s.replace(\"\\n\", self._writenl)\n  encoder = self._encoder or self._get_encoder()\n  \n  b = encoder.encode(s)\n  self.buffer.write(b)\n  if self._line_buffering and (haslf or \"\\r\" in s):\n   self.flush()\n  self._snapshot = None\n  if self._decoder:\n   self._decoder.reset()\n  return length\n  \n def _get_encoder(self):\n  make_encoder = codecs.getincrementalencoder(self._encoding)\n  self._encoder = make_encoder(self._errors)\n  return self._encoder\n  \n def _get_decoder(self):\n  make_decoder = codecs.getincrementaldecoder(self._encoding)\n  decoder = make_decoder(self._errors)\n  if self._readuniversal:\n   decoder = IncrementalNewlineDecoder(decoder, self._readtranslate)\n  self._decoder = decoder\n  return decoder\n  \n  \n  \n  \n def _set_decoded_chars(self, chars):\n  \"\"\n  self._decoded_chars = chars\n  self._decoded_chars_used = 0\n  \n def _get_decoded_chars(self, n=None):\n  \"\"\n  offset = self._decoded_chars_used\n  if n is None:\n   chars = self._decoded_chars[offset:]\n  else:\n   chars = self._decoded_chars[offset:offset + n]\n  self._decoded_chars_used += len(chars)\n  return chars\n  \n def _rewind_decoded_chars(self, n):\n  \"\"\n  if self._decoded_chars_used < n:\n   raise AssertionError(\"rewind decoded_chars out of bounds\")\n  self._decoded_chars_used -= n\n  \n def _read_chunk(self):\n  \"\"\n  \n  \n  \n  \n  \n  \n  \n  if self._decoder is None:\n   raise ValueError(\"no decoder\")\n   \n  if self._telling:\n  \n  \n  \n   dec_buffer, dec_flags = self._decoder.getstate()\n   \n   \n   \n   \n  if self._has_read1:\n   input_chunk = self.buffer.read1(self._CHUNK_SIZE)\n  else:\n   input_chunk = self.buffer.read(self._CHUNK_SIZE)\n  eof = not input_chunk\n  decoded_chars = self._decoder.decode(input_chunk, eof)\n  self._set_decoded_chars(decoded_chars)\n  if decoded_chars:\n   self._b2cratio = len(input_chunk) / len(self._decoded_chars)\n  else:\n   self._b2cratio = 0.0\n   \n  if self._telling:\n  \n  \n   self._snapshot = (dec_flags, dec_buffer + input_chunk)\n   \n  return not eof\n  \n def _pack_cookie(self, position, dec_flags=0,\n bytes_to_feed=0, need_eof=0, chars_to_skip=0):\n \n \n \n \n \n  return (position | (dec_flags<<64) | (bytes_to_feed<<128) |\n  (chars_to_skip<<192) | bool(need_eof)<<256)\n  \n def _unpack_cookie(self, bigint):\n  rest, position = divmod(bigint, 1<<64)\n  rest, dec_flags = divmod(rest, 1<<64)\n  rest, bytes_to_feed = divmod(rest, 1<<64)\n  need_eof, chars_to_skip = divmod(rest, 1<<64)\n  return position, dec_flags, bytes_to_feed, need_eof, chars_to_skip\n  \n def tell(self):\n  if not self._seekable:\n   raise UnsupportedOperation(\"underlying stream is not seekable\")\n  if not self._telling:\n   raise IOError(\"telling position disabled by next() call\")\n  self.flush()\n  position = self.buffer.tell()\n  decoder = self._decoder\n  if decoder is None or self._snapshot is None:\n   if self._decoded_chars:\n   \n    raise AssertionError(\"pending decoded text\")\n   return position\n   \n   \n  dec_flags, next_input = self._snapshot\n  position -= len(next_input)\n  \n  \n  chars_to_skip = self._decoded_chars_used\n  if chars_to_skip == 0:\n  \n   return self._pack_cookie(position, dec_flags)\n   \n   \n   \n  saved_state = decoder.getstate()\n  try:\n  \n  \n  \n  \n  \n  \n  \n   skip_bytes = int(self._b2cratio * chars_to_skip)\n   skip_back = 1\n   assert skip_bytes <= len(next_input)\n   while skip_bytes > 0:\n    decoder.setstate((b'', dec_flags))\n    \n    n = len(decoder.decode(next_input[:skip_bytes]))\n    if n <= chars_to_skip:\n     b, d = decoder.getstate()\n     if not b:\n     \n      dec_flags = d\n      chars_to_skip -= n\n      break\n      \n     skip_bytes -= len(b)\n     skip_back = 1\n    else:\n    \n     skip_bytes -= skip_back\n     skip_back = skip_back * 2\n   else:\n    skip_bytes = 0\n    decoder.setstate((b'', dec_flags))\n    \n    \n   start_pos = position + skip_bytes\n   start_flags = dec_flags\n   if chars_to_skip == 0:\n   \n    return self._pack_cookie(start_pos, start_flags)\n    \n    \n    \n    \n    \n   bytes_fed = 0\n   need_eof = 0\n   \n   chars_decoded = 0\n   for i in range(skip_bytes, len(next_input)):\n    bytes_fed += 1\n    chars_decoded += len(decoder.decode(next_input[i:i+1]))\n    dec_buffer, dec_flags = decoder.getstate()\n    if not dec_buffer and chars_decoded <= chars_to_skip:\n    \n     start_pos += bytes_fed\n     chars_to_skip -= chars_decoded\n     start_flags, bytes_fed, chars_decoded = dec_flags, 0, 0\n    if chars_decoded >= chars_to_skip:\n     break\n   else:\n   \n    chars_decoded += len(decoder.decode(b'', final=True))\n    need_eof = 1\n    if chars_decoded < chars_to_skip:\n     raise IOError(\"can't reconstruct logical file position\")\n     \n     \n   return self._pack_cookie(\n   start_pos, start_flags, bytes_fed, need_eof, chars_to_skip)\n  finally:\n   decoder.setstate(saved_state)\n   \n def truncate(self, pos=None):\n  self.flush()\n  if pos is None:\n   pos = self.tell()\n  return self.buffer.truncate(pos)\n  \n def detach(self):\n  if self.buffer is None:\n   raise ValueError(\"buffer is already detached\")\n  self.flush()\n  buffer = self._buffer\n  self._buffer = None\n  return buffer\n  \n def seek(self, cookie, whence=0):\n  if self.closed:\n   raise ValueError(\"tell on closed file\")\n  if not self._seekable:\n   raise UnsupportedOperation(\"underlying stream is not seekable\")\n  if whence == 1: \n   if cookie != 0:\n    raise UnsupportedOperation(\"can't do nonzero cur-relative seeks\")\n    \n    \n   whence = 0\n   cookie = self.tell()\n  if whence == 2: \n   if cookie != 0:\n    raise UnsupportedOperation(\"can't do nonzero end-relative seeks\")\n   self.flush()\n   position = self.buffer.seek(0, 2)\n   self._set_decoded_chars('')\n   self._snapshot = None\n   if self._decoder:\n    self._decoder.reset()\n   return position\n  if whence != 0:\n   raise ValueError(\"unsupported whence (%r)\" % (whence,))\n  if cookie < 0:\n   raise ValueError(\"negative seek position %r\" % (cookie,))\n  self.flush()\n  \n  \n  \n  start_pos, dec_flags, bytes_to_feed, need_eof, chars_to_skip = self._unpack_cookie(cookie)\n  \n  \n  self.buffer.seek(start_pos)\n  self._set_decoded_chars('')\n  self._snapshot = None\n  \n  \n  if cookie == 0 and self._decoder:\n   self._decoder.reset()\n  elif self._decoder or dec_flags or chars_to_skip:\n   self._decoder = self._decoder or self._get_decoder()\n   self._decoder.setstate((b'', dec_flags))\n   self._snapshot = (dec_flags, b'')\n   \n  if chars_to_skip:\n  \n   input_chunk = self.buffer.read(bytes_to_feed)\n   self._set_decoded_chars(\n   self._decoder.decode(input_chunk, need_eof))\n   self._snapshot = (dec_flags, input_chunk)\n   \n   \n   if len(self._decoded_chars) < chars_to_skip:\n    raise IOError(\"can't restore logical file position\")\n   self._decoded_chars_used = chars_to_skip\n   \n   \n  try:\n   encoder = self._encoder or self._get_encoder()\n  except LookupError:\n  \n   pass\n  else:\n   if cookie != 0:\n    encoder.setstate(0)\n   else:\n    encoder.reset()\n  return cookie\n  \n def read(self, n=None):\n  self._checkReadable()\n  if n is None:\n   n = -1\n  decoder = self._decoder or self._get_decoder()\n  try:\n   n.__index__\n  except AttributeError as err:\n   raise TypeError(\"an integer is required\") from err\n  if n < 0:\n  \n   result = (self._get_decoded_chars() +\n   decoder.decode(self.buffer.read(), final=True))\n   self._set_decoded_chars('')\n   self._snapshot = None\n   return result\n  else:\n  \n   eof = False\n   result = self._get_decoded_chars(n)\n   while len(result) < n and not eof:\n    eof = not self._read_chunk()\n    result += self._get_decoded_chars(n - len(result))\n   return result\n   \n def __next__(self):\n  self._telling = False\n  line = self.readline()\n  if not line:\n   self._snapshot = None\n   self._telling = self._seekable\n   raise StopIteration\n  return line\n  \n def readline(self, limit=None):\n  if self.closed:\n   raise ValueError(\"read from closed file\")\n  if limit is None:\n   limit = -1\n  elif not isinstance(limit, int):\n   raise TypeError(\"limit must be an integer\")\n   \n   \n  line = self._get_decoded_chars()\n  \n  start = 0\n  \n  if not self._decoder:\n   self._get_decoder()\n   \n  pos = endpos = None\n  while True:\n   if self._readtranslate:\n   \n    pos = line.find('\\n', start)\n    if pos >= 0:\n     endpos = pos + 1\n     break\n    else:\n     start = len(line)\n     \n   elif self._readuniversal:\n   \n   \n   \n   \n    nlpos = line.find(\"\\n\", start)\n    crpos = line.find(\"\\r\", start)\n    if crpos == -1:\n     if nlpos == -1:\n     \n      start = len(line)\n     else:\n     \n      endpos = nlpos + 1\n      break\n    elif nlpos == -1:\n    \n     endpos = crpos + 1\n     break\n    elif nlpos < crpos:\n    \n     endpos = nlpos + 1\n     break\n    elif nlpos == crpos + 1:\n    \n     endpos = crpos + 2\n     break\n    else:\n    \n     endpos = crpos + 1\n     break\n   else:\n   \n    pos = line.find(self._readnl)\n    if pos >= 0:\n     endpos = pos + len(self._readnl)\n     break\n     \n   if limit >= 0 and len(line) >= limit:\n    endpos = limit \n    break\n    \n    \n   while self._read_chunk():\n    if self._decoded_chars:\n     break\n   if self._decoded_chars:\n    line += self._get_decoded_chars()\n   else:\n   \n    self._set_decoded_chars('')\n    self._snapshot = None\n    return line\n    \n  if limit >= 0 and endpos > limit:\n   endpos = limit \n   \n   \n  self._rewind_decoded_chars(len(line) - endpos)\n  return line[:endpos]\n  \n @property\n def newlines(self):\n  return self._decoder.newlines if self._decoder else None\n  \n  \nclass StringIO(TextIOWrapper):\n \"\"\n \n def __init__(self, initial_value=\"\", newline=\"\\n\"):\n  super(StringIO, self).__init__(BytesIO(),\n  encoding=\"utf-8\",\n  errors=\"strict\",\n  newline=newline)\n  \n  \n  if newline is None:\n   self._writetranslate = False\n  if initial_value is not None:\n   if not isinstance(initial_value, str):\n    raise TypeError(\"initial_value must be str or None, not {0}\"\n    .format(type(initial_value).__name__))\n    initial_value = str(initial_value)\n   self.write(initial_value)\n   self.seek(0)\n   \n def getvalue(self):\n  self.flush()\n  return self.buffer.getvalue().decode(self._encoding, self._errors)\n  \n def __repr__(self):\n \n \n  return object.__repr__(self)\n  \n @property\n def errors(self):\n  return None\n  \n @property\n def encoding(self):\n  return None\n  \n def detach(self):\n \n  self._unsupported(\"detach\")\n"], "linecache": [".py", "\"\"\n\nimport sys\nimport os\nimport tokenize\n\n__all__ = [\"getline\", \"clearcache\", \"checkcache\"]\n\ndef getline(filename, lineno, module_globals=None):\n lines = getlines(filename, module_globals)\n if 1 <= lineno <= len(lines):\n  return lines[lineno-1]\n else:\n  return ''\n  \n  \n  \n  \ncache = {} \n\n\ndef clearcache():\n \"\"\n \n global cache\n cache = {}\n \n \ndef getlines(filename, module_globals=None):\n \"\"\n \n if filename in cache:\n  return cache[filename][2]\n else:\n  return updatecache(filename, module_globals)\n  \n  \ndef checkcache(filename=None):\n \"\"\n \n if filename is None:\n  filenames = list(cache.keys())\n else:\n  if filename in cache:\n   filenames = [filename]\n  else:\n   return\n   \n for filename in filenames:\n  size, mtime, lines, fullname = cache[filename]\n  if mtime is None:\n   continue \n  try:\n   stat = os.stat(fullname)\n  except os.error:\n   del cache[filename]\n   continue\n  if size != stat.st_size or mtime != stat.st_mtime:\n   del cache[filename]\n   \n   \ndef updatecache(filename, module_globals=None):\n \"\"\n \n if filename in cache:\n  del cache[filename]\n if not filename or (filename.startswith('<') and filename.endswith('>')):\n  return []\n  \n fullname = filename\n try:\n  stat = os.stat(fullname)\n except OSError:\n  basename = filename\n  \n  \n  if module_globals and '__loader__' in module_globals:\n   name = module_globals.get('__name__')\n   loader = module_globals['__loader__']\n   get_source = getattr(loader, 'get_source', None)\n   \n   if name and get_source:\n    try:\n     data = get_source(name)\n    except (ImportError, IOError):\n     pass\n    else:\n     if data is None:\n     \n     \n      return []\n     cache[filename] = (\n     len(data), None,\n     [line+'\\n' for line in data.splitlines()], fullname\n     )\n     return cache[filename][2]\n     \n     \n     \n  if os.path.isabs(filename):\n   return []\n   \n  for dirname in sys.path:\n   try:\n    fullname = os.path.join(dirname, basename)\n   except (TypeError, AttributeError):\n   \n    continue\n   try:\n    stat = os.stat(fullname)\n    break\n   except os.error:\n    pass\n  else:\n   return []\n try:\n  with tokenize.open(fullname) as fp:\n   lines = fp.readlines()\n except IOError:\n  return []\n if lines and not lines[-1].endswith('\\n'):\n  lines[-1] += '\\n'\n size, mtime = stat.st_size, stat.st_mtime\n cache[filename] = size, mtime, lines, fullname\n return lines\n"], "_strptime": [".py", "\"\"\nimport time\nimport locale\nimport calendar\nfrom re import compile as re_compile\nfrom re import IGNORECASE\nfrom re import escape as re_escape\nfrom datetime import (date as datetime_date,\ntimedelta as datetime_timedelta,\ntimezone as datetime_timezone)\ntry:\n from _thread import allocate_lock as _thread_allocate_lock\nexcept ImportError:\n from _dummy_thread import allocate_lock as _thread_allocate_lock\n \n__all__ = []\n\ndef _getlang():\n\n return locale.getlocale(locale.LC_TIME)\n \nclass LocaleTime(object):\n \"\"\n \n def __init__(self):\n  \"\"\n  self.lang = _getlang()\n  self.__calc_weekday()\n  self.__calc_month()\n  self.__calc_am_pm()\n  self.__calc_timezone()\n  self.__calc_date_time()\n  if _getlang() != self.lang:\n   raise ValueError(\"locale changed during initialization\")\n   \n def __pad(self, seq, front):\n \n  seq = list(seq)\n  if front:\n   seq.insert(0, '')\n  else:\n   seq.append('')\n  return seq\n  \n def __calc_weekday(self):\n \n \n  a_weekday = [calendar.day_abbr[i].lower() for i in range(7)]\n  f_weekday = [calendar.day_name[i].lower() for i in range(7)]\n  self.a_weekday = a_weekday\n  self.f_weekday = f_weekday\n  \n def __calc_month(self):\n \n  a_month = [calendar.month_abbr[i].lower() for i in range(13)]\n  f_month = [calendar.month_name[i].lower() for i in range(13)]\n  self.a_month = a_month\n  self.f_month = f_month\n  \n def __calc_am_pm(self):\n \n \n \n \n \n  am_pm = []\n  for hour in (1, 22):\n   time_tuple = time.struct_time((1999,3,17,hour,44,55,2,76,0))\n   am_pm.append(time.strftime(\"%p\", time_tuple).lower())\n  self.am_pm = am_pm\n  \n def __calc_date_time(self):\n \n \n \n \n \n \n \n  time_tuple = time.struct_time((1999,3,17,22,44,55,2,76,0))\n  date_time = [None, None, None]\n  date_time[0] = time.strftime(\"%c\", time_tuple).lower()\n  date_time[1] = time.strftime(\"%x\", time_tuple).lower()\n  date_time[2] = time.strftime(\"%X\", time_tuple).lower()\n  replacement_pairs = [('%', '%%'), (self.f_weekday[2], '%A'),\n  (self.f_month[3], '%B'), (self.a_weekday[2], '%a'),\n  (self.a_month[3], '%b'), (self.am_pm[1], '%p'),\n  ('1999', '%Y'), ('99', '%y'), ('22', '%H'),\n  ('44', '%M'), ('55', '%S'), ('76', '%j'),\n  ('17', '%d'), ('03', '%m'), ('3', '%m'),\n  \n  ('2', '%w'), ('10', '%I')]\n  replacement_pairs.extend([(tz, \"%Z\") for tz_values in self.timezone\n  for tz in tz_values])\n  for offset,directive in ((0,'%c'), (1,'%x'), (2,'%X')):\n   current_format = date_time[offset]\n   for old, new in replacement_pairs:\n   \n   \n   \n   \n    if old:\n     current_format = current_format.replace(old, new)\n     \n     \n     \n   time_tuple = time.struct_time((1999,1,3,1,1,1,6,3,0))\n   if '00' in time.strftime(directive, time_tuple):\n    U_W = '%W'\n   else:\n    U_W = '%U'\n   date_time[offset] = current_format.replace('11', U_W)\n  self.LC_date_time = date_time[0]\n  self.LC_date = date_time[1]\n  self.LC_time = date_time[2]\n  \n def __calc_timezone(self):\n \n \n \n \n \n \n \n  no_saving = frozenset([\"utc\", \"gmt\", time.tzname[0].lower()])\n  if time.daylight:\n   has_saving = frozenset([time.tzname[1].lower()])\n  else:\n   has_saving = frozenset()\n  self.timezone = (no_saving, has_saving)\n  \n  \nclass TimeRE(dict):\n \"\"\n \n def __init__(self, locale_time=None):\n  \"\"\n  if locale_time:\n   self.locale_time = locale_time\n  else:\n   self.locale_time = LocaleTime()\n  base = super()\n  base.__init__({\n  \n  'd': r\"(?P<d>3[0-1]|[1-2]\\d|0[1-9]|[1-9]| [1-9])\",\n  'f': r\"(?P<f>[0-9]{1,6})\",\n  'H': r\"(?P<H>2[0-3]|[0-1]\\d|\\d)\",\n  'I': r\"(?P<I>1[0-2]|0[1-9]|[1-9])\",\n  'j': r\"(?P<j>36[0-6]|3[0-5]\\d|[1-2]\\d\\d|0[1-9]\\d|00[1-9]|[1-9]\\d|0[1-9]|[1-9])\",\n  'm': r\"(?P<m>1[0-2]|0[1-9]|[1-9])\",\n  'M': r\"(?P<M>[0-5]\\d|\\d)\",\n  'S': r\"(?P<S>6[0-1]|[0-5]\\d|\\d)\",\n  'U': r\"(?P<U>5[0-3]|[0-4]\\d|\\d)\",\n  'w': r\"(?P<w>[0-6])\",\n  \n  'y': r\"(?P<y>\\d\\d)\",\n  \n  \n  'Y': r\"(?P<Y>\\d\\d\\d\\d)\",\n  'z': r\"(?P<z>[+-]\\d\\d[0-5]\\d)\",\n  'A': self.__seqToRE(self.locale_time.f_weekday, 'A'),\n  'a': self.__seqToRE(self.locale_time.a_weekday, 'a'),\n  'B': self.__seqToRE(self.locale_time.f_month[1:], 'B'),\n  'b': self.__seqToRE(self.locale_time.a_month[1:], 'b'),\n  'p': self.__seqToRE(self.locale_time.am_pm, 'p'),\n  'Z': self.__seqToRE((tz for tz_names in self.locale_time.timezone\n  for tz in tz_names),\n  'Z'),\n  '%': '%'})\n  base.__setitem__('W', base.__getitem__('U').replace('U', 'W'))\n  base.__setitem__('c', self.pattern(self.locale_time.LC_date_time))\n  base.__setitem__('x', self.pattern(self.locale_time.LC_date))\n  base.__setitem__('X', self.pattern(self.locale_time.LC_time))\n  \n def __seqToRE(self, to_convert, directive):\n  \"\"\n  to_convert = sorted(to_convert, key=len, reverse=True)\n  for value in to_convert:\n   if value != '':\n    break\n  else:\n   return ''\n  regex = '|'.join(re_escape(stuff) for stuff in to_convert)\n  regex = '(?P<%s>%s' % (directive, regex)\n  return '%s)' % regex\n  \n def pattern(self, format):\n  \"\"\n  processed_format = ''\n  \n  \n  \n  regex_chars = re_compile(r\"([\\\\.^$*+?\\(\\){}\\[\\]|])\")\n  format = regex_chars.sub(r\"\\\\\\1\", format)\n  whitespace_replacement = re_compile('\\s+')\n  format = whitespace_replacement.sub('\\s+', format)\n  while '%' in format:\n   directive_index = format.index('%')+1\n   processed_format = \"%s%s%s\" % (processed_format,\n   format[:directive_index-1],\n   self[format[directive_index]])\n   format = format[directive_index+1:]\n  return \"%s%s\" % (processed_format, format)\n  \n def compile(self, format):\n  \"\"\n  return re_compile(self.pattern(format), IGNORECASE)\n  \n_cache_lock = _thread_allocate_lock()\n\n\n_TimeRE_cache = TimeRE()\n_CACHE_MAX_SIZE = 5 \n_regex_cache = {}\n\ndef _calc_julian_from_U_or_W(year, week_of_year, day_of_week, week_starts_Mon):\n \"\"\n first_weekday = datetime_date(year, 1, 1).weekday()\n \n \n \n if not week_starts_Mon:\n  first_weekday = (first_weekday + 1) % 7\n  day_of_week = (day_of_week + 1) % 7\n  \n  \n week_0_length = (7 - first_weekday) % 7\n if week_of_year == 0:\n  return 1 + day_of_week - first_weekday\n else:\n  days_to_week = week_0_length + (7 * (week_of_year - 1))\n  return 1 + days_to_week + day_of_week\n  \n  \ndef _strptime(data_string, format=\"%a %b %d %H:%M:%S %Y\"):\n \"\"\n \n for index, arg in enumerate([data_string, format]):\n  if not isinstance(arg, str):\n   msg = \"strptime() argument {} must be str, not {}\"\n   raise TypeError(msg.format(index, type(arg)))\n   \n global _TimeRE_cache, _regex_cache\n with _cache_lock:\n \n  if _getlang() != _TimeRE_cache.locale_time.lang:\n   _TimeRE_cache = TimeRE()\n   _regex_cache.clear()\n  if len(_regex_cache) > _CACHE_MAX_SIZE:\n   _regex_cache.clear()\n  locale_time = _TimeRE_cache.locale_time\n  format_regex = _regex_cache.get(format)\n  if not format_regex:\n   try:\n    format_regex = _TimeRE_cache.compile(format)\n    \n    \n   except KeyError as err:\n    bad_directive = err.args[0]\n    if bad_directive == \"\\\\\":\n     bad_directive = \"%\"\n    del err\n    raise ValueError(\"'%s' is a bad directive in format '%s'\" %\n    (bad_directive, format)) from None\n    \n   except IndexError:\n    raise ValueError(\"stray %% in format '%s'\" % format) from None\n   _regex_cache[format] = format_regex\n found = format_regex.match(data_string)\n if not found:\n  raise ValueError(\"time data %r does not match format %r\" %\n  (data_string, format))\n if len(data_string) != found.end():\n  raise ValueError(\"unconverted data remains: %s\" %\n  data_string[found.end():])\n  \n year = None\n month = day = 1\n hour = minute = second = fraction = 0\n tz = -1\n tzoffset = None\n \n \n week_of_year = -1\n week_of_year_start = -1\n \n \n weekday = julian = -1\n found_dict = found.groupdict()\n for group_key in found_dict.keys():\n \n \n \n \n \n  if group_key == 'y':\n   year = int(found_dict['y'])\n   \n   \n   \n   if year <= 68:\n    year += 2000\n   else:\n    year += 1900\n  elif group_key == 'Y':\n   year = int(found_dict['Y'])\n  elif group_key == 'm':\n   month = int(found_dict['m'])\n  elif group_key == 'B':\n   month = locale_time.f_month.index(found_dict['B'].lower())\n  elif group_key == 'b':\n   month = locale_time.a_month.index(found_dict['b'].lower())\n  elif group_key == 'd':\n   day = int(found_dict['d'])\n  elif group_key == 'H':\n   hour = int(found_dict['H'])\n  elif group_key == 'I':\n   hour = int(found_dict['I'])\n   ampm = found_dict.get('p', '').lower()\n   \n   if ampm in ('', locale_time.am_pm[0]):\n   \n   \n   \n    if hour == 12:\n     hour = 0\n   elif ampm == locale_time.am_pm[1]:\n   \n   \n   \n    if hour != 12:\n     hour += 12\n  elif group_key == 'M':\n   minute = int(found_dict['M'])\n  elif group_key == 'S':\n   second = int(found_dict['S'])\n  elif group_key == 'f':\n   s = found_dict['f']\n   \n   s += \"0\" * (6 - len(s))\n   fraction = int(s)\n  elif group_key == 'A':\n   weekday = locale_time.f_weekday.index(found_dict['A'].lower())\n  elif group_key == 'a':\n   weekday = locale_time.a_weekday.index(found_dict['a'].lower())\n  elif group_key == 'w':\n   weekday = int(found_dict['w'])\n   if weekday == 0:\n    weekday = 6\n   else:\n    weekday -= 1\n  elif group_key == 'j':\n   julian = int(found_dict['j'])\n  elif group_key in ('U', 'W'):\n   week_of_year = int(found_dict[group_key])\n   if group_key == 'U':\n   \n    week_of_year_start = 6\n   else:\n   \n    week_of_year_start = 0\n  elif group_key == 'z':\n   z = found_dict['z']\n   tzoffset = int(z[1:3]) * 60 + int(z[3:5])\n   if z.startswith(\"-\"):\n    tzoffset = -tzoffset\n  elif group_key == 'Z':\n  \n  \n   found_zone = found_dict['Z'].lower()\n   for value, tz_values in enumerate(locale_time.timezone):\n    if found_zone in tz_values:\n    \n    \n    \n     if (time.tzname[0] == time.tzname[1] and\n     time.daylight and found_zone not in (\"utc\", \"gmt\")):\n      break\n     else:\n      tz = value\n      break\n leap_year_fix = False\n if year is None and month == 2 and day == 29:\n  year = 1904 \n  leap_year_fix = True\n elif year is None:\n  year = 1900\n  \n  \n if julian == -1 and week_of_year != -1 and weekday != -1:\n  week_starts_Mon = True if week_of_year_start == 0 else False\n  julian = _calc_julian_from_U_or_W(year, week_of_year, weekday,\n  week_starts_Mon)\n  \n  \n  \n if julian == -1:\n \n  julian = datetime_date(year, month, day).toordinal() - datetime_date(year, 1, 1).toordinal() + 1\n else: \n \n  datetime_result = datetime_date.fromordinal((julian - 1) + datetime_date(year, 1, 1).toordinal())\n  year = datetime_result.year\n  month = datetime_result.month\n  day = datetime_result.day\n if weekday == -1:\n  weekday = datetime_date(year, month, day).weekday()\n  \n tzname = found_dict.get(\"Z\")\n if tzoffset is not None:\n  gmtoff = tzoffset * 60\n else:\n  gmtoff = None\n  \n if leap_year_fix:\n \n \n \n  year = 1900\n  \n return (year, month, day,\n hour, minute, second,\n weekday, julian, tz, tzname, gmtoff), fraction\n \ndef _strptime_time(data_string, format=\"%a %b %d %H:%M:%S %Y\"):\n \"\"\n tt = _strptime(data_string, format)[0]\n return time.struct_time(tt[:time._STRUCT_TM_ITEMS])\n \ndef _strptime_datetime(cls, data_string, format=\"%a %b %d %H:%M:%S %Y\"):\n \"\"\n tt, fraction = _strptime(data_string, format)\n tzname, gmtoff = tt[-2:]\n args = tt[:6] + (fraction,)\n if gmtoff is not None:\n  tzdelta = datetime_timedelta(seconds=gmtoff)\n  if tzname:\n   tz = datetime_timezone(tzdelta, tzname)\n  else:\n   tz = datetime_timezone(tzdelta)\n  args += (tz,)\n  \n return cls(*args)\n"], "_browser": [".js", "var $module=(function($B) {\n  return {\n    alert:function(message){window.alert($B.builtins.str(message))},\n    confirm: $B.JSObject(window.confirm),\n    console:$B.JSObject(window.console),\n    document:$B.$DOMNode(document),\n    doc: $B.$DOMNode(document),   //want to use document instead of doc\n    DOMEvent:$B.DOMEvent,\n    DOMNode:$B.DOMNode,\n    mouseCoords: function(ev){return $B.JSObject($mouseCoords(ev))},\n    prompt: function(message, default_value){\n        return $B.JSObject(window.prompt(message, default_value||''))\n    },\n    win: $B.win,\n    window: $B.win,\n    URLParameter:function(name) {\n       name = name.replace(/[\\[]/, \"\\\\[\").replace(/[\\]]/, \"\\\\]\");\n       var regex = new RegExp(\"[\\\\?&]\" + name + \"=([^&#]*)\"),\n           results = regex.exec(location.search);\n       results= results === null ? \"\" : decodeURIComponent(results[1].replace(/\\+/g, \" \"));\n       return $B.builtins.str(results);\n    }\n  }\n})(__BRYTHON__)\n"], "time": [".py", "from browser import window\nimport javascript\n\n\ndate = javascript.JSConstructor(window.Date)\n\n\n\n\n\n\n\n_STRUCT_TM_ITEMS = 9\n\n\n\n\n\ndef _get_day_of_year(arg):\n \"\"\n ml = [31,28,31,30,31,30,31,31,30,31,30,31]\n if arg[0]%4==0:\n  ml[1] += 1\n i=1\n yday=0\n while i<arg[1]:\n  yday += ml[i-1]\n  i += 1\n yday += arg[2]\n return yday\n \ndef _get_week_of_year(arg):\n \"\"\n d1 = date(arg[0], arg[1]-1, arg[2])\n d0 = date(arg[0], 0, 1)\n firstday = d0.getDay()\n if firstday == 0 : firstday = 7\n firstweek = 8 - firstday\n doy = arg[7]\n if firstday != 1:\n  doy = doy - firstweek\n if doy % 7 == 0:\n  week_number = doy // 7\n else:\n  week_number = doy // 7 + 1\n return week_number\n \ndef _check_struct_time(t):\n mm = t[1]\n if mm == 0: mm = 1\n if -1 > mm > 13: raise ValueError(\"month out of range\")\n \n dd = t[2]\n if dd == 0: dd = 1\n if -1 > dd > 32: raise ValueError(\"day of month out of range\")\n \n hh = t[3]\n if -1 > hh > 24: raise ValueError(\"hour out of range\")\n \n minu = t[4]\n if -1 > minu > 60: raise ValueError(\"minute out of range\")\n \n ss = t[5]\n if -1 > ss > 62: raise ValueError(\"seconds out of range\")\n \n wd = t[6] % 7\n if wd < -2: raise ValueError(\"day of week out of range\")\n \n dy = t[7]\n if dy == 0: dy = 1\n if -1 > dy > 367: raise ValueError(\"day of year out of range\")\n \n return t[0], mm, dd, hh, minu, ss, wd, dy, t[-1]\n \n \ndef _is_dst(secs = None):\n \"\"\n d = date()\n if secs is not None:\n  d = date(secs*1000)\n  \n  \n jan = date(d.getFullYear(), 0, 1)\n jul = date(d.getFullYear(), 6, 1)\n dst = int(d.getTimezoneOffset() < max(abs(jan.getTimezoneOffset()), abs(jul.getTimezoneOffset())))\n return dst\n \ndef _get_tzname():\n \"\"\n d = date()\n d = d.toTimeString()\n try:\n  d = d.split('(')[1].split(')')[0]\n  return (d, 'NotAvailable')\n except:\n  return ('', '')\n  \ndef _set_altzone():\n d = date()\n jan = date(d.getFullYear(), 0, 1)\n jul = date(d.getFullYear(), 6, 1)\n result = timezone - (jan.getTimezoneOffset() - jul.getTimezoneOffset()) * 60\n return result\n \ndef _check_input(t):\n if t and isinstance(t, struct_time) and len(t.args) == 9:\n  t = t.args\n elif t and isinstance(t, tuple) and len(t) == 9:\n  t = t\n elif t and isinstance(t, struct_time) and len(t.args) != 9:\n  raise TypeError(\"function takes exactly 9 arguments ({} given)\".format(len(t.args)))\n elif t and isinstance(t, tuple) and len(t) != 9:\n  raise TypeError(\"function takes exactly 9 arguments ({} given)\".format(len(t.args)))\n elif t and not isinstance(t, (tuple, struct_time)):\n  raise TypeError(\"Tuple or struct_time argument required\")\n else:\n  t = localtime().args\n return t\n \n \n \n \n \ndaylight = _is_dst()\ntimezone = date().getTimezoneOffset() * 60\ntzname = _get_tzname()\naltzone = _set_altzone() if daylight else timezone\n\n\ndef asctime(t = None):\n weekdays = {0: \"Mon\", 1: \"Tue\", 2: \"Wed\", 3: \"Thu\", \n 4: \"Fri\", 5: \"Sat\", 6: \"Sun\"}\n months = {1:'Jan',2:'Feb',3:'Mar',4:'Apr',5:'May',6:'Jun',\n 7:'Jul',8:'Aug',9:'Sep',10:'Oct',11:'Nov',12:'Dec'}\n \n t = _check_input(t)\n t = _check_struct_time(t)\n \n result = \"%s %s %2d %02d:%02d:%02d %d\" % (\n weekdays[t[6]], months[t[1]], t[2], t[3], t[4], t[5], t[0])\n return result\n \ndef ctime(timestamp=None):\n if timestamp is None:\n  timestamp = date().getTime() / 1000.\n d = date(0)\n d.setUTCSeconds(timestamp)\n jan = date(d.getFullYear(), 0, 1)\n jul = date(d.getFullYear(), 6, 1)\n dst = int(d.getTimezoneOffset() < max(jan.getTimezoneOffset(), jul.getTimezoneOffset()))\n d = date(0)\n d.setUTCSeconds(timestamp + (1 + dst) * 3600)\n weekdays = {1: \"Mon\", 2: \"Tue\", 3: \"Wed\", 4: \"Thu\", \n 5: \"Fri\", 6: \"Sat\", 0: \"Sun\"}\n months = {0:'Jan',1:'Feb',2:'Mar',3:'Apr',4:'May',5:'Jun',\n 6:'Jul',7:'Aug',8:'Sep',9:'Oct',10:'Nov',11:'Dec'}\n result = \"%s %s %2d %02d:%02d:%02d %d\" % (weekdays[d.getUTCDay()],\n months[d.getUTCMonth()], d.getUTCDate(),\n d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), \n d.getUTCFullYear())\n return result\n \ndef gmtime(secs = None):\n d = date()\n if secs is not None:\n  d = date(secs*1000)\n wday = d.getUTCDay() - 1 if d.getUTCDay() - 1 >= 0 else 6\n tmp = struct_time([d.getUTCFullYear(), \n d.getUTCMonth()+1, d.getUTCDate(),\n d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(),\n wday, 0, 0])\n tmp.args[7] = _get_day_of_year(tmp.args)\n return tmp\n \ndef localtime(secs = None):\n d = date()\n if secs is not None:\n  d = date(secs * 1000)\n dst = _is_dst(secs)\n wday = d.getDay() - 1 if d.getDay() - 1 >= 0 else 6\n tmp = struct_time([d.getFullYear(), \n d.getMonth()+1, d.getDate(),\n d.getHours(), d.getMinutes(), d.getSeconds(),\n wday, 0, dst])\n tmp.args[7] = _get_day_of_year(tmp.args)\n return tmp\n \ndef mktime(t):\n if isinstance(t, struct_time):\n  d1 = date(t.tm_year, t.tm_mon - 1, t.tm_mday, \n  t.tm_hour, t.tm_min, t.tm_sec, 0).getTime()\n elif isinstance(t, tuple):\n  d1 = date(t[0], t[1] - 1, t[2], t[3], t[4], t[5], 0).getTime()\n else:\n  raise ValueError(\"Tuple or struct_time argument required\")\n d2 = date(0).getTime()\n return (d1 - d2) / 1000.\n \ndef monotonic():\n return javascript.JSObject(window.performance.now)()/1000.\n \ndef perf_counter():\n return float(date().getTime()/1000.0)\n \ndef time():\n return float(date().getTime()/1000)\n \ndef sleep(secs):\n start = date().getTime()\n while date().getTime() - start < secs * 1000.:\n  pass\n  \ndef strftime(_format,t = None):\n\n def ns(t,nb):\n \n  res = str(t)\n  while len(res)<nb:\n   res = '0'+res\n  return res\n  \n t = _check_input(t) \n t = _check_struct_time(t)\n \n YY = ns(t[0],4)\n yy = ns(t[0],4)[2:]\n mm = ns(t[1],2)\n dd = ns(t[2],2)\n HH = t[3]\n HH24 = ns(HH,2)\n HH12 = ns(HH % 12,2)\n if HH12 == 0:HH12 = 12\n AMPM = 'AM' if 0 <= HH < 12 else 'PM'\n MM = ns(t[4],2)\n SS = ns(t[5],2)\n DoY = ns(t[7],3)\n w = t[6] + 1 if t[6] < 6 else 0\n W = ns(_get_week_of_year(t),2)\n \n abb_weekdays = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']\n full_weekdays = ['Sunday','Monday','Tuesday','Wednesday',\n 'Thursday','Friday','Saturday']\n abb_months = ['Jan','Feb','Mar','Apr','May','Jun',\n 'Jul','Aug','Sep','Oct','Nov','Dec']\n full_months = ['January','February','March','April','May','June',\n 'July','August','September','October','November','December']\n \n res = _format\n res = res.replace(\"%H\",HH24)\n res = res.replace(\"%I\",HH12)\n res = res.replace(\"%p\",AMPM)\n res = res.replace(\"%M\",MM)\n res = res.replace(\"%S\",SS)\n res = res.replace(\"%Y\",YY)\n res = res.replace(\"%y\",yy)\n res = res.replace(\"%m\",mm)\n res = res.replace(\"%d\",dd)\n res = res.replace(\"%a\",abb_weekdays[w])\n res = res.replace(\"%A\",full_weekdays[w])\n res = res.replace(\"%b\",abb_months[int(mm)-1])\n res = res.replace(\"%B\",full_months[int(mm)-1])\n res = res.replace(\"%j\", DoY)\n res = res.replace(\"%w\", w)\n res = res.replace(\"%W\", W)\n res = res.replace(\"%x\", mm+'/'+dd+'/'+yy)\n res = res.replace(\"%X\", HH24+':'+MM+':'+SS)\n res = res.replace(\"%c\", abb_weekdays[w]+' '+abb_months[int(mm)-1]+\n ' '+dd+' '+HH24+':'+MM+':'+SS+' '+YY)\n res = res.replace(\"%%\", '%')\n \n return res\n \nclass struct_time:\n\n def __init__(self, args):\n \n  if len(args)!=9:\n   raise TypeError(\"time.struct_time() takes a 9-sequence (%s-sequence given)\" %len(args))\n   \n  self.args = args\n  \n @property\n def tm_year(self):\n  return self.args[0]\n  \n @property\n def tm_mon(self):\n  return self.args[1]\n  \n @property\n def tm_mday(self):\n  return self.args[2]\n  \n @property\n def tm_hour(self):\n  return self.args[3]\n  \n @property\n def tm_min(self):\n  return self.args[4]\n  \n @property\n def tm_sec(self):\n  return self.args[5]\n  \n @property\n def tm_wday(self):\n  return self.args[6]\n  \n @property\n def tm_yday(self):\n  return self.args[7]\n  \n @property\n def tm_isdst(self):\n  return self.args[8]\n  \n def __getitem__(self, i):\n  return self.args[i]\n  \n def __iter__(self):\n  return iter(self.args)\n  \n def __repr__(self):\n  return (\"time.structime(tm_year={}, tm_mon={}, tm_day={}, \"+ \"tm_hour={}, tm_min={}, tm_sec={}, tm_wday={}, \"+ \"tm_yday={}, tm_isdst={})\").format(*self.args)\n  \n def __str__(self):\n  return self.__repr__()\n  \ndef to_struct_time(ptuple):\n\n arg = ptuple.arg\n \n \n ml = [31,28,31,30,31,30,31,31,30,31,30,31]\n if arg[0]%4==0:\n  ml[1] += 1\n  \n i=1\n yday=0\n while i<arg[1]:\n  yday += ml[i-1]\n  i += 1\n yday += arg[2]\n arg.append(yday)\n arg.append(-1)\n return struct_time(arg)\n \ndef strptime(string, _format):\n import _strptime\n return struct_time([_strptime._strptime_datetime(to_struct_time, string, _format)])\n \n \n \n_clock_msg = \"\"\"Browser cannot access CPU. See '%s'\"\"\"\ndef _clock_xx(url):\n raise NotImplementedError(_clock_msg % url)\nclock = lambda: _clock_xx(\"https://docs.python.org/3/library/time.html#time.clock\")\nclock_getres = lambda: _clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_getres\")\nclock_gettime = lambda: _clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_gettime\")\nclock_settime = lambda: _clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_settime\")\nCLOCK_HIGHRES = _clock_msg % \"https://docs.python.org/3/library/time.html#time.CLOCK_HIGHRES\"\nCLOCK_MONOTONIC = _clock_msg % \"https://docs.python.org/3/library/time.html#time.CLOCK_MONOTONIC\"\nCLOCK_MONOTONIC_RAW = _clock_msg % \"https://docs.python.org/3/library/time.html#time.CLOCK_MONOTONIC_RAW\"\nCLOCK_PROCESS_CPUTIME_ID = _clock_msg % \"https://docs.python.org/3/library/time.html#time.CLOCK_PROCESS_CPUTIME_ID\"\nCLOCK_REALTIME = _clock_msg % \"https://docs.python.org/3/library/time.html#time.CLOCK_REALTIME\"\nCLOCK_THREAD_CPUTIME_ID = _clock_msg % \"https://docs.python.org/3/library/time.html#time.CLOCK_THREAD_CPUTIME_ID\"\nget_clock_info = lambda: _clock_xx(\"https://docs.python.org/3/library/time.html#time.get_clock_info\")\nprocess_time = lambda: _clock_xx(\"https://docs.python.org/3/library/time.html#time.process_time\")\n\ndef tzset():\n raise NotImplementedError()\n"], "optparse": [".py", "\"\"\n\n__version__ = \"1.5.3\"\n\n__all__ = ['Option',\n'make_option',\n'SUPPRESS_HELP',\n'SUPPRESS_USAGE',\n'Values',\n'OptionContainer',\n'OptionGroup',\n'OptionParser',\n'HelpFormatter',\n'IndentedHelpFormatter',\n'TitledHelpFormatter',\n'OptParseError',\n'OptionError',\n'OptionConflictError',\n'OptionValueError',\n'BadOptionError']\n\n__copyright__ = \"\"\"\nCopyright (c) 2001-2006 Gregory P. Ward.  All rights reserved.\nCopyright (c) 2002-2006 Python Software Foundation.  All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n  * Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\n  * Neither the name of the author nor the names of its\n    contributors may be used to endorse or promote products derived from\n    this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\nIS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\nTO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\nEXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\"\"\"\n\nimport sys, os\nimport textwrap\n\ndef _repr(self):\n return \"<%s at 0x%x: %s>\" % (self.__class__.__name__, id(self), self)\n \n \n \n \n \n \n \n \ntry:\n from gettext import gettext, ngettext\nexcept ImportError:\n def gettext(message):\n  return message\n  \n def ngettext(singular, plural, n):\n  if n == 1:\n   return singular\n  return plural\n  \n_ = gettext\n\n\nclass OptParseError (Exception):\n def __init__(self, msg):\n  self.msg = msg\n  \n def __str__(self):\n  return self.msg\n  \n  \nclass OptionError (OptParseError):\n \"\"\n \n def __init__(self, msg, option):\n  self.msg = msg\n  self.option_id = str(option)\n  \n def __str__(self):\n  if self.option_id:\n   return \"option %s: %s\" % (self.option_id, self.msg)\n  else:\n   return self.msg\n   \nclass OptionConflictError (OptionError):\n \"\"\n \nclass OptionValueError (OptParseError):\n \"\"\n \nclass BadOptionError (OptParseError):\n \"\"\n def __init__(self, opt_str):\n  self.opt_str = opt_str\n  \n def __str__(self):\n  return _(\"no such option: %s\") % self.opt_str\n  \nclass AmbiguousOptionError (BadOptionError):\n \"\"\n def __init__(self, opt_str, possibilities):\n  BadOptionError.__init__(self, opt_str)\n  self.possibilities = possibilities\n  \n def __str__(self):\n  return (_(\"ambiguous option: %s (%s?)\")\n  % (self.opt_str, \", \".join(self.possibilities)))\n  \n  \nclass HelpFormatter:\n\n \"\"\n \n NO_DEFAULT_VALUE = \"none\"\n \n def __init__(self,\n indent_increment,\n max_help_position,\n width,\n short_first):\n  self.parser = None\n  self.indent_increment = indent_increment\n  self.help_position = self.max_help_position = max_help_position\n  if width is None:\n   try:\n    width = int(os.environ['COLUMNS'])\n   except (KeyError, ValueError):\n    width = 80\n   width -= 2\n  self.width = width\n  self.current_indent = 0\n  self.level = 0\n  self.help_width = None \n  self.short_first = short_first\n  self.default_tag = \"%default\"\n  self.option_strings = {}\n  self._short_opt_fmt = \"%s %s\"\n  self._long_opt_fmt = \"%s=%s\"\n  \n def set_parser(self, parser):\n  self.parser = parser\n  \n def set_short_opt_delimiter(self, delim):\n  if delim not in (\"\", \" \"):\n   raise ValueError(\n   \"invalid metavar delimiter for short options: %r\" % delim)\n  self._short_opt_fmt = \"%s\" + delim + \"%s\"\n  \n def set_long_opt_delimiter(self, delim):\n  if delim not in (\"=\", \" \"):\n   raise ValueError(\n   \"invalid metavar delimiter for long options: %r\" % delim)\n  self._long_opt_fmt = \"%s\" + delim + \"%s\"\n  \n def indent(self):\n  self.current_indent += self.indent_increment\n  self.level += 1\n  \n def dedent(self):\n  self.current_indent -= self.indent_increment\n  assert self.current_indent >= 0, \"Indent decreased below 0.\"\n  self.level -= 1\n  \n def format_usage(self, usage):\n  raise NotImplementedError(\"subclasses must implement\")\n  \n def format_heading(self, heading):\n  raise NotImplementedError(\"subclasses must implement\")\n  \n def _format_text(self, text):\n  \"\"\n  text_width = self.width - self.current_indent\n  indent = \" \"*self.current_indent\n  return textwrap.fill(text,\n  text_width,\n  initial_indent=indent,\n  subsequent_indent=indent)\n  \n def format_description(self, description):\n  if description:\n   return self._format_text(description) + \"\\n\"\n  else:\n   return \"\"\n   \n def format_epilog(self, epilog):\n  if epilog:\n   return \"\\n\" + self._format_text(epilog) + \"\\n\"\n  else:\n   return \"\"\n   \n   \n def expand_default(self, option):\n  if self.parser is None or not self.default_tag:\n   return option.help\n   \n  default_value = self.parser.defaults.get(option.dest)\n  if default_value is NO_DEFAULT or default_value is None:\n   default_value = self.NO_DEFAULT_VALUE\n   \n  return option.help.replace(self.default_tag, str(default_value))\n  \n def format_option(self, option):\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  result = []\n  opts = self.option_strings[option]\n  opt_width = self.help_position - self.current_indent - 2\n  if len(opts) > opt_width:\n   opts = \"%*s%s\\n\" % (self.current_indent, \"\", opts)\n   indent_first = self.help_position\n  else: \n   opts = \"%*s%-*s  \" % (self.current_indent, \"\", opt_width, opts)\n   indent_first = 0\n  result.append(opts)\n  if option.help:\n   help_text = self.expand_default(option)\n   help_lines = textwrap.wrap(help_text, self.help_width)\n   result.append(\"%*s%s\\n\" % (indent_first, \"\", help_lines[0]))\n   result.extend([\"%*s%s\\n\" % (self.help_position, \"\", line)\n   for line in help_lines[1:]])\n  elif opts[-1] != \"\\n\":\n   result.append(\"\\n\")\n  return \"\".join(result)\n  \n def store_option_strings(self, parser):\n  self.indent()\n  max_len = 0\n  for opt in parser.option_list:\n   strings = self.format_option_strings(opt)\n   self.option_strings[opt] = strings\n   max_len = max(max_len, len(strings) + self.current_indent)\n  self.indent()\n  for group in parser.option_groups:\n   for opt in group.option_list:\n    strings = self.format_option_strings(opt)\n    self.option_strings[opt] = strings\n    max_len = max(max_len, len(strings) + self.current_indent)\n  self.dedent()\n  self.dedent()\n  self.help_position = min(max_len + 2, self.max_help_position)\n  self.help_width = self.width - self.help_position\n  \n def format_option_strings(self, option):\n  \"\"\n  if option.takes_value():\n   metavar = option.metavar or option.dest.upper()\n   short_opts = [self._short_opt_fmt % (sopt, metavar)\n   for sopt in option._short_opts]\n   long_opts = [self._long_opt_fmt % (lopt, metavar)\n   for lopt in option._long_opts]\n  else:\n   short_opts = option._short_opts\n   long_opts = option._long_opts\n   \n  if self.short_first:\n   opts = short_opts + long_opts\n  else:\n   opts = long_opts + short_opts\n   \n  return \", \".join(opts)\n  \nclass IndentedHelpFormatter (HelpFormatter):\n \"\"\n \n def __init__(self,\n indent_increment=2,\n max_help_position=24,\n width=None,\n short_first=1):\n  HelpFormatter.__init__(\n  self, indent_increment, max_help_position, width, short_first)\n  \n def format_usage(self, usage):\n  return _(\"Usage: %s\\n\") % usage\n  \n def format_heading(self, heading):\n  return \"%*s%s:\\n\" % (self.current_indent, \"\", heading)\n  \n  \nclass TitledHelpFormatter (HelpFormatter):\n \"\"\n \n def __init__(self,\n indent_increment=0,\n max_help_position=24,\n width=None,\n short_first=0):\n  HelpFormatter.__init__ (\n  self, indent_increment, max_help_position, width, short_first)\n  \n def format_usage(self, usage):\n  return \"%s  %s\\n\" % (self.format_heading(_(\"Usage\")), usage)\n  \n def format_heading(self, heading):\n  return \"%s\\n%s\\n\" % (heading, \"=-\"[self.level] * len(heading))\n  \n  \ndef _parse_num(val, type):\n if val[:2].lower() == \"0x\": \n  radix = 16\n elif val[:2].lower() == \"0b\": \n  radix = 2\n  val = val[2:] or \"0\" \n elif val[:1] == \"0\": \n  radix = 8\n else: \n  radix = 10\n  \n return type(val, radix)\n \ndef _parse_int(val):\n return _parse_num(val, int)\n \n_builtin_cvt = { \"int\" : (_parse_int, _(\"integer\")),\n\"long\" : (_parse_int, _(\"integer\")),\n\"float\" : (float, _(\"floating-point\")),\n\"complex\" : (complex, _(\"complex\")) }\n\ndef check_builtin(option, opt, value):\n (cvt, what) = _builtin_cvt[option.type]\n try:\n  return cvt(value)\n except ValueError:\n  raise OptionValueError(\n  _(\"option %s: invalid %s value: %r\") % (opt, what, value))\n  \ndef check_choice(option, opt, value):\n if value in option.choices:\n  return value\n else:\n  choices = \", \".join(map(repr, option.choices))\n  raise OptionValueError(\n  _(\"option %s: invalid choice: %r (choose from %s)\")\n  % (opt, value, choices))\n  \n  \n  \nNO_DEFAULT = (\"NO\", \"DEFAULT\")\n\n\nclass Option:\n \"\"\n \n \n \n ATTRS = ['action',\n 'type',\n 'dest',\n 'default',\n 'nargs',\n 'const',\n 'choices',\n 'callback',\n 'callback_args',\n 'callback_kwargs',\n 'help',\n 'metavar']\n \n \n \n ACTIONS = (\"store\",\n \"store_const\",\n \"store_true\",\n \"store_false\",\n \"append\",\n \"append_const\",\n \"count\",\n \"callback\",\n \"help\",\n \"version\")\n \n \n \n \n STORE_ACTIONS = (\"store\",\n \"store_const\",\n \"store_true\",\n \"store_false\",\n \"append\",\n \"append_const\",\n \"count\")\n \n \n \n TYPED_ACTIONS = (\"store\",\n \"append\",\n \"callback\")\n \n \n \n ALWAYS_TYPED_ACTIONS = (\"store\",\n \"append\")\n \n \n CONST_ACTIONS = (\"store_const\",\n \"append_const\")\n \n \n \n TYPES = (\"string\", \"int\", \"long\", \"float\", \"complex\", \"choice\")\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n TYPE_CHECKER = { \"int\" : check_builtin,\n \"long\" : check_builtin,\n \"float\" : check_builtin,\n \"complex\": check_builtin,\n \"choice\" : check_choice,\n }\n \n \n \n \n \n \n \n \n \n \n CHECK_METHODS = None\n \n \n \n \n def __init__(self, *opts, **attrs):\n \n \n  self._short_opts = []\n  self._long_opts = []\n  opts = self._check_opt_strings(opts)\n  self._set_opt_strings(opts)\n  \n  \n  self._set_attrs(attrs)\n  \n  \n  \n  \n  \n  \n  for checker in self.CHECK_METHODS:\n   checker(self)\n   \n def _check_opt_strings(self, opts):\n \n \n \n  opts = [opt for opt in opts if opt]\n  if not opts:\n   raise TypeError(\"at least one option string must be supplied\")\n  return opts\n  \n def _set_opt_strings(self, opts):\n  for opt in opts:\n   if len(opt) < 2:\n    raise OptionError(\n    \"invalid option string %r: \"\n    \"must be at least two characters long\" % opt, self)\n   elif len(opt) == 2:\n    if not (opt[0] == \"-\" and opt[1] != \"-\"):\n     raise OptionError(\n     \"invalid short option string %r: \"\n     \"must be of the form -x, (x any non-dash char)\" % opt,\n     self)\n    self._short_opts.append(opt)\n   else:\n    if not (opt[0:2] == \"--\" and opt[2] != \"-\"):\n     raise OptionError(\n     \"invalid long option string %r: \"\n     \"must start with --, followed by non-dash\" % opt,\n     self)\n    self._long_opts.append(opt)\n    \n def _set_attrs(self, attrs):\n  for attr in self.ATTRS:\n   if attr in attrs:\n    setattr(self, attr, attrs[attr])\n    del attrs[attr]\n   else:\n    if attr == 'default':\n     setattr(self, attr, NO_DEFAULT)\n    else:\n     setattr(self, attr, None)\n  if attrs:\n   attrs = sorted(attrs.keys())\n   raise OptionError(\n   \"invalid keyword arguments: %s\" % \", \".join(attrs),\n   self)\n   \n   \n   \n   \n def _check_action(self):\n  if self.action is None:\n   self.action = \"store\"\n  elif self.action not in self.ACTIONS:\n   raise OptionError(\"invalid action: %r\" % self.action, self)\n   \n def _check_type(self):\n  if self.type is None:\n   if self.action in self.ALWAYS_TYPED_ACTIONS:\n    if self.choices is not None:\n    \n     self.type = \"choice\"\n    else:\n    \n     self.type = \"string\"\n  else:\n  \n  \n  \n  \n  \n   import builtins\n   if ( isinstance(self.type, type) or\n   (hasattr(self.type, \"__name__\") and\n   getattr(builtins, self.type.__name__, None) is self.type) ):\n    self.type = self.type.__name__\n    \n   if self.type == \"str\":\n    self.type = \"string\"\n    \n   if self.type not in self.TYPES:\n    raise OptionError(\"invalid option type: %r\" % self.type, self)\n   if self.action not in self.TYPED_ACTIONS:\n    raise OptionError(\n    \"must not supply a type for action %r\" % self.action, self)\n    \n def _check_choice(self):\n  if self.type == \"choice\":\n   if self.choices is None:\n    raise OptionError(\n    \"must supply a list of choices for type 'choice'\", self)\n   elif not isinstance(self.choices, (tuple, list)):\n    raise OptionError(\n    \"choices must be a list of strings ('%s' supplied)\"\n    % str(type(self.choices)).split(\"'\")[1], self)\n  elif self.choices is not None:\n   raise OptionError(\n   \"must not supply choices for type %r\" % self.type, self)\n   \n def _check_dest(self):\n \n \n  takes_value = (self.action in self.STORE_ACTIONS or\n  self.type is not None)\n  if self.dest is None and takes_value:\n  \n  \n  \n   if self._long_opts:\n   \n    self.dest = self._long_opts[0][2:].replace('-', '_')\n   else:\n    self.dest = self._short_opts[0][1]\n    \n def _check_const(self):\n  if self.action not in self.CONST_ACTIONS and self.const is not None:\n   raise OptionError(\n   \"'const' must not be supplied for action %r\" % self.action,\n   self)\n   \n def _check_nargs(self):\n  if self.action in self.TYPED_ACTIONS:\n   if self.nargs is None:\n    self.nargs = 1\n  elif self.nargs is not None:\n   raise OptionError(\n   \"'nargs' must not be supplied for action %r\" % self.action,\n   self)\n   \n def _check_callback(self):\n  if self.action == \"callback\":\n   if not callable(self.callback):\n    raise OptionError(\n    \"callback not callable: %r\" % self.callback, self)\n   if (self.callback_args is not None and\n   not isinstance(self.callback_args, tuple)):\n    raise OptionError(\n    \"callback_args, if supplied, must be a tuple: not %r\"\n    % self.callback_args, self)\n   if (self.callback_kwargs is not None and\n   not isinstance(self.callback_kwargs, dict)):\n    raise OptionError(\n    \"callback_kwargs, if supplied, must be a dict: not %r\"\n    % self.callback_kwargs, self)\n  else:\n   if self.callback is not None:\n    raise OptionError(\n    \"callback supplied (%r) for non-callback option\"\n    % self.callback, self)\n   if self.callback_args is not None:\n    raise OptionError(\n    \"callback_args supplied for non-callback option\", self)\n   if self.callback_kwargs is not None:\n    raise OptionError(\n    \"callback_kwargs supplied for non-callback option\", self)\n    \n    \n CHECK_METHODS = [_check_action,\n _check_type,\n _check_choice,\n _check_dest,\n _check_const,\n _check_nargs,\n _check_callback]\n \n \n \n \n def __str__(self):\n  return \"/\".join(self._short_opts + self._long_opts)\n  \n __repr__ = _repr\n \n def takes_value(self):\n  return self.type is not None\n  \n def get_opt_string(self):\n  if self._long_opts:\n   return self._long_opts[0]\n  else:\n   return self._short_opts[0]\n   \n   \n   \n   \n def check_value(self, opt, value):\n  checker = self.TYPE_CHECKER.get(self.type)\n  if checker is None:\n   return value\n  else:\n   return checker(self, opt, value)\n   \n def convert_value(self, opt, value):\n  if value is not None:\n   if self.nargs == 1:\n    return self.check_value(opt, value)\n   else:\n    return tuple([self.check_value(opt, v) for v in value])\n    \n def process(self, opt, value, values, parser):\n \n \n \n  value = self.convert_value(opt, value)\n  \n  \n  \n  \n  return self.take_action(\n  self.action, self.dest, opt, value, values, parser)\n  \n def take_action(self, action, dest, opt, value, values, parser):\n  if action == \"store\":\n   setattr(values, dest, value)\n  elif action == \"store_const\":\n   setattr(values, dest, self.const)\n  elif action == \"store_true\":\n   setattr(values, dest, True)\n  elif action == \"store_false\":\n   setattr(values, dest, False)\n  elif action == \"append\":\n   values.ensure_value(dest, []).append(value)\n  elif action == \"append_const\":\n   values.ensure_value(dest, []).append(self.const)\n  elif action == \"count\":\n   setattr(values, dest, values.ensure_value(dest, 0) + 1)\n  elif action == \"callback\":\n   args = self.callback_args or ()\n   kwargs = self.callback_kwargs or {}\n   self.callback(self, opt, value, parser, *args, **kwargs)\n  elif action == \"help\":\n   parser.print_help()\n   parser.exit()\n  elif action == \"version\":\n   parser.print_version()\n   parser.exit()\n  else:\n   raise ValueError(\"unknown action %r\" % self.action)\n   \n  return 1\n  \n  \n  \n  \nSUPPRESS_HELP = \"SUPPRESS\"+\"HELP\"\nSUPPRESS_USAGE = \"SUPPRESS\"+\"USAGE\"\n\nclass Values:\n\n def __init__(self, defaults=None):\n  if defaults:\n   for (attr, val) in defaults.items():\n    setattr(self, attr, val)\n    \n def __str__(self):\n  return str(self.__dict__)\n  \n __repr__ = _repr\n \n def __eq__(self, other):\n  if isinstance(other, Values):\n   return self.__dict__ == other.__dict__\n  elif isinstance(other, dict):\n   return self.__dict__ == other\n  else:\n   return NotImplemented\n   \n def _update_careful(self, dict):\n  \"\"\n  for attr in dir(self):\n   if attr in dict:\n    dval = dict[attr]\n    if dval is not None:\n     setattr(self, attr, dval)\n     \n def _update_loose(self, dict):\n  \"\"\n  self.__dict__.update(dict)\n  \n def _update(self, dict, mode):\n  if mode == \"careful\":\n   self._update_careful(dict)\n  elif mode == \"loose\":\n   self._update_loose(dict)\n  else:\n   raise ValueError(\"invalid update mode: %r\" % mode)\n   \n def read_module(self, modname, mode=\"careful\"):\n  __import__(modname)\n  mod = sys.modules[modname]\n  self._update(vars(mod), mode)\n  \n def read_file(self, filename, mode=\"careful\"):\n  vars = {}\n  exec(open(filename).read(), vars)\n  self._update(vars, mode)\n  \n def ensure_value(self, attr, value):\n  if not hasattr(self, attr) or getattr(self, attr) is None:\n   setattr(self, attr, value)\n  return getattr(self, attr)\n  \n  \nclass OptionContainer:\n\n \"\"\n \n def __init__(self, option_class, conflict_handler, description):\n \n \n \n \n  self._create_option_list()\n  \n  self.option_class = option_class\n  self.set_conflict_handler(conflict_handler)\n  self.set_description(description)\n  \n def _create_option_mappings(self):\n \n \n \n  self._short_opt = {} \n  self._long_opt = {} \n  self.defaults = {} \n  \n  \n def _share_option_mappings(self, parser):\n \n \n  self._short_opt = parser._short_opt\n  self._long_opt = parser._long_opt\n  self.defaults = parser.defaults\n  \n def set_conflict_handler(self, handler):\n  if handler not in (\"error\", \"resolve\"):\n   raise ValueError(\"invalid conflict_resolution value %r\" % handler)\n  self.conflict_handler = handler\n  \n def set_description(self, description):\n  self.description = description\n  \n def get_description(self):\n  return self.description\n  \n  \n def destroy(self):\n  \"\"\n  del self._short_opt\n  del self._long_opt\n  del self.defaults\n  \n  \n  \n  \n def _check_conflict(self, option):\n  conflict_opts = []\n  for opt in option._short_opts:\n   if opt in self._short_opt:\n    conflict_opts.append((opt, self._short_opt[opt]))\n  for opt in option._long_opts:\n   if opt in self._long_opt:\n    conflict_opts.append((opt, self._long_opt[opt]))\n    \n  if conflict_opts:\n   handler = self.conflict_handler\n   if handler == \"error\":\n    raise OptionConflictError(\n    \"conflicting option string(s): %s\"\n    % \", \".join([co[0] for co in conflict_opts]),\n    option)\n   elif handler == \"resolve\":\n    for (opt, c_option) in conflict_opts:\n     if opt.startswith(\"--\"):\n      c_option._long_opts.remove(opt)\n      del self._long_opt[opt]\n     else:\n      c_option._short_opts.remove(opt)\n      del self._short_opt[opt]\n     if not (c_option._short_opts or c_option._long_opts):\n      c_option.container.option_list.remove(c_option)\n      \n def add_option(self, *args, **kwargs):\n  \"\"\n  if isinstance(args[0], str):\n   option = self.option_class(*args, **kwargs)\n  elif len(args) == 1 and not kwargs:\n   option = args[0]\n   if not isinstance(option, Option):\n    raise TypeError(\"not an Option instance: %r\" % option)\n  else:\n   raise TypeError(\"invalid arguments\")\n   \n  self._check_conflict(option)\n  \n  self.option_list.append(option)\n  option.container = self\n  for opt in option._short_opts:\n   self._short_opt[opt] = option\n  for opt in option._long_opts:\n   self._long_opt[opt] = option\n   \n  if option.dest is not None: \n   if option.default is not NO_DEFAULT:\n    self.defaults[option.dest] = option.default\n   elif option.dest not in self.defaults:\n    self.defaults[option.dest] = None\n    \n  return option\n  \n def add_options(self, option_list):\n  for option in option_list:\n   self.add_option(option)\n   \n   \n   \n def get_option(self, opt_str):\n  return (self._short_opt.get(opt_str) or\n  self._long_opt.get(opt_str))\n  \n def has_option(self, opt_str):\n  return (opt_str in self._short_opt or\n  opt_str in self._long_opt)\n  \n def remove_option(self, opt_str):\n  option = self._short_opt.get(opt_str)\n  if option is None:\n   option = self._long_opt.get(opt_str)\n  if option is None:\n   raise ValueError(\"no such option %r\" % opt_str)\n   \n  for opt in option._short_opts:\n   del self._short_opt[opt]\n  for opt in option._long_opts:\n   del self._long_opt[opt]\n  option.container.option_list.remove(option)\n  \n  \n  \n  \n def format_option_help(self, formatter):\n  if not self.option_list:\n   return \"\"\n  result = []\n  for option in self.option_list:\n   if not option.help is SUPPRESS_HELP:\n    result.append(formatter.format_option(option))\n  return \"\".join(result)\n  \n def format_description(self, formatter):\n  return formatter.format_description(self.get_description())\n  \n def format_help(self, formatter):\n  result = []\n  if self.description:\n   result.append(self.format_description(formatter))\n  if self.option_list:\n   result.append(self.format_option_help(formatter))\n  return \"\\n\".join(result)\n  \n  \nclass OptionGroup (OptionContainer):\n\n def __init__(self, parser, title, description=None):\n  self.parser = parser\n  OptionContainer.__init__(\n  self, parser.option_class, parser.conflict_handler, description)\n  self.title = title\n  \n def _create_option_list(self):\n  self.option_list = []\n  self._share_option_mappings(self.parser)\n  \n def set_title(self, title):\n  self.title = title\n  \n def destroy(self):\n  \"\"\n  OptionContainer.destroy(self)\n  del self.option_list\n  \n  \n  \n def format_help(self, formatter):\n  result = formatter.format_heading(self.title)\n  formatter.indent()\n  result += OptionContainer.format_help(self, formatter)\n  formatter.dedent()\n  return result\n  \n  \nclass OptionParser (OptionContainer):\n\n \"\"\n \n standard_option_list = []\n \n def __init__(self,\n usage=None,\n option_list=None,\n option_class=Option,\n version=None,\n conflict_handler=\"error\",\n description=None,\n formatter=None,\n add_help_option=True,\n prog=None,\n epilog=None):\n  OptionContainer.__init__(\n  self, option_class, conflict_handler, description)\n  self.set_usage(usage)\n  self.prog = prog\n  self.version = version\n  self.allow_interspersed_args = True\n  self.process_default_values = True\n  if formatter is None:\n   formatter = IndentedHelpFormatter()\n  self.formatter = formatter\n  self.formatter.set_parser(self)\n  self.epilog = epilog\n  \n  \n  \n  \n  \n  self._populate_option_list(option_list,\n  add_help=add_help_option)\n  \n  self._init_parsing_state()\n  \n  \n def destroy(self):\n  \"\"\n  OptionContainer.destroy(self)\n  for group in self.option_groups:\n   group.destroy()\n  del self.option_list\n  del self.option_groups\n  del self.formatter\n  \n  \n  \n  \n  \n def _create_option_list(self):\n  self.option_list = []\n  self.option_groups = []\n  self._create_option_mappings()\n  \n def _add_help_option(self):\n  self.add_option(\"-h\", \"--help\",\n  action=\"help\",\n  help=_(\"show this help message and exit\"))\n  \n def _add_version_option(self):\n  self.add_option(\"--version\",\n  action=\"version\",\n  help=_(\"show program's version number and exit\"))\n  \n def _populate_option_list(self, option_list, add_help=True):\n  if self.standard_option_list:\n   self.add_options(self.standard_option_list)\n  if option_list:\n   self.add_options(option_list)\n  if self.version:\n   self._add_version_option()\n  if add_help:\n   self._add_help_option()\n   \n def _init_parsing_state(self):\n \n  self.rargs = None\n  self.largs = None\n  self.values = None\n  \n  \n  \n  \n def set_usage(self, usage):\n  if usage is None:\n   self.usage = _(\"%prog [options]\")\n  elif usage is SUPPRESS_USAGE:\n   self.usage = None\n   \n  elif usage.lower().startswith(\"usage: \"):\n   self.usage = usage[7:]\n  else:\n   self.usage = usage\n   \n def enable_interspersed_args(self):\n  \"\"\n  self.allow_interspersed_args = True\n  \n def disable_interspersed_args(self):\n  \"\"\n  self.allow_interspersed_args = False\n  \n def set_process_default_values(self, process):\n  self.process_default_values = process\n  \n def set_default(self, dest, value):\n  self.defaults[dest] = value\n  \n def set_defaults(self, **kwargs):\n  self.defaults.update(kwargs)\n  \n def _get_all_options(self):\n  options = self.option_list[:]\n  for group in self.option_groups:\n   options.extend(group.option_list)\n  return options\n  \n def get_default_values(self):\n  if not self.process_default_values:\n  \n   return Values(self.defaults)\n   \n  defaults = self.defaults.copy()\n  for option in self._get_all_options():\n   default = defaults.get(option.dest)\n   if isinstance(default, str):\n    opt_str = option.get_opt_string()\n    defaults[option.dest] = option.check_value(opt_str, default)\n    \n  return Values(defaults)\n  \n  \n  \n  \n def add_option_group(self, *args, **kwargs):\n \n  if isinstance(args[0], str):\n   group = OptionGroup(self, *args, **kwargs)\n  elif len(args) == 1 and not kwargs:\n   group = args[0]\n   if not isinstance(group, OptionGroup):\n    raise TypeError(\"not an OptionGroup instance: %r\" % group)\n   if group.parser is not self:\n    raise ValueError(\"invalid OptionGroup (wrong parser)\")\n  else:\n   raise TypeError(\"invalid arguments\")\n   \n  self.option_groups.append(group)\n  return group\n  \n def get_option_group(self, opt_str):\n  option = (self._short_opt.get(opt_str) or\n  self._long_opt.get(opt_str))\n  if option and option.container is not self:\n   return option.container\n  return None\n  \n  \n  \n  \n def _get_args(self, args):\n  if args is None:\n   return sys.argv[1:]\n  else:\n   return args[:] \n   \n def parse_args(self, args=None, values=None):\n  \"\"\n  rargs = self._get_args(args)\n  if values is None:\n   values = self.get_default_values()\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  self.rargs = rargs\n  self.largs = largs = []\n  self.values = values\n  \n  try:\n   stop = self._process_args(largs, rargs, values)\n  except (BadOptionError, OptionValueError) as err:\n   self.error(str(err))\n   \n  args = largs + rargs\n  return self.check_values(values, args)\n  \n def check_values(self, values, args):\n  \"\"\n  return (values, args)\n  \n def _process_args(self, largs, rargs, values):\n  \"\"\n  while rargs:\n   arg = rargs[0]\n   \n   \n   \n   if arg == \"--\":\n    del rargs[0]\n    return\n   elif arg[0:2] == \"--\":\n   \n    self._process_long_opt(rargs, values)\n   elif arg[:1] == \"-\" and len(arg) > 1:\n   \n   \n    self._process_short_opts(rargs, values)\n   elif self.allow_interspersed_args:\n    largs.append(arg)\n    del rargs[0]\n   else:\n    return \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n def _match_long_opt(self, opt):\n  \"\"\n  return _match_abbrev(opt, self._long_opt)\n  \n def _process_long_opt(self, rargs, values):\n  arg = rargs.pop(0)\n  \n  \n  \n  if \"=\" in arg:\n   (opt, next_arg) = arg.split(\"=\", 1)\n   rargs.insert(0, next_arg)\n   had_explicit_value = True\n  else:\n   opt = arg\n   had_explicit_value = False\n   \n  opt = self._match_long_opt(opt)\n  option = self._long_opt[opt]\n  if option.takes_value():\n   nargs = option.nargs\n   if len(rargs) < nargs:\n    self.error(ngettext(\n    \"%(option)s option requires %(number)d argument\",\n    \"%(option)s option requires %(number)d arguments\",\n    nargs) % {\"option\": opt, \"number\": nargs})\n   elif nargs == 1:\n    value = rargs.pop(0)\n   else:\n    value = tuple(rargs[0:nargs])\n    del rargs[0:nargs]\n    \n  elif had_explicit_value:\n   self.error(_(\"%s option does not take a value\") % opt)\n   \n  else:\n   value = None\n   \n  option.process(opt, value, values, self)\n  \n def _process_short_opts(self, rargs, values):\n  arg = rargs.pop(0)\n  stop = False\n  i = 1\n  for ch in arg[1:]:\n   opt = \"-\" + ch\n   option = self._short_opt.get(opt)\n   i += 1 \n   \n   if not option:\n    raise BadOptionError(opt)\n   if option.takes_value():\n   \n   \n    if i < len(arg):\n     rargs.insert(0, arg[i:])\n     stop = True\n     \n    nargs = option.nargs\n    if len(rargs) < nargs:\n     self.error(ngettext(\n     \"%(option)s option requires %(number)d argument\",\n     \"%(option)s option requires %(number)d arguments\",\n     nargs) % {\"option\": opt, \"number\": nargs})\n    elif nargs == 1:\n     value = rargs.pop(0)\n    else:\n     value = tuple(rargs[0:nargs])\n     del rargs[0:nargs]\n     \n   else: \n    value = None\n    \n   option.process(opt, value, values, self)\n   \n   if stop:\n    break\n    \n    \n    \n    \n def get_prog_name(self):\n  if self.prog is None:\n   return os.path.basename(sys.argv[0])\n  else:\n   return self.prog\n   \n def expand_prog_name(self, s):\n  return s.replace(\"%prog\", self.get_prog_name())\n  \n def get_description(self):\n  return self.expand_prog_name(self.description)\n  \n def exit(self, status=0, msg=None):\n  if msg:\n   sys.stderr.write(msg)\n  sys.exit(status)\n  \n def error(self, msg):\n  \"\"\n  self.print_usage(sys.stderr)\n  self.exit(2, \"%s: error: %s\\n\" % (self.get_prog_name(), msg))\n  \n def get_usage(self):\n  if self.usage:\n   return self.formatter.format_usage(\n   self.expand_prog_name(self.usage))\n  else:\n   return \"\"\n   \n def print_usage(self, file=None):\n  \"\"\n  if self.usage:\n   print(self.get_usage(), file=file)\n   \n def get_version(self):\n  if self.version:\n   return self.expand_prog_name(self.version)\n  else:\n   return \"\"\n   \n def print_version(self, file=None):\n  \"\"\n  if self.version:\n   print(self.get_version(), file=file)\n   \n def format_option_help(self, formatter=None):\n  if formatter is None:\n   formatter = self.formatter\n  formatter.store_option_strings(self)\n  result = []\n  result.append(formatter.format_heading(_(\"Options\")))\n  formatter.indent()\n  if self.option_list:\n   result.append(OptionContainer.format_option_help(self, formatter))\n   result.append(\"\\n\")\n  for group in self.option_groups:\n   result.append(group.format_help(formatter))\n   result.append(\"\\n\")\n  formatter.dedent()\n  \n  return \"\".join(result[:-1])\n  \n def format_epilog(self, formatter):\n  return formatter.format_epilog(self.epilog)\n  \n def format_help(self, formatter=None):\n  if formatter is None:\n   formatter = self.formatter\n  result = []\n  if self.usage:\n   result.append(self.get_usage() + \"\\n\")\n  if self.description:\n   result.append(self.format_description(formatter) + \"\\n\")\n  result.append(self.format_option_help(formatter))\n  result.append(self.format_epilog(formatter))\n  return \"\".join(result)\n  \n def print_help(self, file=None):\n  \"\"\n  if file is None:\n   file = sys.stdout\n  file.write(self.format_help())\n  \n  \n  \n  \ndef _match_abbrev(s, wordmap):\n \"\"\n \n if s in wordmap:\n  return s\n else:\n \n  possibilities = [word for word in wordmap.keys()\n  if word.startswith(s)]\n  \n  if len(possibilities) == 1:\n   return possibilities[0]\n  elif not possibilities:\n   raise BadOptionError(s)\n  else:\n  \n   possibilities.sort()\n   raise AmbiguousOptionError(s, possibilities)\n   \n   \n   \n   \n   \n   \nmake_option = Option\n"], "site-packages.pygame.surface": [".py", "from browser import document, html, window\nfrom javascript import console, JSConstructor\n\nfrom .rect import Rect\n\n\ncanvas_ID=1\n\n_canvas_id=None\n\nclass Surface:\n def __init__(self, dim=[], depth=16, surf=None):\n  if surf is None:\n   self._depth=depth\n   self._canvas=html.CANVAS(width=dim[0], height=dim[1])\n  elif isinstance(surf, Surface):\n   self._canvas=surf.copy()\n   \n   \n  elif isinstance(surf, html.CANVAS):\n   self._canvas=surf\n   \n   \n   \n  self._context=self._canvas.getContext('2d')\n  self._canvas.id='layer_%s' % canvas_ID\n  \n  \n  \n  \n  canvas_ID+=1\n  \n  \n  \n def blit(self, source, dest, area=None, special_flags=0):\n \n \n \n \n \n \n \n \n \n \n  global _canvas_id\n  \n  if _canvas_id is None:\n   try:\n    _canvas_id=document.get(selector='canvas')[0].getAttribute('id')\n   except:\n    pass\n    \n  if self._canvas.id == _canvas_id:\n   self._canvas.width=self._canvas.width\n   \n  if area is None:\n  \n   if isinstance(source, Surface):\n    area=[(0, 0), (source.canvas.width, source.canvas.height)]\n    \n    \n  if isinstance(source, Surface):\n   _ctx=source.canvas.getContext('2d')\n   _subset=_ctx.getImageData(area[0][0],area[0][1], area[1][0], area[1][1])\n   \n   self._context.putImageData(_subset, dest[0], dest[1])\n   \n   return Rect(dest[0], dest[1], dest[0]+_subset.width, dest[1]+_subset.height)\n   \n def convert(self, surface=None):\n \n  return self\n  \n def copy(self):\n  _imgdata=self._context.toDataURL('image/png')\n  \n  _canvas=html.CANVAS(width=self._canvas.width,height=self._canvas.height)\n  _ctx=_canvas.getContext('2d')\n  _ctx.drawImage(_imgdata, 0, 0)\n  \n  return _canvas\n  \n def fill(self, color):\n  \"\"\n  self._context.fillStyle=\"rgb(%s,%s,%s)\" % color\n  \n  self._context.fillRect(0,0,self._canvas.width,self._canvas.height)\n  \n  \n @property\n def height(self):\n  return int(self._canvas.height)\n  \n @property\n def width(self):\n  return int(self._canvas.width)\n  \n @property\n def canvas(self):\n  return self._canvas\n  \n def scroll(self, dx=0, dy=0):\n  _imgdata=self._context.toDataURL('image/png')\n  self._context.drawImage(_imgdata, dx, dy)\n  \n def get_at(self, pos):\n \n  return self._context.getImageData(pos[0], pos[1],1,1).data\n  \n def set_at(self, pos, color):\n  self._context.fillStyle='rgb(%s,%s,%s)' % color\n  self._context.fillRect(pos[0], pos[1], 1, 1)\n  \n def get_size(self):\n  return self._canvas.width, self._canvas.height\n  \n def get_width(self):\n  return self._canvas.width\n  \n def get_height(self):\n  return self._canvas.height\n  \n def get_rect(self, centerx=None, centery=None):\n  return Rect(0, 0, self._canvas.width, self._canvas.height)\n  \n def set_colorkey(self, key, val):\n  pass\n"]};

